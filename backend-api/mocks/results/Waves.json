[{"category": "technology", "description": "In this project, take an old post-box and an Arduino, to create an incredibly functional monophonic synthesizer. This synthesizer includes such features as: - Dual oscillators - 6 wave forms (Sin, Triangle, Left Saw, Right Saw, Square, Flat) - Noise feature on the main oscillator - Adjustable mixing of the two oscillators - Adjustable cents, semitone, and octave for the second oscillator - LFO from 0 to 10 Hz - Routing the LFO to semitone, cents and octave control of the second oscillator - 20 note arpeggio feature with adjustable speed from 0 to 50Hz. - 5 banks for saving presets - Internal speaker and 3.5mm aux output with volume control - LCD - MIDI input - UART inputParts Filter: - 2X 4.7mH inductor - 2X 47nF capacitor - 1X 100nF capacitor - 2X 270 ohm resistor\u00a0 - PC board MIDI Input: - 1X Female MIDI connector - 1X 6N138 opto-isolator - 1X 220 ohm resistor - 1X 270 ohm resistor - 1X 1N194 diode Audio Output: - 1X 3.5mm Female audio jack - 1X 8 ohm speaker - 1X SPDT switch - 1X Amplifier (For this I used a ready made breakout from SparkFun\u00a0https://www.sparkfun.com/products/11044) - 1X 10k ohm potentiometer User Input/Output: - 1X Serial Enabled LCD (20x4 Character LCD from SparkFun\u00a0https://www.sparkfun.com/products/9568) - 6X Tactile Switches - 4X 10k ohm potentiometers Misc: - 1X DC Barrel Jack - 1X 7805 voltage regulator - 1X 5 pin male header - 1X 10k ohm resistor - 1X push switch (for the reset)", "title": "Post-Box Synthesizer", "url": "https://www.instructables.com/id/Post-Box-Synthesizer/", "section": "technology", "steps": [{"step": 1, "steps_text": "The synthesis method used in this project is called DDS, direct digital synthesis. With this method, a digital signal, 1's and 0's, can be turned into an analog signal without the addition of a DAC, digital to analog converter. In fact with DDS, there are very few extra components are actually required; only a low pass filter. The method works by creating a PWM, pulse width modulation, signal and modulating the duty cycle, the amount of time the signal stays on, in proportion to the amplitude of a wave form at a given time. So in the code there is a wave table of one period for various wave forms. The program then steps through the table at different speeds to create different frequencies. The output of the PWM is shown in the image below. As the duty cycle increase, the amplitude of the output wave increases. The filter removes the carrier frequency, the square wave, and leave the clean wave form from the table.", "step_imgs": ["https://cdn.instructables.com/FRQ/YRT9/HJ1WZ5O9/FRQYRT9HJ1WZ5O9.LARGE.jpg"], "step_title": "Step 1: Synthesis Method"}, {"step": 2, "steps_text": "There are a couple ways to create a filter. You can make an RC or LC filter, as long as it's built in a lowpass configuration with a 12.5 kHz cutoff frequency. I used a 2nd Order Chebyshef filter which removes the carrier frequency extremely well, and leaves a smooth sound for the output signal. The schematic is fairly simple, even though it requires inductors, and only needs 7 components. First I tried to just solder the leads together, but then I used a PC board to make is easier, and look a little more professional. It makes connecting the input and output easier and keeps all the components for the filter nice and segmented.", "step_imgs": ["https://cdn.instructables.com/F6P/7YAR/HJ1WZ5OW/F6P7YARHJ1WZ5OW.LARGE.jpg", "https://cdn.instructables.com/FKG/YA1P/HJ1WZ5NF/FKGYA1PHJ1WZ5NF.LARGE.jpg", "https://cdn.instructables.com/FNW/ZN6W/HJ1WZ5NM/FNWZN6WHJ1WZ5NM.LARGE.jpg", "https://cdn.instructables.com/FE1/J3UR/HJ1WZ5NN/FE1J3URHJ1WZ5NN.LARGE.jpg"], "step_title": "Step 2: The Filter"}, {"step": 3, "steps_text": "The first step is to create the wave table. The table is saved into the Atmega328 RAM using the pgmspace library. Each wave table has 256 values from 0 to 255, so each value can be mapped to a byte data type. The sine wave definition is shown below. Each value is the amplitude of the wave at a specific time. This represents one period of the wave. The higher the frequency that is played, the faster the program steps through the table. #include \"avr/pgmspace.h\" //Waveform definitions PROGMEM\u00a0 prog_uchar waveTable[]\u00a0 = { \u00a0 //sine wave \u00a0 0,0,0,0,1,1,1,2,2,3,4,5,5,6,7,9,10,11,12,14, 15,16,18,20,21,23,25,27,29,31,33,35,37,39, 42,44,46,49,51,54,56,59,62,64,67,70,73,76, 78,81,84,87,90,93,96,99,102,105,108,111,115, 118,121,124,127,130,133,136,139,143,146,149, 152,155,158,161,164,167,170,173,176,178,181, 184,187,190,192,195,198,200,203,205,208,210, 212,215,217,219,221,223,225,227,229,231,233, 234,236,238,239,240,242,243,244,245,247,248, 249,249,250,251,252,252,253,253,253,254,254, 254,254,254,254,254,253,253,253,252,252,251, 250,249,249,248,247,245,244,243,242,240,239, 238,236,234,233,231,229,227,225,223,221,219, 217,215,212,210,208,205,203,200,198,195,192, 190,187,184,181,178,176,173,170,167,164,161, 158,155,152,149,146,143,139,136,133,130,127, 124,121,118,115,111,108,105,102,99,96,93,90, 87,84,81,78,76,73,70,67,64,62,59,56,54,51,49, 46,44,42,39,37,35,33,31,29,27,25,23,21,20,18, 16,15,14,12,11,10,9,7,6,5,5,4,\u00a03,2,2,1,1,1,0,0,0, }; To get the Arduino to create the PWM signal, the timer has to be properly initialized. For this I used the C method to setup the timer so that I can better control it. The timer is created so that we have a 32 kHz sampling rate for our audio and the output of the signal is put on 11 of the Arduino. I also enable an overflow interrupt, so that when the timer value goes over 255, the interrupt triggers. void Setup_timer2() { \u00a0 // Timer2 Clock Prescaler to : 1 \u00a0 sbi (TCCR2B, CS20); \u00a0 cbi (TCCR2B, CS21); \u00a0 cbi (TCCR2B, CS22); \u00a0 // Timer2 PWM Mode set to Phase Correct PWM \u00a0 cbi (TCCR2A, COM2A0);\u00a0 // clear Compare Match \u00a0 sbi (TCCR2A, COM2A1); \u00a0 sbi (TCCR2A, WGM20);\u00a0 // Mode 1\u00a0 / Phase Correct PWM \u00a0 cbi (TCCR2A, WGM21); \u00a0 cbi (TCCR2B, WGM22); } This is the overflow interrupt. When the interrupt occurs I calculate the next value that should be pulled from the wave table and write that value to pin 11. A variable called the phase accumulator keeps track of where the program is in the table. ISR(TIMER2_OVF_vect) { \u00a0 phaccu=phaccu+tword_m; // soft DDS, phase accu with 32 bits \u00a0 icnt=phaccu >> 24;\u00a0\u00a0\u00a0\u00a0 // use upper 8 bits for phase accu as frequency information \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // read value fron ROM sine table and send to PWM DAC \u00a0 OCR2A=pgm_read_byte_near(waveTable + icnt + (waveSelect << 8));\u00a0\u00a0\u00a0 \u00a0 if(icnt1++ == 125) {\u00a0 // increment variable c4ms all 4 milliseconds \u00a0\u00a0\u00a0 c4ms++; \u00a0\u00a0\u00a0 icnt1=0; \u00a0\u00a0 }\u00a0\u00a0 } That value is calculated using a tuning word which is found by dividing the frequency you want by a reference clock, in this case the 32kHz reference clock. const double refclk=31376.6;\u00a0\u00a0\u00a0\u00a0\u00a0 // measured tword_m=pow(2,32)*dfreq/refclk;\u00a0 // calulate DDS new tuning word", "step_imgs": [], "step_title": "Step 3: PWM Code"}, {"step": 4, "steps_text": "The note values are stored to an array. You can find the values here:\u00a0http://en.wikipedia.org/wiki/Piano_key_frequencies double keyFreq[] = { \u00a0 27.5, 29.1352, 30.8677,\u00a0\u00a0\u00a0\u00a0 //Octave 0 \u00a0 32.7032, 34.6478, 36.7081, 38.8909, 41.2034, 43.6535, 46.2493, 48.9994, 51.9131, 55, 58.2075, 61.7354,\u00a0\u00a0\u00a0\u00a0 //Octave 1 \u00a0 65.4064, 69.2957, 73.4162, 77.7817, 82.4069, 87.3071, 92.4986, 97.9989, 103.826, 110, 116.541, 123.471,\u00a0\u00a0\u00a0 //Octave 2 \u00a0 130.813, 138.591, 146.832, 155.563, 164.814, 174.614, 184.997, 195.998, 207.652, 220, 233.082, 246.942,\u00a0\u00a0\u00a0 //Octave 3 \u00a0 261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 394.995, 415.305, 440, 466.164, 493.883,\u00a0\u00a0\u00a0 //Octave 4 \u00a0 523.251, 554.365, 587.330, 622.254, 659.255, 698.456, 739.989, 783.991, 830.609, 880, 932.328, 987.767,\u00a0\u00a0\u00a0 //Octave 5 \u00a0 1406.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760, 1864.66, 1975.53,\u00a0\u00a0 //Octave 6 \u00a0 2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96, 3322.44, 3520, 3729.31, 3951.07,\u00a0\u00a0 //Octave 7 \u00a0 4186.01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //Octave 8 }; So notes sent from the MIDI or over UART have an appropriate value, instead of having to be calculated on the fly. The second oscillator can be detuned from the first in 3 ways. 1. Is using a system called cents, which are fractions of a note. \u00a0Calculated like this: centMultiplier = pow(2.0,(cents + dC)/1200.0); That value is then multiplied to the note frequency. 2. Is using a system called semi, which are full note shifts from -1 to +1 octave 3. Finally by full octaves from -3 to +3 The two oscillators are then mixed by using an adjustable weight. byte osc1 = ((pgm_read_byte(waveTable + icnt1 + (osc1WaveForm<<8))*weight1)/MAX_WEIGHT); //first osc byte osc2 = ((pgm_read_byte(waveTable + icnt2 + (osc2WaveForm<<8))*weight2)/MAX_WEIGHT); //second osc The two values are then summed. The weight value goes from 0 to 16. So you can have entirely the first oscillator, entirely the second, or some mixture in between. The LFO adjusts the detuning of the second oscillator by adjusting the values in proportion to the amplitude of the wave.So it works in a similar way to the first 2 oscillators but instead of creating sound, it tweaks values.", "step_imgs": [], "step_title": "Step 4: Note Effects"}, {"step": 5, "steps_text": "The arpeggiator is a system that creates an arpeggio based upon the notes played when in arpeggio mode. When arpeggio mode begins, you play a note. That note becomes the root key. Every key hit afterward is saved to an array, of a max of 20 notes. The value stored to the array is the difference between the note played and the root key. if(appMode) //add notes to the app array \u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(appMaxCount == 0) //if just starting app mode \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 rootKey = note - MIDI_OFFSET; //get new root key, all notes in array are relative to this value \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 else \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 app[appMaxCount - 1] = noteSelect - rootKey; //calculate relative note \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appMaxCount++; //increment number of notes in app array \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(appMaxCount > MAX_APP_NOTES) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appMode = false; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appUpdate(); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0 } When playing, the arpeggio array is stepped through at a speed depending on the value from one of the control potentiometers. The value in the array is added to the note being played. noteSelect = rootKey + app[appCount]; \u00a0\u00a0\u00a0 appTimer = millisecs; \u00a0\u00a0\u00a0 appCount++; //move through the array \u00a0\u00a0\u00a0 if(appCount >= appMaxCount) \u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0 appCount = 0; \u00a0\u00a0\u00a0 }", "step_imgs": [], "step_title": "Step 5: Arpeggiator"}, {"step": 6, "steps_text": "To start, wire the MIDI connector according to the schematic. It's important to note that the MIDI connector is probably upside down in the schematic, make note before you start soldering. The point of the opto-isolator is to keep the signal from the MIDI controller from damaging the control board. The output from the opto-isolator is connected to the serial input, RX, pin on the Arduino. The MIDI in is serial at 32150 baud. The system is 3 bytes. The first byte is whether or not the note is on or off. The second is the note value and the third is the velocity, but I ignore that. I handle it with a serial event. void serialEvent() { \u00a0 if(Serial.available() >= 3) //messages in 3 byte packets \u00a0 { \u00a0\u00a0\u00a0 byte cmd = Serial.read(); \u00a0\u00a0\u00a0 byte note = Serial.read(); \u00a0\u00a0\u00a0 byte vel = Serial.read(); \u00a0\u00a0\u00a0 if(cmd >= 0x80 && cmd <= 0x8F && (rootKey == note - MIDI_OFFSET || noteSelect == note - MIDI_OFFSET)) //note off \u00a0\u00a0\u00a0 {\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 notePlaying = false; \u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0 else if(cmd >= 0x90 && cmd <= 0x9F) //note on \u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0 noteSelect = note - MIDI_OFFSET; \u00a0\u00a0\u00a0\u00a0\u00a0 notePlaying = true; \u00a0\u00a0\u00a0 }\u00a0 \u00a0 } } Because the synthesizer is mono, I connected the left and right channels of the audio jack together. The SPDT switch is used to switch between audio output to the jack or the speaker. The center pin is where the signal from the amplifier is connected. The right pin goes to the audio jack and the left to the speaker. The ground of the audio jack, the center pin, is connected to one of the pins of the speaker, then both are connected to ground.", "step_imgs": ["https://cdn.instructables.com/FJE/6MIG/HJ1WZ5NW/FJE6MIGHJ1WZ5NW.LARGE.jpg", "https://cdn.instructables.com/FVC/ZCFQ/HJ1WZ5NX/FVCZCFQHJ1WZ5NX.LARGE.jpg", "https://cdn.instructables.com/FK3/P2RQ/HJ1WZ627/FK3P2RQHJ1WZ627.LARGE.jpg", "https://cdn.instructables.com/FNK/WQWM/HJ1WZ6NP/FNKWQWMHJ1WZ6NP.LARGE.jpg"], "step_title": "Step 6: Control"}, {"step": 7, "steps_text": "The user control is composed of 3 parts, the LCD, the switches, and the potentiometers. If you look at the schematic, all the switches are connected via a common ground. Luckily I had a switch array from an old computer monitor that already had the right number of switches, all connected by common ground. It even had an LED, which isn't necessary but I included it anyway. Without this array each switch would have had to be connected together manually. One side of all the switches is connected to ground, then each switch's other side is connected to a pin on the Arduino. Each of the pins on the Arduino then has an internal pull-up enabled. The LCD is serial enabled, but because the MIDI in takes the main serial connection, the LCD requires a software serial connection. The software serial is enabled on pin 13, so that is connected to the receiving pin on the LCD. The LCD is also connected to the power and ground on the main board. The potentiometers are connected to the Arduino's analog input pins 0 through 3. The Arduino's AREF pin is connected to the 5 volts. In order to avoid sacrificing an entire Arduino board for this project, \u00a0I programmed the chip first, then remove it to a separate board with a separate crystal. This requires a PC board for the chip and crystal. Now this becomes the control board, having rails for power and ground and all the pins broken out.", "step_imgs": ["https://cdn.instructables.com/FMD/78RF/HJ1WZ5NA/FMD78RFHJ1WZ5NA.LARGE.jpg", "https://cdn.instructables.com/FB4/6LYM/HJ1WZ5NB/FB46LYMHJ1WZ5NB.LARGE.jpg", "https://cdn.instructables.com/FXP/VKHN/HJ1WZ5NT/FXPVKHNHJ1WZ5NT.LARGE.jpg", "https://cdn.instructables.com/FU1/58HF/HJ1WZ5NP/FU158HFHJ1WZ5NP.LARGE.jpg", "https://cdn.instructables.com/F0J/0JDU/HJ1WZ65C/F0J0JDUHJ1WZ65C.LARGE.jpg", "https://cdn.instructables.com/FBW/1J7F/HJ1WZ5NU/FBW1J7FHJ1WZ5NU.LARGE.jpg", "https://cdn.instructables.com/F95/LKWQ/HJ1WZ5NV/F95LKWQHJ1WZ5NV.LARGE.jpg"], "step_title": "Step 7: User Control"}, {"step": 8, "steps_text": "\n          First step is lay out the parts, mark spaces, then cut the holes. Using generous helping of hot glue I put the LCD and button array into place on the lid of the box. Then using the nuts and washers that came with the potentiometers, and attach them through the lid. Next I wire up the amplifier. I connect the power to the main power on the control board. Then I wire the volume potentiometer to the three spaces on the amp. The nice thing about the breakout board is all of the connections are appropriately labeled. I take the volume potentiometer and connect it through the left side of the box. The output from the filter is connected to the input on the amplifier. The output of the amplifier is connected to the switch. Only the positive output from the output on the amplifier is connected to the middle pin on the audio switch.\u00a0 I added an external reset switch just in case, next to the volume control potentiometer. It helps when reprogramming the board, or if the synthesizer get stuck. Wire up the power supply. I used a DC barrel jack and a 7805 voltage regulator. The back of the DC barrel is the positive, so by the schematic, that is connected to the input pin on the 7805. The control board and barrel jack share a common ground. The output from the voltage regulator is then run to the 5 volt line on the control board. The DC jack is glued to the back of the box. I only recommend putting in 9V to the jack, maximum. The FTDI connector is 5 male header pins connected as shown in the schematic. This allows for serial communication to the synthesizer if you don't have a MIDI controller. Using the speaker, I marked a space. Then using a compass, I created concentric circles to drill holes for the sound to come through. Once everything is properly wired, use that hot glue again to secure everything down. I put the MIDI In/Audio Out in the upper right hand corner, the control board in the upper left, speaker lower right, and the filter and amplifier in toward the center. Add a little paint, and that's it. Now a little demo...", "step_imgs": ["https://cdn.instructables.com/FH7/RZY1/HJ1WZ5NC/FH7RZY1HJ1WZ5NC.LARGE.jpg", "https://cdn.instructables.com/FHP/UGUS/HJ1WZ5NS/FHPUGUSHJ1WZ5NS.LARGE.jpg", "https://cdn.instructables.com/FVM/CFUZ/HJ1WZ5N9/FVMCFUZHJ1WZ5N9.LARGE.jpg", "https://cdn.instructables.com/FBW/1J7F/HJ1WZ5NU/FBW1J7FHJ1WZ5NU.LARGE.jpg", "https://cdn.instructables.com/FNW/ZN6W/HJ1WZ5NM/FNWZN6WHJ1WZ5NM.LARGE.jpg", "https://cdn.instructables.com/F95/LKWQ/HJ1WZ5NV/F95LKWQHJ1WZ5NV.LARGE.jpg", "https://cdn.instructables.com/F3K/DB6G/HJ1WZ5NK/F3KDB6GHJ1WZ5NK.LARGE.jpg", "https://cdn.instructables.com/FEF/NMYS/HJ1WZ5NL/FEFNMYSHJ1WZ5NL.LARGE.jpg", "https://cdn.instructables.com/FEU/LMYS/HJ1WZ5NO/FEULMYSHJ1WZ5NO.LARGE.jpg", "https://cdn.instructables.com/FVC/ZCFQ/HJ1WZ5NX/FVCZCFQHJ1WZ5NX.LARGE.jpg", "https://cdn.instructables.com/FNK/WQWM/HJ1WZ6NP/FNKWQWMHJ1WZ6NP.LARGE.jpg", "https://cdn.instructables.com/FUV/S8WT/HJ1WZ6LE/FUVS8WTHJ1WZ6LE.LARGE.jpg", "https://cdn.instructables.com/FJP/1SCG/HJ1WZ5NY/FJP1SCGHJ1WZ5NY.LARGE.jpg", "https://cdn.instructables.com/FJW/O8Z0/HJ1WZ5NZ/FJWO8Z0HJ1WZ5NZ.LARGE.jpg", "https://cdn.instructables.com/F7Q/VYSX/HJ1WZ5O4/F7QVYSXHJ1WZ5O4.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Putting It Together"}], "channel": "Electronics"}, {"category": "technology", "description": "I wanted to have a two-channel function generator that goes above audio frequencies.I was inspired by this xmega-based waveform generator Instructable.  But instead of using an xmega development board, I used the handy little Brainlink.  That's a device with an atxmega 16a4, a Bluetooth adapter, a USB-rechargeable battery, various sensors, and a firmware designed for easy Bluetooth control, all in a cute package.  They are sadly discontinued, but can bought for $39 at SurplusShed which is the cost of the parts (and SurplusShed has occasional sales that go up to 50% off all stock).To get a two-channel function generator that I could control over Bluetooth from my phone, all I had to do was to extend the Brainlink's firmware to add a waveform generator function, and then to write a simple Android app that communicates over Bluetooth with the Brainlink.Now that this is done, all you need to do is to install the firmware with my Android-based firmware uploader which sends the new firmware (which is backwards compatible) via Bluetooth to the Brainlink, and then use my Android app that controls the function generator.  All source code is here.Ingredients:Brainlink Tether for Brainlink's 8-pin port (included with Brainlink, but I recommend buying extra 8-pin 1.25mm pin spacing JST cables on ebay) Android device (theoretically any Bluetooth-enabled device will work with your own software, and you can just control the Brainlink directly with Realterm) Optional: Capacitor(s) for bipolar mode (I used 0.1 microFarad)The Brainlink, of course, remains fully usable for other purposes (e.g., this or this) when you're not using it as a signal generator.Gratitude: While I have no affiliation with Birdbrain Technologies, the maker of the Brainlink, Tom Lauwers of Birdbrain was pleased to see my earlier firmware developments and very kindly gifted me three more Brainlinks.", "title": "Bluetooth 100kHz+ Two-channel Function Generator", "url": "https://www.instructables.com/id/Bluetooth-100kHz-two-channel-function-generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "The updated firmware for the Brainlink with waveform generator is backwards compatible, but also adds some new features (e.g., Roomba bridge support) and fixes a nasty buffer overflow bug. The easiest way to update the firmware over Bluetooth is from an Android phone or tablet. Just: make sure your Brainlink is fully chargeddownload my firmware update app from Google Playpair your Android device with Brainlink (PIN 1234)turn off the Brainlinkconnect pins 2 and 8 (numbered from right to left; see photo) on the Brainlink's 8-pin portturn on Brainlink while keeping pins connected (blue firmware update light should turn on)run Brainlink Firmware Uploader on your Android devicechoose your Brainlink device (typically shows up as RN42-xxxx) and whether you want firmware optimized for connecting to a Roomba 500+ or for one of the older Roomba 400 / Create robots tap on \"Program device\"Before the last step, you might also want to increase the Bluetooth connectivity setting in the Uploader. This sets the Brainlink's Bluetooth module to higher connectivity, making it easier to connect to it in the future (you do lose some battery life).", "step_imgs": ["https://cdn.instructables.com/FM7/I47W/I0A57ACU/FM7I47WI0A57ACU.LARGE.jpg", "https://cdn.instructables.com/F0F/E7A1/I0A5723S/F0FE7A1I0A5723S.LARGE.jpg"], "step_title": "Step 1: Upgrade Brainlink Firmware"}, {"step": 2, "steps_text": "Install Brainlink Wave Generator on your Android device.  If you're using a different Android device from the previous step, pair your Brainlink with it. Make sure Brainlink is turned on. Plug tether into the 8-pin port on the Brainlink, making sure no wires short together.  (If you use this configuration a lot, you might make a modified tether where the lines irrelevant to the function generator are cut off.) Use Ohm's Law to ensure that the current draw at the voltages you want to generate won't exceed 20mA, as the Brainlink's pins are rated only for 20mA.  For instance, if you're connecting to a 50 ohm load, make sure no voltage exceeds V=IR=(0.020)(50)=1v. If you're connecting to a 1 mega-ohm oscilloscope, no worries. Set the settings for channel 1 or channel 2 and press the right Play button.   The waveform generator output will come from the pins marked in the photo. (On the original 8-pin tether, the CH1 and CH2 pins are blue, and the GND pin is black.)The sine/square/triangle wave function requires an amplitude between 0 and 3.3v (with 254 steps in between). See step 5 for a warning. The square wave generator requires choosing duty cycle (percentage between 0 and 100).  The arbitrary wave generator function requires a sequence of voltages, which whole sequence is played at the indicated frequency.Limitations: The xmega is limited to 1.0 MS/s in single-channel mode and 0.67 MS/s in dual-channel mode. This means that the theoretical maximum for a single-channel square wave is 500 kHz.  In practice, about 320 kHz is the highest I'd go for a single-channel square wave, and \"square\" is a bit of an overstatement (see picture).  For sine waves, rather lower frequency is better.  Even at 100 kHz, a sine wave doesn't look great, given how few samples it has per period.  My experiments suggest that generally dual-channel operation is best at 100 kHz and below.", "step_imgs": ["https://cdn.instructables.com/FZK/RRRO/I0A5723T/FZKRRROI0A5723T.LARGE.jpg", "https://cdn.instructables.com/F08/IUXE/I0A573TR/F08IUXEI0A573TR.LARGE.jpg", "https://cdn.instructables.com/FAA/QUBR/I0A573MU/FAAQUBRI0A573MU.LARGE.jpg", "https://cdn.instructables.com/FR9/2FKE/I0A573LS/FR92FKEI0A573LS.LARGE.jpg", "https://cdn.instructables.com/FX0/KIHM/I0A573N3/FX0KIHMI0A573N3.LARGE.jpg", "https://cdn.instructables.com/FX8/9SPT/I0A573MX/FX89SPTI0A573MX.LARGE.jpg"], "step_title": "Step 2: Use Waveform Generator Via Android Device"}, {"step": 3, "steps_text": "The xmega in the Brainlink has a unipolar Digital to Analog Converter (DAC).  This means that it generates a voltage between 0 and 3.3v.  If you want to generate a bipolar wave, say between -0.5v and +0.5v (e.g., for audio use), you need to pass the output through a capacitor.  A 0.1 microfarad one worked perfectly for me.  Note that if you use the capacitor, then the voltage you specify in the app will become the peak-to-peak voltage.  Thus, if in the app you specify a symmetric wave of 1v amplitude, you'll get a bipolar wave ranging from -0.5v to +0.5v.", "step_imgs": ["https://cdn.instructables.com/FGQ/VMJC/I0A573MW/FGQVMJCI0A573MW.LARGE.jpg", "https://cdn.instructables.com/FND/AV84/I0A573MV/FNDAV84I0A573MV.LARGE.jpg"], "step_title": "Step 3: Optional: Bipolar Waveform Generator"}, {"step": 4, "steps_text": "The custom Brainlink firmware adds three new functions.  To access them, first enter Brainlink command mode by sending an ASCII '*' (outside of command mode, the Brainlink emits a repeating 'BL' sequence).To play a sine, triangle or square wave, use the 'w' function.  Just send a w followed by (with less than a second in between characters) seven bytes:byte 1: channel, either ASCII '0' or ASCII '1'byte 2: type, either ASCII 's' (sine), 't' (triangle) or 'q' (square)byte 3: duty, between 0x00 and 0x3F; only matters for square waves and is otherwise ignored; however, I recommend setting it to 0x20 for other waves in case I want to use it to describe sawtooth waves in the futurebyte 4: amplitude, between 0x00 (=0v) and 0xFF (=3.3v)bytes 5-7: frequency in Hz, 24-bit number, most significant byte firstTo play an arbitrary wave, use the 'W' function.  Just send a W followed by (with less than a second in between characters) 5+n bytes:byte 1: channel, either ASCII '0' or ASCII '1'bytes 2-4: frequency in Hz, 24-bit number, most significant byte firstbyte 5: number n of data points (between 1 and 0x40)bytes 6 through 6+n-1: amplitudes, between 0x00 (=0v) and 0xFF (=3.3v)To stop playback, send ASCII '@' followed by the channel (ASCII '0' or '1').Note that the first wave channel ('0') cannot be used simultaneously with the Brainlink buzzer (buzzer will turn the channel off, and vice versa) and the second wave channel ('1') cannot be used simultaneously with the Brainlink IR emitter (IR turns off the wave channel and vice versa).", "step_imgs": [], "step_title": "Step 4: Optional: Control From Other Devices"}], "channel": "Electronics"}, {"category": "technology", "description": "I wanted to have a two-channel function generator that goes above audio frequencies.I was inspired by this xmega-based waveform generator Instructable.  But instead of using an xmega development board, I used the handy little Brainlink.  That's a device with an atxmega 16a4, a Bluetooth adapter, a USB-rechargeable battery, various sensors, and a firmware designed for easy Bluetooth control, all in a cute package.  They are sadly discontinued, but can bought for $39 at SurplusShed which is the cost of the parts (and SurplusShed has occasional sales that go up to 50% off all stock).To get a two-channel function generator that I could control over Bluetooth from my phone, all I had to do was to extend the Brainlink's firmware to add a waveform generator function, and then to write a simple Android app that communicates over Bluetooth with the Brainlink.Now that this is done, all you need to do is to install the firmware with my Android-based firmware uploader which sends the new firmware (which is backwards compatible) via Bluetooth to the Brainlink, and then use my Android app that controls the function generator.  All source code is here.Ingredients:Brainlink Tether for Brainlink's 8-pin port (included with Brainlink, but I recommend buying extra 8-pin 1.25mm pin spacing JST cables on ebay) Android device (theoretically any Bluetooth-enabled device will work with your own software, and you can just control the Brainlink directly with Realterm) Optional: Capacitor(s) for bipolar mode (I used 0.1 microFarad)The Brainlink, of course, remains fully usable for other purposes (e.g., this or this) when you're not using it as a signal generator.Gratitude: While I have no affiliation with Birdbrain Technologies, the maker of the Brainlink, Tom Lauwers of Birdbrain was pleased to see my earlier firmware developments and very kindly gifted me three more Brainlinks.", "title": "Bluetooth 100kHz+ Two-channel Function Generator", "url": "https://www.instructables.com/id/Bluetooth-100kHz-two-channel-function-generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "The updated firmware for the Brainlink with waveform generator is backwards compatible, but also adds some new features (e.g., Roomba bridge support) and fixes a nasty buffer overflow bug. The easiest way to update the firmware over Bluetooth is from an Android phone or tablet. Just: make sure your Brainlink is fully chargeddownload my firmware update app from Google Playpair your Android device with Brainlink (PIN 1234)turn off the Brainlinkconnect pins 2 and 8 (numbered from right to left; see photo) on the Brainlink's 8-pin portturn on Brainlink while keeping pins connected (blue firmware update light should turn on)run Brainlink Firmware Uploader on your Android devicechoose your Brainlink device (typically shows up as RN42-xxxx) and whether you want firmware optimized for connecting to a Roomba 500+ or for one of the older Roomba 400 / Create robots tap on \"Program device\"Before the last step, you might also want to increase the Bluetooth connectivity setting in the Uploader. This sets the Brainlink's Bluetooth module to higher connectivity, making it easier to connect to it in the future (you do lose some battery life).", "step_imgs": ["https://cdn.instructables.com/FM7/I47W/I0A57ACU/FM7I47WI0A57ACU.LARGE.jpg", "https://cdn.instructables.com/F0F/E7A1/I0A5723S/F0FE7A1I0A5723S.LARGE.jpg"], "step_title": "Step 1: Upgrade Brainlink Firmware"}, {"step": 2, "steps_text": "Install Brainlink Wave Generator on your Android device.  If you're using a different Android device from the previous step, pair your Brainlink with it. Make sure Brainlink is turned on. Plug tether into the 8-pin port on the Brainlink, making sure no wires short together.  (If you use this configuration a lot, you might make a modified tether where the lines irrelevant to the function generator are cut off.) Use Ohm's Law to ensure that the current draw at the voltages you want to generate won't exceed 20mA, as the Brainlink's pins are rated only for 20mA.  For instance, if you're connecting to a 50 ohm load, make sure no voltage exceeds V=IR=(0.020)(50)=1v. If you're connecting to a 1 mega-ohm oscilloscope, no worries. Set the settings for channel 1 or channel 2 and press the right Play button.   The waveform generator output will come from the pins marked in the photo. (On the original 8-pin tether, the CH1 and CH2 pins are blue, and the GND pin is black.)The sine/square/triangle wave function requires an amplitude between 0 and 3.3v (with 254 steps in between). See step 5 for a warning. The square wave generator requires choosing duty cycle (percentage between 0 and 100).  The arbitrary wave generator function requires a sequence of voltages, which whole sequence is played at the indicated frequency.Limitations: The xmega is limited to 1.0 MS/s in single-channel mode and 0.67 MS/s in dual-channel mode. This means that the theoretical maximum for a single-channel square wave is 500 kHz.  In practice, about 320 kHz is the highest I'd go for a single-channel square wave, and \"square\" is a bit of an overstatement (see picture).  For sine waves, rather lower frequency is better.  Even at 100 kHz, a sine wave doesn't look great, given how few samples it has per period.  My experiments suggest that generally dual-channel operation is best at 100 kHz and below.", "step_imgs": ["https://cdn.instructables.com/FZK/RRRO/I0A5723T/FZKRRROI0A5723T.LARGE.jpg", "https://cdn.instructables.com/F08/IUXE/I0A573TR/F08IUXEI0A573TR.LARGE.jpg", "https://cdn.instructables.com/FAA/QUBR/I0A573MU/FAAQUBRI0A573MU.LARGE.jpg", "https://cdn.instructables.com/FR9/2FKE/I0A573LS/FR92FKEI0A573LS.LARGE.jpg", "https://cdn.instructables.com/FX0/KIHM/I0A573N3/FX0KIHMI0A573N3.LARGE.jpg", "https://cdn.instructables.com/FX8/9SPT/I0A573MX/FX89SPTI0A573MX.LARGE.jpg"], "step_title": "Step 2: Use Waveform Generator Via Android Device"}, {"step": 3, "steps_text": "The xmega in the Brainlink has a unipolar Digital to Analog Converter (DAC).  This means that it generates a voltage between 0 and 3.3v.  If you want to generate a bipolar wave, say between -0.5v and +0.5v (e.g., for audio use), you need to pass the output through a capacitor.  A 0.1 microfarad one worked perfectly for me.  Note that if you use the capacitor, then the voltage you specify in the app will become the peak-to-peak voltage.  Thus, if in the app you specify a symmetric wave of 1v amplitude, you'll get a bipolar wave ranging from -0.5v to +0.5v.", "step_imgs": ["https://cdn.instructables.com/FGQ/VMJC/I0A573MW/FGQVMJCI0A573MW.LARGE.jpg", "https://cdn.instructables.com/FND/AV84/I0A573MV/FNDAV84I0A573MV.LARGE.jpg"], "step_title": "Step 3: Optional: Bipolar Waveform Generator"}, {"step": 4, "steps_text": "The custom Brainlink firmware adds three new functions.  To access them, first enter Brainlink command mode by sending an ASCII '*' (outside of command mode, the Brainlink emits a repeating 'BL' sequence).To play a sine, triangle or square wave, use the 'w' function.  Just send a w followed by (with less than a second in between characters) seven bytes:byte 1: channel, either ASCII '0' or ASCII '1'byte 2: type, either ASCII 's' (sine), 't' (triangle) or 'q' (square)byte 3: duty, between 0x00 and 0x3F; only matters for square waves and is otherwise ignored; however, I recommend setting it to 0x20 for other waves in case I want to use it to describe sawtooth waves in the futurebyte 4: amplitude, between 0x00 (=0v) and 0xFF (=3.3v)bytes 5-7: frequency in Hz, 24-bit number, most significant byte firstTo play an arbitrary wave, use the 'W' function.  Just send a W followed by (with less than a second in between characters) 5+n bytes:byte 1: channel, either ASCII '0' or ASCII '1'bytes 2-4: frequency in Hz, 24-bit number, most significant byte firstbyte 5: number n of data points (between 1 and 0x40)bytes 6 through 6+n-1: amplitudes, between 0x00 (=0v) and 0xFF (=3.3v)To stop playback, send ASCII '@' followed by the channel (ASCII '0' or '1').Note that the first wave channel ('0') cannot be used simultaneously with the Brainlink buzzer (buzzer will turn the channel off, and vice versa) and the second wave channel ('1') cannot be used simultaneously with the Brainlink IR emitter (IR turns off the wave channel and vice versa).", "step_imgs": [], "step_title": "Step 4: Optional: Control From Other Devices"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          This experiment was conducted based on the example provided on\u00a0http://relwin.hackhut.com/2011/03/10/19/ . The example was built on the PICAXE platform and I've converted it onto the Arduino. However, certain attributes to the LED that was explained by hackhut was not taken into consideration for example, the LED discharge time. I simply wrote the code treating the sensing LEDs as normal sensor and they would output whatever they detect on the other LED. The red and white LEDs were chosen as to provide a reference to see the difference of different LED colour attributes on its sensitivity and transmit ability.\u00a0\nThe result could be used in some sort of half-duplex Morse code application or even as an relay or isolator. As tested, the LED does conduct voltage when it senses light of same or lower wavelength than it was designed for. However, the different brands or structures of LEDs differs its capabilities. I provided the source code for Arduino for reference.\n/*Demonstrates using LED as a sensor and emitter.\nWhen LED A1 or A2 senses input, the other will emit\nlight according to the blinking sequence detected*/\n#include \"pitches.h\"\nconst int led1 = A0;\nconst int led2 = A1;\nconst int breakTime = 3000; //in ms\nconst int speaker = 8;\nint value1, value2;\nint threshold1 = 250;\nint threshold2 = 250;\nint numNotes = 4;\nboolean timeout = false;\nlong time = 0;\nint melody[] = {\n\u00a0 NOTE_A4,NOTE_E4,NOTE_G4,NOTE_A4};\nint noteDurations[] = {\n\u00a0 4, 4, 4, 4};\nvoid setup(){\n\u00a0 Serial.begin(9600);\n\u00a0 pinMode(led1,INPUT);\n\u00a0 pinMode(led2,INPUT);\n\u00a0 pinMode(speaker,OUTPUT);\n}\nvoid loop(){\n\u00a0 value1 = analogRead(A0);\n\u00a0 value2 = analogRead(A1);\n\u00a0 if(value1 >= threshold1){\n\u00a0 \u00a0 Serial.print(\"Value 1 : \");\n\u00a0 \u00a0 Serial.println(value1);\n\u00a0 \u00a0 time = millis();\n\u00a0 \u00a0 out(led1,led2,threshold1);\n\u00a0 \u00a0 pinMode(led2,INPUT);\n\u00a0 \u00a0 timeout = false;\n\u00a0 }\n\u00a0 else if(value2 >= threshold2){\n\u00a0 \u00a0 Serial.print(\"Value 2 : \");\n\u00a0 \u00a0 Serial.println(value2);\n\u00a0 \u00a0 time = millis();\n\u00a0 \u00a0 out(led2,led1,threshold2);\n\u00a0 \u00a0 pinMode(led1,INPUT);\n\u00a0 \u00a0 timeout = false;\n\u00a0 }\n}\nvoid out(int a, int b, int threshold){\n\u00a0 pinMode(b,OUTPUT);\n\u00a0 delay(20);\n\u00a0 while(timeout != true){\n\u00a0 \u00a0 int value = analogRead(a);\n\u00a0 \u00a0 if(value >= threshold){\n\u00a0 \u00a0 \u00a0 analogWrite(b,value);\n\u00a0 \u00a0 \u00a0 time = millis();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 else{\n\u00a0 \u00a0 \u00a0 analogWrite(b,0);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 if(millis() - time >= breakTime){\n\u00a0 \u00a0 \u00a0 timeout = true;\n\u00a0 \u00a0 \u00a0 playTone();\n\u00a0 \u00a0 }\n\u00a0 }\n}\nvoid playTone(){\n\u00a0 for (int thisNote = 0; thisNote < numNotes; thisNote++) {\n\u00a0 \u00a0 int noteDuration = 1000/noteDurations[thisNote];\n\u00a0 \u00a0 tone(8, melody[thisNote],noteDuration);\n\u00a0 \u00a0 int pauseBetweenNotes = noteDuration * 1.30;\n\u00a0 \u00a0 delay(pauseBetweenNotes);\n\u00a0 \u00a0 noTone(8);\n\u00a0 }\n}\n___________________________________________________________________\nAs you can see from the video, the red LED cannot respond (transmit) \u00a0quick enough to the received signal.\nThis suggest that the red LED has capacitive properties but may differ due to the holding and discharge time of different LED.\u00a0When the white LED transmits, its very clear that with every quick interval signals, the white light was able to transmit accordingly and with minimum delay.\u00a0\nIn terms of sensitivity, the red LED would win hands down. White light consists of broad spectrum rays and the wavelength is undetectable by the red LED unless it is put very VERY closely. With the red LED, the distance between the transmitter and receiver for successful sensing could be larger. However, we must put into account that the noise received from the atmosphere was no doubt a big disadvantage as the experiment was done under fluorescent lighting. This problem was partially solved by calibrating possible received values before writing the threshold values of both sensors. Its very simple. The piezo speaker functions to show end of transmission and the Arduino will start sensing both inputs again.\nThe testing code used is shown below:\nvoid setup(){\n\u00a0 Serial.begin(9600);\n\u00a0 pinMode(A0,INPUT);\n\u00a0 pinMode(A1,INPUT);\n}\nvoid loop(){\n\u00a0 int value1 = analogRead(A0);\n\u00a0 int value2 = analogRead(A1);\n\u00a0 Serial.print(\"Value 1 = \");\n\u00a0 Serial.print(value1);\n\u00a0 Serial.print(\"\\tValue 2 = \");\n\u00a0 Serial.println(value2);\n\u00a0 delay(300);\n}\nAlso include the pitches.h file obtained from the Arduino page .\nThe circuit drawings were done on Fritzing . It is open-source like the Arduino.\n        ", "title": "Bi-directional LED Sensing Try-out", "url": "https://www.instructables.com/id/Bi-directional-LED-Sensing-Try-out/", "section": "technology", "steps": [], "channel": "LEDs"}, {"category": "technology", "description": "Have you thought about a cup that behaves differently depending on the liquid, temperature or the amount of liquid in that cup?\nThis is a group of interactive cups. The one on the left (Cup 1) can tells the difference in the liquid you put in it, and play a certain song for that liquid in react. The one on the right (Cup 2) can change the speed of the song playing depending on the amount of liquid you add in it. Also, the color of the pink cup changes when you pour hot water in it so it depends on the temperature.", "title": "Interactive Cups", "url": "https://www.instructables.com/id/Interactive-Cups/", "section": "technology", "steps": [{"step": 1, "steps_text": "Here is a video of the instructive cups moving.", "step_imgs": [], "step_title": "Step 1: "}, {"step": 2, "steps_text": "Materials you need:\n-a few disposable cups (transparent and opaque, different sizes)\n-a small box as a base\n-thermochromic paint and fabric paint\n-a paintbrush\n-glue\n-scissors\n-a coil of wire\n-wire strippers\n-Soldering supplies\n-Arduino UNO board\n-Wav Shield for Arduino (http://www.ladyada.net/make/waveshield/)\n-a LED\n-a light sensor\n-a bendy sensor\n-a speaker", "step_imgs": ["https://cdn.instructables.com/FYR/UX3U/H1KHA03K/FYRUX3UH1KHA03K.LARGE.jpg"], "step_title": "Step 2: "}, {"step": 3, "steps_text": "Connect the audio shield with the arduino and connect the speaker to the audio shield. The followings are ways to connect each sensors, or LED to the arduino and the bread board. However, be careful not to solder everything first. You will need to unwire them later on when connecting to the cups.\u00a0A. Flex Sensor\nTo connect the flex(bend) sensor see the diagram.\nThe analog input should go to analog (0) for this one and we used a bread board to connect the resistors to Vcc because we will be using the Vcc power in many nodes.\nYou can test out if this sensor is working by using the code:\nvoid setup()\n{ Serial.begin(9600);\n}\nvoid loop()\n{\n\u00a0 int sensor, degrees;\n\u00a0 sensor = analogRead(0);\n\u00a0 degrees = map(sensor, 768, 853, 0, 90);\n\u00a0 Serial.print(\"analog input: \");\n\u00a0 Serial.print(sensor,DEC);\n\u00a0 Serial.print(\"\u00a0\u00a0 degrees: \");\n\u00a0 Serial.println(degrees,DEC);\n\u00a0\n\u00a0 delay(100);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n}\nhttp://www.sparkfun.com/tutorials/270", "step_imgs": ["https://cdn.instructables.com/FHX/KFI2/H1JUJGPN/FHXKFI2H1JUJGPN.LARGE.jpg", "https://cdn.instructables.com/FCA/3Y0M/H1KHAN6Q/FCA3Y0MH1KHAN6Q.LARGE.jpg"], "step_title": "Step 3: "}, {"step": 4, "steps_text": "B. Photocell light sensor\nThe connection for the photocell is the same principle to the flex sensor. As we did in the flex sensor, connect a resistor (1k) in between the Vcc and one of the node of the sensor. Then, connect the other to the ground. ( It is better to solder a long wire to each legs because this photocell is going to be connected inside to the cup). Also, a the input analog (2) should be connected in the node where the resistor and the photocell is connected.\nYou can check the range of this sensor by using the same code above except change the analog(0) to anolog(2) and without printing the degree value.", "step_imgs": ["https://cdn.instructables.com/F7J/OXEI/H1JUJGOZ/F7JOXEIH1JUJGOZ.LARGE.jpg"], "step_title": "Step 4: "}, {"step": 5, "steps_text": "C. Light Ambient Sensor\nConnect the light sensor as shown in the diagram above. The GND node goes to ground, S goes to analog read (5) and Vcc connects to the power source.", "step_imgs": ["https://cdn.instructables.com/FB8/6IO8/H1LWQH9J/FB86IO8H1LWQH9J.LARGE.jpg", "https://cdn.instructables.com/FTC/9VDE/H1QMLEB3/FTC9VDEH1QMLEB3.LARGE.jpg"], "step_title": "Step 5: "}, {"step": 6, "steps_text": "D. LED\nConnect the led to the battery. You will need a resistor in between the LED and the battery to prevent the LED breaking from too much current going through. Also, in between these connections, connect a button that can turn the light on and off. This will help saving the battery.You can see the final connections in the pictures.", "step_imgs": ["https://cdn.instructables.com/FC0/LHR6/H1LWQH9O/FC0LHR6H1LWQH9O.LARGE.jpg", "https://cdn.instructables.com/FKP/JJ5B/H1PITB11/FKPJJ5BH1PITB11.LARGE.jpg", "https://cdn.instructables.com/F7F/HJ1X/H1KHAN74/F7FHJ1XH1KHAN74.LARGE.jpg", "https://cdn.instructables.com/FV0/8Q4D/H1LWQH9Q/FV08Q4DH1LWQH9Q.LARGE.jpg"], "step_title": "Step 6: "}, {"step": 7, "steps_text": "For cup 1, you need a bigger opaque cup and several smaller transparent cups (that you can put the smaller ones in the big one). Attach the LED and the photocell light sensor to the inside of the opaque cup, one on each side (as shown in the picture. Do this before you solder the light sensor and the LED to the circuits!). So when you put the transparent cups with different liquid in the opaque cup, the light sensor can sense the difference in the amount of photons that go through the liquid, depending on the difference of transmittance.", "step_imgs": ["https://cdn.instructables.com/FWM/FTGK/H1KHAN7A/FWMFTGKH1KHAN7A.LARGE.jpg"], "step_title": "Step 7: "}, {"step": 8, "steps_text": "For cup 2, you need a light heat-conducting cup and a base (which was made from a slightly bigger cup) that the cup can stand in. Mix the Thermochromic paint with the fabric paint, apply evenly on the surface of both the cup and the base. After the paint dry out, make two parallel holes on the \u201cwall\u201d about 0.5 inches away from the bottom, each on one side of the base. Put the bendy sensor through the base via the two holes. Now you can put the cup in the base (on the bendy sensor). So the bendy sensor bends when you add water to the cup, and speed up the music. Also, the cup will change color following the change in temperature, due to the thermochromism paint.", "step_imgs": ["https://cdn.instructables.com/F1Z/XQ5E/H1JUHHH8/F1ZXQ5EH1JUHHH8.LARGE.jpg", "https://cdn.instructables.com/FQ9/GQ4Y/H1PITB1I/FQ9GQ4YH1PITB1I.LARGE.jpg"], "step_title": "Step 8: "}, {"step": 9, "steps_text": "Attach two cups and the speaker on top of the base (the box), and hide all the electrical component in the box, except for the light ambient sensor.\nThe picture shows how it looks from the back.", "step_imgs": ["https://cdn.instructables.com/F90/45QK/H1JUHHIE/F9045QKH1JUHHIE.LARGE.jpg"], "step_title": "Step 9: "}, {"step": 10, "steps_text": "Download arduino 1.0.\nAlso, before\u00a0 using the code go to http://www.ladyada.net/make/waveshield/use.html.\nYou should format the SD card, convert audio files as suggested in this site.\nAlso, don\u2019t forget to put the converted audio to the SD card.\nArduino Code that we used :\n#include <FatReader.h>\n#include <SdReader.h>\n#include <avr/pgmspace.h>\n#include \"WaveUtil.h\"\n#include \"WaveHC.h\"\nSdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card\nFatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card\nFatReader root;\u00a0\u00a0 // This holds the information for the filesystem on the card\nFatReader f;\u00a0\u00a0\u00a0\u00a0\u00a0 // This holds the information for the file we're play\nWaveHC wave;\u00a0 // This is the only wave (audio) object, since we will only play one at a time\n#define DEBOUNCE 100\u00a0 // button debouncer\n// this handy function will return the number of bytes currently free in RAM, great for debugging!\u00a0\u00a0\nint freeRam(void)\n{\n\u00a0 extern int\u00a0 __bss_end;\n\u00a0 extern int\u00a0 *__brkval;\n\u00a0 int free_memory;\n\u00a0 if((int)__brkval == 0) {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)&__bss_end);\n\u00a0 }\n\u00a0 else {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)__brkval);\n\u00a0 }\n\u00a0 return free_memory;\n}\nvoid sdErrorCheck(void)\n{\n\u00a0 if (!card.errorCode()) return;\n\u00a0 putstring(\"\\n\\rSD I/O error: \");\n\u00a0 //Serial.print(card.errorCode(), HEX);\n\u00a0 putstring(\", \");\n\u00a0 Serial.println(card.errorData(), HEX);\n\u00a0 while(1);\n}\nvoid setup() {\n\u00a0 // set up serial port\n\u00a0 Serial.begin(9600);\n\u00a0 Serial.println(freeRam());\u00a0\u00a0\u00a0\u00a0\u00a0 // if this is under 150 bytes it may spell trouble!\n\u00a0\n\u00a0 // Set the output pins for the DAC control. This pins are defined in the library\n\u00a0 //\u00a0 if (!card.init(true)) { //play with 4 MHz spi if 8MHz isn't working for you\n\u00a0 if (!card.init()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //play with 8 MHz spi (default faster!)\u00a0\n\u00a0\u00a0\u00a0 putstring_nl(\"Card init. failed!\");\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 sdErrorCheck();\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // enable optimize read - some cards may timeout. Disable if you're having problems\n\u00a0 card.partialBlockRead(true);\n// Now we will look for a FAT partition!\n\u00a0 uint8_t part;\n\u00a0 for (part = 0; part < 5; part++) {\u00a0\u00a0\u00a0\u00a0 // we have up to 5 slots to look in\n\u00a0\u00a0\u00a0 if (vol.init(card, part))\n\u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // we found one, lets bail\n\u00a0 }\n\u00a0 if (part == 5) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if we ended up not finding one\u00a0 :(\n\u00a0\u00a0\u00a0 putstring_nl(\"No valid FAT partition!\");\n\u00a0\u00a0\u00a0 sdErrorCheck();\u00a0\u00a0\u00a0\u00a0\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Lets tell the user about what we found\n\u00a0 //putstring(\"Using partition \");\n\u00a0 //Serial.print(part, DEC);\n\u00a0 //putstring(\", type is FAT\");\n\u00a0 //Serial.println(vol.fatType(),DEC);\u00a0\u00a0\u00a0\u00a0 // FAT16 or FAT32?\n\u00a0\n\u00a0 // Try to open the root directory\n\u00a0 if (!root.openRoot(vol)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Can't open root dir!\"); // Something went wrong,\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Whew! We got past the tough parts.\n\u00a0 putstring_nl(\"Ready!\");\n}\nvoid loop() {\n\u00a0 //putstring(\".\");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // uncomment this to see if the loop isnt running\n\u00a0 int sensorValue;\n\u00a0\u00a0\u00a0\u00a0\n\u00a0 sensorValue = analogRead(2);\u00a0\u00a0 // read analog input pin 2\n\u00a0\u00a0\u00a0\n\u00a0 if(sensorValue<100){// this determines the song we play\n\u00a0\u00a0\u00a0 playcomplete(\"water.WAV\");\n\u00a0\u00a0\u00a0\u00a0 playcomplete(\"friday.WAV\");\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\n\u00a0 else if(sensorValue>=100 && sensorValue<250){\n\u00a0 playcomplete(\"milkbaby.WAV\");\n\u00a0 playcomplete(\"baby.WAV\");}\n\u00a0\n\u00a0 else {playcomplete(\"coke.WAV\");\n\u00a0\u00a0\u00a0\u00a0 playcomplete(\"myjeans.WAV\");\n}\n}\nvoid playcomplete(char *name) {\n\u00a0 // call our helper to find and play this name\n\u00a0 playfile(name);\n\u00a0 while (wave.isplaying) { //while it's playing!\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 int16_t potval = 450;\n\u00a0 uint32_t newsamplerate;\n\u00a0\u00a0 int16_t lastpotval = 0;\n\u00a0\u00a0 #define HYSTERESIS 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 int sensorValue;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sensorValue = analogRead(5); //read input 5 which is the light ambient sensor\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0 if(sensorValue<10){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break;} //if we get close to the light ambient sensor, it stops the song and change it to another music\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0 // this is the code that changes the speed\n\u00a0\u00a0 potval = analogRead(0); //read the bend sensor and this code changes the speed depending on the sensor\n\u00a0\u00a0\u00a0\u00a0 if ( ((potval - lastpotval) > HYSTERESIS) || ((lastpotval - potval) > HYSTERESIS)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 newsamplerate = wave.dwSamplesPerSec;\u00a0 // get the original sample rate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 newsamplerate *= potval;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // scale it by the analog value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 newsamplerate /= 512;\u00a0\u00a0 // we want to 'split' between 2x sped up and slowed down.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 wave.setSampleRate(newsamplerate);\u00a0 // set it immediately!\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(newsamplerate, DEC);\u00a0 // for debugging\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 lastpotval = potval;\n\u00a0\u00a0\u00a0\n\u00a0\u00a0 }\n\u00a0\n\u00a0\u00a0 Serial.print(potval,DEC);\n\u00a0\u00a0 delay(100);\n\u00a0\u00a0 }\n\u00a0 // now its done playing\n}\nvoid playfile(char *name) {\n\u00a0 // see if the wave object is currently doing something\n\u00a0 if (wave.isplaying) {// already playing something, so stop it!\n\u00a0\u00a0\u00a0 wave.stop();\n\u00a0\u00a0\u00a0\n// stop it\n\u00a0 }\n\u00a0 // look in the root directory and open the file\n\u00a0 if (!f.open(root, name)) {\n\u00a0\u00a0\u00a0 putstring(\"Couldn't open file \"); Serial.print(name); return;\n\u00a0 }\n\u00a0 // OK read the file and turn it into a wave object\n\u00a0 if (!wave.create(f)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Not a valid WAV\"); return;\n\u00a0 }\n\u00a0\n\u00a0 // ok time to play! start playback\n\u00a0 wave.play();}", "step_imgs": [], "step_title": "Step 10: Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "So you have an n64? Want to trick out your N64 to make some LEDs pulse to the sound of the game....well...LETS BEGIN!", "title": "SubZero 64 by Raizer04", "url": "https://www.instructables.com/id/SubZero-64-by-Raizer04/", "section": "technology", "steps": [{"step": 1, "steps_text": "First we need to get an n64. If you have one already your good to go! If not, simply search for a cheap (working) used one on ebay and your good.\nSame as the pulseVu chip....simply go on ebay and search for one and your on point.\nThe pulse vu 2x chips is what is being used in this tutorial.", "step_imgs": ["https://cdn.instructables.com/FY0/YWWK/H9G18VFY/FY0YWWKH9G18VFY.LARGE.jpg"], "step_title": "Step 1: Obtaining Your N64 + PulseVu 2x Chip"}, {"step": 2, "steps_text": "Now its time to take apart your N64:\nUse a 4.5mm Gamebit Screwdriver (or look up the pen hack) and take off the the bottom screws.\nNow that the inside is exposed, used a phillips screw driver and remove the many...lol....screws to expose the motherboard.\nIf you have any confusion: View the great step by step here: http://www.youtube.com/watch?v=1ZjldRekpnM&feature=related\nor also here: http://www.ifixit.com/Guide/Repairing+Nintendo+64+Motherboard/1608/1", "step_imgs": ["https://cdn.instructables.com/F43/OK9A/H9K2FB68/F43OK9AH9K2FB68.LARGE.jpg"], "step_title": "Step 2: Take Apart Your N64"}, {"step": 3, "steps_text": "The pulsevu 2x chip is thoroughly labeled with everything you need.\nYour PulseVU can operate within the range of 3V-5V. You will need to find a suitable power source and connect this to the + pad of your PulseVU. In order for the PulseVU to work when your target device is off, you will need to find a voltage source that is available in standby also. The - pad of the PulseVU connects to ground.\nThe PO pad of the PulseVU is used to determine when the target device is on and off. This must be a voltage source that toggles between 0V to 3V-5V (not exceeding your + input) when the target device is turned on/off. If you do not wish to use this feature, you can connect PO directly to -. If the modes are acting reversed from the mode list, simply change the mode to \"Function Swap\" and they will be switched around.\nThe SW pad connects to a momentary button or switch. This is the button you use to change modes. You can use an existing button by connecting it to the point that toggles between + and - when pressed down. If you want to instead add a button specifically for the PulseVU, you can follow this schematic.\nThe VU pad is what controls your LEDs. Connect the cathode (negative) side of your LEDs to this pad. The anode (positive) side should connect to a power source capable of handling the current. Use the appropriate resistor(s).\nAL & AR connect to the audio left and right pins that connect to the A/V connector or speakers of your target device.\nCO on the back of the PulseVU is an output which connects to the Power Extender.\nThe two pads on the right side of the PulseVU 2 and the resistor between them are only used for the Wii. These may be cut off if you require a smaller PCB for other devices.\nThe L1, L2, and jumper next to the \"2X\" text are all only used for the Xbox360. Do not connect anything else here.\n5V line: Under the AV line you will see a 5V line (see attached picture)\nPO line: Wire this to G (ground line)\nSW line: You will need to wire a monetary switch (you can get this easily at radioshack) to this\nVU: Connect the \"NEGATIVE\" side of your LED to this pad. The positive side needs to go to the 5v line for power.\nAL/AR Lines: Connect this to L and R (11/12) of the AV connector...this is audio left and audio right.\nAs for LEDS...i used ones from OZNIUM that are prewired and wont overheat in any way: http://www.oznium.com/prewired-superflux.\nNote: If for any reason you need a 12v line just look under the power port and 12v is on #6.", "step_imgs": ["https://cdn.instructables.com/FP1/TIKV/H9K2FB70/FP1TIKVH9K2FB70.LARGE.jpg"], "step_title": "Step 3: Wiring Your PulseVu 2x Chip"}, {"step": 4, "steps_text": "Once you have everything wired up, turn on your system and use the blink pattern to select which type of blinking you want:\nThese are the blink patterns:\nBlink Pattern Mode Function when console is off Function when console is on\nS-S-S-S Mode0 Off Off\nS-S-S-L Mode1 Fading PulseVU\nS-S-L-S Mode2 Off PulseVU\nS-S-L-L Mode3 Dim PulseVU\nS-L-S-S Mode4 On PulseVU\nS-L-S-L Mode5 Fading Fading\nS-L-L-S Mode6 Fading Off\nS-L-L-L Mode7 Fading Dim\nL-S-S-S Mode8 Fading On\nL-S-S-L Mode9 Dim Off\nL-S-L-S Mode10 Dim On\nL-S-L-L Mode11 On Off\nL-L-S-S Mode12 Audio Calibration (Peak)\nL-L-S-L Mode13 Audio Calibration (Noise)\nL-L-L-S Mode14 Function Swap\nL-L-L-L Mode15 Factory Reset", "step_imgs": [], "step_title": "Step 4: Blink Patterns"}, {"step": 5, "steps_text": "After you are done, turn it on, select your blink pattern and BEHOLD!\nhttp://www.youtube.com/watch?feature=player_embedded&v=TMOqzXic9mE\nThanks...and remember BEHOLD THE AWESOMNESS OF THE LED!", "step_imgs": [], "step_title": "Step 5: Finale"}], "channel": "LEDs"}, {"category": "technology", "description": "Volume Units (VU) meters have always been the most fun and simplistic projects for electronic lovers and hobbyists. VU meters are those little gizmos on your stereo or other audio electronics that show how strong or loud the audio signal is. There are literally dozens of different audio metering systems in common used around the world and they often appear to read completely differently when supposedly displaying the same audio signal such as we could have a full fledge audio spectrum analyzer that can display the intensity of different frequency signals within the same audio signal but they are moreover used in the professional audio analysis only and are not suitable for everyone\u2019s purpose. For basic purpose, simple VU meters are more than enough to have a literal idea about the loudness of your audio signal and are amongst the simplest of meter designs, and they have been used since the very beginning of the audio broadcasting and recording industry. There are two basic kinds of VU meter: An \u201canalog\u201d meter, which looks like a dial with a moving needle; and a \u201cdigital\u201d meter, which uses some sort of level comparison to trigger ON lights (e.g. LED bar-graph),the more lights are ON, the louder the sound. VU meters are inherently cheap, though, whether in the form of a moving-coil meter or as a bar-graph of LEDs. This is principally because there is no complex peak-sensing driver circuitry involved and as a consequence, VU meters tend to be used in order to cut costs where the meter needs only to provide an indication that the sound is reaching a particular level or not. Presented here is a very simple PC parallel port drivenVU meter that displays the audio intensity of your sound signal that is being played on your computer system. Although in nearly most of the VU meter designs, the capturing and processing of audio signal is handled by a specific circuitry that adds cost to the project apart from the display circuitry. Here in our project the capturing and processing of audio signal is handled by the computer itself running a simple visual basic application and the display circuitry is driven by the computer\u2019s parallel port. Now as the processing of audio signal is done in the computer itself, it inherently simplifies the circuit complexity of the project and reduces the cost. Thus only display part is needed to be designed. Two hardware circuits are presented here that can be connected to the computer\u2019s parallel port to display the VU levels. One circuit is designed to drive a simple array of LEDs while the other to drive mains 220v AC powered lamps displaying the volume level of the audio signal.", "title": "Parallel Port Based VU Meter", "url": "https://www.instructables.com/id/Parallel-port-based-VU-Meter/", "section": "technology", "steps": [{"step": 1, "steps_text": "The project uses the very simple audio capturing technique from computer system. A visual basic application is designed which uses the windows multimedia library that is used by the windows operating system to play and capture audio signals through the audio device available on your system. With the help of this library the software samples the audio played through the sound channel and decision making is done to drive the LEDs/lights connected to the parallel port of the computer. The \u201cinpout32\u201d library is used to access the parallel port of the computer. Thus the application drives the LEDs/lights connected to the parallel port after processing the audio signal samples. Due to the limitation of the input/output pins available on the parallel port, only eight LEDs/lights can be driven to display the volume intensity. The software section is thus responsible only for generating logic signals through the parallel port to drive the eight outputs. The status of lights and full VU display for left and right audio channels is displayed on the software interface. The next section is the display section. The logic signals on the parallel port are used to drive the LEDs and opto-couplers section which then will be used to drive the TRIACs and thus driving the mains 220V AC powered lamps. Thus in a nutshell, the logic signal generated by the software according to the audio level on the parallel port will drive the corresponding LED and opto-coupler. The opto-coupler then switches ON/OFF the TRIAC associated with it and lights the lamp. There are two versions of hardware associated with the project for the display section. One uses simple LED array, while the other can be used to drive mains 220V AC lamps.", "step_imgs": ["https://cdn.instructables.com/F3B/ZRJ8/HPFZZGOF/F3BZRJ8HPFZZGOF.LARGE.jpg"], "step_title": "Step 1: Block Diagram Description"}, {"step": 2, "steps_text": "The software for the project has been designed in Visual Basic 6.0 which is a rapid application development tool from Microsoft used for synthesizing application for the windows operating system. The audio capturing and processing section for the software is built around the Windows Multimedia (winmm) library. \u201cwinmm\u201d is a module for the Windows Multimedia API, which contains low-level audio functions which can be used to access the real-time audio data streamed through the computer\u2019s audio driver. To access the functions of the \u201cwinmm\u201d library, a visual basic module \u201cWaveAudio.bas\u201d is written which declares all the variables and functions that will be used to process the real time data. The next section within the software is the main form module itself which holds all the code required to handle the user interface of the software. To access the printer port of the computer, a function \u201cOut\u201d has been declared which is called from the input-output library (inpout32.dll). We use this function to output any data to the parallel port. However functions for reading the parallel port are also available within the same library, but we do not have such requirements in our project. The \u201cOut\u201d function is fairly simple to deploy and uses only two arguments to work. One is the parallel port\u2019s physical address itself that is usually 378(hexadecimal) on most of the computers, and other is the 8-bit data itself which is needed to be sent. On the top-right of the application, a settings frame has been drawn which holds the audio device selection combobox, parallel port selection combobox and the left or right channel selection option buttons. The audio device selection combobox can be used to select one of the audio hardware drivers available on your computer which you want to sample the audio signal from. The parallel port selection combobox can be used to select the parallel port physical address on your computer. And as the 8 LEDs/lights on the parallel port can only display one of the left or right channels only, so the sample channel option buttons enables you to choose from either the left or right\u00a0 channel of your audio signal to sample from. On the mid-left of the GUI, two LED meter components have been drawn which are used to display the sampled audio intensity from the left and right channels of the audio signal. This led-meter component is derived from the \u201cLedMeter.ocx\u201d activex object. On the mid-right of the GUI, eight circular shapes have been drawn which imitates the status of the eight LEDs/lights connected to the parallel port. On the very bottom of the GUI, four buttons named \u201cSTART\u201d, \u201cSTOP\u201d, \u201cRESET\u201d and \u201cEXIT\u201d will let you start/stop the VU meter, reset the outputs and exit the application. Other important functions used in the main module are \u201cEnumDevices\u201d and \u201cCapture\u201d. \u201cEnumDevices\u201d functions is called in the load event of the form module. It is basically used to get the list of physical audio hardware devices available on the computer system from which the user can select one as the default channel for sampling. The function generates the list and updates it onto the audio devices selection combobox on the settings frame. \u201cCapture\u201d is the function where all sampling and decision making takes place. Here a 512 byte buffer is dimensioned which will hold the samples for the left and right channels at even and odd places respectively. \u201cwaveInPrepareHeader\u201d and \u201cwaveInAddBuffer\u201d are then called to start the capturing process from \u201cwinmm.dll\u201d and asks the sound driver to fill the buffer with the audio samples. When the buffer is full, the process is stopped. The default sampling settings in the software is set to \u201cWAVE_FORMAT_PCM\u201d format, 2\u00a0 channels, 8-bit sampling at 22.05 KHz, which the user can change according to his needs. Now the reading of the buffer starts for right and left channel accordingly and for each sample, it gives you a number between 0 to 255 to give the intensity of the audio signal for the particular channel. It is to be noticed that the sample value returned is 127 when nothing is played back and it goes to 0 max for negatively going signal transitions and to 255 max for positively going signal transitions. So when nothing is being played, a value 127 or near is returned and the LedMeter component on the software will be right in the middle.\u00a0 However in the project we used the scale between 127 to 255 to turn on the lights by first converting it to a scale of 0 to 100 and then dividing it into 8 equal parts for level triggering each of the eight bits on the parallel port. Thus the 8 shapes on the software GUI are updated accordingly and \u201cOut\u201d function is the used to switch ON corresponding LEDs/lights connected to the parallel port. The user can select to sample either the left or right channel as per his need during the runtime as this is checked every time after the capturing has taken place.", "step_imgs": ["https://cdn.instructables.com/F29/Y48F/HPFZZGOR/F29Y48FHPFZZGOR.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 2: The Software Description"}, {"step": 3, "steps_text": "As capturing and level comparison of the audio data has already been taken place on the computer side, only display hardware is now required to display the volume levels. Two circuits have been designed here for the purpose. The first is very simple one that uses an array of eight LEDs connected directly to the parallel port data outputs. This circuit has both its advantages and disadvantages: It is easy to build, does not use mains voltage, and it does not endanger your parallel port in any way. However, the LEDs are not as bright as normal mains powered lights, so you probably can't use them at a party. Also you can't use super bright or high current LEDs as those LEDs draw too much current, and the port will not be able to power them. This circuit for this LED based display section is shown in the above figure. The 8-bit data outputs are taken from the parallel port via the pins D0, D1, D2\u2026\u2026D7 those are physically located on pin number 2, 3, 4, 5\u2026...9 on the DB25 parallel port as shown in the circuit. Pin number 18 to 25 are the ground pins connecting to the common cathodes of the LEDs series. Two LEDs in series along with a current limiting resistor are connected to each bit output on the parallel port from D0 to D7. Hence for each level incremented in the audio intensity, two LEDs will glow. It is up to the choice of user only, he can use only one LED for each channel instead of the two or moreover can also increase the number by using a current driver circuit like ULN2003, etc or transistor based drivers. It is important to note that each pin on the parallel port can not source more than 20mA of current so if you use more LEDs, you have to add a driver circuit for the same.", "step_imgs": ["https://cdn.instructables.com/F33/G7M9/HPFZZGP5/F33G7M9HPFZZGP5.LARGE.jpg", "https://cdn.instructables.com/F0F/V0FV/HPFZZGR6/F0FV0FVHPFZZGR6.LARGE.jpg", "https://cdn.instructables.com/FSJ/8Y8T/HPFZZGV4/FSJ8Y8THPFZZGV4.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Circuit Description(LED Based)"}, {"step": 4, "steps_text": "The second circuit is the one which can be used to drive higher loads like mains 220V AC lamps up to 100watts on each of the eight output channels. This circuit too has both its advantages and disadvantages: It is fairly complex to build, does use mains voltage, and as it does connects to your parallel port and directly to 220V AC mains, so a little bit of precautionary measure is required to use this circuit. However, the 220V, 100watt AC lamps are bright enough, so you use them at a party. The circuit for the AC lamps based display section is shown in above figure. Again, the 8-bit data outputs are taken from the parallel port via the pins D0, D1, D2\u2026\u2026D7 those are physically located on pin number 2, 3, 4, 5\u2026\u2026.9 on the DB25 parallel port as shown in the circuit. Pin number 18 to 25 are the ground pins. Now, to drive the mains rated AC lamps, we use the TRIAC here as a switch. To drive the TRIACs and to isolate our +5 volt parallel port logic circuitry, we use the opto-coupler MOC3041. An opto-coupler is a device which is used to keep low-voltage circuits such as the very delicate parallel port and high-voltage (mains) circuits apart. They generally consist of 1 or more Infrared LED's pointing at a detector. The detector is used to trigger the TRIAC. Sometimes, as is the case with the MOC3041, there is a Zero-crossing detector also incorporated into the same package. Pin number 1 and 2 of the MOC3041 opto-coupler has the LED which acts as a signal transmitter inside the opto-coupler. We connect an external LED in series with this opto-coupler LED along with a current limiting resistor directly to the data lines of the parallel port for each of the eight output channels. The ground lines are shared by all the cathodes of opto-coupler LEDs and connected to pin 18 to 25 of the parallel port. The other side that is the detector side of the opto-coupler at pin number 4 and 6 is connected to the TRIAC pins via 470 and 330ohm resistors as shown in the circuit. The traditional way of proportionally controlling mains electricity is by using a TRIAC. These 3-terminal devices can be triggered to act as an on-off mains switch. Once they are turned on, they stay on until the voltage across them is reversed. This will happen every half of an AC cycle. To accurately control the power you need to know where you are in the mains cycle, so you can turn the TRIAC on in the appropriate place. However the purpose of ours is just to ON/OFF the load, and the zero crossing detector built already onto the MOC 3041 opto-coupler serves the purpose for us by switching the TRIAC on every reverse cycles of mains AC according to the control signal input. BT136 or any general purpose TRIAC with rating more than 4A, 400V can be used here. A combination of 39 ohm resistance and 0.01uF, 400v mains rated capacitor is used as a protection for the TRIAC, however they are optional but are recommended to be on the safe side. The correct pins of the BT136 TRIAC are shown in the second figure. To be on the safe side, it is recommended to use 0.5 watts resistor for the 470 ohm and 330 ohm value ones that connect the MOC3041 opto-coupler and the BT136 TRIAC, however 0.25 watts will also work fine. The mains 220V live input is fed to the MT2 pins of all TRIACS in series with an 8A fuse as shown in the circuit, while the MT1 pin goes to one of the terminal of the lamp and other terminal of the lamp goes to the mains neutral wire.", "step_imgs": ["https://cdn.instructables.com/FJ9/WU09/HPFZZGPD/FJ9WU09HPFZZGPD.LARGE.jpg", "https://cdn.instructables.com/F4Y/U05W/HPFZZGPM/F4YU05WHPFZZGPM.LARGE.jpg", "https://cdn.instructables.com/FL5/ND87/HPFZZGRL/FL5ND87HPFZZGRL.LARGE.jpg", "https://cdn.instructables.com/FXO/YSST/HPFZZGVP/FXOYSSTHPFZZGVP.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Circuit Description(AC Lamp Based)"}, {"step": 5, "steps_text": "Install the visual basic application on your computer system. After you have constructed either the LED based or AC lamp based display circuit as per your choice, connect it to the parallel port of your computer system. Open your \u201cVolume control\u201d settings either from the control panel or from the bottom-right of the taskbar of your computer as shown in figure 1. Then go to the \u201cOptions\u201d menu in the menu bar of the volume control window and choose \u201cProperties\u201d. The following screen will appear as shown in figure 2. In the \u201cProperties\u201d window, click the \u201cRecording\u201d option button and then from the list below, check mark on \u201cRecord Mixer\u201d and click on OK. Now the following screen will appear as shown in figure 3. Now mark the \u201cSelect\u201d check button of the Record Mixer section and set volume to maximum as shown in the screenshot. Run the VU Meter application. In the application, on the top-right settings frame, select the default audio driver hardware of your computer. Then select the physical address of your parallel port on the computer(default 378). Select either the left or right channel to sample, you can change this afterwards also. Now click on \u201cSTART\u201d button. You will observe that the green level in the LedMeter on the software will be right in the middle. Now play any song or anything on your computer, you will notice the LedMeter bars and Lights status LEDs on the software will follow the beats of your audio being played and the same sequence the display section consisting of the LEDs/AC lamps will follow.", "step_imgs": ["https://cdn.instructables.com/FWU/T7VF/HPFZZGQD/FWUT7VFHPFZZGQD.LARGE.jpg", "https://cdn.instructables.com/FOU/127J/HPFZZGQF/FOU127JHPFZZGQF.LARGE.jpg", "https://cdn.instructables.com/FR6/YJV8/HPFZZGQI/FR6YJV8HPFZZGQI.LARGE.jpg"], "step_title": "Step 5: Test and Setup"}, {"step": 6, "steps_text": "The LED based display circuit is not only simple in construction but also safe to implement. It will not do any harm to your computer\u2019s parallel port. While implementing the AC lamp based circuit for display section, some precautions must be kept in mind before powering the circuit for the first time which are described herein. It is recommended that if you design your own PCB for the AC lamp based circuit, the traces of the PCB especially which carry the mains AC power must be thick enough to handle higher currents. A 220V, 100 watt lamp for example consumed about 0.45 A of current, so traces must be so designed that they can handle more than 0.45A current. For example for a trace of length 10mm with 35um of copper thickness, to carry 1A current at ambient 25\u2019C temperature its width required is about 300um(11.8 mil). It is good to give a fair distance between the traces of the parallel port circuit connections to the opto-coupler and the mains 220V AC carrying traces to the TRIACs, etc. Next consideration is to house your circuit in a plastic or non-conducting enclosure only because the circuit runs on mains 220V. Before soldering your TRIAC it is good to recheck for the correct pins otherwise it can harm the TRIAC or to the circuit. Do not skip the 8A fuse, otherwise you may damage your mains wiring if something wrong happens. Also the wire used to carry 220V from mains wall socket to the circuit must be capable of carrying more that 5 A of current or equivalent. At last always recheck for the connections and wiring before you plug it for the first time.", "step_imgs": [], "step_title": "Step 6: Precautions"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          SOS is the commonly used description for the international Morse code distress signal (\u00b7 \u00b7 \u00b7 \u2014 \u2014 \u2014 \u00b7 \u00b7 \u00b7). \u00a0[read more on wiki]Requirements:\n1) Arduino\n2*) 8 \u03a9 speaker\n3*) 150 \u03a9 or similar resistor\n4) 5mm RED LED\n5) Hook-up wires\n6) Any breadboard\n* \u03a9 = OhmsDemo:", "title": "Arduino SOS Signal With 8ohms Speaker + LED Blinking", "url": "https://www.instructables.com/id/Arduino-SOS-signal-with-8ohms-speaker-LED-blinki/", "section": "technology", "steps": [{"step": 1, "steps_text": "Hook-up wires as shown (original pic here). Make sure that LED's anode and cathode correctly connected. [read more on wiki]", "step_imgs": ["https://cdn.instructables.com/F83/GEI8/H130PDN0/F83GEI8H130PDN0.LARGE.jpg"], "step_title": "Step 1: Schematic"}, {"step": 2, "steps_text": "\n          Lets start coding./*\u00a0\u00a0SOS\u00a0signal\u00a0\u00a0Created\u00a0by\u00a0Vaidotas\u00a0on\u00a04/16/2012.\u00a0\u00a0Copyright\u00a0(c)\u00a02012\u00a0https://www.instructables.com/id/Arduino-SOS-signal-with-8ohms-speaker-LED-blinki/*/int pin = 8;\nint pause = 100;\nint note = 440; // music note A4voidsetup()\n{\n\u00a0\u00a0// no need\n}\n\n//\u00a0SOS\u00a0signalvoidloop()\n{\n\u00a0\u00a0threeDots();\n\u00a0\u00a0threeDashes();\n\u00a0\u00a0threeDots();\n\u00a0\u00a0delay(3000);\n}\n\n//\u00a0three\u00a0short\u00a0signalsvoid threeDots()\n{\n\u00a0\u00a0for (int i=0; i<3; i++){\n\u00a0\u00a0\u00a0\u00a0tone(pin, note, 100);\n\u00a0\u00a0\u00a0\u00a0delay(200);\n\u00a0\u00a0\u00a0\u00a0noTone(pin);\n\u00a0\u00a0}\n\u00a0\u00a0delay(200);\n}\n\n//\u00a0three\u00a0long\u00a0signals8void threeDashes()\n{\n\u00a0\u00a0for (int i=0; i<3; i++){\n\u00a0\u00a0\u00a0\u00a0tone(pin, note, 300);\n\u00a0\u00a0\u00a0\u00a0delay(400);\n\u00a0\u00a0\u00a0\u00a0noTone(pin);\n\u00a0\u00a0}\n\u00a0\u00a0delay(200);\n}\n\n\nUpload and enjoy ;)\n        ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: Code"}, {"step": 3, "steps_text": "\n          If You want to change tone, You should change lines number:int note = 440; // music note A4\nHere is the list of notes:/*************************************************\u00a0*\u00a0Public\u00a0Constants\u00a0*************************************************/\n\n#define\u00a0NOTE_B0\u00a0\u00a031\n#define\u00a0NOTE_C1\u00a0\u00a033\n#define\u00a0NOTE_CS1\u00a035\n#define\u00a0NOTE_D1\u00a0\u00a037\n#define\u00a0NOTE_DS1\u00a039\n#define\u00a0NOTE_E1\u00a0\u00a041\n#define\u00a0NOTE_F1\u00a0\u00a044\n#define\u00a0NOTE_FS1\u00a046\n#define\u00a0NOTE_G1\u00a0\u00a049\n#define\u00a0NOTE_GS1\u00a052\n#define\u00a0NOTE_A1\u00a0\u00a055\n#define\u00a0NOTE_AS1\u00a058\n#define\u00a0NOTE_B1\u00a0\u00a062\n#define\u00a0NOTE_C2\u00a0\u00a065\n#define\u00a0NOTE_CS2\u00a069\n#define\u00a0NOTE_D2\u00a0\u00a073\n#define\u00a0NOTE_DS2\u00a078\n#define\u00a0NOTE_E2\u00a0\u00a082\n#define\u00a0NOTE_F2\u00a0\u00a087\n#define\u00a0NOTE_FS2\u00a093\n#define\u00a0NOTE_G2\u00a0\u00a098\n#define\u00a0NOTE_GS2\u00a0104\n#define\u00a0NOTE_A2\u00a0\u00a0110\n#define\u00a0NOTE_AS2\u00a0117\n#define\u00a0NOTE_B2\u00a0\u00a0123\n#define\u00a0NOTE_C3\u00a0\u00a0131\n#define\u00a0NOTE_CS3\u00a0139\n#define\u00a0NOTE_D3\u00a0\u00a0147\n#define\u00a0NOTE_DS3\u00a0156\n#define\u00a0NOTE_E3\u00a0\u00a0165\n#define\u00a0NOTE_F3\u00a0\u00a0175\n#define\u00a0NOTE_FS3\u00a0185\n#define\u00a0NOTE_G3\u00a0\u00a0196\n#define\u00a0NOTE_GS3\u00a0208\n#define\u00a0NOTE_A3\u00a0\u00a0220\n#define\u00a0NOTE_AS3\u00a0233\n#define\u00a0NOTE_B3\u00a0\u00a0247\n#define\u00a0NOTE_C4\u00a0\u00a0262\n#define\u00a0NOTE_CS4\u00a0277\n#define\u00a0NOTE_D4\u00a0\u00a0294\n#define\u00a0NOTE_DS4\u00a0311\n#define\u00a0NOTE_E4\u00a0\u00a0330\n#define\u00a0NOTE_F4\u00a0\u00a0349\n#define\u00a0NOTE_FS4\u00a0370\n#define\u00a0NOTE_G4\u00a0\u00a0392\n#define\u00a0NOTE_GS4\u00a0415\n#define\u00a0NOTE_A4\u00a0\u00a0440\n#define\u00a0NOTE_AS4\u00a0466\n#define\u00a0NOTE_B4\u00a0\u00a0494\n#define\u00a0NOTE_C5\u00a0\u00a0523\n#define\u00a0NOTE_CS5\u00a0554\n#define\u00a0NOTE_D5\u00a0\u00a0587\n#define\u00a0NOTE_DS5\u00a0622\n#define\u00a0NOTE_E5\u00a0\u00a0659\n#define\u00a0NOTE_F5\u00a0\u00a0698\n#define\u00a0NOTE_FS5\u00a0740\n#define\u00a0NOTE_G5\u00a0\u00a0784\n#define\u00a0NOTE_GS5\u00a0831\n#define\u00a0NOTE_A5\u00a0\u00a0880\n#define\u00a0NOTE_AS5\u00a0932\n#define\u00a0NOTE_B5\u00a0\u00a0988\n#define\u00a0NOTE_C6\u00a0\u00a01047\n#define\u00a0NOTE_CS6\u00a01109\n#define\u00a0NOTE_D6\u00a0\u00a01175\n#define\u00a0NOTE_DS6\u00a01245\n#define\u00a0NOTE_E6\u00a0\u00a01319\n#define\u00a0NOTE_F6\u00a0\u00a01397\n#define\u00a0NOTE_FS6\u00a01480\n#define\u00a0NOTE_G6\u00a0\u00a01568\n#define\u00a0NOTE_GS6\u00a01661\n#define\u00a0NOTE_A6\u00a0\u00a01760\n#define\u00a0NOTE_AS6\u00a01865\n#define\u00a0NOTE_B6\u00a0\u00a01976\n#define\u00a0NOTE_C7\u00a0\u00a02093\n#define\u00a0NOTE_CS7\u00a02217\n#define\u00a0NOTE_D7\u00a0\u00a02349\n#define\u00a0NOTE_DS7\u00a02489\n#define\u00a0NOTE_E7\u00a0\u00a02637\n#define\u00a0NOTE_F7\u00a0\u00a02794\n#define\u00a0NOTE_FS7\u00a02960\n#define\u00a0NOTE_G7\u00a0\u00a03136\n#define\u00a0NOTE_GS7\u00a03322\n#define\u00a0NOTE_A7\u00a0\u00a03520\n#define\u00a0NOTE_AS7\u00a03729\n#define\u00a0NOTE_B7\u00a0\u00a03951\n#define\u00a0NOTE_C8\u00a0\u00a04186\n#define\u00a0NOTE_CS8\u00a04435\n#define\u00a0NOTE_D8\u00a0\u00a04699\n#define\u00a0NOTE_DS8\u00a04978\n\n", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 3: Optional"}], "channel": "Arduino"}, {"category": "technology", "description": "In this first video we will be looking at how to begin using the PWM module in a PIC microcontroler.\u00a0 These videos were getting large and I needed to split it up since I want to make sure I give all that is involved. Enjoy! In the second video we will be looking at the code for the PWM module. The code will be placed on the project code link on my channel. In the third video we will be looking at a demo of producing different PWM wave forms at different frequencies. Follow me on youtube http://www.youtube.com/misperry Follow me on Twitter http://www.twitter.com/misperryee T-Shirts http://www.zazzle.com/misperry", "title": "PIC Basics - PWM", "url": "https://www.instructables.com/id/PIC-Basics-PWM/", "section": "technology", "steps": [], "channel": "Microcontrollers"}, {"category": "technology", "description": "It is a simple time pass project.. All of you can make on your ceiling fan. the led lights are attached on the leaves of the fan. the lights will glow with respect to the audio source attached to it.", "title": "Equalizer Light on FAN ", "url": "https://www.instructables.com/id/Equalizer-Light-On-FAN/", "section": "technology", "steps": [{"step": 1, "steps_text": "to feed the external power and audio input. use/make slip rings on the fans neck.", "step_imgs": ["https://cdn.instructables.com/FAM/GWKT/IBW27IW9/FAMGWKTIBW27IW9.LARGE.jpg", "https://cdn.instructables.com/FZR/426R/IBW27IW6/FZR426RIBW27IW6.LARGE.jpg"], "step_title": "Step 1: Slip Rings on Fan"}, {"step": 2, "steps_text": "LM 3914 equalizer I.C is used here to made the circuit.", "step_imgs": ["https://cdn.instructables.com/FXC/8S4Q/IBW27IW0/FXC8S4QIBW27IW0.LARGE.jpg", "https://cdn.instructables.com/F3D/HY9X/IBW27IW4/F3DHY9XIBW27IW4.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram"}, {"step": 3, "steps_text": "these are the pics showing lighting variations at different audio intensities.", "step_imgs": ["https://cdn.instructables.com/FQW/1HKP/IBW27IVQ/FQW1HKPIBW27IVQ.LARGE.jpg", "https://cdn.instructables.com/F6Q/M1RK/IBW27IVZ/F6QM1RKIBW27IVZ.LARGE.jpg", "https://cdn.instructables.com/FS2/GL8K/IBW27IVW/FS2GL8KIBW27IVW.LARGE.jpg", "https://cdn.instructables.com/FQX/ZGDQ/IBW27IW2/FQXZGDQIBW27IW2.LARGE.jpg", "https://cdn.instructables.com/F6E/DFPS/IBW27IVU/F6EDFPSIBW27IVU.LARGE.jpg", "https://cdn.instructables.com/FVP/81NB/IBW27IVS/FVP81NBIBW27IVS.LARGE.jpg", "https://cdn.instructables.com/FVQ/EGX6/IBW27IW3/FVQEGX6IBW27IW3.LARGE.jpg"], "step_title": "Step 3: Photos "}, {"step": 4, "steps_text": "", "step_imgs": [], "step_title": "Step 4: "}], "channel": "LEDs"}, {"category": "technology", "description": "It is a simple time pass project.. All of you can make on your ceiling fan. the led lights are attached on the leaves of the fan. the lights will glow with respect to the audio source attached to it.", "title": "Equalizer Light on FAN ", "url": "https://www.instructables.com/id/Equalizer-Light-On-FAN/", "section": "technology", "steps": [{"step": 1, "steps_text": "to feed the external power and audio input. use/make slip rings on the fans neck.", "step_imgs": ["https://cdn.instructables.com/FAM/GWKT/IBW27IW9/FAMGWKTIBW27IW9.LARGE.jpg", "https://cdn.instructables.com/FZR/426R/IBW27IW6/FZR426RIBW27IW6.LARGE.jpg"], "step_title": "Step 1: Slip Rings on Fan"}, {"step": 2, "steps_text": "LM 3914 equalizer I.C is used here to made the circuit.", "step_imgs": ["https://cdn.instructables.com/FXC/8S4Q/IBW27IW0/FXC8S4QIBW27IW0.LARGE.jpg", "https://cdn.instructables.com/F3D/HY9X/IBW27IW4/F3DHY9XIBW27IW4.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram"}, {"step": 3, "steps_text": "these are the pics showing lighting variations at different audio intensities.", "step_imgs": ["https://cdn.instructables.com/FQW/1HKP/IBW27IVQ/FQW1HKPIBW27IVQ.LARGE.jpg", "https://cdn.instructables.com/F6Q/M1RK/IBW27IVZ/F6QM1RKIBW27IVZ.LARGE.jpg", "https://cdn.instructables.com/FS2/GL8K/IBW27IVW/FS2GL8KIBW27IVW.LARGE.jpg", "https://cdn.instructables.com/FQX/ZGDQ/IBW27IW2/FQXZGDQIBW27IW2.LARGE.jpg", "https://cdn.instructables.com/F6E/DFPS/IBW27IVU/F6EDFPSIBW27IVU.LARGE.jpg", "https://cdn.instructables.com/FVP/81NB/IBW27IVS/FVP81NBIBW27IVS.LARGE.jpg", "https://cdn.instructables.com/FVQ/EGX6/IBW27IW3/FVQEGX6IBW27IW3.LARGE.jpg"], "step_title": "Step 3: Photos "}, {"step": 4, "steps_text": "", "step_imgs": [], "step_title": "Step 4: "}], "channel": "LEDs"}, {"category": "No category to show", "description": "Make a head piece that can transmit light and color based on your pulse!", "title": "Fiber Optic Head Piece", "url": "https://www.instructables.com/id/Fiber-Optic-Head-Piece/", "section": "craft", "steps": [{"step": 1, "steps_text": "Arduino Uno R3Pulse SensorFlora RGB Smart NeoPixelFiber Optics9V Battery ClipHeat ShrinkMetal WireLaceGreeneryFeathersHot GlueSuper Glue", "step_imgs": ["https://cdn.instructables.com/FGO/R5CV/J2AW24QD/FGOR5CVJ2AW24QD.LARGE.jpg", "https://cdn.instructables.com/F3Z/V5VP/J2AW24QE/F3ZV5VPJ2AW24QE.LARGE.jpg", "https://cdn.instructables.com/F56/EXYS/J2AW24QF/F56EXYSJ2AW24QF.LARGE.jpg", "https://cdn.instructables.com/FLO/PLN2/J2AW24QG/FLOPLN2J2AW24QG.LARGE.jpg", "https://cdn.instructables.com/FR9/MCRK/J2AW24QI/FR9MCRKJ2AW24QI.LARGE.jpg", "https://cdn.instructables.com/F30/UNCJ/J2AW24QP/F30UNCJJ2AW24QP.LARGE.jpg"], "step_title": "Step 1: Materials"}, {"step": 2, "steps_text": "Interrupt /*This code uses the Pulse Sensor Amped by Joel Murphy and Yury Gitman      www.pulsesensor.com       >>> Pulse Sensor purple wire goes to Analog Pin 0 <<< Pulse Sensor sample aquisition and processing happens in the background via Timer 2 interrupt. 2mS sample rate. PWM on pins 3 and 11 will not work when using this code, because we are using Timer 2! The following variables are automatically updated: Signal :    int that holds the analog signal data straight from the sensor. updated every 2mS. IBI  :      int that holds the time interval between beats. 2mS resolution. BPM  :      int that holds the heart rate value, derived every beat, from averaging previous 10 IBI values. QS  :       boolean that is made true whenever Pulse is found and BPM is updated. User must reset. Pulse :     boolean that is true when a heartbeat is sensed then false in time with pin13 LED going out.NOTE: This code works with Arduino UNO or Arduino PRO or Arduino Pro Mini 5V or any Arduino running with an  ATmega328 and 16MHz clock. This will disable PWM output on pin 3 and 11. Also, it will disable the tone() command. All the work to find the heartbeat and determine the heartrate happens in the code below. For using the Pulse Sensor code, see the link below for a code walkthrough:  http://pulsesensor.myshopify.com/pages/pulse-sens...Code Version 02 by Joel Murphy & Yury Gitman  Fall 2012 */volatile int rate[10];                    // used to hold last ten IBI values volatile unsigned long sampleCounter = 0;          // used to determine pulse timing volatile unsigned long lastBeatTime = 0;           // used to find the inter beat interval volatile int P =512;                      // used to find peak in pulse wave volatile int T = 512;                     // used to find trough in pulse wave volatile int thresh = 512;                // used to find instant moment of heart beat volatile int amp = 100;                   // used to hold amplitude of pulse waveform volatile boolean firstBeat = true;        // used to seed rate array so we startup with reasonable BPM volatile boolean secondBeat = true;       // used to seed rate array so we startup with reasonable BPMvoid interruptSetup(){        // Initializes Timer2 to throw an interrupt every 2mS.   TCCR2A = 0x02;     // DISABLE PWM ON DIGITAL PINS 3 AND 11, AND GO INTO CTC MODE   TCCR2B = 0x06;     // DON'T FORCE COMPARE, 256 PRESCALER    OCR2A = 0X7C;      // SET THE TOP OF THE COUNT TO 124 FOR 500Hz SAMPLE RATE   TIMSK2 = 0x02;     // ENABLE INTERRUPT ON MATCH BETWEEN TIMER2 AND OCR2A   sei();             // MAKE SURE GLOBAL INTERRUPTS ARE ENABLED       } // THIS IS THE TIMER 2 INTERRUPT SERVICE ROUTINE.  // Timer 2 makes sure that we take a reading every 2 miliseconds ISR(TIMER2_COMPA_vect){                         // triggered when Timer2 counts to 124     cli();                                      // disable interrupts while we do this     Signal = analogRead(pulsePin);              // read the Pulse Sensor      sampleCounter += 2;                         // keep track of the time in mS with this variable     int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise//  find the peak and trough of the pulse wave     if(Signal < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI         if (Signal < T){                        // T is the trough             T = Signal;                         // keep track of lowest point in pulse wave           }        }            if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise         P = Signal;                             // P is the peak        }                                        // keep track of highest point in pulse wave        //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT   // signal surges up in value every time there is a pulse if (N > 250){                                   // avoid high frequency noise   if ( (Signal > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){             Pulse = true;                               // set the Pulse flag when we think there is a pulse     digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED     IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS     lastBeatTime = sampleCounter;               // keep track of time for next pulse                    if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE              firstBeat = false;                 // clear firstBeat flag              return;                            // IBI value is unreliable so discard it             }             if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE             secondBeat = false;                 // clear secondBeat flag                for(int i=0; i<=9; i++){         // seed the running total to get a realisitic BPM at startup                     rate[i] = IBI;                                           }             }                // keep a running total of the last 10 IBI values     word runningTotal = 0;                   // clear the runningTotal variable        for(int i=0; i<=8; i++){                // shift data in the rate array           rate[i] = rate[i+1];              // and drop the oldest IBI value            runningTotal += rate[i];          // add up the 9 oldest IBI values         }              rate[9] = IBI;                          // add the latest IBI to the rate array     runningTotal += rate[9];                // add the latest IBI to runningTotal     runningTotal /= 10;                     // average the last 10 IBI values      BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!     QS = true;                              // set Quantified Self flag      // QS FLAG IS NOT CLEARED INSIDE THIS ISR     }                        }  if (Signal < thresh && Pulse == true){     // when the values are going down, the beat is over       digitalWrite(blinkPin,LOW);            // turn off pin 13 LED       Pulse = false;                         // reset the Pulse flag so we can do it again       amp = P - T;                           // get amplitude of the pulse wave       thresh = amp/2 + T;                    // set thresh at 50% of the amplitude       P = thresh;                            // reset these for next time       T = thresh;      }      if (N > 2500){                             // if 2.5 seconds go by without a beat       thresh = 512;                          // set thresh default       P = 512;                               // set P default       T = 512;                               // set T default       lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date               firstBeat = true;                      // set these to avoid noise       secondBeat = true;                     // when we get the heartbeat back      }      sei();                                     // enable interrupts when youre done! }// end isrPulse Sensor#include     // Library containing  // Behavior setting variables int pulsePin = 0;                 // Pulse Sensor purple wire connected to analog pin 0 int blinkPin = 13;                // Digital pin to blink led at each beat int fadePin  = 5;                 // pin to do fancy neopixel effects at each beat int fadeRate = 0;                 // used to fade LED on with PWM on fadePin   // these variables are volatile because they are used during the interrupt service routine volatile int BPM;                   // used to hold the pulse rate volatile int Signal;                // holds the incoming raw data volatile int IBI = 600;             // holds the time between beats, the Inter-Beat Interval volatile boolean Pulse = false;     // true when pulse wave is high, false when it's low volatile boolean QS = false;        // becomes true when Arduoino finds a beat.   // Set up use of NeoPixels const int NUMPIXELS = 12;           // Put the number of NeoPixels you are using here const int BRIGHTNESS = 255;          // Set brightness of NeoPixels here Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMPIXELS, fadePin, NEO_GRB + NEO_KHZ800);   void setup(){   pinMode(blinkPin,OUTPUT);         // pin that will blink to your heartbeat! //  Serial.begin(115200);           // Serial output data for debugging or external use   strip.begin();   strip.setBrightness(BRIGHTNESS);   for (int x=0; x < NUMPIXELS; x++) {  // Initialize all pixels to 'off'      strip.setPixelColor(x, strip.Color(0, 0, 0));   }   strip.show();                     // Ensure the pixels are off   delay(1000);                      // Wait a second   interruptSetup();                 // sets up to read Pulse Sensor signal every 2mS }   void loop(){ //  sendDataSerial('S', Signal);      // send Processing the raw Pulse Sensor data   if (QS == true){                    // Quantified Self flag is true when arduino finds a heartbeat      fadeRate = 255;                  // Set 'fadeRate' Variable to 255 to fade LED with pulse //     sendDataSerial('B',BPM);       // send heart rate with a 'B' prefix //     sendDataSerial('Q',IBI);       // send time between beats with a 'Q' prefix      QS = false;                      // reset the Quantified Self flag for next time      }   ledFadeToBeat();                    // Routine that fades color intensity to the beat   delay(20);                          //  take a break }   void ledFadeToBeat() {     fadeRate -= 15;                         // Set LED fade value     fadeRate = constrain(fadeRate,0,255);   // Keep LED fade value from going into negative numbers     setStrip(fadeRate);                     // Write the value to the NeoPixels //    sendDataSerial('R',fadeRate); }   void sendDataSerial(char symbol, int data ) { //    Serial.print(symbol);                // symbol prefix tells Processing what type of data is coming //    Serial.println(data);                // the data to send culminating in a carriage return }   void setStrip(int r) {     // Set the strip to one color intensity (red)      if (BPM >= 0 && BPM <= 50) {       int g=0;       int b=r;       int r=0;        for (int x=0; x < NUMPIXELS; x++) {         strip.setPixelColor(x, strip.Color(r, g, b));      }      strip.show();    }    else if(BPM >=51 && BPM <= 100) {       int g=r;       int b=0;       int r=0;        for (int x=0; x < NUMPIXELS; x++) {         strip.setPixelColor(x, strip.Color(r, g, b));      }      strip.show();         }    else {       int g = 0;              // Green is set to zero (for non-red colors, change this)       int b = 0;              // Blue is set to zero (for non-red colors, change this)        for (int x=0; x < NUMPIXELS; x++) {         strip.setPixelColor(x, strip.Color(r, g, b));      }      strip.show();         } }", "step_imgs": [], "step_title": "Step 2: Code Your Arduino "}, {"step": 3, "steps_text": "After coding your Arduino, soldier wires from LED and Pulse Sensor to Arduino based on input and output.Once connected, begin connection of Fiber Optics to LED using super glue.Fiber Optics should be held in heat shrunk tubing, shrunk by a blow dryer.Hot glue will be used as an eliminator and light conductor through your design. Place Fiber Optics with hot glue throughout your head piece.Attach your Arduino and Pulse Sensor with wire on the head piece. Hide electronics as best as possible. Pulse Sensor will read your pulse, and change color based on given code. Fiber Optics will reflect off LED and light up head piece.Make sure all wires and fibers are fully attached. ", "step_imgs": [], "step_title": "Step 3: Construction"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "\u00a0 This Arduino project is a throwback to several carnival and novelty arcade games from when I was a kid. I\u2019ve done many Arduino projects, but this is my first project that was my own design. Prior to this, I generally followed someone else\u2019s design or idea. My main motivation was to try to understand using the Adafruit Wave shield. Someday I would like to have the Arduino also control the servo that controls the skull, but for this project the talking skull portion was a kit. There are other talking skulls available (Talking thru Boris, a halloween decoration that can be found on auction sites). I also wanted to build this as inexpensively as possible & use parts that are either things I already had on hand, or parts that are plentiful & cheap. Using this approach often makes the finished project more unique. A note about the video: I removed the glass to make the project more visible in the video.", "title": "Multi-personality Fortune Teller", "url": "https://www.instructables.com/id/Multi-personality-Fortune-teller/", "section": "craft", "steps": [{"step": 1, "steps_text": "This was a long project so I won't attempt to list everything but the key elements are:\n-Arduino\n-Wave shield & SD card(Adafruit)\n-Talking skull (I got mine from Nuts & Volts)\n-potentiometer (Radio Shack)\n-coin op mechanism (Adafruit)\n-inexpensive computer speakers (Thrift store)\n-LED strip lights (online supplier)\n-UV LED lights(online supplier)\n-Windshield wiper motor (salvage)\n-11X14 frame\n-Mirror window tint\n-3/4\" plywood\u00a0\n-1/2 doors\n-flocked paper\u00a0\nI will try to point out helpful parts throughout the instructable but slight alterations in the design should make it easier to utilize parts you already have.", "step_imgs": [], "step_title": "Step 1: Parts List"}, {"step": 2, "steps_text": "I built the box that contains the skull first. The dimensions of the box will depend on the size of frame you use & how thick the border of the frame is. The wider the border, the more room for error. It is mounted with a piano hinge on one side & some brackets on the other, so I could make adjustments easily, although it doesn't allow easy access to the general public. My box is slightly wider than the inside edge of the frame. There is a groove that is cut into the plywood on the backside for mounting the back panel.\nOnce the box was constructed, I lined the inside of the box with black paper on all sides except for the bottom. Fuzzy, flocked paper works best, but ordinary black construction paper will be fine, or even painting the inside of the box. I cut a piece of plywood that fits just inside the bottom of the box when stood upright. This is what we'll mount the bracket that holds the skull to.\nI used flat steel bracket stock to make the bracket. After deciding approximately how high I wanted the skull, I cut & bent the bracket accordingly, being sure to allow enough surface area to mount the skull securely. Once I'd bent the bracket, I mounted the skull on it. In my case, I cut two small notches in the hole at the base of the skull, which were large enough to insert the bracket. I also added a bolt for the skull to rest on. Now put the whole assembly together & line it up in the box, confirming that the skull is where you want it. Confirm the bend is at the right place & that the skull has enough clearance at the front & the back, since you do not want the spinning disc rubbing up against the skull or the skull touching the glass. Mark where you want your mounting holes for the bracket & remove everything so you can drill your pilot holes into the base. Remove everything from the bracket temporarily, and make any necessary adjustments to the bracket. Once you have the bracket perfect, heat the bracket with a plumbers torch until it's red hot. Then drop it into a pan of water to cool it quickly. This will set your bend & make it springy & rigid. Cover your plywood base with black paper & cut out your pilot holes with a craft knife.\nI rolled some paper over a piece of a florescent tube protector & taped it with some black tape to conceal the bracket.\nDrill a hole large enough to fit the ends to all your power & audio cables into at the base of the bracket. You want your tube to be able to conceal this. NOTE: this hole needs to be big enough to stuff the cables through, while also having other wires running through it. Mount your bracket using large screws & washers or lag bolts. I used a stiff piece of wire to fish all the cables through the hole & the tube.\nYour finished base should look something like the final picture in this step.", "step_imgs": ["https://cdn.instructables.com/F7J/T5S6/H7A8PNAK/F7JT5S6H7A8PNAK.LARGE.jpg", "https://cdn.instructables.com/F96/HZMV/H7A8PNAP/F96HZMVH7A8PNAP.LARGE.jpg", "https://cdn.instructables.com/FD1/D8UH/H7A8PNLM/FD1D8UHH7A8PNLM.LARGE.jpg", "https://cdn.instructables.com/FIM/1EGC/H7A8PNAW/FIM1EGCH7A8PNAW.LARGE.jpg", "https://cdn.instructables.com/FPN/OQ82/H7A8PNBF/FPNOQ82H7A8PNBF.LARGE.jpg", "https://cdn.instructables.com/F1W/N8JJ/H7A8PNBR/F1WN8JJH7A8PNBR.LARGE.jpg", "https://cdn.instructables.com/FBD/UCZU/H7A8PNC1/FBDUCZUH7A8PNC1.LARGE.jpg", "https://cdn.instructables.com/F6N/0A3M/H7A8PNCD/F6N0A3MH7A8PNCD.LARGE.jpg"], "step_title": "Step 2: Skull Housing Construction"}, {"step": 3, "steps_text": "The frame is just an ordinary picture frame purchased from a hobby supplier. You want to get a wood frame that is wide enough to hide the edges of the box, yet deep enough to put a screw into without the screw coming out of the front of the frame. As I mentioned before, the wider the border of the frame, the more forgiving it will be when aligning it.\nI used mirror privacy tint on the glass, which can be purchased at a hardware store or done by a pro at an auto tint service. I had mine done at an auto-tinter because I didn't see the need to buy a whole roll of tint just so I could use a couple of feet of it.\nWhen you typically buy frames at a hobby store, they are just the frame, so I used strips of 1/8\" plywood that were cut on the table saw. I predrilled the holes for the screws & lined it all up on the frame. I predrilled holes in the frame also, using a scrap piece of plexiglas instead of the glass as a spacer. In my project, I used a matte board border to frame the skull & help conceal the lights. Since this sits right next to the glass, I slipped a piece of this next to the plexiglas before drilling my pilot holes.\nWhen drilling your pilot holes, mark one spot on each strip on both the strip & the frame with something distinct. This is so you will not get the pieces mixed up when you reassemble them. I drew a line on one, an x on the next one, a 0 on the third one and a black dot on the final one. This way, when or if you take it apart, you can easily reassemble it by aligning the symbols, so that all you pilot holes will match up.\nMounting a piano hinge is usually easier than using separate hinges. Just line it up so that it\u2019s even along the frame from the edge. Drill a pilot hole for a screw on the middle of the hinge and put a screw in it.\u00a0 Re-align so that you\u2019re sure it\u2019s where you want it & drill a pilot hole for one of the end screws. Then put a screw in it. It should be held in place good enough that you can drill all the other pilot holes. The other side is easy because it should just line up with the outside edge of the box.\nOnce assembled, the whole box & frame should resemble a very deep medicine cabinet.", "step_imgs": ["https://cdn.instructables.com/FQ3/I9BM/H7KZ28NH/FQ3I9BMH7KZ28NH.LARGE.jpg", "https://cdn.instructables.com/FOB/8W7G/H7KZ28QR/FOB8W7GH7KZ28QR.LARGE.jpg", "https://cdn.instructables.com/FFW/FR0U/H7KZ2A7J/FFWFR0UH7KZ2A7J.LARGE.jpg"], "step_title": "Step 3: Preparing the Frame"}, {"step": 4, "steps_text": "The base sits inside the box on two strips of wood, which allows the wires to sit in the space without being pinched. I used a piece of stretchy fabric in the back to keep the wires in place for the notch in the back cover.\nI mounted the LED light strips onto some drywall corner protector. This material already has adhesive strips on them. I was able to peel adhesive off of the LEDs & the adhesive off the corner protector to make a really good bond. I then used screws to mount the corner protector to the inside front of the box, just inside where the frame is. On this project, I also wanted to use some UV LEDs, but I couldn't find any lightstrips that were UV so I made my own with single LEDs & some spare strips of thin plastic.\nI cut a piece of 1/2 inch plywood to fit inside the groove on the back of the box. This is what we will mount the windshield wiper motor to. I also mounted the Arduino electronics to this, but if I did it again I probably wouldn't do it that way. When mounting the motor, be sure that you mount it securely because over time, vibration from the motor might work it loose. I made the support sturdier by using a metal plate on the inside. Make sure that you put the screw heads on the inside so that you'll have enough clearance for your spinning disc. Since the skull sits right in the middle of the spinning disc, it isn't necessary to cover up the mounting bolt to the motor because it won't be visible.", "step_imgs": ["https://cdn.instructables.com/F8I/X8FH/H7A8PNCV/F8IX8FHH7A8PNCV.LARGE.jpg", "https://cdn.instructables.com/FI1/XUKZ/H7A8PNKT/FI1XUKZH7A8PNKT.LARGE.jpg", "https://cdn.instructables.com/FBG/JQHS/H7A8PNNW/FBGJQHSH7A8PNNW.LARGE.jpg", "https://cdn.instructables.com/FP3/FYZ5/H7A8PNQW/FP3FYZ5H7A8PNQW.LARGE.jpg"], "step_title": "Step 4: "}, {"step": 5, "steps_text": "My disc is cut from Plexiglas, but could be done with anything fairly lightweight. There is an easy method for cutting true circles out of plexiglas. First, decide how big you want your circle, then divide that number in half. Nail two nails in a strip of wood exactly that far apart. Then, drive the nails in, just far enough that the points only stick out an 1/8\". Drill a hole in your plexiglas where you would like your disc\u2019s center to be. Sharpen one of the nails so that the front side is flat. Picture a chisel edge on the nail, instead of a knife edge. Insert the other nail in the hole on the plexiglas & slowly rotate the tool around the perimeter of the hole. Flip the plastic over & do the same on the other side. Make multiple passes. The more patient you are, the better the finished product.\nGently flex the plex along the cut edge, so that it snaps along where you've made your cut. This is the best method I've used to cut from plex, because using a saw heats the plastic & melts it. I glued my spiral to the disc using craft glue. The example shown isn't the same size disc that I used in the final project, it's just an example I made to show this technique.", "step_imgs": ["https://cdn.instructables.com/FHE/0X6I/H7KZ294V/FHE0X6IH7KZ294V.LARGE.jpg", "https://cdn.instructables.com/F1O/0B5C/H7KZ2953/F1O0B5CH7KZ2953.LARGE.jpg", "https://cdn.instructables.com/F4E/SIW6/H7KZ296Z/F4ESIW6H7KZ296Z.LARGE.jpg", "https://cdn.instructables.com/F5M/L9ET/H7KZ297M/F5ML9ETH7KZ297M.LARGE.jpg", "https://cdn.instructables.com/FAI/MP0W/H7KZ297S/FAIMP0WH7KZ297S.LARGE.jpg"], "step_title": "Step 5: Cutting the Disc"}, {"step": 6, "steps_text": "This is how I have assembled the back cover. Originally, I used a cigar box to contain the electronics, but it isn't important to the design. This box was available & was about the right size, so I used it.\nThe LED light strips are 12v, so they are controlled using IRF510 mosfets using a signal sent from the Arduino. These lights flicker/strobe, which creates the illusion that the spinning disc is moving slower than it actually is. The motor is also 12V & is just turned on via mosfet. I used a separate power source to avoid any interference to the Arduino.\nLining the area where the back cover meets the box with craft foam sheets cut into strips will dampen any noise caused by the vibration of the motor. Using a layer of foam between the motor & the back cover will help as well.\nThe mosfets could all be soldered to the same board, but I just used one that I had created prior to this project. Since the motor & the LEDs are only on briefly, a heat sink isn't needed. Although if you alter the sketch to where they\u2019re always on, a heat sink would be a good idea, especially for the motor mosfet.", "step_imgs": ["https://cdn.instructables.com/F5Y/WVYO/H7A8PNSI/F5YWVYOH7A8PNSI.LARGE.jpg", "https://cdn.instructables.com/FKA/DZZF/H7A8PNW0/FKADZZFH7A8PNW0.LARGE.jpg"], "step_title": "Step 6: "}, {"step": 7, "steps_text": "The cabinet itself could be an instructable all on it's own. I had two half doors sitting in my basement, so I cut them to the right length & used them for the sides. I used scrap plywood to make shelves that hold everything together. Make sure that you make the shelves wide enough to fit your skull compartment, but not so wide that you'll have to fill up extra space.\nSince I was going to make this coin operated, I needed a compartment that would be easily accessible. I made three shelves that were the same size: One for the box to sit on and to be the top of the compartment, one for the lower part of the compartment, and one shelf for the bottom that also helps stabilize the whole project.\u00a0 I also attached a hinged door to the middle shelf. This will be the access point to collect the coins. I was also able to install a lock on the door, which is just a simple lock that you put a key in and turns. A little strip of metal slides into a groove & keeps the whole compartment locked.\n\u00a0 The interior of the compartment contains the potentiometer, the amplifier, the speakers, & the coin op mechanism. The coin op mechanism is programmable. Once it is powered up, you push a button on the top of the unit. Then, you would drop 30 of same coin you'd like it to accept. After this, the light goes out & from then on it will only accept that coin, unless you repeat the programming process. From then on, any time someone drops the proper coin in, it sends a 5v signal out which is read by the Arduino. I made it 5 cents because I wanted to make it cheap, but didn't want to have to beg the bank to take my pennies. The potentiometer had an extraordinarily long shaft, so I mounted the pot to a piece of bracket stock & mounted the bracket stock to the machine.\nThe front side has the knob, the coin op slot, and the grills for the speakers. I routed the slots in the plywood & mounted the speakers behind them. I wanted there to be some depth to the front plate, so I copied my designs (5 cents/mood meter) to some shrink plastic & shrunk them down. They were then attached to the unit using screws. Shrink plastic shrinks down to a third of it's size, so calculate accordingly if you use this method.", "step_imgs": ["https://cdn.instructables.com/F5H/5FOF/H7A8PNWO/F5H5FOFH7A8PNWO.LARGE.jpg", "https://cdn.instructables.com/FN7/LPLJ/H7A8PNWS/FN7LPLJH7A8PNWS.LARGE.jpg", "https://cdn.instructables.com/FFP/Z497/H7KZ1ZZU/FFPZ497H7KZ1ZZU.LARGE.jpg", "https://cdn.instructables.com/FXZ/ZQBM/H7KZ203C/FXZZQBMH7KZ203C.LARGE.jpg", "https://cdn.instructables.com/F7W/B0E4/H7KZ2058/F7WB0E4H7KZ2058.LARGE.jpg"], "step_title": "Step 7: "}, {"step": 8, "steps_text": "I really wanted a fortune teller that would have more personality than the average machine, so I decided that I'd make it so the user could select the mood of the fortune teller. In the sketch, the wave files are divided up into different sections. You'll need to either name your sound files after the file names listed in the sketch or rename the names in the sketch after your files. So for example, the normal fortunes are named 1-14 (case 1-14). The sarcastic fortunes are named 15s-29s (case 15-29), so on & so forth. When you load your SD card with sound files, you'll need to rename your files accordingly. So if you were going to use this sketch as is, in order to make a Beatles jukebox , you\u2019d have to rename Hey Jude \u201c1\u201d (that's 1, not 1.wav).\nYou'll need the wave shield, the Arduino, and an SD card. You'll also need to install the library for WaveHC. There are instructions on the Adafruit website on how to properly convert your audio files to the proper format for the Wave shield. I used Audacity for this, since there are lots of options for changing the sound of the files in Audacity, and also because I didn't really want the fortune teller to sound like me.\nThere are only a few digital pins available because the wave shield needs some of the pins to communicate with the Arduino. In my sketch, I used pins 6,7,8,& 9, as well as analog\u00a0 pin 5. The sketch uses noise from analog pin 0 for a more random audio selection. My project uses\u00a0 two different light sources. In the sketch, these are leduvPin & ledstrobePin. It also uses a pin for motor control (pin 9) & a pin for the coin slot (pin 8), labeled button in the sketch. The pot is wired to analog pin 5.\n#include <FatReader.h>\n#include <SdReader.h>\n#include <avr/pgmspace.h>\n#include \"WaveUtil.h\"\n#include \"WaveHC.h\"\nint ledstrobePin = 7;\nint leduvPin = 6;\nint delayPeriod = 20;\nSdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card\nFatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card\nFatReader root;\u00a0\u00a0 // This holds the information for the filesystem on the card\nFatReader f;\u00a0\u00a0\u00a0\u00a0\u00a0 // This holds the information for the file we're play\nWaveHC wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // This is the only wave (audio) object, since we will only play one at a time\n#define MOTOR 9\n#define BUTTON 8\n#define LED 13\nint val = 0;\nint potvalue = 0;\nlong randNum;\n// this handy function will return the number of bytes currently free in RAM, great for debugging!\u00a0\u00a0\nint freeRam(void)\n{\n\u00a0 extern int\u00a0 __bss_end;\n\u00a0 extern int\u00a0 *__brkval;\n\u00a0 int free_memory;\n\u00a0 if((int)__brkval == 0) {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)&__bss_end);\n\u00a0 }\n\u00a0 else {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)__brkval);\n\u00a0 }\n\u00a0 return free_memory;\n}\nvoid sdErrorCheck(void)\n{\n\u00a0 if (!card.errorCode()) return;\n\u00a0 putstring(\"\\n\\rSD I/O error: \");\n\u00a0 Serial.print(card.errorCode(), HEX);\n\u00a0 putstring(\", \");\n\u00a0 Serial.println(card.errorData(), HEX);\n\u00a0 while(1);\n}\nvoid setup() {\n\u00a0\n\u00a0 // set up serial port\n\u00a0 Serial.begin(9600);\n\u00a0 pinMode(BUTTON, INPUT);\n\u00a0 pinMode(LED, OUTPUT);\n\u00a0 pinMode(leduvPin, OUTPUT);\n\u00a0 pinMode(ledstrobePin, OUTPUT);\n\u00a0 randomSeed(analogRead(0));\n\u00a0 digitalWrite (BUTTON,HIGH);\n\u00a0 pinMode(MOTOR, OUTPUT);\n\u00a0\n\u00a0 putstring(\"Free RAM: \");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // This can help with debugging, running out of RAM is bad\n\u00a0 Serial.println(freeRam());\u00a0\u00a0\u00a0\u00a0\u00a0 // if this is under 150 bytes it may spell trouble!\n\u00a0\n\u00a0 // Set the output pins for the DAC control. This pins are defined in the library\n\u00a0 pinMode(2, OUTPUT);\n\u00a0 pinMode(3, OUTPUT);\n\u00a0 pinMode(4, OUTPUT);\n\u00a0 pinMode(5, OUTPUT);\n\u00a0\n\u00a0 //\u00a0 if (!card.init(true)) { //play with 4 MHz spi if 8MHz isn't working for you\n\u00a0 if (!card.init()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //play with 8 MHz spi (default faster!)\u00a0\n\u00a0\u00a0\u00a0 putstring_nl(\"Card init. failed!\");\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 sdErrorCheck();\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // enable optimize read - some cards may timeout. Disable if you're having problems\n\u00a0 card.partialBlockRead(true);\n// Now we will look for a FAT partition!\n\u00a0 uint8_t part;\n\u00a0 for (part = 0; part < 5; part++) {\u00a0\u00a0\u00a0\u00a0 // we have up to 5 slots to look in\n\u00a0\u00a0\u00a0 if (vol.init(card, part))\n\u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // we found one, lets bail\n\u00a0 }\n\u00a0 if (part == 5) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if we ended up not finding one\u00a0 :(\n\u00a0\u00a0\u00a0 putstring_nl(\"No valid FAT partition!\");\n\u00a0\u00a0\u00a0 sdErrorCheck();\u00a0\u00a0\u00a0\u00a0\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Lets tell the user about what we found\n\u00a0 putstring(\"Using partition \");\n\u00a0 Serial.print(part, DEC);\n\u00a0 putstring(\", type is FAT\");\n\u00a0 Serial.println(vol.fatType(),DEC);\u00a0\u00a0\u00a0\u00a0 // FAT16 or FAT32?\n\u00a0\n\u00a0 // Try to open the root directory\n\u00a0 if (!root.openRoot(vol)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Can't open root dir!\"); // Something went wrong,\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Whew! We got past the tough parts.\n\u00a0 putstring_nl(\"Ready!\");\n\u00a0\n/*\u00a0 TCCR2A = 0;\n\u00a0 TCCR2B = 1<<CS22 | 1<<CS21 | 1<<CS20;\n\u00a0 //Timer2 Overflow Interrupt Enable\n\u00a0 TIMSK2 |= 1<<TOIE2;\n*/\n}\nvoid loop()\n{\n\u00a0 val = digitalRead(BUTTON);\n\u00a0 potvalue = analogRead(5);\n\u00a0 Serial.println(potvalue, DEC);\n\u00a0\n\u00a0 if (val == HIGH && potvalue >= 0 && potvalue <= 4)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 randNum = random(1, 14);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(1000);\nswitch (randNum)\n{\n\u00a0\u00a0 case 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(1);\n\u00a0 playcomplete(\"1.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 2:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(2);\n\u00a0 playcomplete(\"2.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 3:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(3);\n\u00a0 playcomplete(\"3.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 4:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(4);\n\u00a0 playcomplete(\"4.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 5:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(5);\n\u00a0 playcomplete(\"5.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 6:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(6);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"6.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 7:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(7);\n\u00a0 playcomplete(\"7.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 8:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(8);\n\u00a0 playcomplete(\"8.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 9:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(9);\n\u00a0 playcomplete(\"9.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 10:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(10);\n\u00a0 playcomplete(\"10.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 11:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(11);\n\u00a0 playcomplete(\"11.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 12:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(12);\n\u00a0 playcomplete(\"12.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 13:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(13);\n\u00a0 playcomplete(\"13.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 14:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(14);\n\u00a0 playcomplete(\"14.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 default:\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 if (val == HIGH && potvalue >= 5 && potvalue <= 15)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 randNum = random(15, 29);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(1000);\nswitch (randNum)\n{\n\u00a0 case 15:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Serial.println(15);\n\u00a0 playcomplete(\"15s.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 16:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(16);\n\u00a0 playcomplete(\"16s.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 17:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(17);\n\u00a0 playcomplete(\"17s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 18:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(18);\n\u00a0 playcomplete(\"18s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 19:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(19);\n\u00a0 playcomplete(\"19s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 20:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(20);\n\u00a0 playcomplete(\"20s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 21:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(21);\n\u00a0 playcomplete(\"21s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 22:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(22);\n\u00a0 playcomplete(\"22s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 23:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(23);\n\u00a0 playcomplete(\"23s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 24:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(24);\n\u00a0 playcomplete(\"24s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 25:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(25);\n\u00a0 playcomplete(\"25s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 26:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(26);\n\u00a0 playcomplete(\"26s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 27:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(27);\n\u00a0 playcomplete(\"27s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 28:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(28);\n\u00a0 playcomplete(\"28s.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 29:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(29);\n\u00a0 playcomplete(\"29s.WAV\");\n\u00a0 break;\n\u00a0\u00a0 default:\n\u00a0 break;\n}\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 if (val == HIGH && potvalue >= 16 && potvalue <= 22)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 randNum = random(30, 44);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(1000);\nswitch (randNum)\n{\n\u00a0\u00a0 case 30:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(30);\n\u00a0 playcomplete(\"30m.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 31:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(31);\n\u00a0 playcomplete(\"31m.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 32:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(32);\n\u00a0 playcomplete(\"32m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 33:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(33);\n\u00a0 playcomplete(\"33m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 34:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(34);\n\u00a0 playcomplete(\"34m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 35:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(35);\n\u00a0 playcomplete(\"35m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 36:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(36);\n\u00a0 playcomplete(\"36m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 37:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(37);\n\u00a0 playcomplete(\"37m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 38:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(38);\n\u00a0 playcomplete(\"38m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 39:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(39);\n\u00a0 playcomplete(\"39m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 40:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(40);\n\u00a0 playcomplete(\"40m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 41:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(41);\n\u00a0 playcomplete(\"41m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 42:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(42);\n\u00a0 playcomplete(\"42m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 43:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(43);\n\u00a0 playcomplete(\"43m.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 44:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(44);\n\u00a0 playcomplete(\"44m.WAV\");\n\u00a0 break;\n\u00a0\u00a0 default:\n\u00a0 break;\n}\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 if (val == HIGH && potvalue >= 23 && potvalue <= 1023)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 randNum = random(45, 60);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(1000);\nswitch (randNum)\n{\n\u00a0 case 45:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Serial.println(45);\n\u00a0 playcomplete(\"45.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 46:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(46);\n\u00a0 playcomplete(\"46e.WAV\");\n\u00a0 break;\n\u00a0\u00a0 case 47:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(47);\n\u00a0 playcomplete(\"47e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 48:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(48);\n\u00a0 playcomplete(\"48e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 49:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(49);\n\u00a0 playcomplete(\"49e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 50:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(50);\n\u00a0 playcomplete(\"50e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 51:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(51);\n\u00a0 playcomplete(\"51e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 52:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(52);\n\u00a0 playcomplete(\"52e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 53:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(53);\n\u00a0 playcomplete(\"53e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 54:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(54);\n\u00a0 playcomplete(\"54e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 55:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(55);\n\u00a0 playcomplete(\"55e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 56:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(56);\n\u00a0 playcomplete(\"56e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 57:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(57);\n\u00a0\u00a0\u00a0 playcomplete(\"57e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 58:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(58);\n\u00a0 playcomplete(\"58e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 59:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(59);\n\u00a0 playcomplete(\"59e.WAV\");\n\u00a0 break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 60:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(60);\n\u00a0 playcomplete(\"60e.WAV\");\n\u00a0 break;\n\u00a0\u00a0 default:\n\u00a0 break;\n}\n\u00a0\u00a0\u00a0 }\n\u00a0\n}\n// Plays a full file from beginning to end with no pause.\nvoid playcomplete(char *name) {\n\u00a0 // call our helper to find and play this name\n\u00a0 playfile(name);\n\u00a0 while (wave.isplaying) {\n\u00a0\u00a0\u00a0 digitalWrite (MOTOR, HIGH);\n\u00a0\u00a0\u00a0 flash (20, delayPeriod);\n\u00a0\u00a0\u00a0 digitalWrite (MOTOR, LOW);\n\u00a0 // do nothing while its playing\n\u00a0 }\n\u00a0 // now its done playing\n}\nvoid flash (int numFlashes, int d)\n{\n\u00a0 for (int i = 0; i < numFlashes; i ++)\n\u00a0 {\n\u00a0\u00a0\u00a0 digitalWrite (ledstrobePin, HIGH);\n\u00a0\u00a0\u00a0 digitalWrite (leduvPin, LOW);\n\u00a0\u00a0\u00a0 delay (d);\n\u00a0\u00a0\u00a0 digitalWrite (ledstrobePin, LOW);\n\u00a0\u00a0\u00a0 digitalWrite (leduvPin, HIGH);\n\u00a0\u00a0\u00a0 delay (d);\n\u00a0\u00a0\u00a0 digitalWrite (ledstrobePin, LOW);\n\u00a0\u00a0\u00a0 digitalWrite (leduvPin, LOW);\n\u00a0 }\n}\nvoid playfile(char *name) {\n\u00a0 // see if the wave object is currently doing something\n\u00a0 if (wave.isplaying) {\n\u00a0\u00a0\u00a0 flash (20, delayPeriod);// already playing something, so stop it!\n\u00a0\u00a0\u00a0 wave.stop(); // stop it\n\u00a0 }\n\u00a0 // look in the root directory and open the file\n\u00a0 if (!f.open(root, name)) {\n\u00a0\u00a0\u00a0 putstring(\"Couldn't open file \"); Serial.print(name); return;\n\u00a0 }\n\u00a0 // OK read the file and turn it into a wave object\n\u00a0 if (!wave.create(f)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Not a valid WAV\"); return;\n\u00a0 }\n\u00a0\n\u00a0 // ok time to play! start playback\n\u00a0 wave.play();\n}", "step_imgs": [], "step_title": "Step 8: The Arduino Sketch"}, {"step": 9, "steps_text": "Once the sketch is loaded, the audio from the wave shield should go directly to the audio \"in\" input, inside the skull. The plug for audio from the amplifier should go to the audio \u201cout\u201d input inside the skull. You will want the volume on the wave shield turned all the way up, but you can adjust the amplifier to the volume that best suits you. I made some adjustments to the skull kit just for visual purposes. The kit comes with LEDs, which light up with the sound for the eyes. I didn't think it had enough contrast, so I cut out some insulating foam to fit the eye sockets. I then glued some black paper to the exposed area of the foam &\u00a0 installed the LEDs into the foam.", "step_imgs": ["https://cdn.instructables.com/FBR/J3JD/H7KZ29US/FBRJ3JDH7KZ29US.LARGE.jpg", "https://cdn.instructables.com/FJ1/1KFS/H7KZ29WH/FJ11KFSH7KZ29WH.LARGE.jpg", "https://cdn.instructables.com/FSJ/64ZR/H7KZ29X0/FSJ64ZRH7KZ29X0.LARGE.jpg"], "step_title": "Step 9: "}, {"step": 10, "steps_text": "I decided that I wanted to make this project look as professional as possible. I felt that the back needed to be covered, but I also wanted to have easy access without having to move it too much to get into it. The chances are pretty good that it will be sitting against a wall somewhere, so a hinged door would require too much space to open.\u00a0 I decided to cut plywood to fit the back & use gravity to keep the covers on. I ripped a piece of wood on the table saw at an angle, and then cut segments of it for my gravity brackets. If you use this technique, use a strong enough wood type where you can drill a hole & put a screw into it without splitting. Be sure to cut large enough segments so that there is plenty of room to drill for a screw, without compromising the strength of the brackets. Measure carefully so that the brackets on both the panel & cabinet line up. Then, drill pilot holes. I only used one screw so that the brackets would be self aligning. Put the screw in tight enough so that the bracket doesn't move around when covering & removing the panel, but will move slightly to align with the angle on it's mate.\nThe final picture is the back view with the panels installed.", "step_imgs": ["https://cdn.instructables.com/F6X/LEKF/H7KZ2AFW/F6XLEKFH7KZ2AFW.LARGE.jpg", "https://cdn.instructables.com/FC7/N9DI/H7KZ2AHK/FC7N9DIH7KZ2AHK.LARGE.jpg", "https://cdn.instructables.com/FRO/ON0S/H7KZ2ANG/FROON0SH7KZ2ANG.LARGE.jpg"], "step_title": "Step 10: "}, {"step": 11, "steps_text": "I wanted my fortune teller to have an old look. Since I'd chosen to re-use some pre-painted doors I already had, I decided rather than to strip & refinish the whole project, I'd just use that to my advantage by using milk paint on them.\u00a0\n\u00a0Milk paint dries differently than other paints. It shrinks as it dries, so if it's painted over another painted surface, it'll crack & bunch up in some areas, yet adhere well in others. This gives a look similar to something that has been painted & repainted over a long period of time. It's easy to use, has no fumes, is durable, and lasts a long time. Once the paint was dry, I applied a liquid beeswax protectant to protect the paint from dirt.", "step_imgs": ["https://cdn.instructables.com/FD3/OV2Y/H7KZ2AV2/FD3OV2YH7KZ2AV2.LARGE.jpg", "https://cdn.instructables.com/FMT/HG3P/H7KZ2AV8/FMTHG3PH7KZ2AV8.LARGE.jpg"], "step_title": "Step 11: Finishing"}, {"step": 12, "steps_text": "http://youtu.be/ioBKZJC_1GQ  \u00a0", "step_imgs": ["https://cdn.instructables.com/FDP/TBWC/H7KZ2HOY/FDPTBWCH7KZ2HOY.LARGE.jpg"], "step_title": "Step 12: Photo & Video"}], "channel": "No channel to show"}, {"category": "technology", "description": "Here you can see sound waves and observe the interference patterns made by two or more transducers as the spacing between them is varied.  (Leftmost, interference pattern with two microphones at 40,000 cycles per second; top right, single microphone at 3520 cps; bottom right, single microphone at 7040cps).The sound waves drive a color LED, and the color is the phase of the wave, and the brightness is the amplitude.An X-Y plotter is used to plot out the sound waves and conduct experiments on phenomenological augmented reality (\"Real Reality\"\u2122), by way of a Sequential Wave Imprinting Machine (SWIM).ACKNOWLEDGEMENTS:First I'd like to acknowledge the many people who have helped with this project that started out as a childhood hobby of mine, photographing radio waves and sound waves (http://wearcam.org/par).  Thank you to many past and present students, including Ryan, Max, Alex, Arkin, Sen, and Jackson, and others in MannLab, including Kyle and Daniel. Thanks also to Stephanie (age 12) for the observation that the phase of ultrasonic transducers is random, and for help in devising a method of sorting them by phase into two piles: ``Stephative'' (Stephanie positive) and ``Stegative'' (Stephanie negative). Thanks to Arkin, Visionertech, Shenzhen Investment Holdings, and Professor Wang (SYSU).", "title": "See Sound Waves Using Colored Light (RGB LED)", "url": "https://www.instructables.com/id/See-Sound-Waves-Using-Colored-Light-RGB-LED/", "section": "technology", "steps": [{"step": 1, "steps_text": "The basic idea is to use color to represent waves, such as sound waves.Here we see a simple example in which I have used color to show electrical waves.This allows us to visualize, for example, the Fourier transform, or any other wave-based electrical signal, visually.I used this as a book cover that I designed [Advances in Machine Vision, 380pp, Apr 1992], along with some contributed chapters to the book.", "step_imgs": ["https://cdn.instructables.com/FFP/P4CZ/JIUJZ4PD/FFPP4CZJIUJZ4PD.LARGE.jpg", "https://cdn.instructables.com/FO9/3T7V/JIUJZ4V1/FO93T7VJIUJZ4V1.LARGE.jpg"], "step_title": "Step 1: Principle of Using Colors to Represent Waves"}, {"step": 2, "steps_text": "To convert sound to color, we need to build a sound to color converter.The sound comes from the output of a lock-in amplifier referenced to the frequency of the sound waves, as explained in some of my previous Instructables, as well as some of my published papers.The output of the lock-in amplifier is a complex valued output, which appears on two terminals (many amplifiers use BNC connectors for their outputs), one for \"X\" (the in-phase component which is the real part) and one for \"Y\" (the quadrature component which is the imaginary part).  Together the voltages present at X and Y denote a complex number, and the drawing above (left) depicts the Argand plane upon which complex valued quantities are displayed as color.  We use an Arduino with two analog inputs and three analog outputs to convert from XY (complex number) to RGB (Red, Green, Blue color), as per the swimled.ino code supplied.We bring these out as RGB color signals to an LED light source.  The result is to go around a color wheel with phase as angle, and with the light qualtity is the signal strength (sound level). This is done with a complex number to RGB color-mapper, as follows:The complex color-mapper converts from a complex-valued quantity, typically output from a homodyne receiver or lock-in amplifier or phase-coherent detector into a colored light source.  Typically more light is produced when the magnitude of the signal is greater.  The phase affects the hue of the colour.Consider these examples (as outlined in IEEE conference paper \"Rattletale\"):A strong positive real signal (i.e. when X=+10 volts) is encoded as bright red.  A weakly positive real signal, i.e. when X=+5 volts, is encoded as a dim red. Zero output (X=0 and Y=0) presents itself as black. A strong negative real signal (i.e. X=-10 volts) is green, whereas weakly negative real (X=-5 volts) is dim green. Strongly imaginary positive signals (Y=10v) are bright yellow, and weakly positive-imaginary (Y=5v) are dim yellow. Negatively imaginary signals are blue (e.g. bright blue for Y=-10v and dim blue for Y=-5v). More generally, the quantity of light produced is approximately proportional to a magnitude, R_{XY}=\\sqrt{X^2+Y^2}, and the color to a phase, \\Theta=\\arctan(Y/X).  So a signal equally positive real and positive imaginary (i.e. \\Theta=45 degrees) is dim orange if weak, bright orange of strong (e.g. X=7.07 volts, Y=7.07 volts), and brightest orange of very strong, i.e. X=10v and Y=10v, in which case the R (red) and G (green) LED components are on full.  Similarly a signal that is equally positive real and negative imaginary renders itself as purple or violet, i.e. with the R (red) and B (blue) LED components both on together.  This produces a dim violet or bright violet, in accordance with the magnitude of the signal.[link]The outputs X=augmented reality, and Y=augmented imaginality, of any phase-coherent detector, lock-in amplifier, or homodyne receiver are therefore used to overlay a phenomenologically augmented reality upon a field of vision or view, thus showing a degree of acoustic response as a visual overlay.Special thanks to one of my students, Jackson, who helped with an implementation of my XY to RGB converter.The above is a simplified version, which I did to make it easy to teach and explain.  The original implementation that I did back in the 1980s and early 1990s works even better, because it spaces the color wheel in a perceptually uniform way.  See attached Matlab \".m\" files that I wrote back in the early 1990s to implement the improved XY to RGB conversion.", "step_imgs": ["https://cdn.instructables.com/FTE/L93D/JBWK6WKC/FTEL93DJBWK6WKC.LARGE.jpg", "https://cdn.instructables.com/F1Y/0G87/JC6K0JA8/F1Y0G87JC6K0JA8.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Build the Sound to Color Converter"}, {"step": 3, "steps_text": "The \"print head\" is an RGB LED, with 4 wires to connect it to the output of the XY to RGB converter.Simply connect 4 wires to the LED, one to common, and one to each of the terminals for the colours (Red, Green, and Blue).Special thanks to my former student, Alex, who helped with putting together a print head.", "step_imgs": ["https://cdn.instructables.com/FY0/JALH/JC6JXOTE/FY0JALHJC6JXOTE.LARGE.jpg", "https://cdn.instructables.com/FJC/7T8Y/JC6JXOSI/FJC7T8YJC6JXOSI.LARGE.jpg", "https://cdn.instructables.com/F33/45P6/JC6JXOPK/F3345P6JC6JXOPK.LARGE.jpg", "https://cdn.instructables.com/FXI/ADII/JC6JXOQG/FXIADIIJC6JXOQG.LARGE.jpg"], "step_title": "Step 3: Make an RGB \"print Head\""}, {"step": 4, "steps_text": "We require some kind of 3D positioning device.  I prefer to obtain or build something that moves easily in the XY plane, but I don't require easy movement in the third (Z) axis, because this is quite infrequent (since we usually scan in a raster).  Thus what we have here is primarily an XY plotter but it has long rails allowing it to be moved along the third axis when necessary.The plotter scans out the space, by moving a transducer, together with a light source (RGB LED), through the space, while the shutter of a camera is open for the correct exposure duration to capture each frame of visual image (one or more frames, e.g. for a still picture or movie file).XY-PLOTTER (Fusion 360 file).The mechanics are simple; any XYZ  or XY plotter will do.  Here is the plotter we use, 2-dimensional SWIM  (Sequential Wave Imprinting Machine):   https://a360.co/2KkslB3  The  plotter moves easily in the XY plane, and moves in a more cumbersome  way in Z, such that we sweep out images in 2D and then advance in the Z  axis slowly. The link is to a  Fusion 360 file.  We use Fusion 360 because it is cloud-based and  allows us to collaborate between MannLab Silicon Valley, MannLab  Toronto, and MannLab Shenzhen, across 3 time zones.  Solidworks is  useless for doing that!  (We no longer use Solidworks because we had too  many problems with version forking across timezones as we used to spend  a lot of time piecing together different edits of Solidworks files.  It  is essential to keep everything in one place and Fusion 360 does that  really well.)", "step_imgs": ["https://cdn.instructables.com/FQW/D2RZ/JJ4JVA8B/FQWD2RZJJ4JVA8B.LARGE.jpg"], "step_title": "Step 4: Obtain or Build an XY Plotter or Other 3D Positioning System (Fusion360 Link Included)"}, {"step": 5, "steps_text": "The apparatus measures sound waves with respect to a particular reference frequency.The sound waves are measured throughout a space, by way of a mechanism that moves a microphone or speaker throughout the space.We can see the interference pattern between two speakers by moving a microphone through the space, together with the RGB LED, while exposing photographic media to the moving light source.Alternatively we can move a speaker through space to photograph the capacity of an array of microphones to listen.  This creates a form of bug sweeper that senses the capacity of sensors (microphones) to sense.Sensing sensors and sensing their capacity to sense is called metaveillance and is described in detail in the following research paper:  http://wearcam.org/kineveillance.pdfCONNECTING IT UP:The pictures in this Instructable were taken by connecting a signal generator to a speaker as well as to the reference input of a lock-in amplifier, while moving an RGB LED together with the speaker.  An Arduino was used to synchronize a photographic camera to the moving LED.The specific lock-in amplifier used here is the SYSU x Mannlab Scientific Outstrument\u2122 which is designed specifically for augmented reality, although you can build your own lock-in amplifier (a childhood hobby of mine was photographing sound waves and radio waves, so I have built a number of lock-in amplifiers for this purpose, as described inhttp://wearcam.org/par).You can exchange the role of speaker(s) and microphone(s).  In this way you can measure sound waves, or meta sound waves.Welcome to the world of phenomenological reality.  For more information, see also  https://arxiv.org/pdf/1804.08386.pdf", "step_imgs": ["https://cdn.instructables.com/FN5/IZEV/JIUJYXPM/FN5IZEVJIUJYXPM.LARGE.jpg", "https://cdn.instructables.com/FA3/76AV/JIUJYXOA/FA376AVJIUJYXOA.LARGE.jpg"], "step_title": "Step 5: Connect to a Lock-in Amplifier"}, {"step": 6, "steps_text": "For a quick guide on how to photograph waves, see some of my previous Instructables such as:https://www.instructables.com/id/Seeing-Sound-Wave...andhttps://www.instructables.com/id/Abakography-Long-...Have fun, and click \"I made it\" to share your results, and I will be happy to offer constructive help and hints on how to have fun with phenomenological reality.", "step_imgs": ["https://cdn.instructables.com/FBN/S3P0/JIOUE115/FBNS3P0JIOUE115.LARGE.jpg", "https://cdn.instructables.com/F57/DKBL/JBWK4DCZ/F57DKBLJBWK4DCZ.LARGE.jpg"], "step_title": "Step 6: Photograph and Share Your Results."}, {"step": 7, "steps_text": "Here we can see, for example, a comparison between a 6-element microphone array and a 5-element microphone array.We can see that when there is an odd number of elements, we get a nicer central lobe happening sooner, and thus sometimes \"less is more\" (e.g. 5 microphones are sometimes better than six, when we're trying to do beamforming).", "step_imgs": ["https://cdn.instructables.com/FVB/5IYX/JIOUE8KU/FVB5IYXJIOUE8KU.LARGE.jpg", "https://cdn.instructables.com/FLM/B1K5/JIUJZE0G/FLMB1K5JIUJZE0G.LARGE.jpg"], "step_title": "Step 7: Conduct Scientific Experiments"}, {"step": 8, "steps_text": "Using hydrophones instead of microphones, we can see sound waves underwater.Here we put our XY plotter laying down flat, hovering over a small pool made of clear arcylic.In the left there is a pair of hydrophones and there is a third hydrophone on the moving stage that moves together with the RGB LED.", "step_imgs": ["https://cdn.instructables.com/FBW/XR5D/JIUJZ3VN/FBWXR5DJIUJZ3VN.ANIMATED.LARGE.gif", "https://cdn.instructables.com/FPA/RHZ7/JIOUE3O1/FPARHZ7JIOUE3O1.LARGE.jpg"], "step_title": "Step 8: Try It Underwater"}, {"step": 9, "steps_text": "Capture photographs using the method taught in this Instructable, and then render them in a 3D VR (Virutal Reality) environment.  Now you can  see sound waves in VR.", "step_imgs": ["https://cdn.instructables.com/F6Y/BO37/JIUJZFGV/F6YBO37JIUJZFGV.LARGE.jpg", "https://cdn.instructables.com/FQF/ICB4/JIUJYZV2/FQFICB4JIUJYZV2.ANIMATED.LARGE.gif"], "step_title": "Step 9: Try It in VR"}, {"step": 10, "steps_text": "I entered the \"Rainbow Colors\" contest because I think my use of the rainbow colors to represent electric waves fits this theme nicely.Please click \"Vote\" below.You need to register (create an Instructables account) to vote.Please create an Instructuables account if you don't have one already.Instructables is really wonderful and you'll be glad if you do!Please keep in touch through Instructables!", "step_imgs": ["https://cdn.instructables.com/FV1/JWDM/JIXQFBDV/FV1JWDMJIXQFBDV.LARGE.jpg", "https://cdn.instructables.com/F2B/2LPP/JIXQFBDZ/F2B2LPPJIXQFBDZ.LARGE.jpg"], "step_title": "Step 10: If You Like This Instructable, Please Vote for Me."}], "channel": "Art"}, {"category": "technology", "description": "This Arduino-powered vocal effects box pitch shifts and distorts incoming audio signals to produce a wide variety of vocal effects.  This project is my first experiment with real-time digital signal processing using Arduino.  It samples an incoming microphone signal at a rate of about 40kHz, manipulates the audio digitally, and then outputs 8 bit audio at 40kHz.  To minimize the amount of computation required by the Arduino, I used a technique called granular synthesis to manipulate the incoming audio signal.  Essentially, as audio comes into the Arduino it gets cut up and stored as small (millisecond or microsecond sized) samples called \"grains.\"  These grains are then individually manipulated and played back; they may be lengthened or shortened, stretched or compressed, played back in reverse, copied several times, or mixed with other grains.  You can hear a (somewhat creepy) audio sample from the effects box below: Granular synthesis creates a unique type of distortion caused by discontinuities between individual grains in the outgoing signal.  Sometimes this distortion creates an effect I can only describe as a \"ripping\" sound, other times it introduces new frequencies into the audio that were not present before.  Here is an example by Aphex Twin, the granular synthesis is especially prominent in the bridge at around 3min in. Another example of granular synthesis, this time applied to vocals for pitch shifting and textural effects, is from Paul Lansky.  My favorite thing to do with this effects box is to use subtle pitch shifting to achieve an androgynous vocal sound, I got the idea for the project after listening to copious amounts of Fever Ray this past winter, you can hear how she pitch shifts her voice to sound somewhat masculine at times.PARTS LIST(1x) Arduino Uno REV 3 Radioshack 276-128 (7x) 10K Ohm 1/4-Watt Carbon Film Resistor (2 packages) Radioshack #271-1335 (9x) 20K Ohm 1/4-Watt Carbon Film Resistor (2 packages) (1x) 1K Ohm 1/4-Watt Carbon Film Resistor Radioshack 271-1321 (1x) 50K-Ohm Linear-Taper Potentiometer Radioshack #271-1716 (1x) 10KOhm Audio Control Potentiometer with SPST Switch Radioshack #271-215 (this will be used to control volume and turn the device on/off) (5x) 0.25\" Knurled Knob Radioshack 274-424 (2x) 9V Alkaline Battery Radioshack #23-866 (2x) Heavy-Duty 9V Snap Connectors Radioshack #270-324 (1x) PC Board with Copper Radioshack #276-147 (1x) SPST PC-Mountable Submini Toggle Switch Radioshack #275-645 (2x) Male Header Pins Jameco 103393 (3x) 8 pin socket Radioshack 276-1995 (1x) TL082 Wide Dual JFET Input Op Amp Radioshack 276-1715 (3x) 100K Ohm 1/4-Watt Carbon Film Resistor (1 package) Radioshack 271-1347 (1x) 10uF electrolytic capacitor (1x) 47nF capacitor (3x) 0.1uf capacitor Radioshack 55047557 (2x) 1M-Ohm Linear Taper Potentiometer Radioshack 271-211 (1x) 1MOhm logarithmic potentiometer (1x) 2kOhm 1/4-Watt Carbon Film Resistor (1x) male header pins Jameco 103393 (1x) 10K-Ohm Linear-Taper Potentiometer Radioshack 271-1715 (1x) DPDT Flatted Metal Lever Toggle Switch Radioshack 275-636 (2x) 1/4\" stereo jack Radioshack 274-141 or Radioshack 274-312 (2x) 5mm High-Brightness White LED (1 package) Radioshack 276-017 (2x) 100 ohm 1/4W 5% Carbon Film Resistor Radioshack 271-1311 (2x) TS922IN Dual Op Amp Digikey 497-3049-5-ND (one TS924 would also work, but they are not available on digikey at the moment)Additional Materials: 22 Gauge Wire Radioshack #278-1224 Solder Radioshack #64-013 sand paper plywood wood glue hot glue screwsDownload Arduino IDE", "title": "Arduino Vocal Effects Box", "url": "https://www.instructables.com/id/Arduino-Vocal-Effects-Box/", "section": "technology", "steps": [{"step": 1, "steps_text": "I've broken the schematic into three parts so it is easier to understand. The first schematic shows the audio out circuit. This project outputs audio through an 8 bit R2Rdigital to analog converter through Arduino digital pins 0-7.\u00a0 This signal is sent through an amplifier, a low pass filter, and a volume control pot before being sent out to speakers. The second schematic shows the mic input circuit.\u00a0 The line in the from the mic is sent through an amplifier and a DC offset circuit before being sent into the Arduino via analog input pin A0. The third schematic shows how all the controls of the effects box are connected to the Arduino.\u00a0 There are two LED indicators in this project: one clipping indicator and one output indicator.\u00a0 Three pots on the device control grain size, pitch, and wet/dry mix and a switch controls the direction of sample playback (forward or reverse).", "step_imgs": ["https://cdn.instructables.com/F5U/3U30/H63P41MC/F5U3U30H63P41MC.LARGE.jpg", "https://cdn.instructables.com/F1Y/QKUS/H5ED98L9/F1YQKUSH5ED98L9.LARGE.jpg", "https://cdn.instructables.com/F49/BQUA/H5TVBEDH/F49BQUAH5TVBEDH.LARGE.jpg"], "step_title": "Step 1: Schematic"}, {"step": 2, "steps_text": "Solder header pins to your protoboard so that you can snap the arduino directly to the board.\u00a0 Unfortunately the spacing between digital pins 7 and 8 on the arduino is not the standard 2.54mm, so I've found that it's best to try to avoid using these pins if possible (anolog pins can also be used as digital I/O).\u00a0 If you have to use them, try finding long header pins which you can bend into shape (fig 4- from another project).", "step_imgs": ["https://cdn.instructables.com/FTF/RUL0/H337JN8Z/FTFRUL0H337JN8Z.LARGE.jpg", "https://cdn.instructables.com/F29/9I7U/H337JN8Y/F299I7UH337JN8Y.LARGE.jpg", "https://cdn.instructables.com/FC0/D9IL/H347FEBD/FC0D9ILH347FEBD.LARGE.jpg", "https://cdn.instructables.com/F1B/T38R/H27CB465/F1BT38RH27CB465.LARGE.jpg"], "step_title": "Step 2: Header Pins"}, {"step": 3, "steps_text": "Solder eight 20kOhm resistors to arduino pins D0-D7 as shown in the images above.", "step_imgs": ["https://cdn.instructables.com/FHD/9WAK/H2WEQGEH/FHD9WAKH2WEQGEH.LARGE.jpg", "https://cdn.instructables.com/FZC/A1HC/H337JN96/FZCA1HCH337JN96.LARGE.jpg"], "step_title": "Step 3: DAC: Part 1"}, {"step": 4, "steps_text": "Solder seven 10kOhm resistors in between each of the 20kOhm's you just soldered.\u00a0 Add an additional 20kOhm resistor to the 20kOhm connected to arduino D0 (the bottom of the ladder).", "step_imgs": ["https://cdn.instructables.com/FO8/XVFM/H347FG3X/FO8XVFMH347FG3X.LARGE.jpg", "https://cdn.instructables.com/FM5/ZLFR/H2WET306/FM5ZLFRH2WET306.LARGE.jpg", "https://cdn.instructables.com/FB3/E491/H337JMZ2/FB3E491H337JMZ2.LARGE.jpg"], "step_title": "Step 4: DAC: Part 2"}, {"step": 5, "steps_text": "Connect the other end of the 20kOhm reisistor to arduino ground", "step_imgs": ["https://cdn.instructables.com/FAL/P9EO/H337JN9F/FALP9EOH337JN9F.LARGE.jpg", "https://cdn.instructables.com/FBB/KP59/H2WEWLS2/FBBKP59H2WEWLS2.LARGE.jpg"], "step_title": "Step 5: DAC: Part 3"}, {"step": 6, "steps_text": "\n          Connect the output from the DAC up to an oscilloscope, be sure to connect ground as well.\u00a0 Load the firmware below onto the Arduino.\u00a0 The DAC should output a sine wave oscillating between 0 and 5V with a frequency of ~63Hz (see image above).\u00a0 If you need help understanding how to use/read the oscilloscope check out this tutorial.//63Hz sine wave\n//by Amanda Ghassaei 2012\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\n//sends 63Hz sine wave to arduino PORTD DAC\nfloat t = 0;\n\nvoid setup() {\n  //set port/pin  mode. see http://www.arduino.cc/en/Reference/PortManipulation for more info\n  DDRD = 0xFF;//port d (digital pins 0-7) all outputs\n  \n  cli();//stop interrupts\n\n  //set timer2 interrupt at 40kHz\n  TCCR2A = 0;// set entire TCCR2A register to 0\n  TCCR2B = 0;// same for TCCR2B\n  TCNT2  = 0;//initialize counter value to 0\n  // set compare match register for 40khz increments\n  OCR2A = 49;// = (16*10^6) / (8*40000)-1\n  // turn on CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set CS11 bit for 8 prescaler\n  TCCR2B |= (1 << CS11);   \n  // enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n  \n  sei();//allow interrupts\n}\n\nISR(TIMER2_COMPA_vect) {\n  //increment t\n  t+=1;\n  if (t==628){//40kHz/628 =~ 63Hz\n    t=0;\n  }\n}\n\n\nvoid loop(){\n  //sine wave of frequency ~63Hz\n  //send sine values to PORTD between 0 and 255\n  PORTD=byte(127+127*sin(t/100));\n}\n\n\n Some info about the code- basically what I've done here is set up a timer interrupt that increments the variable t at a frequency of 40kHz.\u00a0 Once t reaches 627 it resets back to zero (this happens with a frequency of 40,000/628 = 63Hz).\u00a0 Meanwhile, in the main loop the Arduino sends a value between 0 (00000000 in binary) and 255 (11111111 in binary) to digital pins 0 through 7 (PORTD).\u00a0 It calculates this value with the following equation:PORTD=byte(127+127*sin(2*t/100)); So as t increments from 0 to 627 the sine function moves through one complete cycle.\u00a0 The value sent to PORTD is a sine wave with frequency 63Hz and amplitude 127, oscillating around 127.\u00a0 The DAC translates this to a voltage between 0 and 5V, where a 0 sent to PORTD equals 0V and a 255 sent to PORTD equals 5V.", "step_imgs": ["https://cdn.instructables.com/FYY/B8JH/H4AGKE5L/FYYB8JHH4AGKE5L.LARGE.jpg", "https://cdn.instructables.com/F5U/3U30/H63P41MC/F5U3U30H63P41MC.LARGE.jpg"], "step_title": "Step 6: Test DAC"}, {"step": 7, "steps_text": "Solder an 8 pin socket to the breadboard.\u00a0 Connect ground to pin 4, 5V to pin 8 and the signal from the DAC to pin3.\u00a0 Solder pins 1 and 2 together (fig 2).\u00a0 This puts the signal through a voltage follower.\u00a0 The voltage follower acts as a buffer, protecting the output from the DAC from any loads that are put on it later in the circuit.", "step_imgs": ["https://cdn.instructables.com/FID/5JM7/H4AGKUUU/FID5JM7H4AGKUUU.LARGE.jpg", "https://cdn.instructables.com/F6K/0ZRF/H4I7W02F/F6K0ZRFH4I7W02F.LARGE.jpg"], "step_title": "Step 7: 8 Pin Socket and Buffer"}, {"step": 8, "steps_text": "Connect three leads to a 10k exponential pot (labelled with an \"A\") as shown in fig 3.\u00a0 Solder the red lead to pin 1, the green lead to pin 5, and the black lead to ground/pin 4.\u00a0 Solder pins 6 and 7 together (fig 2).\u00a0 This pot will adjust the amplitude of the signal- it is a volume control knob.\u00a0 It does this by acting as a variable voltage divider.", "step_imgs": ["https://cdn.instructables.com/FKG/QUFG/H4AG09SU/FKGQUFGH4AG09SU.LARGE.jpg", "https://cdn.instructables.com/FOB/UT75/H4AG09SV/FOBUT75H4AG09SV.LARGE.jpg", "https://cdn.instructables.com/F67/HU17/H4AGKVL6/F67HU17H4AGKVL6.LARGE.jpg"], "step_title": "Step 8: Wire Up Pot"}, {"step": 9, "steps_text": "Solder a second 8 pin socket and connect ground to pin 4 and 5V to pin 8.", "step_imgs": ["https://cdn.instructables.com/FKS/ZWQW/H4I7W02G/FKSZWQWH4I7W02G.LARGE.jpg", "https://cdn.instructables.com/F1U/EWDU/H4AG9H4E/F1UEWDUH4AG9H4E.LARGE.jpg"], "step_title": "Step 9: Second 8 Pin Socket"}, {"step": 10, "steps_text": "Solder a 10kOhm resistor to pin 7 of the first TS922IN.\u00a0 Connect a 2kOhm resistor in series with the 10kOhm resistor and connect the other end of the 2kOhm to ground.\u00a0 This is another voltage divider- the purpose of this portion of the circuit is to scale the signal to 2000/(10000+2000) =1/6th its amplitude, I did this so that the max volume would not completely destroy my hearing.\u00a0 Unlike the voltage divider I set up in the last step with the pot, this voltage divider does not change; it scales the amplitude of the signal permanently.\u00a0 The scaled signal comes out from the junction between the two resistors. If you are planning to send the output out as line level into another effects module or amplifier, then do not add this voltage divider.", "step_imgs": ["https://cdn.instructables.com/FHV/4HM9/H4AGM44O/FHV4HM9H4AGM44O.LARGE.jpg", "https://cdn.instructables.com/F8Q/CC52/H4AGKUVT/F8QCC52H4AGKUVT.LARGE.jpg", "https://cdn.instructables.com/F5U/3U30/H63P41MC/F5U3U30H63P41MC.LARGE.jpg"], "step_title": "Step 10: Voltage Divider"}, {"step": 11, "steps_text": "The purpose of a low pass filter in this part of the circuit is to remove the digital artifacts from the output of the DAC without losing too much detail in the higher frequencies of the audio signal.Nyquist's Theroum states that for a sampling rate of x Hz, the highest frequency that can be produced is x/2 Hz.\u00a0 So if you have a sampling rate of 40kHz (standard for most audio), then the maximum frequency you can reproduce is 20kHz (the upper limit of the audible spectrum). By using a low pass filter on the signal with a cutoff frequency of 20kHz, you can smooth out the \"steps\" in your waveform while keeping the overall shape of the waveform intact.\u00a0 I used a simple RC flow pass filter to achieve this: a resistor and a capacitor in series to ground.\u00a0 Connect the resistor to the incoming signal and the capacitor to ground, the signal from the junction between these two components will be low pass filtered. You can calculate the values of the capacitor and resistor you need for a low pass filter according to the following equation:cutoff frequency = 1/ (2*pi*R*C) so for a cutoff frequency of 20,000Hz and 1kOhm resistor:20000=1/(2*3.14*1000*C) C =~ 8nF Since 8nF capacitors are hard to come by I rounded up to 0.01uF.\u00a0 This gives a cutoff frequency of about 16kHz.\u00a0 You can mess around with different values and see what you like best, I tend to like heavier filtering bc it removes more unwanted noise. Solder a 1kOhm resistor to the junction from the voltage divider from the last step (if you did not include the voltage divider, solder straight to pin 7).\u00a0 Solder a 0.01uF capacitor in series with this resistor to ground.\u00a0 Solder a wire from the junction between the capacitor and resistor to pin 5 of the second socket. \u00a0", "step_imgs": ["https://cdn.instructables.com/FDQ/BBPO/H4AGM54W/FDQBBPOH4AGM54W.LARGE.jpg", "https://cdn.instructables.com/FKJ/GW3Z/H4UZYZ7M/FKJGW3ZH4UZYZ7M.LARGE.jpg"], "step_title": "Step 11: RC Low Pass Filter"}, {"step": 12, "steps_text": "In this step I wired the two op amps on the second chip as voltage followers and wired them in parallel so they could source twice the current.\u00a0 As in step 7, this voltage follower acts as a buffer, protecting the incoming waveform from the load of the headphones which will eventually be attached to the output of the buffer. Solder a wire between the two non-inveting inputs of the op amps (pins 5 and 3 of the second socket).\u00a0 Solder another wire between the two outputs (pins 1 and 7 of the second socket).\u00a0 On the underside of the board solder the inverting inputs to their outputs (fig 2).", "step_imgs": ["https://cdn.instructables.com/FMG/4BAX/H4V01261/FMG4BAXH4V01261.LARGE.jpg", "https://cdn.instructables.com/FDK/3PKK/H4UZI96F/FDK3PKKH4UZI96F.LARGE.jpg"], "step_title": "Step 12: More Buffering"}, {"step": 13, "steps_text": "After all the voltage dividers, the signal coming out of the op amps oscillates between 0 to about 1V (or 0 to 5V if you did not include the voltage divider in step 10).\u00a0 Before sending the signal out to speakers/headphones, it must be offset to oscillate around 0V.\u00a0 This is called a DC offset, it is achieved by running the signal through a capacitor. Solder the - end of a 100uF (or higher) capacitor to the output of the second op amp.\u00a0 The signal coming from the + end of the capacitor will be DC offset to oscillated around 0V.", "step_imgs": ["https://cdn.instructables.com/FA2/4LD9/H4UZV7PD/FA24LD9H4UZV7PD.LARGE.jpg", "https://cdn.instructables.com/F4C/HRSQ/H4UZETFO/F4CHRSQH4UZETFO.LARGE.jpg"], "step_title": "Step 13: DC Offset"}, {"step": 14, "steps_text": "Unscrew the plastic case of the audio jack.\u00a0 Solder a black wire (ground) to the longer lead, and wire a green wire (signal out) to the two shorter leads.\u00a0 This jack is stereo, but the signal out of the Arduino is mono, so just wire the mono signal to both stereo outputs. Use hot glue to add some structural support to these connections and prevent short circuits.\u00a0 Solder the green wire to the + end of the 100uF capacitor and solder the black wire to ground.", "step_imgs": ["https://cdn.instructables.com/F93/MLB9/H4UZR7UF/F93MLB9H4UZR7UF.LARGE.jpg", "https://cdn.instructables.com/FYR/EDJV/H0KL4FHY/FYREDJVH0KL4FHY.LARGE.jpg", "https://cdn.instructables.com/FAC/OUI4/H0KR942R/FACOUI4H0KR942R.LARGE.jpg", "https://cdn.instructables.com/F9G/Y07P/H2WEWNAS/F9GY07PH2WEWNAS.LARGE.jpg", "https://cdn.instructables.com/F6O/QZFG/H2WEJX27/F6OQZFGH2WEJX27.LARGE.jpg", "https://cdn.instructables.com/FC7/CORI/H2WERM32/FC7CORIH2WERM32.LARGE.jpg", "https://cdn.instructables.com/F5U/3U30/H63P41MC/F5U3U30H63P41MC.LARGE.jpg"], "step_title": "Step 14: Audio Jack"}, {"step": 15, "steps_text": "Fig 2 shows the signal coming straight out of the microphone on an oscilloscope.\u00a0 The signal is relatively weak, with an amplitude of only 200mV.\u00a0 Notice how the signal oscillates around 0 volts- this is typical of audio signals.\u00a0 Ideally, you want to have a signal with a max amplitude of 2.5V oscillating around 2.5V.\u00a0 This way the signal is completely contained within 0-5V; the Arduino will be able to measure it with maximum resolution and no clipping.\u00a0 In order to do this, the signal will need to be DC offset and amplified.\u00a0 DC offset means changing the level that the wave oscillated around (the midpoint of the wave).\u00a0 Amplification means increasing the amplitude (distance between the center point and max or min) of a signal.\u00a0 Amplification also buffers the microphone element from any loads that you may put on it later in the circuit, which is a good thing because it prevents distortion. Fig 3 shows the same microphone signal after amplification, you can see how the height of the peaks has increased so that the wave oscillates between -2.5 and 2.5 V (amplitude of 2.5V).\u00a0 Fig 4 shows the signal after it has been DC offset; it still has an amplitude of 2.5V, but the center point is 2.5V instead of 0V, so the wave never drops down below 0V.\u00a0 (Note- the slight change in shape between the signals in figure 3 and 4 is dues to changes in my voice between the two pics, it has nothing to do with the circuit).\u00a0 The signal in fig 4 is ready to go to an Arduino analog input pin.", "step_imgs": ["https://cdn.instructables.com/F1Y/QKUS/H5ED98L9/F1YQKUSH5ED98L9.LARGE.jpg", "https://cdn.instructables.com/F9J/T83Y/H5Y9W70T/F9JT83YH5Y9W70T.LARGE.jpg", "https://cdn.instructables.com/FLF/0AZ7/H5Y9W70V/FLF0AZ7H5Y9W70V.LARGE.jpg", "https://cdn.instructables.com/FHQ/ZH99/H63P42CM/FHQZH99H63P42CM.LARGE.jpg"], "step_title": "Step 15: Microphone Circuit"}, {"step": 16, "steps_text": "Two nine volt batteries will be needed to power the TL082.\u00a0 The double pole double throw (DPDT) switch will act as a power switch to both batteries.\u00a0 DPDT switches actually have two separate switches in them, but they are controlled by the same toggle mechanism (fig 1).\u00a0 Wire the red ends of two battery snaps to one side (the same side) of each switch (figs 3 and 4).\u00a0 Solder red wires to the middle leads of each switch (figs 5 and 6).\u00a0 Use hot glue to secure the solder joints if necessary (fig 7).", "step_imgs": ["https://cdn.instructables.com/F4C/NWE4/H4VQ6KJZ/F4CNWE4H4VQ6KJZ.LARGE.jpg", "https://cdn.instructables.com/FWR/R5JU/H4VQO60S/FWRR5JUH4VQO60S.LARGE.jpg", "https://cdn.instructables.com/FUN/504L/H5405PI1/FUN504LH5405PI1.LARGE.jpg", "https://cdn.instructables.com/FED/SZVQ/H4VQ6KK0/FEDSZVQH4VQ6KK0.LARGE.jpg", "https://cdn.instructables.com/FKR/S34I/H54088YD/FKRS34IH54088YD.LARGE.jpg", "https://cdn.instructables.com/F3Q/R0NF/H54088YE/F3QR0NFH54088YE.LARGE.jpg", "https://cdn.instructables.com/FCK/5QDA/H4VQDOJY/FCK5QDAH4VQDOJY.LARGE.jpg"], "step_title": "Step 16: Batteries"}, {"step": 17, "steps_text": "Solder an 8 pin socket onto the protoboard (fig 1).\u00a0 As shown in the pin diagram for the TL082, +V connects to pin 8 and -V connects to pin 4.\u00a0 Connect on of the red wires from the middle lead of the DPDT switch to pin 8.\u00a0 Let's call the battery snap that is attached to this red lead snap #1.\u00a0 Solder the black lead from snap #2 to pin 4 of the socket (figs 2 and 3).\u00a0 Solder the black lead from snap #1 and the remaining red lead from the center pin of switch #2 together on the protoboard (figs 3 and 4), this is the center tap (0v) between the +9/-9V supply.\u00a0 Solder this connection to arduino ground (fig 8).", "step_imgs": ["https://cdn.instructables.com/FA9/9FZQ/H5405PJH/FA99FZQH5405PJH.LARGE.jpg", "https://cdn.instructables.com/FAW/5J7R/H540890I/FAW5J7RH540890I.LARGE.jpg", "https://cdn.instructables.com/FDJ/DPCK/H4VQDOK4/FDJDPCKH4VQDOK4.LARGE.jpg", "https://cdn.instructables.com/FIJ/97YJ/H4VQDOK5/FIJ97YJH4VQDOK5.LARGE.jpg", "https://cdn.instructables.com/FKM/PKM2/H5405PKK/FKMPKM2H5405PKK.LARGE.jpg", "https://cdn.instructables.com/FBY/98TD/H540890T/FBY98TDH540890T.LARGE.jpg", "https://cdn.instructables.com/F8J/OX3H/H540890S/F8JOX3HH540890S.LARGE.jpg", "https://cdn.instructables.com/FFL/AZYS/H5405PR9/FFLAZYSH5405PR9.LARGE.jpg", "https://cdn.instructables.com/FR7/L1EG/H5408963/FR7L1EGH5408963.LARGE.jpg", "https://cdn.instructables.com/FA2/D6BM/H52FWYPC/FA2D6BMH52FWYPC.LARGE.jpg"], "step_title": "Step 17: Amplifier Socket and Power"}, {"step": 18, "steps_text": "Unscrew the plastic case from the 1/4\" jack.\u00a0 If you have a mono microphone, unclip the right lead (fig 2).\u00a0 I also trimmed some of the metal from the larger lead- the ground lead (figs 5 and 6).\u00a0 Solder a black wire to the ground lead and a green wire to the other lead.\u00a0 Cover the leads of the jack with hot glue to prevent short circuiting or breakage.", "step_imgs": ["https://cdn.instructables.com/F3P/L4VO/H4ZN5G4K/F3PL4VOH4ZN5G4K.LARGE.jpg", "https://cdn.instructables.com/FRJ/OFA8/H4ZN5G4L/FRJOFA8H4ZN5G4L.LARGE.jpg", "https://cdn.instructables.com/FIR/ND7F/H5035LJ4/FIRND7FH5035LJ4.LARGE.jpg", "https://cdn.instructables.com/FHM/77WX/H4VQ6F31/FHM77WXH4VQ6F31.LARGE.jpg", "https://cdn.instructables.com/F0E/Y1PF/H51ASOMN/F0EY1PFH51ASOMN.LARGE.jpg", "https://cdn.instructables.com/FR9/RN9C/H4ZN5G4M/FR9RN9CH4ZN5G4M.LARGE.jpg", "https://cdn.instructables.com/FYD/A5ZV/H4VQNX5S/FYDA5ZVH4VQNX5S.LARGE.jpg", "https://cdn.instructables.com/F6X/P1L1/H4VQKQNQ/F6XP1L1H4VQKQNQ.LARGE.jpg"], "step_title": "Step 18: Microphone Input"}, {"step": 19, "steps_text": "Solder the wires from the 1/4\" jack to the protoboard.\u00a0 Solder the black wire to arduino ground and the green wire to pin 5 of the 8 pin socket.", "step_imgs": ["https://cdn.instructables.com/FGD/MABZ/H4VQ6KKT/FGDMABZH4VQ6KKT.LARGE.jpg"], "step_title": "Step 19: Non-inverting Amplifier: Part 1"}, {"step": 20, "steps_text": "Solder a 100K resistor between pins 6 and 7 of the 8 pin socket.", "step_imgs": ["https://cdn.instructables.com/F01/3TPE/H540896L/F013TPEH540896L.LARGE.jpg", "https://cdn.instructables.com/FW7/FLCS/H4VQO6AL/FW7FLCSH4VQO6AL.LARGE.jpg", "https://cdn.instructables.com/FOR/1YQL/H52FWYR3/FOR1YQLH52FWYR3.LARGE.jpg"], "step_title": "Step 20: Non-inverting Amplifier: Part 1"}, {"step": 21, "steps_text": "Solder two leads onto a potentiomer (shown in fig 1) so that it acts as a variable resistor.\u00a0 Solder one side (doesn't matter which) to ground and the other side to pin 6 of the socket.\u00a0 This pot will control the amplitude of the incoming microphone signal.", "step_imgs": ["https://cdn.instructables.com/F7Y/RXNE/H4VQDOLB/F7YRXNEH4VQDOLB.LARGE.jpg", "https://cdn.instructables.com/FWB/5H9P/H4VQKQUU/FWB5H9PH4VQKQUU.LARGE.jpg"], "step_title": "Step 21: Non-inverting Amplifier: Part 2"}, {"step": 22, "steps_text": "The DC offset circuit is comprised of two capacitors and a voltage divider.\u00a0 Solder a 10uF electrolytic capacitor so that the + lead connects to pin 7 of the socket.", "step_imgs": ["https://cdn.instructables.com/FDT/CV1T/H4VQKQUV/FDTCV1TH4VQKQUV.LARGE.jpg", "https://cdn.instructables.com/FKT/35N1/H5035MTI/FKT35N1H5035MTI.LARGE.jpg"], "step_title": "Step 22: DC Offset: Part 1"}, {"step": 23, "steps_text": "Solder a 47nF capacitor to the - end of the 10uF capacitor.\u00a0 Connect the other side of the 47nF cap to ground.", "step_imgs": ["https://cdn.instructables.com/FZQ/821R/H54089AO/FZQ821RH54089AO.LARGE.jpg", "https://cdn.instructables.com/FFK/U4D3/H4VQDOMK/FFKU4D3H4VQDOMK.LARGE.jpg"], "step_title": "Step 23: DC Offset: Part 2"}, {"step": 24, "steps_text": "Create a voltage divider between Arduino +5V and ground by wiring two 100kOhm resistors in series between 5V and ground.\u00a0 Connect the middle junction of the voltage divider to the junction between the two capacitors of the DC offset circuit.\u00a0 This will add 2.5V to the amplified microphone signal.", "step_imgs": ["https://cdn.instructables.com/FJO/9OFL/H4VQDOMM/FJO9OFLH4VQDOMM.LARGE.jpg", "https://cdn.instructables.com/F5M/H3CV/H54089HZ/F5MH3CVH54089HZ.LARGE.jpg", "https://cdn.instructables.com/FZD/3BYP/H5405RH3/FZD3BYPH5405RH3.LARGE.jpg", "https://cdn.instructables.com/FMF/5X4F/H54089I3/FMF5X4FH54089I3.LARGE.jpg"], "step_title": "Step 24: DC Offset: Part 3"}, {"step": 25, "steps_text": "Connect analog input 0 to the junction between the two capacitors in the DC offset circuit.", "step_imgs": ["https://cdn.instructables.com/F86/G3EO/H5405RH6/F86G3EOH5405RH6.LARGE.jpg", "https://cdn.instructables.com/FG3/LRPD/H5405RHB/FG3LRPDH5405RHB.LARGE.jpg"], "step_title": "Step 25: Connect to Analog Input"}, {"step": 26, "steps_text": "\n          Load the following code onto the Arduino.\u00a0 This code reads the signal coming into A0, converts it to a number between 0 and 255, and outputs it to the DAC.\u00a0 On the oscilloscope in the image above you can see the incoming mic signal in blue and the signal straight out of the DAC in yellow.\u00a0 Notice how each step of the DAC output is about 125us long.\u00a0 In this simple setup, the sampling rate is 1/125us or 8kHz.\u00a0 In the next steps I'll be manually setting the ADC counter and lowering the resolution of the Arduino's analog to digital conversion from 10 bit (0-1023) to 8 bit (0-255) to increase speed and get the sampling rate up. //Simple Audio Out\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n//July 2012\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\nint incomingAudio;\n\nvoid setup(){\n  for (byte i=0;i<8;i++){\n    pinMode(i,OUTPUT);//set digital pins 0-7 as outputs\n  }\n  pinMode(A0,INPUT);\n}\n\nvoid loop(){\n  incomingAudio = analogRead(A0);//read input from A0\n  incomingAudio = incomingAudio/4;//scale from 10 bit to 8 bit\n  PORTD = incomingAudio;//send out DAC\n}\n\n", "step_imgs": ["https://cdn.instructables.com/FZA/PA9E/H5ENPY1T/FZAPA9EH5ENPY1T.LARGE.jpg", "https://cdn.instructables.com/FET/QB3I/H5E9JRXO/FETQB3IH5E9JRXO.LARGE.jpg", "https://cdn.instructables.com/FCQ/ZBVM/H5E9Q518/FCQZBVMH5E9Q518.LARGE.jpg", "https://cdn.instructables.com/FV9/P0YI/H5E9Q519/FV9P0YIH5E9Q519.LARGE.jpg", "https://cdn.instructables.com/FKP/WAB1/H5F2Z2O8/FKPWAB1H5F2Z2O8.LARGE.jpg", "https://cdn.instructables.com/F2Z/F0FA/H5ENPY1S/F2ZF0FAH5ENPY1S.LARGE.jpg"], "step_title": "Step 26: Simple Audio Out"}, {"step": 27, "steps_text": "\n          In the code below I bypassed the function analogRead() in order to increase my sampling rate.\u00a0 I manually set the ADC counter to 500kHz and read an 8 bit value from analog input 0 from the ADCH directly.\u00a0 I set the ADC counter to 500kHz because the ADC takes 13 clock cycles to read a new analog value.\u00a0 500/13 = 38.5kHz which gets me pretty close to 40kHz (standard audio sampling rate) without introducing extra noise.//Audio out with 38.5kHz sampling rate\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n//July 2012\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\nvoid setup(){\n  DDRD=0xFF;//set port d (digital pin s0-7) as outputs\n  DDRC=0x00;//set all analog pins as inputs\n  \n  \n  //set up continuous sampling of analog pin 0\n  \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA = 0;\n  ADCSRB = 0;\n  \n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enabble auto trigger\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n}\n\nvoid loop(){\n  PORTD = ADCH;//send 8 bit value from analog pin 0 to DAC\n}\n\n In the code below I triggered the output to the DAC via the ADC interrupt. This interrupt is similar to other Arduino timer interrupts, but it only executed when a new ADC value has been reached (in this case at a rate of ~38.5kHz, or every 26us). The output of the code below is exactly the same as the code above, but it will be more convenient to use the interrupt code moving forward.//Audio out with 38.5kHz sampling rate and interrupts\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n//July 2012\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\nvoid setup(){\n  DDRD=0xFF;//set port d (digital pin s0-7) as outputs\n  DDRC=0x00;//set all analog pins as inputs\n  \n  cli();//diable interrupts\n  \n  //set up continuous sampling of analog pin 0\n  \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA = 0;\n  ADCSRB = 0;\n  \n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enabble auto trigger\n  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n  sei();//enable interrupts\n}\n\nISR(ADC_vect) {//when new ADC value ready\n  PORTD = ADCH;//send 8 bit value from analog pin 0 to DAC\n}\n\nvoid loop(){\n}\n\n", "step_imgs": ["https://cdn.instructables.com/FAA/FRK5/H5F2Z2OA/FAAFRK5H5F2Z2OA.LARGE.jpg", "https://cdn.instructables.com/FJQ/BXFK/H5ED7OIV/FJQBXFKH5ED7OIV.LARGE.jpg", "https://cdn.instructables.com/FJ3/G0GY/H4VQDQ20/FJ3G0GYH4VQDQ20.LARGE.jpg"], "step_title": "Step 27: "}, {"step": 28, "steps_text": "\n          The code below records short section of incoming audio into one of two arrays: buffer1 and buffer2.\u00a0 It also introduces a variable called \"scale.\"\u00a0 This variable is used to scale the playback of the stored buffer audio in order to change the frequency.\u00a0 The code below sets scale to 2, this doubles the length of time it takes for the dac to output the stored audio.\u00a0 As you can see in the image above, the output from the dac (yellow) is half the frequency of the input from the microphone (blue).//Half Frequency Playback\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n//July 2012\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\n//audio storage\nbyte buffer1[1000];\nbyte buffer2[1000];\n\nbyte incomingAudio;//storage variable\n\nint i = 0;//index variable\nint iscale = 0;//index variable\nint scale = 2;\nboolean toggle = 0;\nboolean rec = 1;\nint limit = 1000;\n\n\nvoid setup(){\n  DDRD=0xFF;//set port d (digital pin s0-7) as outputs\n  DDRC=0x00;//set all analog pins as inputs\n  \n  cli();//diable interrupts\n  \n  //set up continuous sampling of analog pin 0\n  \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA=0;\n  ADCSRB = 0;\n  \n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enabble auto trigger\n  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n  sei();//enable interrupts\n}\n\nISR(ADC_vect) {//when new ADC value ready\n  incomingAudio = ADCH;\n  if (rec){\n    if (toggle){\n      buffer1[i] = incomingAudio;//store incoming\n      PORTD = buffer2[iscale];//send out DAC\n    }\n    else{\n      buffer2[i] = incomingAudio;//store incoming\n      PORTD = buffer1[iscale];//send out DAC\n    }\n  }\n  else{\n    if (toggle){\n      PORTD = buffer2[iscale];//send out DAC\n    }\n    else{\n      PORTD = buffer1[iscale];//send out DAC\n    }\n  }\n  i += 1;\n  iscale = i/scale;\n  if (i==limit){\n    rec = 0;//stop recording\n  }\n  if (i == (limit*scale)){\n    i = 0;\n    iscale = 0;\n    toggle^=1;\n    rec = 1;\n  }\n}\n\nvoid loop(){\n}\n\n", "step_imgs": ["https://cdn.instructables.com/FEB/T3H3/H5F2Z2OQ/FEBT3H3H5F2Z2OQ.LARGE.jpg"], "step_title": "Step 28: Half Frequency Playback"}, {"step": 29, "steps_text": "Since the ADC is busy converting the incoming audio from A0 to digital, the three control pots on the effects box (wet/dry, pitch, and grain size) will have to be monitored using one of the digital pins.\u00a0 This can be down using an RC circuit.\u00a0 This circuit uses a digital pin on the Arduino to measure the amount of time it takes to discharge a capacitor.\u00a0 This time is related to the resistance in the circuit which is set by a potentiometer.\u00a0 This way, we can indirectly measure the resistance of the potentiometer. Solder a row to header pins to digital pins 9-13.\u00a0 Solder a 10kOhm resistor and 0.1uF capacitor in series to pins 10-12.\u00a0 Solder the free end of the 0.1uF capacitors together and connect to Arduino +5V.\u00a0 Connect the outside pin of two 1mOhm linear taper pots to the junction between the resistor and capacitor attached to digital pins 11 and 12.\u00a0 Connect the outside pin of a 1mOhm logarithmic taper pot to the junction between the resistor and capacitor attached to digital pin 10.\u00a0 Solder the middle pins of each pot to ground. I you'd like you can increase the resolution of any of these controls by increasing the capacitance of the 0.1uF cap to 1uF or 10uF.\u00a0 This change will have to be accounted for in the final firmware as well.", "step_imgs": ["https://cdn.instructables.com/F3Y/LNWJ/H5TU7BR8/F3YLNWJH5TU7BR8.LARGE.jpg", "https://cdn.instructables.com/FAW/8IJL/H5TU8K93/FAW8IJLH5TU8K93.LARGE.jpg", "https://cdn.instructables.com/F8Q/YFW8/H5TU9QYB/F8QYFW8H5TU9QYB.LARGE.jpg", "https://cdn.instructables.com/FRS/8WL2/H5TUCEQP/FRS8WL2H5TUCEQP.LARGE.jpg", "https://cdn.instructables.com/FDM/782R/H5TUCEQS/FDM782RH5TUCEQS.LARGE.jpg", "https://cdn.instructables.com/FJ4/PDJJ/H5ED8H5O/FJ4PDJJH5ED8H5O.LARGE.jpg", "https://cdn.instructables.com/F90/25X2/H5TU7BR9/F9025X2H5TU7BR9.LARGE.jpg", "https://cdn.instructables.com/FAD/QA7J/H5TUCDTZ/FADQA7JH5TUCDTZ.LARGE.jpg"], "step_title": "Step 29: RC Potentiometers"}, {"step": 30, "steps_text": "This switch allows reverse playback of recorded samples.\u00a0 Solder a 10kOhm resistor to one of the leads from the switch.\u00a0 Solder a red wire to the other end of the resistor and connect to ground.\u00a0 Solder a wire to the junction between the resistor and the switch and connect to Arduino digital pin 9.\u00a0 solder a black wire to the remaining pin from the switch and connect to ground.", "step_imgs": ["https://cdn.instructables.com/FEJ/LPL9/H0KL4F69/FEJLPL9H0KL4F69.LARGE.jpg"], "step_title": "Step 30: Switch"}, {"step": 31, "steps_text": "Solder 100ohm resistors to the anodes of two white indicator LEDs.\u00a0 Connect the cathodes of both indicator LEDs to ground.\u00a0 Connect the anode of one of the LEDs to digital pin 13- this is the clipping indicator.\u00a0 The other indicator LED will be connected to a switch in the next step.", "step_imgs": ["https://cdn.instructables.com/F0W/HTT4/H5IRUMDF/F0WHTT4H5IRUMDF.LARGE.jpg", "https://cdn.instructables.com/F2M/U4QT/H5IRUMDG/F2MU4QTH5IRUMDG.LARGE.jpg"], "step_title": "Step 31: Indicator LEDs"}, {"step": 32, "steps_text": "this switch will turn on an indicator LED to show that the output is on.\u00a0 Solder two wires to the back of the 10kOhm pot.\u00a0 Connect one wire to Arduino 5V and the other to the anode of the indicator LED.\u00a0 The other end of the indicator LED connects to ground.", "step_imgs": ["https://cdn.instructables.com/FCS/C9TK/H5EDUW7D/FCSC9TKH5EDUW7D.LARGE.jpg", "https://cdn.instructables.com/FAW/P1HJ/H5TUCDTN/FAWP1HJH5TUCDTN.LARGE.jpg", "https://cdn.instructables.com/F0W/HTT4/H5IRUMDF/F0WHTT4H5IRUMDF.LARGE.jpg", "https://cdn.instructables.com/F2M/U4QT/H5IRUMDG/F2MU4QTH5IRUMDG.LARGE.jpg"], "step_title": "Step 32: Output Switch"}, {"step": 33, "steps_text": "I designed a triangular enclosure in corel draw and cut it from 1/4\" plywood on a laser cutter.\u00a0 Two sides have holes for the input and outputs controls (jack, indicator LED, and gain potentiometer).\u00a0 The front panel has holes for the rest of the controls (on/off switch, reverse switch, wet/dry mixer, pitch pot, grain size pot).\u00a0 The bottom has a hole for easy access to the arduino's usb port. I coated the plywood in three coats of polycrylic and glued the sides together with wood glue.\u00a0 I glued three small triangular pieces into the corners of the enclosure so that I could screw the back panel on with wood screws (fig 3).\u00a0 Attach the Arduino to the header pins on the protoboard and begin installing the components in the enclosure.\u00a0 I started by attaching the pots and switches to the front panel and then added the jacks, LED indicators, and pots to the sides.\u00a0 Finally I pushed the arduino's usb port through the square hole on the bottom of the enclosure. My arduino sat firmly in place, you could screw it to the back panel for an extra secure fit. I've attaches the corel file for the enclosure that I built.", "step_imgs": ["https://cdn.instructables.com/FTH/5D0V/H5TVASA3/FTH5D0VH5TVASA3.LARGE.jpg", "https://cdn.instructables.com/FE7/JQ67/H5TU9QAQ/FE7JQ67H5TU9QAQ.LARGE.jpg", "https://cdn.instructables.com/FOW/SFLS/H5TU8K88/FOWSFLSH5TU8K88.LARGE.jpg", "https://cdn.instructables.com/F8I/0W2N/H5EDUW76/F8I0W2NH5EDUW76.LARGE.jpg", "https://cdn.instructables.com/FR1/HH6W/H5TU9QB8/FR1HH6WH5TU9QB8.LARGE.jpg", "https://cdn.instructables.com/FR4/TVXF/H5TU9QBK/FR4TVXFH5TU9QBK.LARGE.jpg", "https://cdn.instructables.com/FTV/2RGO/H5TUCDVN/FTV2RGOH5TUCDVN.LARGE.jpg", "https://cdn.instructables.com/FIQ/KMQ6/H5TUCDVG/FIQKMQ6H5TUCDVG.LARGE.jpg", "https://cdn.instructables.com/FTY/LNXJ/H5TUCDVM/FTYLNXJH5TUCDVM.LARGE.jpg", "https://cdn.instructables.com/FFK/CPK7/H5TU9QCA/FFKCPK7H5TU9QCA.LARGE.jpg", "https://cdn.instructables.com/F75/IAOO/H5TUCDWA/F75IAOOH5TUCDWA.LARGE.jpg", "https://cdn.instructables.com/F0S/FS08/H5TUCEGC/F0SFS08H5TUCEGC.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 33: Enclosure"}, {"step": 34, "steps_text": "Secure batteries in the corners of the enclosure with a battery clip or a piece of velcro.\u00a0 Screw on back panel of enclosure.", "step_imgs": ["https://cdn.instructables.com/F0G/4MXU/H5TUCDW7/F0G4MXUH5TUCDW7.LARGE.jpg"], "step_title": "Step 34: Batteries"}, {"step": 35, "steps_text": "Attach knobs to potentiometers and secure with a set screw.", "step_imgs": ["https://cdn.instructables.com/FFA/PGUL/H5Y9WAH5/FFAPGULH5Y9WAH5.LARGE.jpg"], "step_title": "Step 35: Knobs"}, {"step": 36, "steps_text": "\n          Here is the final code for the project.\u00a0 I've already explained the basic ideas behind most of the audio processing in previous steps.\u00a0 The only changes I've made here is to add some code which allows the pots and switches on the device to change the value of a few variables: \"scale,\" \"grain,\" \"forward,\" and \"wet\" and \"dry.\"//Final effects box code\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Vocal-Effects-Box/\n//Aug 2012\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\n/*\npots:\nwet/dry\ngrain size\npitch shift\n*/\n\n//audio storage\nbyte buffer1[500];\nbyte buffer2[500];\n\n//buffer recording variables\nboolean toggle = 0;\nboolean rec = 1;\n\n//pot checking storage\nint scale = 20;\nint scalePot;\nint newScale = scale;\nbyte multiplier = 0;\nint grain = 500;\nint grainPot;\nint newGrain = grain;\nint wetDryPot;\nint wet = 16;\nint dry = 16-wet;\nint newWetDry = wet;\n\n//data retrieval variables\nunsigned int i = 0;//index variable\nint iscale = 0;//index variable\nint iscalerev = grain-1;\n\n//clipping indicator variables\nboolean clipping;\nint clippingCounter = 5000;\n\n//reverse switch variables\nboolean forward = 0;\nboolean newForward = forward;\n\n\nvoid setup(){\n  DDRD=0xFE;//set digital pins 0-7 as outputs\n  DDRB=0xFD;//set digital pins 10-13 as outputs, 9 as input\n  DDRC=0x00;//set all analog pins as inputs\n  \n  cli();//diable interrupts\n  \n  //set up continuous sampling of analog pin 0\n  \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA = 0;\n  ADCSRB = 0;\n  \n  ADMUX = 0;//Clear ADMUX register\n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so I can read highest 8 bits from ADCH register only\n  //since I'm reading A0, I don't need to specifiy which analog pin I want to read from (0 is default)\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enabble auto trigger\n  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n  sei();//enable interrupts\n}\n\n\n\nISR(ADC_vect) {//when new ADC value ready\n  if (rec){\n    if (toggle){\n      buffer1[i] = ADCH;//store incoming\n      if (ADCH == 0 || ADCH == 1023){//if clipping\n        PORTB |= 32;//set pin 13 high\n        clippingCounter = 5000;//reset clipping counter\n        clipping = 1;//currently clipping\n      }\n      if (forward){//forward\n        PORTD = (wet*int(buffer2[iscale])+dry*int(ADCH))>>4;//send out DAC\n      }\n      else{//reverse\n        PORTD = (wet*int(buffer2[iscalerev])+dry*int(ADCH))>>4;//send out DAC\n      }\n    }\n    else{\n      buffer2[i] = ADCH;//store incoming\n      if (ADCH == 0 || ADCH == 1023){//if clipping\n        PORTB |= 32;//set pin 13 high\n        clippingCounter = 5000;//reset clipping counter\n        clipping = 1;//currently clipping\n      }\n      if (forward){\n        PORTD = (wet*int(buffer1[iscale])+dry*int(ADCH))>>4;//send out DAC\n      }\n      else{\n        PORTD = (wet*int(buffer1[iscalerev])+dry*int(ADCH))>>4;//send out DAC\n      }\n    }\n  }\n  else{\n    if (toggle){\n      if (forward){\n        PORTD = (wet*int(buffer2[iscale])+dry*int(ADCH))>>4;//send out DAC\n      }\n      else{\n        PORTD = (wet*int(buffer2[iscalerev])+dry*int(ADCH))>>4;//send out DAC\n      }\n    }\n    else{\n      if (forward){\n        PORTD = (wet*int(buffer1[iscale])+dry*int(ADCH))>>4;//send out DAC\n      }\n      else{\n        PORTD = (wet*int(buffer1[iscalerev])+dry*int(ADCH))>>4;//send out DAC\n      }\n    }\n  }\n  i++;//increment i\n  iscale = i*10/scale-grain*multiplier;\n  iscalerev = grain-iscale-1;\n  if (i==grain){\n    rec = 0;//stop recording\n  }\n  if (i>=(grain*scale/10)){\n    if (scale<10){\n      if (i==grain){\n        i = 0;\n        iscale = 0;\n        iscalerev = grain-1;\n        forward = newForward;//update direction\n        scale = newScale;//update scale\n        grain = newGrain;//update grain\n        dry = newWetDry;//update wet dry\n        wet = 16-dry;\n        toggle ^= 1;//try removing this\n        rec = 1;\n        multiplier = 0;\n      }\n      else if (iscale>=grain){\n        iscale = 0;\n        iscalerev = grain-1;\n        multiplier++;\n      }\n    }\n    else{\n      i = 0;\n      iscale = 0;\n      iscalerev = grain-1;\n      forward = newForward;//update direction\n      scale = newScale;//update scale\n      grain = newGrain;//update grain\n      dry = newWetDry;//update wet dry\n      wet = 16-dry;\n      toggle ^= 1;//try removing this\n      rec = 1;\n      multiplier = 0;\n    }\n  }\n  if (clipping){\n    clippingCounter--;//decrement clipping counter\n  }\n}\n\nvoid checkScale(){\n  PORTB &= 251;//set pin 10 low\n  scalePot = 0;\n  while(digitalRead(10)){\n    scalePot++;\n  }\n  newScale = scalePot+2;\n}\n\nvoid checkGrainSize(){\n  PORTB &= 247;//set pin 11 low\n  grainPot = 0;\n  while(digitalRead(11)){\n    grainPot++;\n  }\n  if (grainPot < 1){\n    grainPot = 1;\n  }\n  else if (grainPot > 20){\n    grainPot = 20;\n  }\n  newGrain = grainPot*25;\n}\n\nvoid checkWetDry(){\n  PORTB &= 239;//set pin 12 low\n  wetDryPot = 0;\n  while(digitalRead(12)){\n    wetDryPot++;//from 0 to ~185\n  }\n  if (wetDryPot < 10){\n    wetDryPot = 0;\n  }\n  else if (wetDryPot > 160){\n    wetDryPot = 160;\n  }\n  newWetDry = wetDryPot/10;//scale down to 16\n}\n\nvoid checkRev(){//check reverse switch\n  if (digitalRead(9)){\n    newForward = 1;\n  }\n  else{\n    newForward = 0;\n  }\n}\n\nvoid loop(){\n  if (clipping){//if currently clipping\n    if (clippingCounter<=0){//if enough time has passed since clipping\n      clipping = 0;//not currently clipping\n      PORTB &= 223;//turn off clipping led indicator (pin 13)\n    }\n  }\n  DDRB=0xFD;//set pins 10-12 as outputs\n  PORTB |= 28;//set pins 10-12 high\n  delay(1);//wait for capacitor to discharge\n  checkRev();//check reverse switch\n  DDRB= 0xE1;//set pins 10-12 as inputs\n  checkScale();\n  checkGrainSize();\n  checkWetDry();\n}\n\n\n", "step_imgs": ["https://cdn.instructables.com/FQ7/0QYH/H2MYKNK9/FQ70QYHH2MYKNK9.LARGE.jpg"], "step_title": "Step 36: Final Firmware"}], "channel": "Arduino"}, {"category": "technology", "description": "After building a full size Dalek in 2012, I wanted to make it talk and I didn't have the budget for the high end audio equipment that some people use and wanted to see if it would be possible to create a simple, low-cost voice changer using an Arduino.After many different approaches, I was able to put together a simple shield for the Arduino Uno that lets you combine your voice with a sine wave to create a digital ring modulator effect. The frequency of the sine wave can be adjusted real-time with a potentiometer, so that you can change from a Dalek voice to a Cyberman voice very easily.The main components are a 12-bit ADC for converting mic input to a digital signal, a 12-bit DAC for converting the modified digital sound back to an analog audio signal, and a low-pass filter (resistors and capacitors) for filtering out some of the noise from the signal.In this instructable, I will explain the theory behind this board and hopefully provide enough information for building this on a breadboard.The schema, board layout, and Arduino source code are all available for free from this git repo. I also sell kits in my Tindie store and from the Ultimate Voice Changer web site.", "title": "Dalek & Cyberman Voice Changer With Arduino Uno", "url": "https://www.instructables.com/id/Dalek-Voice-Changer-Arduino-Shield/", "section": "technology", "steps": [{"step": 1, "steps_text": "The diagram above shows the overall workings of the voice changer shield.The Arduino uses SPI to read data from the microphone and potentiometer (SPI is a high speed protocol so more than capable of audio processing).The Arduino then manipulates the audio data by mixing it with a sine wave.The modified audio data is then sent to the DAC over SPI. The DAC outputs an analog audio signal that passes through an RC filter (RC stands for Resister and Capacitor, by the way) which filters out some noise.Finally the signal goes to a speaker. The signal isn't strong enough to driver a speaker directly though, so you'll need a speaker that has a built-in amplifier, like the popular \"portable MP3 speakers\" that you would connect to a phone or tablet.", "step_imgs": ["https://cdn.instructables.com/F95/BDNS/II4WPNHU/F95BDNSII4WPNHU.LARGE.jpg"], "step_title": "Step 1: How Does It Work?"}, {"step": 2, "steps_text": "At first glance, the schematic looks complex, but that is mostly because of all the headers that are broken out as convenient ways to attach inputs to the ADC.There are really only three major areas of interest:1. Arduino to ADCThe ADC (MPC3208) is connected to the Arduno via SPI (Arduino pins 13, 12, 11). Pin 10 is used for the Slave Select.Note that VREF is connected to 3.3V and VDD is connected to 5V.2. Arduino to DACThe DAC (MPC4921) is also connected to the Arduno via SPI (Arduino pins 13, 12, 11). Pin 9 is used for the Slave Select. The DAC also has an additional connection for an LDAC latch that is conencted to Pin 8 on the Arduino.As with the ADC, VREF is connected to 3.3V and VDD is connected to 5V.3. High-pass and Low-pass FilterThe output of the MCP4921 DAC passes through both a low-pass and a high-pass filter, to remove some noise, before connecting to the audio jack. The full schematic file (in Eagle PCB format) is available here.", "step_imgs": ["https://cdn.instructables.com/F2H/K7S3/II4WPOK7/F2HK7S3II4WPOK7.LARGE.jpg"], "step_title": "Step 2: Schematic"}, {"step": 3, "steps_text": "I chose this board layout in an effort to keep all of the SPI communication happening on the shortest possible path, since this is high frequency and could cause interface with the audio circuitry. The low-pass and high-pass filters (all those capacitors and resistors) are kept close together, near to the audio jack.There are lots of headers broken out to allow the flexibility of using all of the inputs to the ADC but so far I have only used two of them (one for the mic, and one for a potentiometer).You can download the full board layout (in Eagle PCB format) here.", "step_imgs": ["https://cdn.instructables.com/FE1/O1SK/II4WPNON/FE1O1SKII4WPNON.LARGE.jpg"], "step_title": "Step 3: Board Layout"}, {"step": 4, "steps_text": "The bulk of the source code deals with SPI communication between the ADC and the DAC.The interesting parts that I want to cover in this instructable are how the audio processing works to combine the voice with the sine wave.This code reads a value from the Mic. This results in a number between 0 and 4095:audio_in = read_adc(1);The sine wave is generated in the setup method and stored in an array. The main loop then iterates over that array to pick the next value in the sine wave:index += incr;\n  if (index >= NUM_SINE_WAVE_POINTS)  {\n    index -= NUM_SINE_WAVE_POINTS;\n  }\n  data = sineWave[index];\nThe audio signal and sine wave value are then multiplied together:audio_out = 2047 + ((audio_in-2047) * ((data-127) / 127.0));\nThe full source code is available here.", "step_imgs": [], "step_title": "Step 4: Arduino Code"}], "channel": "Arduino"}, {"category": "technology", "description": "Turn on music as soon as you walk into a room! This tutorial covers a minimalistic entrance sensor that triggers music of your choice. The design can easily be adapted to suit a variety of needs (e.g. alarm system, motion-triggered lights, etc.). The system is controlled by a Raspberry Pi, and aside from the RPi and speakers, the materials cost is extremely low (~ $20). Build time is approximately 1 - 2 hours.For an inexpensive set of speakers, check thrift stores and/or friends' garages. ", "title": "Motion-Triggered Music Player", "url": "https://www.instructables.com/id/Motion-Triggered-Music-Player/", "section": "technology", "steps": [{"step": 1, "steps_text": "1. Raspberry Pi + AccessoriesThis tutorial assumes that the RPi has been set up and includes all necessary accessories (e.g. power cord, SD card, etc.). It is also recommended to use an RPi that has been set up for wireless and with a GPIO breakout cable. Here's a tutorial on how to set up the RPi.2. Infrared (IR) Breakbeam Sensor(s)3. 10 kOhm Resistor4. Speakers w/ 1/8\" audio jack (standard headphone jack)5. 22 or 24 gauge wire (min. 15 feet)Recommended to get at least two to three colors (e.g. red, black & yellow).6. Optional: PCB board and/or Connectors Although not necessary, a small PCB is recommended to make the system more robust and longer lasting.Add connectors between the sensor and RPi GPIO for simpler installation, transportation and to more easily allow for future customization. 7. Recommended: LED + 10kOhm Resistor (for testing)", "step_imgs": ["https://cdn.instructables.com/FS6/INH0/IB8Q07D1/FS6INH0IB8Q07D1.LARGE.jpg"], "step_title": "Step 1: Materials"}, {"step": 2, "steps_text": "1. Soldering Iron*, Solder & Solder Wick2. Wire Strippers3. Epoxy4. Multimeter5. Recommended: Breadboard + Breadboard Wires (for setup and testing)*Note: If you do not have access to a soldering iron, you can twist wires together and coat in hot glue. ", "step_imgs": ["https://cdn.instructables.com/FB0/3D2J/IB8Q07D2/FB03D2JIB8Q07D2.LARGE.jpg"], "step_title": "Step 2: Tools"}, {"step": 3, "steps_text": "This project provides an overview for how to play a music file saved on the RPi SD card. Possible modifications include setting up the RPi to play music from an external USB drive or streaming music from a website.1. Install updates.sudo apt-get update2. Download example music file for testing.wget   http://goo.gl/MOXGX3   -O example.mp3 --no-check-certificatesNote: This saves the file in whatever directory you are currently in.3. Open the Terminal window and go into the folder with the music fileUse following command (switch \u201cFolderName\u201d for location of music file): Cd /home/pi/FolderName4. Type following command to play file over the audio output:omxplayer example.mp3", "step_imgs": ["https://cdn.instructables.com/FTN/8500/IBFS4WIK/FTN8500IBFS4WIK.LARGE.jpg"], "step_title": "Step 3: Setup Raspberry Pi to Play Music"}, {"step": 4, "steps_text": "Recommended to build the circuit on a breadboard and test prior to soldering any of the components onto the PCB board.1. Extend the wire leads of the IR beam (2 wires: red & black) and IR receiver (3 wires: red, black & yellow).Plan out and measure the route of the wires from where the IR beam and receiver will be installed to the speaker system. At a minimum, make each wire lead 3 - 5 ft. Recommended to add connectors to the IR beam and/or receiver to make it easier to disconnect them and, if necessary in the future, modify the system. If the schematic makes sense, skip the rest of the Build it! steps.2.  Connect the positive side of the IR sensor beam to Raspberry Pi 5V pin.3. Connect the negative side of the IR beam to RPi ground pin.4. Connect the positive side of the IR receiver to RPi 5V pin.5. Connect the negative side of the IR received to the RPi ground pin. ", "step_imgs": ["https://cdn.instructables.com/FAU/94ZK/IBFSEI1Q/FAU94ZKIBFSEI1Q.LARGE.jpg", "https://cdn.instructables.com/FVB/HA2L/IBFS5NX2/FVBHA2LIBFS5NX2.LARGE.jpg", "https://cdn.instructables.com/FQP/BMPM/IBFSGDHC/FQPBMPMIBFSGDHC.LARGE.jpg", "https://cdn.instructables.com/FPT/6ME7/IBFS4Y7D/FPT6ME7IBFS4Y7D.LARGE.jpg", "https://cdn.instructables.com/FLR/OBOX/IBFS4YA4/FLROBOXIBFS4YA4.LARGE.jpg"], "step_title": "Step 4: Build It! Pt. 1"}, {"step": 5, "steps_text": "1. Connect the data pin (yellow wire) of the IR receiver to RPi GPIO pin 23.2. Connect the 10kOhm resistor between the data pin/RPi GPIO pin 23 and the RPi 5V pin.3.Recommended: Connect an LED + resistor across the IR receiver data pin (yellow wire).Connect the positive LED leg to the IR receiver data pin. Connect the negative LED leg to the resistor. Connect the other side of the resistor to ground.4. Plug in RPi and log in; check that IR beam turns on.If you've connected the LED, it should turn on when the IR receiver gets the signal from the IR beam. Check that the LED turns off if you interrupt the beam.", "step_imgs": ["https://cdn.instructables.com/FQH/UIEZ/IBFS4YCD/FQHUIEZIBFS4YCD.LARGE.jpg", "https://cdn.instructables.com/FZ7/VMMN/IBFS4YLR/FZ7VMMNIBFS4YLR.LARGE.jpg", "https://cdn.instructables.com/F2I/H476/IBFS58XV/F2IH476IBFS58XV.LARGE.jpg", "https://cdn.instructables.com/FVJ/FGUH/IBFS5JCS/FVJFGUHIBFS5JCS.LARGE.jpg"], "step_title": "Step 5: Build It! Pt. 2"}, {"step": 6, "steps_text": "The following is a basic program to play a song when the IR beam signal is broken (AKA when you walk between the IR beam and IR receiver). Here's a link to the github code.Save the song of your choice to an easy-to-remember-and-type folder, in this example I used \"FolderName\" to designate the title of the folder in which the mp3 is saved.Note: This program prints a message to the screen each time the song is played. This worked for my needs, as I wanted to have a log of each time music is played, but of course this code is just an outline of what is possible. Modify it to suit your needs. Also, please note that the spacing may be off; this is important in Python so be sure to \"tabify\" your code before running it and check that the spacing is consistent.#DIY Motion Triggered Music Playerimport timefrom threading import Threadimport RPi.GPIO as GPIOimport subprocessclass AutoTrigger():    def call_omxplayer(self):     \tprint (\"playing \" + self.file_path)        pid = subprocess.call(['omxplayer', self.file_path], stderr=subprocess.PIPE, stdout=subprocess.PIPE)       self.is_running = False    def play_song(self):        if not self.is_running:           self.song_thread = Thread(target=self.call_omxplayer, args=())           self.song_thread.start()           self.is_running = True    def __init__(self,pin, file_path):        self.pin = pin        self.file_path = file_path       self.is_running = False       GPIO.setup(pin, GPIO.IN)        '''            This is a hack (the callback) thanks for python closures!        '''     GPIO.add_event_detect(self.pin, GPIO.FALLING, callback=lambda x: self.play_song(), bouncetime=10)def main(): GPIO.setmode(GPIO.BCM)    AutoTrigger(25, '/home/pi/FolderName/SongName.wav')    AutoTrigger(24, '/home/pi/FolderName/SongName2.mp3')    print (\"Ready: !\")    try:        while True:            pass    except KeyboardInterrupt:       GPIO.cleanup()        if __name__ == '__main__':    main()", "step_imgs": [], "step_title": "Step 6: Code It! Pt. 1"}, {"step": 7, "steps_text": "1. Check system for functionality. If system works as expected, coat all exposed electrical connections (except for RPi plugs) in hot glue or epoxy.Be aware that epoxy is essentially permanent; use hot glue if you want to modify the system in the future.2. Attach the IR beam to one side of your front door frame, and the IR receiver on the other side of the door frame, directly in line with the beam. Run the wires up and over the door frame.It is somewhat tricky to align the IR beam and receiver; highly recommended to use the LED + resistor to quickly see when the beam and receiver are aligned. Use sticky tack or tape to help w/ alignment.Secure the IR sensor via thumbtacks, nails, screws, etc. Suggested to run the wires up and over the door frame (instead of on the floor).3. Place the RPi in a convenient and out-of-the-way location. Consider where you want to place the speakers. If you need longer wires, measure the needed distance and solder in additional wires to the RPi power, ground and GPIO pins. 4. Set up the speakers.5. Test!Plug in the RPi and trigger the system to be sure that the music plays when you walk through the IR beam.", "step_imgs": ["https://cdn.instructables.com/FQX/L88E/IBFSAWYR/FQXL88EIBFSAWYR.LARGE.jpg", "https://cdn.instructables.com/FC3/98FK/IBFSAWYQ/FC398FKIBFSAWYQ.LARGE.jpg", "https://cdn.instructables.com/FET/RM3J/IBFS7RSB/FETRM3JIBFS7RSB.LARGE.jpg"], "step_title": "Step 7: Install It!"}, {"step": 8, "steps_text": "The only issue w/ this design is that the IR receiver range is shorter than I originally wanted, only about 2 feet. Some solutions to this problem would be to use a lens to magnify the IR beam or increase the power input.Possible modifications of the project include using WiFi to stream music or podcasts, triggering lights, and/or using it to detect motion in and out of your home for a basic security system.. or to see how many times your cat leaves the house while you're gone.Thanks for reading! Please subscribe and check out my YouTube channel for more projects and other cool science stuff. Happy building!", "step_imgs": ["https://cdn.instructables.com/FUH/SZF4/IBFSEY3N/FUHSZF4IBFSEY3N.LARGE.jpg"], "step_title": "Step 8: Activate and Enjoy!"}], "channel": "Raspberry Pi"}, {"category": "technology", "description": "I got the idea for this circuit from one of my professors. That design wasn't meant for passing frequencies high enough to be able to pass an audio file, e.g. 500Hz+, so I built this by modifying the carrier and signal frequencies, using only the Digilent Analog Discovery and the Analog Parts Kit. It should be noted that this circuit is primarily for educational purposes. Also note that there is no radio transmission here either. FM doesn't necessarily mean radio waves have to be involved.Throughout this Instructable I will be going through some of the functions and features of the Analog Discovery, but it will not be an exhaustive tutorial.", "title": "FM Modulation/de-modulation Circuit", "url": "https://www.instructables.com/id/FM-Modulationde-modulation-Circuit/", "section": "technology", "steps": [{"step": 1, "steps_text": "All of the parts listed below are provided in the Analog Starter Kit, except for the 9V batteries and clips. They should also be available through various online suppliers, local shops, or the salvage bin on your workbench.The Parts:- 2 OP482 quad op-amps (datasheet)- AD654 voltage to frequency converter (datasheet)- 9 ceramic capacitors: 2 - 39pF (39), 2 - 100pF (101), 2 - 1nF (102), 2 - 4.7nF (472), 1 - 10nF (103)- 17 carbon film resistors: 1 - 68, 3 - 1k, 1 - 6.8k, 3 - 10k, 1 - 20k, 1 - 47k, 2 - 100k, 5 - 470k- 1 1N4001 rectifier diode- 1 speaker- solderless breadboard- jumper wires(optional)- 1 TIP31C NPN BJT- 1 TIP32C PNP BJT- 2 9V batteries with clipsThe Tools:- Digilent Analog Discovery- Waveforms software (free but required to run the Analog Discovery)- short, free .wav file download.Pin-out diagrams are included for the OP482 quad op-amp and AD654 voltage to frequency converter, also called a voltage controlled oscillator or VCO.", "step_imgs": ["https://cdn.instructables.com/FQ2/9MZK/HWRC6WMT/FQ29MZKHWRC6WMT.LARGE.jpg", "https://cdn.instructables.com/FOT/PFX3/HWRC6WOA/FOTPFX3HWRC6WOA.LARGE.jpg", "https://cdn.instructables.com/FCL/FJSY/HWNU6JKG/FCLFJSYHWNU6JKG.LARGE.gif", "https://cdn.instructables.com/FMA/1047/HWNU6JJC/FMA1047HWNU6JJC.LARGE.jpg"], "step_title": "Step 1: Parts and Tools"}, {"step": 2, "steps_text": "The schematic for this can be daunting to say the least. When I first started working with it, I got lost all the time and had to keep going back over it again and again. You'll notice in the schematic that there are breaks throughout the design. Each of those breaks represents a good stopping point for verifying the circuit function. Take it slow and add one section at a time. The OP482 ICs are quad op-amps, meaning four op-amps on one piece of silicone. That can make it tricky to hook everything together as components can get crowded. This project can be built using individual op-amps if that is easier for you, but I would recommend using the OP27 and not the LM741. The LM741 should work, but I have had problems with it when it comes to needing fast, reliable response times. The specs are just a bit too slow for some applications, specifically the skew rate when you need high gain at a relatively high frequency.For clarification the schematic image is broken up. Point A matches to point A, B with B.", "step_imgs": ["https://cdn.instructables.com/FHA/UFLP/HWNU65LC/FHAUFLPHWNU65LC.LARGE.jpg", "https://cdn.instructables.com/FL6/EG9O/HWNU65LS/FL6EG9OHWNU65LS.LARGE.jpg"], "step_title": "Step 2: Designing"}, {"step": 3, "steps_text": "I won't go into the details of FM or AM technology too much here. I would refer you to Wikipedia for that (note the animation on the right side of the page). In a nutshell, for FM signals, the frequency of the signal varies based on the voltage level coming in. So a high voltage gives a high frequency, and vice versa. With AM, the frequency stays the same, but the amplitude goes high or low depending on the input voltage. As you will see, this circuit actually uses both.The higher frequency signal is the carrier frequency, while the original signal is the data that you want to relay. We will use the data signal to modulate a much higher frequency carrier wave. Later we will filter out the carrier and recover the data.The first three sections of the schematic are the modulation circuit. We first modulate the carrier wave, then amplify it. The AD654 changes the frequency of the output based on the voltage level of the input. The timing resistors and capacitors give a base frequency value for the IC to work with based on the equation found in the datasheet.Using pages 1 and 4 of the datasheet for the AD654, connect the components as shown. Note that 'Vs' indicates voltage supply, so '+Vs' is +5V and '-Vs' is ground. '+Vin' is the signal coming from the Analog Discovery AWG Channel 1 pin, labeled 'input' in the schematic.Turn on the Voltage function from the Waveforms main window (image 2). Click V+ to 'ON', connect the red V+ wire from the Discovery header to pin 8 on the AD654, then turn it on. Using the Discovery's AWG channel 1, output a 1VDC signal (image 3) and plug it into pin 4 of the AD654. You should get a readout on the scope like image 4. Next we add the first OP482. The first part is a simple voltage follower or buffer. Since op-amps are active components, we will get a boost in current from this part. Next we add an active low-pass filter set to cutoff at approximately 50kHz, which is high enough to allow our signal to pass through but low enough to filter out random high frequency noise we don't want. When connecting the OP482, connect the Discovery's red V+ wire to pin 4 and the white V- wire to pin 11. Turn on the power supply (like in image 2, but both channels this time) before turning on AWG 1 with the signal. Set AWG 1 to an amplitude of 500mV this time. Your scope should look something image 5.", "step_imgs": ["https://cdn.instructables.com/FNM/7FJQ/HWNU66WJ/FNM7FJQHWNU66WJ.LARGE.jpg", "https://cdn.instructables.com/FQZ/1238/HWJJW15Y/FQZ1238HWJJW15Y.LARGE.jpg", "https://cdn.instructables.com/FB8/CKKE/HWJJVXKQ/FB8CKKEHWJJVXKQ.LARGE.jpg", "https://cdn.instructables.com/FCL/A8KX/HWJJVXLF/FCLA8KXHWJJVXLF.LARGE.jpg", "https://cdn.instructables.com/FAZ/F80I/HWJJWBFP/FAZF80IHWJJWBFP.LARGE.jpg", "https://cdn.instructables.com/F8A/1SGL/HWNU6SGG/F8A1SGLHWNU6SGG.LARGE.jpg"], "step_title": "Step 3: Frequency Modulation"}, {"step": 4, "steps_text": "The theory behind most of these parts is a bit much to get into here. Again, check out wikipedia for the differentiator (note that this one is active because of the op-amp) and the envelope detector explanations. In short, the differentiator, believe it or not, differentiates the signal (think calculus and it makes total sense). As the input signal rises or falls quickly (high frequency), the output amplitude increases. As the input rises or falls slowly (low frequency), the output amplitude decreases closer to 0. This has the interesting effect of turning the FM signal into an AM signal. See the o-scope display in image 2 for a comparison (scope CH 1 to pin 14 of the OP482 and CH 2 to pin 8).The envelope detector detects only the top edge of the signal, so as the amplitude rises and falls, so will the signal coming out of the envelope detector. See image 3 for an example (CH 1 to pin 8 of OP482 and CH 2 to cathode of 1N4001 diode).", "step_imgs": ["https://cdn.instructables.com/F2K/78EN/HWNU6EBM/F2K78ENHWNU6EBM.LARGE.jpg", "https://cdn.instructables.com/FY1/57C7/HWNU7CJO/FY157C7HWNU7CJO.LARGE.jpg", "https://cdn.instructables.com/F6Z/MNDZ/HWNU7CJR/F6ZMNDZHWNU7CJR.LARGE.jpg", "https://cdn.instructables.com/FHX/GGTN/HWNU7DD6/FHXGGTNHWNU7DD6.LARGE.jpg"], "step_title": "Step 4: Differentiator and Envelope Detector"}, {"step": 5, "steps_text": "The signal from the envelope detector doesn't have much amplitude and contains quite a bit of noise. So we add several filters to both clarify and boost the signal. Look at the o-scope display in image 2. The red CH 1 signal is a 25kHz carrier with a 1kHz modulation frequency, amplitude of 500mV and index of 10%. These settings are all under the advanced tab on the Analog Discovery AWG tool (see image 3) if you would like to generate the signal yourself. This signal then is inserted into the input of the differentiator, bypassing the modulation circuit for now. The blue CH 2 is the output of the envelope detector, before any filtering. Do you see the scale on the left of the display in image 2? Each division is 20mV for CH 2. Most scopes will let you choose different scales for each channel, and here the scale for CH 1 is 200mV/div, larger by a factor of 10. With these two signals on a scale of 200mV/div, you would barely be able to see the output of the envelope detector because it is so weak. You can also see the noise in the signal as well in image 2. We need to filter that out and amplify the signal by a fair amount. We will also be running the signal through a band-pass filter to only allow audible frequencies between 200Hz and 2kHz to pass.The first part is the band-pass filter. It allows only a small range of frequencies to pass through, and in our case 200Hz to 2kHz is more than enough. Note that because the resistors match, there is no gain here, only filtering. We don't want to amplify noise, so let's filter it out first. After the band-pass filter we have two low-pass filters, the first with gain of approximately 23.5 and cutoff of about 8.6kHz, and the second with unity gain of 1, which means no amplification, and cutoff of about 3.4kHz. Even after the band-pass filter we still have some noise from the carrier wave (filters aren't perfect after all) and the signal is weak. We filter out noise above 8.6kHz and then amplify it 23.5 times. Yep, it's high but it needs it (you can change it by changing the resistor ratio. Click the low-pass filter link above for the equation). The second low-pass filter then further cleans up that signal by filtering noise above 3.4kHz, which is higher than our target range of 200Hz-2kHz, so we're good. The second filter is not absolutely necessary, but it did make a difference in the end.Image 4 shows the difference in the signal between the output of the envelope detector and the output of the last filter. The scale is not exactly the same as before, but the data was just outside of range so I shrunk it down a little bit. Did you notice the measurement window at the bottom right? That's the 1kHz modulation value we saw in the settings in image 3 above. It's not a perfect sine wave, but it's a far sight cleaner than it was before, and it's good enough that you won't notice the difference.If you don't want to add the class B amplifier, you're done here. Otherwise, get yourself some 9V batteries and turn the page.", "step_imgs": ["https://cdn.instructables.com/FQF/7136/HWNU6EBH/FQF7136HWNU6EBH.LARGE.jpg", "https://cdn.instructables.com/FO7/SAWC/HWNU7K2E/FO7SAWCHWNU7K2E.LARGE.jpg", "https://cdn.instructables.com/F8N/9W8K/HWNU7K3U/F8N9W8KHWNU7K3U.LARGE.jpg", "https://cdn.instructables.com/FN2/PPML/HWNU7K3S/FN2PPMLHWNU7K3S.LARGE.jpg", "https://cdn.instructables.com/FHV/IUIU/HWRC6QTY/FHVIUIUHWRC6QTY.LARGE.jpg"], "step_title": "Step 5: Filtering"}, {"step": 6, "steps_text": "The 9 V batteries and connectors are not included with the Analog Parts Kit, and it is not absolutely necessary to amplify the signal coming from the last low-pass filter. However, as you can see from comparing images 2 and 3, the signal will clip when you add the speaker and form more of a square wave than a sine wave. A small 8-Ohm speaker will clip even more. This happens because the speaker itself also has a transfer function that must be accounted for, which is a fancy way of saying that it is trying to draw too much current at peak voltage, so it clips the voltage. It will actually sound louder, but won't be as clear. Adding the amplifier allows more current to be available and that allows the voltage level at the speaker match the output level at the last filter. Image 4 shows the signal with the amplifier in place and the speaker attached. The difference is minimal this time. I've used this on a 4-inch computer speaker I salvaged and even a 6-inch woofer and they all worked with this amplifier. Just remember that larger speakers require more current so you will drain your batteries faster.When putting the BJTs on the breadboard it is very easy to get the pins mixed up. I've built this circuit, start to finish, at least half a dozen times, and I still did it. Again. I've included the pin-out diagram for them (they have the same B/C/E pin assignments), so good luck.", "step_imgs": ["https://cdn.instructables.com/FL2/U2NA/HWNU6EBK/FL2U2NAHWNU6EBK.LARGE.jpg", "https://cdn.instructables.com/FFA/T0XS/HWRC4554/FFAT0XSHWRC4554.LARGE.jpg", "https://cdn.instructables.com/FVA/H2L2/HWRC453K/FVAH2L2HWRC453K.LARGE.jpg", "https://cdn.instructables.com/FP5/ETJ4/HWRC453M/FP5ETJ4HWRC453M.LARGE.jpg", "https://cdn.instructables.com/FST/QC0S/HWRC6P83/FSTQC0SHWRC6P83.LARGE.jpg", "https://cdn.instructables.com/FR5/TSJW/HWRC4YHK/FR5TSJWHWRC4YHK.LARGE.jpg"], "step_title": "Step 6: Amplifying the Signal"}, {"step": 7, "steps_text": "Now let's do some testing to verify. If you haven't yet downloaded a short .wav file, do so now. Go into the AWG tool settings and check both channels to turn them both on. Click on the 'player' tab, then on 'add'. A window will come up to allow you to find the downloaded .wav file. Double click on it to load it. Notice the playback frequency in the window to the left? My file is set at 11.02kHz. For now, set the AWG channels to playback at this frequency. You won't break anything if you change it, it just changes the playback speed of the file. Load the file for both AWG channels. There are notes on the image that will help clarify this step.Set the channels according to image 1, making sure that the offset for CH 1 is 1.25V. It will make a big difference and took me a while to troubleshoot the first time. The amplitude (volume) settings are not super critical, but remember that we are amplifying the signal by quite a lot in the circuit, so start smaller and work your way up as desired.Start with CH 2 on the AWG and plug the yellow/white wire directly into the speaker, bypassing the entire circuit. This way you can hear the file playback on the speaker before passing it through the circuit. Once you have it playing on the speaker using CH 2, plug CH 1 into pin 4 of the AD654. Unplug AWG CH 2 from the speaker and connect the output of the class B amplifier to the speaker. You should hear the same playback either way.And there you have it. Please don't hesitate to ask questions, either in the comments below or PM. Have fun building!", "step_imgs": ["https://cdn.instructables.com/FWP/IHBC/HWRC52MZ/FWPIHBCHWRC52MZ.LARGE.jpg", "https://cdn.instructables.com/F3V/X8KR/HWRC6RM1/F3VX8KRHWRC6RM1.LARGE.jpg"], "step_title": "Step 7: Testing"}], "channel": "Electronics"}, {"category": "technology", "description": "This is the seventh module to the series of Arduino 101 tutorials I've been writing. In this project we will use a sound detector module from SparkFun and depending on the sound levels it is detecting, change the colour of an RGB LED, so you can tell how loud or quiet you have been. You can also use it to make the classic light clapper. ", "title": "RGB LED Sound Level Detector", "url": "https://www.instructables.com/id/RGB-LED-Sound-Level-Detector/", "section": "technology", "steps": [{"step": 1, "steps_text": "Arduino 101 or Arduino Uno Sound Detector from Sparkfun -  https://www.sparkfun.com/products/12642RGB LED 3 100\u03a9 Resistors Jumper Wires", "step_imgs": ["https://cdn.instructables.com/F0G/ALOU/J4SQF2WS/F0GALOUJ4SQF2WS.LARGE.jpg"], "step_title": "Step 1: Tools and Materials"}, {"step": 2, "steps_text": "Firstly, we will connect the power from the Arduino boardConnect the 3.3V pin of the Arduino board to the red power rail on the bread board with a red jumper wire Connect the GND pin of the Arduino board to the black power rail on the bread board with a black jumper wire.Secondly, we will wire the RGB LED. Place the RGB LED anywhere on the bread board with all it's legs in different pin holes. The longest leg is the ground so connect this to the black power rail on the breadboard. For the remaining three pins connect the 100\u03a9 resistors to each one of them. Connect the ends of these resistor starting from the one closest to the ground to pins 5, 6, and 9 on the Arduino board, respectively. Lastly, we will connect the wires to the sound detector module. Place the Sound detector module in a place away from the RGB LED on the breadboard. Connect the VCC of the sound detector module to the red power rail on the breadboard. Connect the GND of the sound detector module to the black ground rail on the breadboard. Connect the pin called \"envelope\" from the sound detector module to the A0 pin of the Arduino", "step_imgs": ["https://cdn.instructables.com/FB5/SG5H/J4SQF2VP/FB5SG5HJ4SQF2VP.LARGE.jpg", "https://cdn.instructables.com/F76/E7EO/J4SQF36F/F76E7EOJ4SQF36F.LARGE.jpg", "https://cdn.instructables.com/FQY/FWZ7/J4SQF2VU/FQYFWZ7J4SQF2VU.LARGE.jpg"], "step_title": "Step 2: Circuit"}, {"step": 3, "steps_text": "//pin variablesconst int redPin = 5; const int greenPin = 6; const int bluePin = 9; const int soundPin = 0;//variables for storing raw sound and scaled value int sound; int scale;void setup() {  //start the serial port a@ 9600bps  Serial.begin(9600);  //set RGB pins to OUTPUT  pinMode(redPin, OUTPUT);  pinMode(greenPin, OUTPUT);  pinMode(bluePin, OUTPUT); }void loop() {  //read and store the audio from Envelope pin  sound = analogRead(soundPin);  //map sound which in a quiet room a clap is 300  //from 0 to 3 to be used with switch case  scale = map(sound, 0, 300, 0, 3); //print values over the serial port for debugging  Serial.print(sound);  Serial.print(\"   \");  Serial.println(scale); //switch case on scaled value switch (scale) { //if 0 RGB = Blue case 0:    digitalWrite(redPin, LOW);   digitalWrite(greenPin, LOW);   digitalWrite(bluePin, HIGH);   break; //if 1 RGB = Green   case 1:   digitalWrite(redPin, LOW);   digitalWrite(greenPin, HIGH);   digitalWrite(bluePin, LOW);   break; //if 2 RGB = Yellow   case 2:   digitalWrite(redPin, HIGH);   digitalWrite(greenPin, HIGH);   digitalWrite(bluePin, LOW);   break; //if 3 RGB = Red case 3:   digitalWrite(redPin, HIGH);   digitalWrite(greenPin, LOW);   digitalWrite(bluePin, LOW);   break; //default off default:   digitalWrite(redPin, LOW);   digitalWrite(greenPin, LOW);   digitalWrite(bluePin, LOW);    break;  } }", "step_imgs": ["https://cdn.instructables.com/F2W/AI2B/J4YFRWNZ/F2WAI2BJ4YFRWNZ.LARGE.jpg"], "step_title": "Step 3: Coding"}, {"step": 4, "steps_text": "The colour of the LED changes depending on how loud the environment is, with red being the loudest and no light being very quiet. ", "step_imgs": [], "step_title": "Step 4: Demo"}], "channel": "Arduino"}, {"category": "technology", "description": "Real Augmented Reality is when the real world is augmented with overlays that are also \"burned\" or cut or inscribed into the real world.For example, I wanted to make an art piece in which otherwise invisible radio waves are overlaid upon reality in the physical world, so you don't need special eyeglasses or other apparatus to see the augmented reality content.I call this piece \"Burner Phone\" == a phone that burns its waves into the real world in which it inhabits.I make these kinds of art pieces from old discarded phones that would otherwise decorate landfill sites.", "title": "Real Augmented Reality\u2122: Burnerphone and Other Phenomenal Realities", "url": "https://www.instructables.com/id/Real-Augmented-Reality-Burnerphone-and-Other-Pheno/", "section": "technology", "steps": [{"step": 1, "steps_text": "Once you have an old phone you want to turn into Real Augmented Reality\u2122 art, you need to get it working for just long enough for it to spit out its last signal transmission -- its \"swan song\" so-to-speak.Now ideally we want to actually burn the waveform into something like a piece of wood directly, i.e. to \"SWIM\" out the wave, to a mechanism that will burn it right into the wood.One of the great things about a place like Pier 9 (world's greatest workshop for sure!) is the willingness there to entertain new ideas, but at the same time we really need a device we can \"hack\".  In my younger years I used to hack X-Y plotters and get them to inscribe waves into things, but here in the modern age it is much harder to \"hack\" things at a fundamental level.So instead, I offer an easy (though somewhat less elegant, philosophically) approach, namely that of capturing the wave, and then transferring it to the Epilog laser cutter to cut into the wood.The capture is by way of SWIM as outlined in previous Instructables (see also the Instructable on making furniture out of recorded waves).  The above diagram summarizes how it works, i.e. there's a reference antenna that sits stationary right next to the item under test (e.g. the phone) and it is connected to the reference input of a Lock-In Amplifier (LIA) or other phase coherent detector.  A moving antenna sweeps across, and the moving antenna is connected to the signal input of the LIA.  The output of the LIA (e.g. the in-phase output, \"X\") is connected to the SWIM.  Refer to my previous Instructables on SWIM for more info, and here's a nice magazine article giving some historical context (link).  T-SWIM is like SWIM except that it is also tactile, arising from the fact that T-SWIM is mechanical (the light source moves up-and-down with a servo motor, typically, rather than being sequenced by LEDs).  T-SWIM is the original SWIM and then later I used sequences of lights, but the tactile element of SWIM was missed so I then added a transducer to vibrate the SWIM and bring back what was lost in going to the electronic rather than mechanical version of SWIM == it is wonderful to be able to feel the wave as well as see it!The important thing here is to make sure you get the scale right, because the wave needs to be recorded as if it came from the phone (i.e. the same result as if a T-SWIM was used to inscribe it directly).Note that the wave should be captured from exactly the same place where the art will be hung, because when you record the wave, you're capturing also the reflections off walls, and other areas of the building.  You can see how the wave gets weaker as it gets further from the antenna, but then it gets stronger again even further on.  This is due to reflections off other objects in the room.  Thus once this is recorded at a particular location, and then burned into the wood, the art needs to ultimately hang where the wave was captured, so that it is true and accurate a depiction of the radio waves in that exact location.The wave is captured by turning off all the lights, sweeping the SWIM across in a dark room, and making a long-exposure photograph of this process with a light source attached to the T-SWIM (or a linear array of lights used for a regular SWIM).", "step_imgs": ["https://cdn.instructables.com/F25/AEBG/IXAQ0UEO/F25AEBGIXAQ0UEO.LARGE.jpg", "https://cdn.instructables.com/FEV/1JO6/IXAQ0V8B/FEV1JO6IXAQ0V8B.LARGE.jpg"], "step_title": "Step 1: Catch the Wave"}, {"step": 2, "steps_text": "Here we have a photograph of a blue LED that was attached to an X-Y plotter sweeping across left-to-right while carrying a signal antenna to scan the waveform from a cordless phone and capture it in a dark room.The first step is to negate it (take the negative of the photograph) and then scale it exactly 1:1.The transmitted signal of the cordless phone was 5.8 GHz so the wavelength is the speed of light divided by that:\u03bb = 300,000,000 m/s / 5.8*109 /s = 5.6cm.Using a ruler on the original recording device, confirm and double check the scale of the original recording.Make sure that the scale of the laser cutting file is such that there are exactly 5.6cm for each cycle of the waveform.Also make sure that the starting point is correct.  For a given gain, the signal strength increases without bound toward the antenna, so there is an artistic decision to be made as to the boundaries of the signal as recorded onto the wood or other material.", "step_imgs": ["https://cdn.instructables.com/F6M/110P/IXAQ0UDB/F6M110PIXAQ0UDB.LARGE.jpg", "https://cdn.instructables.com/FQW/EVUK/IXAQ0UDC/FQWEVUKIXAQ0UDC.LARGE.jpg"], "step_title": "Step 2: Process the Waveform and Make Sure the Scale Is Exactly 1:1"}, {"step": 3, "steps_text": "Now burn the wave into the wood.I experimented with various levels of strength on the beam and found the best settings.Also the wood should be placed so that the bottom of the art piece is toward you.In this way the smoke coming from the wood will stain the wood above the trace, as the smoke is drawn out the exhaust of the unit, which is correct for visual appeal (i.e. the smoke stains look good when they rise above the waveform pattern rather than below it which would look unnatural when the work is hung on the wall).", "step_imgs": ["https://cdn.instructables.com/FRQ/I0RY/IXAQ0U9M/FRQI0RYIXAQ0U9M.ANIMATED.LARGE.gif", "https://cdn.instructables.com/FRE/UA3U/IXAQ0UAN/FREUA3UIXAQ0UAN.LARGE.jpg"], "step_title": "Step 3: Burn It!"}, {"step": 4, "steps_text": "Now all you have to do is drill some holes to mount the phone, and then hang the finished work.I usually drill 2 holes and attach the phone with a piece of stiff wire.The phone should be mounted in the same place corresponding to where it was when the original recording was made.", "step_imgs": ["https://cdn.instructables.com/FY7/A1PY/IXAQ0UBE/FY7A1PYIXAQ0UBE.LARGE.jpg", "https://cdn.instructables.com/F6K/VYUW/IXAQ0UDA/F6KVYUWIXAQ0UDA.LARGE.jpg"], "step_title": "Step 4: Mount It."}], "channel": "Art"}, {"category": "technology", "description": "This instructable walks you through programming and using the Boston Android Xmega evaluation board to work as a simple arbitrary waveform generator taking advantage of the integrated 12bit DAC and high speed DMA controller. I have provided precompiled firmware as well as source code which can be loaded onto the device and configured via a USB port on your PC or laptop. You will need a computer (mac, pc, linux all supported) with an available USB\u00a0port, free driver for the USB-Serial adapter, a Boston Android Xmega EVAL-USB-64 development board ($31.99) and an open source AVR chip programming utility called AVRDUDE. Once set up, you can generate sine, ramp, triangle, square or any waveform you define from 5 to 20KHz with amplitude of up to 3.3Vp-p. It is possible to generate faster waveforms with the arbitrary waveform feature (up to 500KHz).", "title": "Atmel Xmega USB/Serial Arbitrary Waveform Generator", "url": "https://www.instructables.com/id/Atmel-Xmega-USBSerial-Arbitrary-Waveform-Generato/", "section": "technology", "steps": [{"step": 1, "steps_text": "1) Boston Android Xmega EVAL-USB-64 (or comparable) Development Board 2) PC with USB\u00a0port 3) AVRDUDE (free AVR programing software)Also recommended: Oscilloscope (to view waveforms) Headphone or small speaker (to listen to waveforms) WINAVR and AVRSTUDIO to modify the source code and built your own version of the waveform generator software Although this example walks through programming and using the EVAL-USB-64 board, you can use any of the EVAL-USB boards from Boston Android. And if you're very experienced you can download the example source code and build for other target hardware such as the Atmel XPLAIN evaluation board, or the Xmega boards available from chips45 and Mattair, Megavore. The xmega family allows effortless migration of code from one chip to another.", "step_imgs": ["https://cdn.instructables.com/FET/WVPV/G76MFGAH/FETWVPVG76MFGAH.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "Although not necessary, it is helpful to solder lead wires to your board to make it easy to connect an oscilloscope or frequency counter to observe the waveform output. The waveform output is on PORTB pin 2 and pin1 is configured as GND.", "step_imgs": ["https://cdn.instructables.com/FS2/RSWN/G79D44VK/FS2RSWNG79D44VK.LARGE.jpg"], "step_title": "Step 2: Solder Lead Wires (optional)"}, {"step": 3, "steps_text": "AVRDUDE is available as a standalone source distribution which you can compile with the GCC compiler on a number of operating systems (namely Linux). However,\u00a0if you use a PC running Windows there is a complete\u00a0binary distribution (no compiling needed) called WINAVR which includes AVRDUDE, along with the AVR-GCC compiler which will allow you to modify and compile your own\u00a0version of the waveform generator.Download WINAVR (includes AVRDUDE) Then install it. \u00a0", "step_imgs": ["https://cdn.instructables.com/F8I/TWM9/G7844GI3/F8ITWM9G7844GI3.LARGE.jpg"], "step_title": "Step 3: Installing AVRDUDE"}, {"step": 4, "steps_text": "The EVAL-USB-64 board includes a built in usb/serial bridge IC which creates a virtual serial port on your PC. Most Windows, Linux (and probably Macs) include the necessary drivers and you don't need to do anything. However, if your system complains it needs drivers go here and download the VCP drivers for your platform:Download VCP Drivers", "step_imgs": ["https://cdn.instructables.com/FCV/ME9V/G7844GID/FCVME9VG7844GID.LARGE.jpg"], "step_title": "Step 4: Install USB/Serial Drivers"}, {"step": 5, "steps_text": "  If you are using the EVAL-USB-64, you can download the waveform generator .hex file and move on to the next stepAlternative Path:  If you are using an alternative platform you will need to download and compile the source code. All the code is in a single .c file which is written to be compiled with AVR-GCC. If you are running on a Windows PC you can download the following two packages and compile and program the application on to your board.  1) Download WINAVR  2) Download AVR Studio IDE  3) Create new avr-gcc project in AVR Studio and paste the source code into the initial .c file  4) Compile (creates .hex file to load onto target device)", "step_imgs": ["https://cdn.instructables.com/FB2/E5IP/G7844GJ0/FB2E5IPG7844GJ0.LARGE.jpg"], "step_title": "Step 5: Download Waveform Generator Application"}, {"step": 6, "steps_text": "The EVAL-USB-64 board contains a serial bootloader which allows your board to be programmed with avrdude.  1) Plug your board into the usb port of your PC.  2) Open a command line window.  3) Locate the hex file you downloaded xmega-waveform-serial.hex 4) Within 10 seconds of plugging in your board, execute the following command to load the program image.avrdude -p  x64a3 -c avr911 -P COM5 -b 57600 -e -U flash:w:xmega-waveform-serial.hex  Your com port may be different. To be sure, in windows go to the Device Manager and check \"com ports\" to see what port your board is connected to. It is almost always the highest numbered com port on your system since the builtin com ports are assigned COM1-4 typically. On my laptop it comes up as COM5 but your computer will likely be on another numbered port. Alternative Paths: If you have an Atmel AVRISP mkii or JTAGICE mkii or compatible device you can use Atmel's AVRStudio to program the .hex file you downloaded in the previous step. See Atmel's documentation for using this utility.", "step_imgs": [], "step_title": "Step 6: Program Board"}, {"step": 7, "steps_text": "Connect your board to your PC with a standard USB/miniB cable. Open a serial terminal to the board. Under Windows XP you can use Hyperterm and open a connection to the COM port your device is on (you should know your COM port number from the previous step). Under Vista/7 you can use TeraTerm. The serial port configuration is 9600 Baud, 8N1, no flow control. After you connect you should be able to type 'h' which will print out the usage instructions for the waveform generation utility.", "step_imgs": ["https://cdn.instructables.com/FAU/U3XS/G76MOAYE/FAUU3XSG76MOAYE.LARGE.jpg"], "step_title": "Step 7: Connect to Waveform Generator Over Serial Port"}, {"step": 8, "steps_text": "In your serial terminal enter the following command:s 1000 You should be able to measure 1KHz waveform on your oscilloscope or frequency counter. Alternatively you can hook up a speaker or headphone and hear a low constant tone.", "step_imgs": ["https://cdn.instructables.com/FEM/04GD/G79D44X2/FEM04GDG79D44X2.LARGE.jpg", "https://cdn.instructables.com/FK6/9B47/G79DHTO2/FK69B47G79DHTO2.LARGE.jpg"], "step_title": "Step 8: Generate 1KHz Sine Wave"}, {"step": 9, "steps_text": "Okay, Sine wave is easy to generate without a fancy 12bit DAC. Let's generate some other waveforms including Ramp, Triangle and Square waves:r 1000 t 1000 S 1000", "step_imgs": ["https://cdn.instructables.com/FLZ/18DM/G79D44XC/FLZ18DMG79D44XC.LARGE.jpg", "https://cdn.instructables.com/F4G/ADX8/G79D44XO/F4GADX8G79D44XO.LARGE.jpg", "https://cdn.instructables.com/FQX/SXPQ/G79D44XF/FQXSXPQG79D44XF.LARGE.jpg"], "step_title": "Step 9: Generate 1KHz Ramp, Triangle and Square Waves"}, {"step": 10, "steps_text": "Although you can enter any number you want, for the standard waveforms (sine, square, etc) you should limit the frequency to 5Hz-20KHz. For example 20KHz sine waveform is shown below. To go beyond 20KHz you can use the arbitrary waveform function in the next step to create your own waveform with fewer datapoints (the dac is limited by how fast you copy data to it, the fewer datapoints in your waveform the faster you can go).", "step_imgs": ["https://cdn.instructables.com/F1S/D2H3/G79D44YT/F1SD2H3G79D44YT.LARGE.jpg"], "step_title": "Step 10: Frequency Limits"}, {"step": 11, "steps_text": "Okay, let's generate our own waveform. To do this you use the \"w\" command and you will need to specify the number of datapoints, the frequency the waveform is output and then the data itself: w [freq] [num data points] [data1] [data2] ... [dataN]    Here is an example arbitrary waveform which is a square wave with a trapezoidal shape repeated at 1KHz and 20 data points:w 1000 20 0 0 0 0 0 0 0 0 4095 4050 4000 3950 3900 3850 3800 3750 3700 3650 3600 3550 Note the range of data point values is 0 - 4095 (12 bit resolution) Once the arbitrary waveform is loaded you can change the frequency without re-entering all the data. To keep the same waveform as above change the frequency:w 10000", "step_imgs": ["https://cdn.instructables.com/FAY/BIRA/G79D44ZG/FAYBIRAG79D44ZG.LARGE.jpg", "https://cdn.instructables.com/FSB/QJES/G79D4509/FSBQJESG79D4509.LARGE.jpg", "https://cdn.instructables.com/FW0/UXVR/G79D450N/FW0UXVRG79D450N.LARGE.jpg"], "step_title": "Step 11: Arbitrary Waveforms"}, {"step": 12, "steps_text": "By default when you configure a waveform it is played back indefinitely. But you can also specify a small number of cycles. Here's how you would generate two cycles of a sine wave at 10KHz.n 2 s 10000 This works for arbitrary waveforms as well. To go back to infinite cycles enter the following:n 0", "step_imgs": ["https://cdn.instructables.com/FHF/QO36/G79D450Z/FHFQO36G79D450Z.LARGE.jpg"], "step_title": "Step 12: Number of Cycles"}, {"step": 13, "steps_text": "You can connect a small speaker (or headphones) to the circuit in order to hear what your waveform sounds like (or determine your hearing range). You will want to put a blocking capacitor in series to prevent any DC current from the DAC and to create a bipolar (positive and negative swinging) signal. 1) Solder a 47uF(or whatever you have handy over 1uF) electrolytic capacitor between PORTB header pin 3 and one of the leads to your speaker. 2)\u00a0Solder the other speaker lead to PORTB header pin 2 (the Gnd pin) Electrolytic caps are polarized; make sure you connect the positive end of the cap toward the board (PORTB pin 3) Now set some outputs and listen to them: s 1000 s 2000 r 1000 S 100 s 100 t 100 s 16000 I\u00a0can hear 16KHz sine wave, but above that it's silent..  USE EAR PLUGS\u00a0WHEN\u00a0YOU\u00a0OPERATE\u00a0HEAVY\u00a0EQUIPMENT AND\u00a0POWER\u00a0TOOLS\u00a0KIDS! :-)", "step_imgs": ["https://cdn.instructables.com/FVV/YOJ4/G79DOUAO/FVVYOJ4G79DOUAO.LARGE.jpg"], "step_title": "Step 13: Connecting a Speaker"}], "channel": "Electronics"}, {"category": "technology", "description": "Hi everyone!This post is made by Sergio Garc\u00eda Calvente, Tatiana Castillo P\u00e9rez y M\u00edguel Mac\u00edas Mac\u00edas to show you our project, this project was for 'Creative Electronics' a Beng Electronics Engineering 4th year module at the University of M\u00e1laga, School of Telecommunications(www.etsit.uma.es)When teachers told us to make a project with Arduino the first idea we had was to make something using music and lighst but in special we wanted to do something portable.To explain how we make this, we'll split the project in 4 steps:Step 1: Make the box.Step 2: Solder the circuit.Step 3: Put the lights.Step 4: Make the code.To make the project we use:1 Arduino Leonardo.1 Strip board.1 Microphone.1 Terminal block.24 White leds.Some RGB LED stipt light. Wires.   2Hinges.   Some wood.If you need to amplify the output signal from the microphone:1 2N2222A transistor.2 110nF Capacitors.2 10k Resistors.1 100k Potentiometer.If you need to use a voltage regulator:1 7805 Voltage regulator.1 330nF Capacitor.1 110nF Capacitor.", "title": "Light Box (using Frequency)", "url": "https://www.instructables.com/id/Light-Box-using-Frequency/", "section": "technology", "steps": [{"step": 1, "steps_text": "First of all is to make the wood box, you can buy or recycle one if you want.The process to make the box is:Mark the dimensions in the wood.Cut the pieces and sand down them.Make the holes with a drill.Paint the pieces.Join the pieces with wood glue or silicone.Use a hinge to join the top one.", "step_imgs": ["https://cdn.instructables.com/F2D/KAG1/IYOQ7H68/F2DKAG1IYOQ7H68.LARGE.jpg", "https://cdn.instructables.com/F74/DGDW/IYOQ7H8P/F74DGDWIYOQ7H8P.LARGE.jpg"], "step_title": "Step 1: Make the Box."}, {"step": 2, "steps_text": "As we need to amplify the output signal from the microphone, we include an amplifier.The 100k potentiometer is used to regulate the gain of the amlifier.Some LED stript light needs 12V to work correctly so we use a 7805 voltage regulator. Now we can use 12V in the LED strip and 5V in the rest of components. In the images we show you the schematic of the circuit that we solder.", "step_imgs": ["https://cdn.instructables.com/F66/XCU7/IYOQ7H8K/F66XCU7IYOQ7H8K.LARGE.jpg", "https://cdn.instructables.com/F5B/5P93/IYOQ7H8U/F5B5P93IYOQ7H8U.LARGE.jpg", "https://cdn.instructables.com/FGS/Q9E2/IYOQ7J2B/FGSQ9E2IYOQ7J2B.LARGE.jpg", "https://cdn.instructables.com/F10/GOCP/IYOQ7H9E/F10GOCPIYOQ7H9E.LARGE.jpg"], "step_title": "Step 2: Solder the Circuit."}, {"step": 3, "steps_text": "We solder 2 squares with 12 LED to put in the holes that we drilled in the box. Between the squares we add 6 LED strip with 6 LED each one.In the schematic we show how to connect LEDs with Arduino and DC regulator.", "step_imgs": ["https://cdn.instructables.com/FWF/Z2TO/IYOQ7H74/FWFZ2TOIYOQ7H74.LARGE.jpg", "https://cdn.instructables.com/F3A/6Q40/IYOQ7IMS/F3A6Q40IYOQ7IMS.LARGE.jpg", "https://cdn.instructables.com/F86/X347/IYOQ7IMU/F86X347IYOQ7IMU.LARGE.jpg", "https://cdn.instructables.com/FWH/NY0E/IZ6CK3TI/FWHNY0EIZ6CK3TI.LARGE.jpg"], "step_title": "Step 3: Put the Lights."}, {"step": 4, "steps_text": "As we said in the introduction we want to use one different colour for each frequency band. We use the FFT Arduino library to calculate the Fourier Transform of the signal that we read from the microphone. In the code we set the point to calculate the Fourier Transform at 64 so we take an output of 32 bits with the amplitude for each frequency band.We can't use the first and second band because their are so noisy. We use the 3...6 band to turn on the white colour, 7...14 band to turn on the red one, 16...23 to turn on the green one and the last 8 bands to turn on the blue one.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 4: Make the Code."}, {"step": 5, "steps_text": "We finished the process! Now you can enjoy the music with your new light box. It will bright according to the music you are listening at each moment.FFT library web: http://wiki.openmusiclabs.com/wiki/ArduinoFFTArduino web:https://www.arduino.cc/", "step_imgs": [], "step_title": "Step 5: Enjoy!"}], "channel": "Arduino"}, {"category": "technology", "description": "I created an Infinity Mirror for a school project with Arduino which you can control with your phone or tablet by using Bluetooth. The mirror also has a built-in microphone which detects sound/music and reacts accordingly by generating eye-catching light strobes on the beat of the music! Simply start up the app, connect to bluetooth and see the magic happen!In this Instructables I will show you how you can make this Infinity Mirror. So let's get started!", "title": "Arduino Infinity Mirror (Bluetooth & Sound Reactive)", "url": "https://www.instructables.com/id/Arduino-Infinity-Mirror-Bluetooth-Sound-Reactive/", "section": "technology", "steps": [{"step": 1, "steps_text": "To make this infinity mirror, you will need the following materials:1) Arduino Uno ($30)You can also use a different type of Arduino, but that's entirely up to you.2) Mini breadboard or PCB ($5)I used the breadboard for prototyping and later soldered everything to a perfboard/stripboard.3) WS2813 Digital 5050 RGB LED Strip - 144 LEDs (1 meter) ($25)You can also use a different LED strip, but make sure that all LEDs are individually adressable. Also make sure that the LED strip gives an \"extra\" 5V voltage for every meter of LEDs. This is because the voltage drops over the strip and the current at the start can increase considerably. (and maybe burn the start of your LED strip!) You can read more about this here: Powering Neopixels.4) Prototype wires ($3)Colors do not matter in general, but it's very useful to have them as reference for yourself. I used white, black, red, green, yellow, orange and blue.5) USB A to B cable ($4)This will be used to upload your Arduino code to the Arduino Uno board.6) Mean Well Switching Power Supply - 5V 10A ($15)This will be used used to support the LED strip with external 5V voltage, because the Arduino itself isn't powerful enough to light up all LEDs. You can also choose to use a Wall Adapter Power Supply, but make sure that it runs on 5V.7) 230V Power cable with plug ($3)This will be used for connecting the Switching Power Supply to the 230V Power Socket. Depending on where you live, the amount of voltage from the power socket can vary. In any case, you will need a proper cable with plug.8) Bluetooth HC-06 module RF transceiver Slave 4-PIN ($8)This module will be used for sending data from your phone or tablet to the Arduino. This bluetooth module can only serve as a slave. The standard bluetooth pin / password is 1234.9) Sound Detection Sensor Module 3-PIN ($3)This module will be used for detecting sound since it has a built-in microphone. Set the potentiometer for the desired amount of sound at which a signal is generated. You can also use a different sound sensor, but that's up to you.10) 220 \u03a9 Resistor ($0.25)This will be used for controlling the voltages of the LEDs. If you don't use this, then the LEDs will eventually get really hot. A 220\u03a9 resistor has red, red, and brown stripes in that order.  The last stripe represents the tolerance. Gold means \u00b15%. More info here: 220 Ohm Resistor.11) 1000uF 16V Electrolytic Capacitor ($0.25)This will be used to add and store capacitance (energy) to your circuit. More info here: Electrolytic Capacitors.Box and mirror: These are the materials and dimensions that I used to create my box. You can also choose to buy a frame or pre-made box instead which is big enough to fit a one-way reflective mirror, normal mirror, LEDs and electronics in it. I only recommend to build it yourself if you have the correct tools and materials.12) Glass 25 x 25cm (3mm thick) ($5)The glass will be used as a one-way reflective mirror, which you will need the one-way mirror window film for (see 13). You can also choose to buy a one-way mirror/semi-transparent mirror instead which is big enough to fit inside your box. You can cut glass yourself with a glass cutter (see 22), but I rather recommend to consult specialists to do this for you or even better just buy glass with the right dimensions.13) Tinted one-way mirror window film 30 x 30 cm ($5)In order to replicate a one-way mirror, you will need glass and a roll of tinted one-way mirror window film, which will be applied onto the glas with water and soap (see 29). The reason why it's slightly bigger than the glass is because it will shrink over time. If you choose to buy a one-way mirror instead as mentioned above, then you won't be needing this.14) Mirror 25 x 25cm (3mm thick) ($5)Just a normal mirror, like the one you have in the bathroom. This will be used, along with the one-way mirror, to create the \"infinity\" effect.15) 2x Thick Wooden lath 25 x 10 x 2cm ($2)Two wooden lath for the top and bottom of the box.16) 2x Thick Wooden lath 27 x 10 x 2cm ($2)Two wooden lath for the right and left side of the box.17) 2x Thin Wooden lath 25 x 2.5 x 0.5cm ($1)Two wooden lath for the top and bottom of the inside of the box (which the mirrors will rest on and which the LEDs are pasted on).18) 2x Thin Wooden lath 24 x 2.5 x 0.5cm ($1)Two wooden lath for the right and left side of the inside of the box (which the mirrors will rest on and which the LEDs are pasted on).19) Black paint can/sprayI used this to paint my box black to make it blend in more with the dark theme.Tools:These are the tools that you will need to create the box as well as the mirror:20) Measuring tape ($3)Used for measuring your box of course. More info here: How to Read a Measuring Tape.21) Measuring square ($5)Also used for measuring your box/materials. Not really required, but it could come in very handy.22) Wire cutter/stripper ($5)Used for stripping and cutting your wires. As alternative you can also use a kitchen knife or stanley knife. More info here: How to Strip Wire.23) Glass cutter ($5)Used for cutting glass and mirrors. As alternative you can use a diamond, but I do not recommend it. More info here: How to Cut Stained Glass.24) Screwdriver/drill ($2)Used for driving screws and drilling holes. More info here: How to Drive a Woodscrew.25) Hammer ($5) Used for driving nails. More info here: How to Use a Hammer Safely.26) Wood glue ($5)If screws or nails aren't good enough, you can also apply some wood glue to keep parts together. More info here: How to Glue Wood Together.27) Saw ($5)Used for sawing wood. More info here: How to Saw Wood With a Handsaw.28) Nails ($3)Used to keep parts together, in our case permanently.29) Screws ($3) Also used to keep parts together, but by using screws instead of nails you can easily disconnect the parts if needed.30) Water and soapUsed for applying the tinted one-way mirror window film onto the glass. And also used for cleaning the infinity mirror. If you want to know how to install the window film, you can follow this tutorial: How To Install Window Film.31) Sandpaper ($1)Used for refining the sharp edges of the glass and wood.Soldering tools (optional):32) Soldering Iron ($15)Optional if you choose to solder everything together instead of leaving it on the breadboard. If you want to know how to solder, you can follow this tutorial: How to Solder Electronics.33) Solder tin 0.6mm - 100g ($5.50)Used for soldering the wires together.34) Desoldering wire - 1mm 1.5m ($1.50)Used for desoldering the wires, in case you made a mistake by accident.35) Heat shrinking tubes ($2)Used for safely keeping soldered wires together.36) 1x 3 Pins header female ($0.10)Not really required, but it could be handy if you don't want to directly solder the sound detection sensor to the wires.37) 1x 4 Pins header female ($0.10)Not really required, but it could be handy if you don't want to directly solder the bluetooth module to the wires.", "step_imgs": ["https://cdn.instructables.com/FOX/FG1Z/JCGK9C8G/FOXFG1ZJCGK9C8G.LARGE.jpg"], "step_title": "Step 1: Gather Materials"}, {"step": 2, "steps_text": "Once you have assembled the materials, it's time to make your first prototype by using a breadboard. The breadboard has four columns in total. The first two and last two blue and red columns share a connection vertically, representing the +5V (red) and ground/GND (blue) connections. The two columns in the middle are where your main components will be placed. You can learn more about breadboards here.So what you want to do is connect your Arduino to the breadboard by using some prototype wires. As I mentioned before, colors do not matter but they are a useful reference for yourself. For example, I used the red wires to represent the +5V and the white wires to represent the GND. It also does not matter where you place your pins as long as they stay in the same circuit.Next you want to connect your LED strip to the breadboard. You will notice that it has 3-6 wires depending on which type you have. White represents GND/min input, red represents +5V input, green represents the data input PIN and blue represents the back-up data input PIN (don't connect unless the LED is linked). Plug in the external 5V power and connect it to the LED strip. Don't forget to also connect the resistor and capacitor as shown in the picture above, or else you might burn out your LEDs!Lastly you want to connect your bluetooth module and sound detection sensor to the breadboard. Assign the sound detection sensor to pin A0 (analog). As for the bluetooth module, you will notice that it has one RXD and one TXD pin. These are for sending and receiving signals. NOTE: connect the TXD pin of the module to the RXD pin of the Arduino, and the RXD pin of the module to the TXD pin of the Arduino. Not to the same pins!", "step_imgs": ["https://cdn.instructables.com/FGA/A133/JCAUM2RI/FGAA133JCAUM2RI.LARGE.jpg", "https://cdn.instructables.com/FNT/VI1A/JCGK9D62/FNTVI1AJCGK9D62.LARGE.jpg", "https://cdn.instructables.com/F3L/26AA/JCGK9D65/F3L26AAJCGK9D65.LARGE.jpg", "https://cdn.instructables.com/F2O/SHD6/JCGK9D68/F2OSHD6JCGK9D68.LARGE.jpg", "https://cdn.instructables.com/FYA/NYYA/JCGK9D70/FYANYYAJCGK9D70.LARGE.jpg", "https://cdn.instructables.com/F83/84EF/JCGK9D7R/F8384EFJCGK9D7R.LARGE.jpg"], "step_title": "Step 2: Breadboard Connections"}, {"step": 3, "steps_text": "So the next step is to code the Arduino. You will need the Arduino IDE software to do this, which you can download here. Once you have downloaded the IDE open up a new document and copy and paste the following code into the project window:#include <Adafruit_NeoPixel.h>//Pins that are connected to the Arduino\nconst int PIN = 6; //The input pin of the LED strip\nint NUMPIXELS = 144; //The number of pixels that will light up\nconst int SOUNDSENSOR = A0; //The input pin of the Sound Sensorint ButtonState = 0; //State that is assigned to a button on the bluetooth app\nint volume = 0; //State that checks if there is a signal in the microphone or not//Color variables\nboolean PrimBlue = false;\nboolean PrimGreen = false;\nboolean PrimRed = false;\nboolean PrimWhite = false;\nboolean PrimYellow = false;\nboolean PrimOrange = false;\nboolean PrimPink = false;\nboolean PrimPurple = false;//Light and sound variables\nboolean SoundDetect = false;\nboolean FullLight = false;Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);void setup() {\n  pinMode(SOUNDSENSOR, INPUT); //Input of the Sound Sensor\n  pinMode(PIN, OUTPUT); //Input of the LED strip  Serial.begin(9600);\n  strip.setPixelColor(0, 0, 0, 0);\n  strip.setBrightness(0);\n  strip.begin(); //This initializes the NeoPixel library\n  strip.show();}void loop() {\n  //Define the brightness amount according to the slider\n  byte brightness = analogRead(A0)/4;\n  Serial.println(brightness);\n  \n  if (Serial.available() > 0) {\n    ButtonState = Serial.read();\n  }  //Enable or disable LED and Sound Detection\n  if (FullLight == 1 && SoundDetect == 0) {\n    strip.setBrightness(ButtonState);\n    strip.show();\n  }\n  else if (FullLight == 0 && SoundDetect == 0) {\n    strip.setBrightness(0);\n    strip.show();\n  }\n  else if (FullLight == 0 && SoundDetect == 1) {\n    strip.setBrightness(brightness);\n    strip.show();\n  }\n  else if (FullLight == 1 && SoundDetect == 1) {\n    strip.setBrightness(0);\n    strip.show();\n  }  //////////////////////////LED switch//////////////////////////\n  if (ButtonState == 'a') {\n    primaryColors();\n    FullLight = 1;\n    SoundDetect = 0;\n  }  if (ButtonState == 'b') {\n    FullLight = 0;\n    SoundDetect = 0;\n  }  //////////////////////////Sound detection switch//////////////////////////\n  if (ButtonState == 'c') {\n    primaryColors();\n      SoundDetect = 1;\n      FullLight = 0;\n  }  if (ButtonState == 'd') {\n    SoundDetect = 0;\n    FullLight = 0;\n  }  //////////////////////////Primary Colors//////////////////////////\n  if (ButtonState == '1') {\n    primaryColors();\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimRed = 1;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }  if (ButtonState == '2') {\n    primaryColors();\n    PrimGreen = 1;\n    PrimBlue = 0;\n    PrimRed = 0;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }  if (ButtonState == '3') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 1;\n    PrimGreen = 0;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }\n  if (ButtonState == '4') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimWhite = 1;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }\n  if (ButtonState == '5') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimWhite = 0;\n    PrimYellow = 1;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }\n  if (ButtonState == '6') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 1;\n    PrimPink = 0;\n    PrimPurple = 0;\n  }\n  if (ButtonState == '7') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 1;\n    PrimPurple = 0;\n  }\n  if (ButtonState == '8') {\n    primaryColors();\n    PrimRed = 0;\n    PrimBlue = 0;\n    PrimGreen = 0;\n    PrimWhite = 0;\n    PrimYellow = 0;\n    PrimOrange = 0;\n    PrimPink = 0;\n    PrimPurple = 1;\n  }\n}void primaryColors() {\n  for (int i = 0; i < NUMPIXELS; i++) {\n    if (PrimBlue == 1) {\n      strip.setPixelColor(i, 0, 0, 255);\n    }\n    else if (PrimGreen == 1) {\n      strip.setPixelColor(i, 0, 255, 0);\n    }\n    else if (PrimRed == 1) {\n      strip.setPixelColor(i, 255, 0, 0);\n    }\n    else if (PrimWhite == 1) {\n      strip.setPixelColor(i, 255, 255, 255);\n    }\n    else if (PrimYellow == 1) {\n      strip.setPixelColor(i, 255, 255, 0);\n    }\n    else if (PrimOrange == 1) {\n      strip.setPixelColor(i, 255, 102, 0);\n    }\n    else if (PrimPink == 1) {\n      strip.setPixelColor(i, 255, 0, 255);\n    }\n    else if (PrimPurple == 1) {\n      strip.setPixelColor(i, 102, 0, 204);\n    }\n    else {\n      strip.setPixelColor(i, 255, 255, 255);\n    }\n  }\n  strip.show();\n}If it asks you to install the Adafruit NeoPixel library do this by going to Sketch > Import Library > Adafruit NeoPixel.", "step_imgs": ["https://cdn.instructables.com/FET/C5UJ/JCGK9DO2/FETC5UJJCGK9DO2.LARGE.jpg"], "step_title": "Step 3: Code the Arduino"}, {"step": 4, "steps_text": "Now let's get into the interesting part, building your app! I decided to use a third-party software called MIT App Inventor 2 to do this. If you want to download the project files (.aia) and make changes to the app, you can download it below. But you can also download the app itself (.apk) right away without having to code anything. You only have to install it on your device.", "step_imgs": ["https://cdn.instructables.com/FT8/87ID/JCGK9EC7/FT887IDJCGK9EC7.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Build the Bluetooth App"}, {"step": 5, "steps_text": "In this step, we will build the box/frame for the infinity mirror.The Outer FrameFirst, cut the thick lath for the outer frame (see above pictures). You will need two pieces of length 27 cm (for top and bottom) and two pieces of length 25 cm (for left side and right side). Now nail them together by driving nails to the corners of the box (4 for each side), but make sure that the edges will fit perfectly. You can also choose to glue them together, but that's up to you.The Inner FrameNext, cut the thin lath for the inner frame (see above pictures again). You will need two pieces of length 25 cm (for top and bottom) and two pieces of length 24 cm (for the left and right side). Now you want to nail these to about 0.5 cm below the top of the outer frame by using 2 nails for each side. I also applied some wood glue here to make them sturdier. NOTE: make sure that the one-way mirror fits inside the frame perfectly!Drilling The Microphone HoleSince the microphone is a sensitive object, it must be free of coverage. That's why I drilled a hole into the top of the frame from which the microphone head will stick out. Don't make the hole too big, because you don't want your microphone to completely fall out of the frame.Painting Your FrameI decided to paint my frame almost matte black to give it some kind of dark, mysterious effect. If you also decide to paint it, make sure that there are no thick blobs of paint remains on the frame. To prevent this, you have to gently paint the frame with a small to medium brush. Additionally you can paint it for a second time if it's not covered enough. Let it dry for a day or so.", "step_imgs": ["https://cdn.instructables.com/FAZ/6DKN/JCGK9EE2/FAZ6DKNJCGK9EE2.LARGE.jpg", "https://cdn.instructables.com/F0M/9BD5/JCGK9EE4/F0M9BD5JCGK9EE4.LARGE.jpg", "https://cdn.instructables.com/FDV/I6WR/JCGK9EE5/FDVI6WRJCGK9EE5.LARGE.jpg", "https://cdn.instructables.com/FGP/WOSQ/JCGK9EE9/FGPWOSQJCGK9EE9.LARGE.jpg", "https://cdn.instructables.com/F5Y/0IJJ/JCGK9EEE/F5Y0IJJJCGK9EEE.LARGE.jpg", "https://cdn.instructables.com/F1U/IP9I/JCGK9EEF/F1UIP9IJCGK9EEF.LARGE.jpg", "https://cdn.instructables.com/FN9/UXR6/JCGK9EEM/FN9UXR6JCGK9EEM.LARGE.jpg", "https://cdn.instructables.com/F5N/MSZT/JCGK9EEI/F5NMSZTJCGK9EEI.LARGE.jpg", "https://cdn.instructables.com/F6A/SNLK/JCGK9EEP/F6ASNLKJCGK9EEP.LARGE.jpg", "https://cdn.instructables.com/FMD/YAAQ/JCGK9EE1/FMDYAAQJCGK9EE1.LARGE.jpg"], "step_title": "Step 5: Build the Box"}, {"step": 6, "steps_text": "In this step we will solder the electronics to a PCB which we will later on install on the back of our mirror. Soldering is not mandatory, but I highly recommend doing it to keep the electronics safe in place. I soldered everything step by step per \"component\" to the grid to prevent any mistakes. So I first soldered the sound module to the board, then the bluetooth module, and lastly the LED strips. I recommend to leave some blank space between the components which are not allowed to directly touch each other, such as the +5V input wires and the GND input wires (see above pictures).Once you have your components soldered to the board, start making bridge connections by applying some tin between the components underneath the board. Alternatively you can strip some wires and solder these to the components to make a bridge connection.Now you want to test the circuit by simply connecting the wires to the Arduino. Make sure that you have also plugged in the power supply! If the LEDs turn on successfully, then well done! If they don't turn on however, then you might want to double check the circuit and look for faulty connections.", "step_imgs": ["https://cdn.instructables.com/FCW/85CH/JCKUBY5L/FCW85CHJCKUBY5L.LARGE.jpg", "https://cdn.instructables.com/F33/SGT8/JCKUBY5M/F33SGT8JCKUBY5M.LARGE.jpg", "https://cdn.instructables.com/FGL/44C1/JCKUBY7M/FGL44C1JCKUBY7M.LARGE.jpg", "https://cdn.instructables.com/FRC/6M9H/JCKUBYC8/FRC6M9HJCKUBYC8.LARGE.jpg", "https://cdn.instructables.com/FLO/RP1N/JCKUBYEC/FLORP1NJCKUBYEC.LARGE.jpg", "https://cdn.instructables.com/FV2/R1DU/JCKUBYG4/FV2R1DUJCKUBYG4.LARGE.jpg", "https://cdn.instructables.com/F5I/YFMC/JCKUBYG7/F5IYFMCJCKUBYG7.LARGE.jpg", "https://cdn.instructables.com/FS2/GM2X/JCKUBYHX/FS2GM2XJCKUBYHX.LARGE.jpg", "https://cdn.instructables.com/FAI/J2RZ/JCKUBYJN/FAIJ2RZJCKUBYJN.LARGE.jpg", "https://cdn.instructables.com/F5L/QCMF/JCKUBYN4/F5LQCMFJCKUBYN4.LARGE.jpg", "https://cdn.instructables.com/F5I/ZOTK/JCKUBYQJ/F5IZOTKJCKUBYQJ.LARGE.jpg", "https://cdn.instructables.com/FI6/D5VM/JCKUBYSC/FI6D5VMJCKUBYSC.LARGE.jpg"], "step_title": "Step 6: Solder the Electronics to a PCB"}, {"step": 7, "steps_text": "The next step is to install the electronics on a piece of wood, which we will also use for the back of the mirror. I attached the electronics to the board with some screws and glued two blocks on the right and left side of the back which are used to screw the back of the box to the box itself.", "step_imgs": ["https://cdn.instructables.com/F5N/2Y8E/JCKUBY0B/F5N2Y8EJCKUBY0B.LARGE.jpg"], "step_title": "Step 7: Install the Electronics on the Back"}, {"step": 8, "steps_text": "Now it's time to assemble the mirrors, stick the LEDs to the frame and put the sound detection sensor in place.One-Way MirrorThe one-way mirror will be placed on the frame itself, with the tinted side faced downwards to the mirror and LEDs. To make this mirror yourself, you will need the glass plate and the tinted window film. First cut the window film in the right size, but leave about 2-5 cm extra space on every side. Next you want to completely clean the window and remove all dust remains. Then cover the window with some water and soap and carefully remove the plastic from the window film (you can place tape on each side to easily remove it). Now you also want to cover the sticky side of the window film with water and soap to prevent it from sticking to itself. All that you have to do now is place it on top of the glass and tightly sweep it in place (see above pictures). Let it dry for about a day and remove the remaining window film.Stick the LEDs to the BoxThe next step is to stick the LEDs to the box which can be done by removing the sticky paper. I also recommend to apply some fast glue to the back of the strip to prevent it from detaching.Place the Mirrors and Finish it Up!The final step is to put both the one-way mirror and the normal mirror in place. The normal mirror goes behind the LED strip and the one-way mirror goes in front. Glue them in place with some fast glue and screw the back plate with the electronics to the back of the box. Put the sound detection sensor in place, connect all the wires, and voila, you are done!", "step_imgs": ["https://cdn.instructables.com/F57/KIWW/JCKUDNXI/F57KIWWJCKUDNXI.LARGE.jpg", "https://cdn.instructables.com/F8F/A76I/JCKUDNYJ/F8FA76IJCKUDNYJ.LARGE.jpg", "https://cdn.instructables.com/FJ6/DIMZ/JCKUDNZZ/FJ6DIMZJCKUDNZZ.LARGE.jpg", "https://cdn.instructables.com/F80/XCV1/JCKUDO0F/F80XCV1JCKUDO0F.LARGE.jpg", "https://cdn.instructables.com/FZZ/1I7V/JCKUDO1P/FZZ1I7VJCKUDO1P.LARGE.jpg", "https://cdn.instructables.com/FBB/TVMH/JCKUDO2Z/FBBTVMHJCKUDO2Z.LARGE.jpg", "https://cdn.instructables.com/FN4/QXGE/JCKUDO3D/FN4QXGEJCKUDO3D.LARGE.jpg", "https://cdn.instructables.com/FLR/8III/JCKUDO4R/FLR8IIIJCKUDO4R.LARGE.jpg", "https://cdn.instructables.com/F8D/56OK/JCKUDO64/F8D56OKJCKUDO64.LARGE.jpg", "https://cdn.instructables.com/FUJ/XNGO/JCKUDO6M/FUJXNGOJCKUDO6M.LARGE.jpg", "https://cdn.instructables.com/FR5/QDBU/JCKUDO6Z/FR5QDBUJCKUDO6Z.LARGE.jpg", "https://cdn.instructables.com/F6Y/ZL3J/JCKUDO7H/F6YZL3JJCKUDO7H.LARGE.jpg"], "step_title": "Step 8: Assemble the Mirrors With the Box"}, {"step": 9, "steps_text": "All you have to do now is test if everything works. And that's it! Now you have built your own Bluetooth Controllable and Sound Reactive Infinity Mirror! :DDon't hesitate to ask in the comments section if you have any questions.Thank you and have fun!", "step_imgs": [], "step_title": "Step 9: Test Your Infinity Mirror!"}], "channel": "Arduino"}, {"category": "technology", "description": "We've all seen LED fans that you can put in your computer to make it look cool.\u00a0 They usually come in blue, sometimes red or green and consist of a basic PC fan with 4 bright LED's mounted in the 4 corners.\u00a0 They source their voltage from the fan's power input, so if you're using a fan controller (either the one built into your motherboard or otherwise)\u00a0to slow the fan, the LED's get dim.\nWell, I\u00a0got a new case for my server and it took 120mm fans, so I\u00a0had to buy new fans for it.\u00a0 I\u00a0got a nice blue LED\u00a0fan for the front but one of the LED's was burned out and it didn't look good, plus the fan was loud and I\u00a0was out of controllable channels on my motherboard.\u00a0 I\u00a0got a free replacement for the bad LED, but I\u00a0already had my mind set on converting the fan with the bad LED\u00a0into something much better using what I'd learned about microcontrollers last Fall.\u00a0 The plan?\u00a0\u00a0A self-contained, digital, full control fan controller based around an AVR\u00a0microcontroller that could have fine control over the fan's speed, read back the RPM, and control not just the brightness of the LEDs but also the color.\u00a0 Having seen a lot of cool projects using RGB\u00a0(red-green-blue)\u00a0LED's online, I figured it would be a good project.", "title": "Color Changing Digital PC Fan Controller", "url": "https://www.instructables.com/id/Color-Changing-Digital-PC-Fan-Controller/", "section": "technology", "steps": [{"step": 1, "steps_text": "If you don't have an LED\u00a0fan already, you can't just convert a plain fan.\u00a0 The fan I\u00a0am using cost $5 on NewEgg and they sent me a free replacement for one bad LED\u00a0(yet they let me keep the \"bad\"\u00a0one so I\u00a0used it for this project).\nThings you want:\nClear plastic.\u00a0 Tinted plastic may give unwanted effects (but if you want to try, go ahead, it may produce a neat effect, I\u00a0tried one RGB\u00a0LED\u00a0on a blue-tinted fan and it looked OK).\u00a0 Black plastic won't give you the same effect, though I've seen LED\u00a0fans that have black plastic and they do give the LED\u00a0lines when spinning.\n3rd wire (RPM\u00a0sensor wire).\u00a0 This wire (usually yellow or white)\u00a0is what fan controllers use to count RPM.\u00a0 It pulls low (connects to ground)\u00a0twice per revolution of the fan, so you count falling edges per minute and divide by 2 (or count falling edges per second, divide by 2, and then multiply by 60).\n3-pin connector.\u00a0 The 3-pin connector is a PC fan standard, it's the connector that motherboards use and it's the connector I\u00a0designed my controller to use.\u00a0 Some newer fans that use 4 pin connectors won't work for this project.\u00a0 It may have a 4-pin Molex (power supply)\u00a0connector, I\u00a0just cut it off and used that connector to connect the fan controller to my computer's power supply.", "step_imgs": ["https://cdn.instructables.com/FKI/WO1G/G5X4MAWO/FKIWO1GG5X4MAWO.LARGE.jpg"], "step_title": "Step 1: Find a Suitable Fan for Modification."}, {"step": 2, "steps_text": "This is going to be fun...\nIC's:\n1 - ATMega168 (DIP28 through-hole package)\n1 - MAX232\u00a0 or equivalent (DIP16 through-hole package)\nIC\u00a0sockets:\n1 - DIP28 socket\n1 - DIP16 socket\nTransistors:\n1 - PNP, I\u00a0used D1616 (NPN) and B1116 (PNP) transistors, they're capable of 1A current\n1 - NPN\u00a0 If you use any other transistors, they MUST\u00a0BE\u00a0ECB (where base is on the end, not the middle).\u00a0 This is different from most other transistors I've seen and didn't notice until I\u00a0tested them after I\u00a0ordered them.\u00a0 They were cheap though so w/e.\nHere is where I\u00a0ordered them:\nhttp://www.mouser.com/ProductDetail/Fairchild-Semiconductor/KSD1616YBU/?qs=sGAEpiMZZMuCl5o%252b%2fAuPoF6bPDHyecV%252bopNRXL9NXYU%3d\nhttp://www.mouser.com/ProductDetail/Fairchild-Semiconductor/KSB1116AGBU/?qs=sGAEpiMZZMuCl5o%252b%2fAuPoF6bPDHyecV%252bD5J9z1SsUW0%3d\nCapacitors:\n5 - 1.0 uF capacitors, I just used some little blue ones, they're either ceramic or similar, not electrolytic.\nResistors:\n3 - 1KOhm, 1/4 watt (though you could get by with 1/8 watt easily)\n2 - 10KOhm, 1/4 watt (also could use 1/8 watt)\n12 - 300 Ohm, 1/4 watt (might be able to use 1/8 watt, these handle the LED\u00a0current)\nLED's:\n4 - 5mm, Common Cathode RGB\u00a0LED's - I\u00a0used clear (not diffused) ones and diffused them with sandpaper.\u00a0 I think regular diffused ones would probably be \"too diffused\"\u00a0and be a bit dim.\u00a0 I\u00a0got a 50 pack of these RGB\u00a0LED's on eBay from China, was only $15 shipped, compare to Mouser's $2.00 per single LED before shipping.\nConnectors:\nI\u00a0used 0.1\"\u00a0(2.54mm)\u00a0breakaway pin headers for all my connections.\u00a0 To connect to them, I\u00a0got a 32-pin rectangular connector that fits 0.1\"\u00a0pin headers and then cut it into pieces.\u00a0 I got one that was through hole so it had pins that were easy to solder to.\nPCB: \nCopper-clad, single sided PCB that is at least probably 4\"x2\".\u00a0 I\u00a0used a 6x6\"\u00a0and there's room to make at least 2 more.\nPrinter:\nA laser printer to print the PCB\u00a0design, just any old laser printer should work.", "step_imgs": ["https://cdn.instructables.com/FC8/XWCT/G5W7CROB/FC8XWCTG5W7CROB.LARGE.jpg"], "step_title": "Step 2: Parts List"}, {"step": 3, "steps_text": "To start out, you need to modify the fan so it has RGB\u00a0LED's in it.\u00a0 The hardest part is removing the old LED's as they're probably glued in pretty well.\u00a0 I\u00a0just took a small screwdriver and pushed them out from the front (be careful around the fan blades, don't break them!).\u00a0 After pushing them out, I\u00a0desoldered the blue LED's and put them in my parts bin (they still work, so they'll be useful later).\u00a0 I then taped up the LED\u00a0wires with clear tape so it wouldn't short out.\nAfter this, plug the fan back in and make sure it spins without the LED's.", "step_imgs": ["https://cdn.instructables.com/F1M/B44K/G5W7J6DD/F1MB44KG5W7J6DD.LARGE.jpg", "https://cdn.instructables.com/FTE/W5PA/G5X4MF3P/FTEW5PAG5X4MF3P.LARGE.jpg", "https://cdn.instructables.com/F8Z/R18D/G5X4MF3O/F8ZR18DG5X4MF3O.LARGE.jpg", "https://cdn.instructables.com/F8T/EILP/G5X4MF3N/F8TEILPG5X4MF3N.LARGE.jpg"], "step_title": "Step 3: Remove the Original Fan LED's."}, {"step": 4, "steps_text": "I used flat ribbon cable for this.\u00a0 You need 4-wire cable that is thin enough to wrap around the fan without too much work.\u00a0 Ribbon cable (not the really flat stuff, but like IDE\u00a0cord type wire) is very good for this as you can tape it to the outside of the fan.\u00a0 Use pliers to bend the leads from the LED at a 90 degree angle.\u00a0 Keep the bend close to the base of the LED so that it won't stick out of the fan or obstruct the fan mounting holes.\nAfter bending, carefully solder the 4 wires to the 4 pins of the LED.\u00a0 Don't leave the soldering iron touching the LED\u00a0for a long time as LED's are sensitive to heat and you could burn out one or all of the colors, rendering that LED useless.\u00a0 In case this does happen, try \"zapping\"\u00a0the non-functioning LED with 5 volts (no resistor).\u00a0 I had the blue LED on one of mine not work, but after hitting it with straight 5V for like 5 seconds, it started working and works fine now.\nClip the excess leads and put tape or glue around the connections to protect them.\nRepeat until you have 4 RGB\u00a0LED's that have wires coming off of them.\u00a0 Make sure you know which wire goes to which (test them with a battery, the longest pin on the LED\u00a0is the ground [cathode] and the others are red, green, and blue, find out what is what with a battery and remember it or write it down).\u00a0 Test to make sure all the colors light up when connected as well.", "step_imgs": ["https://cdn.instructables.com/FG7/HJC4/G5W7J6OI/FG7HJC4G5W7J6OI.LARGE.jpg"], "step_title": "Step 4: Solder Wires to the RGB LED's."}, {"step": 5, "steps_text": "This is a pretty easy step.\u00a0 Look where the motor wire comes out of the fan.\u00a0 This is where we want the LED wires to come out as well.\u00a0 Start with the two LED's closest to it.\u00a0 Angle them so that the cable coming off the LED is going towards the motor wire and push the LED's into place.\u00a0 You don't have to glue them in unless they don't fit very well otherwise.\u00a0 Use transparent tape (I\u00a0used the cheap Walmart stuff that is truly clear) to tape the LED\u00a0cables tight against the fan.\u00a0 Then put in the other two LED's also with their cables wrapping around on top of the other LED\u00a0cables, tape them down and then tape the 4 cables together (you should have a clean looking square bundle of wires and then tape this bundle to the motor wire.\u00a0 Your RGB\u00a0fan is almost complete, now for something to control it with.", "step_imgs": ["https://cdn.instructables.com/F2A/MJJM/G5X4MF4C/F2AMJJMG5X4MF4C.LARGE.jpg", "https://cdn.instructables.com/FAQ/65FJ/G5X4MF4B/FAQ65FJG5X4MF4B.LARGE.jpg", "https://cdn.instructables.com/FXB/452C/G5X4MF4A/FXB452CG5X4MF4A.LARGE.jpg"], "step_title": "Step 5: Install the RGB LED's in the Fan"}, {"step": 6, "steps_text": "If you like using a breadboard to test things before making the PCB, now is your chance.\u00a0 Stick your Mega168 and MAX232 in a breadboard, put the 2 1uF capacitors on the MAX232, hook the MAX232 to a serial port and the microcontroller's Tx/Rx pins, hook up a 5V regulator and power the two chips, and then follow the LED\u00a0wiring pinout below to hook the AVR\u00a0to the LED's:\nPin 14\u00a0(PB0):\u00a0\u00a0Red 1\nPin 15 (PB1):\u00a0\u00a0Green 1\nPin 16\u00a0(PB2):\u00a0 Blue 1\nPin 17 (PB3):\u00a0 Red 2\nPin 18\u00a0(PB4):\u00a0\u00a0Green 2\nPin 19 (PB5):\u00a0 Blue 2\nPin 23 (PC0):\u00a0\u00a0Red 3\nPin 24\u00a0(PC1):\u00a0\u00a0Green 3\nPin 25\u00a0(PC2):\u00a0\u00a0Blue 3\nPin 26 (PC3):\u00a0\u00a0Red 4\nPin 27 (PC4):\u00a0\u00a0Green 4\nPin 28 (PC5):\u00a0\u00a0Blue 4\nHook each connection through a 300 ohm resistor, and connect the 4 LED\u00a0ground pins to ground.\nConnect the fan motor by putting a 1K\u00a0Ohm resistor from Pin 5 (OC2B)\u00a0to the base of the NPN\u00a0transistor.\u00a0 Connect the middle pin of the transistor to a 10K\u00a0Ohm resistor which then connects to the base of the PNP\u00a0transistor.\u00a0 Connect the remaining pin of the NPN\u00a0to ground, the middle of the PNP to the fan motor, and the remaining pin of the PNP to your 12V (or whatever you're using for a power supply, I\u00a0breadboarded mine with a 9V\u00a0because I\u00a0had one lying around, still good enough for a test).\u00a0 Connect the fan's ground to the breadboard ground, connect the yellow wire to a 10KOhm resistor and also to a 1KOhm resistor.\u00a0 The 10KOhm goes to +5V while the 1KOhm goes to AVR\u00a0pin 11 (T1).\u00a0 Also put a 1uF between pin 11 and ground to smooth out the signal.\nHook up your programmer to the AVR and download the code onto it (the code is at the end of this Instructable).\u00a0 See Step 11, you have to set the fuse bits on the AVR\u00a0to disable the internal clock divider.\u00a0 The clock/8 bit is turned on by default and needs to be disabled before the code will work.\u00a0 After installing the AVR\u00a0code onto the updated AVR, open up the client app and try turning on the fan.\u00a0 It should light up and spin perfectly.\u00a0 At this step you can either just shove your breadboard in your PC and call it done, or you can do it right and make a PCB.", "step_imgs": ["https://cdn.instructables.com/FNI/9TZW/G5W7J6Z3/FNI9TZWG5W7J6Z3.LARGE.jpg", "https://cdn.instructables.com/FN4/5F0G/G5W7J6ZH/FN45F0GG5W7J6ZH.LARGE.jpg", "https://cdn.instructables.com/F1Z/5TIF/G5W7J6ZO/F1Z5TIFG5W7J6ZO.LARGE.jpg"], "step_title": "Step 6: Prototype the Circuit (Optional)"}, {"step": 7, "steps_text": "I designed the PCB\u00a0in Eagle CAD, but it's already done so you can just download the PDF\u00a0and print it out.\u00a0 I've included 4 of them in the PCB if you want extras.\nThe method I\u00a0used is the \"toner transfer method\".\u00a0 What you do is print the PCB design out on a laser printer.\u00a0 It MUST\u00a0be a laser printer, inkjet printers use liquid ink that will not transfer like toner does.\u00a0 Then, cut the design out of the paper, leaving just a little white around it (just make it square, don't try to follow the lines).\u00a0 Clean the copper surface of a blank copper clad board, then lay the paper (printed side down) against the PCB.\u00a0 Notice that the printout is mirror imaged, this is on purpose as it will flip when transferred to the board.\nPut the PCB blank side down against a heat resistant surface, with the paper face down on top of the copper.\u00a0 Then get a hot clothes iron and press it down against the paper.\u00a0 This will melt the toner, adhering it to the PCB.\u00a0 Put a fair amount of pressure down on it to make sure every bit of it melts.\u00a0 Lif the iron up, rotate it, and put it back down (don't drag it across the paper, you might smear the toner if it's hot).\u00a0 Keep changing the orientation to cover every bit of the paper with full heat.\u00a0 This may take a few tries to master the technique but it's an easy way to make nice boards on the cheap.\nAfter heating, take the PCB and let it cool down (it will probably be too hot to pick up at first).\u00a0 After it's cool enough to carry, take it and submerge it in soapy warm water.\u00a0 VERY\u00a0GENTLY start rubbing the back of the paper with your finger (not your fingernail, that will scratch the paper and could damage the transfer.\u00a0 After the water has soaked in a bit, you can start to gently pick apart the paper starting at the outside.\u00a0 You should be able to get at least the top layers of the paper to start to peel off without pulling up any of the toner.\u00a0 After most of the paper is gone, gently rub the paper with a bit of pressure to break up the paper fibers that still may have toner attached to them.\u00a0 Get as much of the paper as you can off without damaging the toner, you can etch around a bit of paper threads but once the toner is gone it is hard to fix.\nIf you mess up, you can use acetone (nail polish remover) to remove the toner and start over, you can also use a scouring pad to gently scrape it away, though a scouring pad may damage the copper layer if you use it too much.\u00a0 Keep trying until you get one that is perfect or very close.\u00a0 I had one pad fall off and a few minor breaks in mine.\u00a0 I touched them up with a Sharpie marker but the etchant still ate through it.\nAfter you've got your board ready, cut the part of the board you want out of any board you want to keep unused with a dremel.\u00a0 Then take the board that you want to etch and stick it in some etchant solution (I\u00a0used ferric chloride, but there are many things that will dissolve copper).\nWear rubber gloves when doing this, it will keep your hands from turning weird colors and staining things, also do this over some newspaper and I would recommend doing it in the garage or unfinished basement so you don't stain carpet or nice floors.\nAfter etching, there should be no copper visible but under the black toner.\u00a0 This means it's ready, take the board out and then use acetone (nail polish remover) to get rid of the black toner and expose the copper.\u00a0 Now you're ready to solder, assuming there are no major missing parts (a little break isn't a big problem, you can bridge it with solder, a missing pad is harder to fix, but mine was close enough to the trace that it bridged easily.\nAfter you get the toner off, use a tiny drill bit and a drill press to drill the holes.\u00a0 I used a cheap $15 drill with a \"drill stand\", a holder that makes a cheap drill into a cheap drill press.\u00a0 I used some tiny drill bits that were for model railroading to drill the tiny holes.\u00a0 There are a lot of holes to drill, don't miss any, and drill starting at the copper side because it's easy to line up the hole right where it's marked on the board.\u00a0 Take your time and it shouldn't be a problem.\nAfter drilling the holes, go over the board and look for any spots where the copper didn't dissolve between two traces.\u00a0 There were a few spots that I had to cut out with a knife, one was the SCK line shorted with the AVCC\u00a0and wouldn't program but works great after I scraped out the tiny flake of copper bridging the traces.", "step_imgs": ["https://cdn.instructables.com/F7T/WP1G/G5W7J9IU/F7TWP1GG5W7J9IU.LARGE.jpg", "https://cdn.instructables.com/FKQ/VZER/G5W7J9IT/FKQVZERG5W7J9IT.LARGE.jpg"], "step_title": "Step 7: Create the PCB"}, {"step": 8, "steps_text": "This is a pretty easy step if you're good with a soldering iron.\u00a0 Just make sure you line everything up right and you'll be good.\u00a0 Look at the circuit board diagram for lining up the chips.\u00a0 Use the diagram below to see what goes where, I've labeled the entire thing.\u00a0 Note that this is a top-down view, the copper layer is the bottom so look at the side where there isn't copper, that's what the diagram is.\nRemember to solder in the IC sockets and not the IC's themselves, make sure you orient the sockets according to the diagram and then plug the IC's in the same direction.\nFor the jumpers, I just used the rest of the resistor leads that I clipped off after soldering in the resistors.\u00a0 If you solder in the resistors first, save the clipped leads, they make good jumpers.\u00a0 There are 3 jumpers on this board (the resistor right next to the ISP header is a mistake, it should be a jumper).", "step_imgs": ["https://cdn.instructables.com/FY3/O9AS/G5W7J9K1/FY3O9ASG5W7J9K1.LARGE.jpg", "https://cdn.instructables.com/FUF/JUEK/G5W7J9QP/FUFJUEKG5W7J9QP.LARGE.jpg", "https://cdn.instructables.com/FXF/DZGG/G5W7JA1K/FXFDZGGG5W7JA1K.LARGE.jpg"], "step_title": "Step 8: Start Inserting Components."}, {"step": 9, "steps_text": "Once you've finished inserting components, you need to make the cables.\u00a0 The board should have components in every spot.\u00a0 You'll need to make 2 cables (Power and Data), attach a pin connector to the RGB\u00a0LED's on the fan, and make sure the fan's 3-pin connector fits the 3-pin connector here.\u00a0 Also, if you haven't done so already, insert the two IC's into their sockets making sure you get them in the correct orientation.\nTo make the power cable, take a 4-pin section of the rectangular connector and solder wires to each pin.\u00a0 The two in the middle are ground, the one on the left (as according to the picture) is +12V, and the one on the right is +5V.\u00a0 The other end is a standard 4-pin Molex connector that connects to your PC's power supply.\nFor the serial cable, one end is a 3-pin section from the rectangular connector.\u00a0 I\u00a0soldered a 3-pin ribbon cable on to it, the top-most pin according to the image below is ground, under that is Rx from the PC, and the front-most pin is Tx from the PC.\u00a0 If your PC has an internal COM\u00a0port (a 10-pin header on the motherboard near the rear COM\u00a0port, usually has one corner pin removed), use a 5x2 rectangular connector (or 2 strips of 5 glued together, or just 3 individual ones since you only need 3 pins connected to that block) and solder them.\u00a0 You may have to look up the exact pinout of the motherboard header.\u00a0 Otherwise just solder a standard DB-9 female connector to it, run it out the back of your PC, and plug it into the rear port.\nIf you want to use USB, you can use a USB to serial adapter and modify it to connect to the serial port, or you can take the attached Eagle PCB file and modify it to use an FTDI chip instead of a MAX232, but that is beyond the scope of this Instructable.", "step_imgs": ["https://cdn.instructables.com/FIG/REJY/G5W7J9N5/FIGREJYG5W7J9N5.LARGE.jpg"], "step_title": "Step 9: Finish Inserting Components, Make Cables."}, {"step": 10, "steps_text": "The fan has 4 groups of 4 LED wires coming off of it.\u00a0 Starting at the right on the PCB connector, it goes:\nGround, Red1, Green1, Blue1, Ground, Red2, Green2, Blue2, Ground, Red3, Green3, Blue3, Ground, Red4, Green4, Blue4\nTake a 16-pin section of the rectangular connector and solder the LED's in that order (you do remember what order the LED's are in, right ;-) )\nWhen you're done soldering it, use hot glue to glue a protective form around the soldered pins, there's a lot of tiny wires and hot glue will keep them from pulling apart.\u00a0 It's only useful if you glue past the insulation break or the exposed metal will snap.\u00a0 Then wrap the whole thing in tape to make sure.\u00a0 Finish by grouping the fan wires with tape segments from the plug all the way to the fan until it is one single cord.\u00a0 Tape the fan's power cord to this as well.\u00a0 When it's done, it should look a lot like the picture below, and plugging it in (if you programmed the AVR in step 6) should cause all the lights to light up.\u00a0 If there's a missing color, you know where to look (I\u00a0had 2 LED's that didn't light up, turns out there were tiny breaks on their PCB traces, bridged them and it works great).", "step_imgs": ["https://cdn.instructables.com/FRC/G202/G5W7J9XV/FRCG202G5W7J9XV.LARGE.jpg"], "step_title": "Step 10: Attach a Pin Connector to the Fan LED's"}, {"step": 11, "steps_text": "\n          Now it's time to see how it works.\u00a0 Plug the serial port into the PC, plug the power cord into your power supply (make sure you orient it right on both ends, +12V goes on the LEFT\u00a0looking at the board from the top), plug the fan in (so that the tabs face towards the center of the board) and plug in the fan LED's (so that the ground pin goes on the RIGHT).\u00a0 Turn on the power.\nYou'll need your AVR\u00a0programmer now.\u00a0 The first thing you want to do is change the frequency of the internal oscillator.\u00a0 By default, ATMega168's come with the clock/8 internal prescaler enabled.\u00a0 This causes the chip to run too slow for this application and the LED's will just flash without glowing solid (or at least\u00a0 appearing to using PWM).\u00a0 You need to reprogram the fuse bits to turn off the prescaler.\nUsing AVRdude, this is accomplished by the options:-U lfuse:w:0xe2:m-U hfuse:w:0xdf:m-U  efuse:w:0xf9:m\nAfter applying these, the lights should fade smoothly and serial communication at 19200 baudrate should work using the supplied Windows or Linux GUI program (download at the end of this Instructable).\u00a0 If so, the board works fine and you can install it.\u00a0 This depends on your case, so just install the fan as usual and mount the controller board however you can (I used tape, it's basic but it works).\u00a0 Also remember to insulate the board so it doesn't short out against the case frame.", "step_imgs": ["https://cdn.instructables.com/FBH/OM90/G5W7R71A/FBHOM90G5W7R71A.LARGE.jpg", "https://cdn.instructables.com/FMW/39MG/G5W7R71C/FMW39MGG5W7R71C.LARGE.jpg", "https://cdn.instructables.com/FGI/446T/G5W7R71B/FGI446TG5W7R71B.LARGE.jpg", "https://cdn.instructables.com/FYY/31QA/G5W7R719/FYY31QAG5W7R719.LARGE.jpg", "https://cdn.instructables.com/FDL/05YE/G5W7R718/FDL05YEG5W7R718.LARGE.jpg"], "step_title": "Step 11: Test and Install"}, {"step": 12, "steps_text": "The software provided is now almost complete!\u00a0 I\u00a0have RPM\u00a0monitoring working and my Windows GUI is nearly complete.\u00a0 I\u00a0also added save-states so that the fan will turn on to its default speed along with the LED's when the PC first turns on.\u00a0 The cross-fading also works, but I\u00a0haven't documented the protcol entirely yet.\nAll serial frames follow this format:\n0xAA\u00a0 |\u00a0 Command byte \u00a0 |\u00a0\u00a0 Value byte \u00a0 |\u00a0 0xFF\nSome commands don't take a value, but you must send a value byte to fill the 4-byte frame,\nthe value you send is ignored, 0x00 will do (so will anything else).\nSome new commands:\n0x03 = Save current state to EEPROM\n0x04 = Load saved state from EEPROM\n0x31 - 0x3C = Receive LED\u00a0values\n0x41 - 0x4C = Set crossfade buffer\n0x51 - 0x5C = Receive crossfade buffer\n0x61 = Start CrossFade (the value byte is microsecond delay in the fade loop, increase for slow fades)\nAll the files are now located on my Google Code Project!http://code.google.com/p/rgbfan/", "step_imgs": ["https://cdn.instructables.com/F7V/DSCT/G5W7CREC/F7VDSCTG5W7CREC.LARGE.jpg", "https://cdn.instructables.com/F8P/96TT/G5W7CRED/F8P96TTG5W7CRED.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 12: The End (and Here's the Files)"}], "channel": "Electronics"}, {"category": "technology", "description": "a.articles {\n\tcolor: white;\n\tbackground: red;\n\tfont-weight: bold;\n\tfont-style: italic;\n\ttext-decoration: none;\n}\na.articles:hover {\n\tbackground: black;\n}\nThis instructable describes how to make an ultrasonic \u201cradar-style\u201d display using an Arduino microcontroller, an ultrasonic sensor, and a small stepping motor.An optional sensor modification allows multiple objects to be detected with each ping. Construction is simple ... all you need are two drills, a sharp knife, a pair of side-cutters , and a soldering iron.Photo 1 shows the basic parts. The \u201cinsert\u201d shows a random-dot test pattern. Dots representing primary objects are shown in red ... dots representing secondary objects are shown in blue.Photo 2 shows the assembled unit.Photo 3 shows an actual screen shot of seven objects. [1]The video clip shows the unit in operation.  [1]The azimuth and distance of each primary object are shown in red. Any echo from a secondary object is shown in blue. Without the sensor modification you will only see the red objects.Since the sonic pulses expand in a cone-like manner, distant objects appear wider. The actual bearing of each object is the midpoint of each continuous (red or red/blue) line.Continuous lines containing both red and blue dots are a single object, part of which is in shadow.", "title": "Acoustic Radar Display", "url": "https://www.instructables.com/id/Acoustic-Radar-Display/", "section": "technology", "steps": [{"step": 1, "steps_text": "The wiring diagram is shown in photo1.An optional modification is shown in photo2.  This modification is the SAME for both the HC-SR04 and the HY-SRF05 ultrasonic sensors and allows multiple echos to be detected. [1][1]For a full explanation see my instructable  https://www.instructables.com/id/Enhanced-Ultraso...If you have an HC-SR04, the integrated circuit to which you solder the wire is labelled U2", "step_imgs": ["https://cdn.instructables.com/F90/OMOV/JIEU59DF/F90OMOVJIEU59DF.LARGE.jpg", "https://cdn.instructables.com/FXR/GQJU/JIEU59DG/FXRGQJUJIEU59DG.LARGE.jpg"], "step_title": "Step 1: Wiring Diagram"}, {"step": 2, "steps_text": "The following parts were obtained locally:1 only plastic food container.1 only sub-miniature micro-switch.1 only male header strip (used for attaching wires from sensor).1 only female header strip (used to mount sensor).1 only piece of 20 gauge aluminium (scrap) sheet 40mm x 55mm.6 only 9mm nylon spacers tapped 3mm.3 only cable-ties.13 only 3mm x 6mm bolts.1 only 3mm nut.4 only 4mm x 10mm bolts.2 only 4mm nuts.The following parts were obtained from  https://www.aliexpress.com/1 only Arduino Uno R3 microcontroller complete with USB cable.1 only 28BJY-48 5 volt stepping motor complete with ULN2003 controller.1 only 5mm bore brass hex shaft to wheel coupler for model cars.1 only HY-SRF05 (or HC-SRF04) ultrasonic sensor.", "step_imgs": ["https://cdn.instructables.com/FFN/SR7Z/JIEU59IJ/FFNSR7ZJIEU59IJ.LARGE.jpg"], "step_title": "Step 2: Parts List"}, {"step": 3, "steps_text": "MechanicalAll parts are housed inside a plastic food container. Power is obtained from your USB port.The circuit comprises an Arduino, an ultrasonic sensor, a stepping-motor, and a micro-switch for moving the sensor to its \u201chome\u201d position. The micro-switch is necessary as it is not possible to rotate the stepping motor by hand due to its 64:1 internal gearing.When first powered up the Arduino rotates the sensor to its \u201chome\u201d position, as determined by the micro-switch,  then  \u201cpolls\u201d the display until it gets a response. The 28BJY-48 stepping motor has a \u201cstride angle\u201d of 5.625/64 degrees which means that 1 degree steps are not possible (even though our graticule is labelled 0..180 degrees). Fortunately, 180/stride-angle  =  180*64/5.625  = 2048 which is evenly divisible by 8. If we increment a number from 0..2048 and divide by 8 there are 256 occasions when we get a remainder of zero ... we simply send a \u201cping\u201d whenever the remainder is zero. This equates to a  \u201cping\u201d every PI/256 radians or 0.703125 degrees.Software [1]The display then takes control and continually asks the Arduino to supply the following data:AzimuthDistance1Distance2DirectionThe \u201cdistance(s)\u201d for each \u201cazimuth\u201d are then displayed on the screen. The \u201cdirection\u201d information is used to create the illusion of \u201cdots\u201d appearing behind the \u201cbeam\u201d as it rotates.The Arduino automatically moves to the next \u201cping\u201d position whenever data is sent to the display.[1]The \u201cProcessing 3\u201d software used for writing the display may be downloaded from  https://processing.org/download/Processing 3 supports 2D and 3D graphics and is very similar to the Arduino IDE (Integrated Development Environment).  The main visual differences are a \u201cgraphics window\u201d when the code is running and the use of a \u201cdraw()\u201d function instead of the Arduino \u201cloop()\u201d.", "step_imgs": [], "step_title": "Step 3: How It Works"}, {"step": 4, "steps_text": "The GraticuleI chose to create a 180 degree graphics display as it provides a \u201cradar shadow\u201d in which to stand while experimenting. Such a display is also compatible with a servo motor should I wish to use one. A full 360 degree display can be obtained by tweaking the code. The following photos explain how the graticule was created:Photo 1The graticule comprises a number of \u201carcs\u201d and \u201clines\u201d. Angled labels are shown in this photo but were later dropped in favour of horizontal text which is easier to read.Photo 2Shows a red line depicting the \u201cbeam\u201d. The text in the label is now horizontal.Photo 3The red line in photo 2 has been rotated 0..180 degrees through 256 azimuth positions. In this photo the outer parts of the graticule are not covered as the beam-width is too narrow. This results in some strange artifacts.Photo 4Increasing the beam-width has eliminated these artifacts.Photo 5Random dots have been introduced to represent primary (red) and secondary (blue) echos.  The range, which can be changed, has been set to exactly 100cm to match the display. A fading beam pattern has also been introduced. The technique used to create this \u201cfading beam\u201d is explained further on.Photo 6The color scheme has been changed to add a touch of realism.AnimationThe animated portions of the graphics display use 3D graphics to greatly simplify the code. To understand how this is possible let\u2019s draw a \u201c30 degree line\u201d of constant radius from an XY start coordinate of (0,0).2D graphics requires the use of sin(30) and cos(30) to calculate the XY end coordinates of the line:X=cos(30)*radius = 0.866*radius\nY=sin(30)*radius = 0.5*radius\nline(0,0,X,Y);3D graphics doesn\u2019t require the use of trigonometry. We simply rotate the XY grid coordinates about the Z-axis then draw a horizontal line .... no maths required!!!pushMatrix();\t\t//preserve our current grid coordinates\nrotateZ(radians(30));\t//rotate our XY grid coordinates about the Z-axis\nline(0,0,radius,0);\t//draw a \u201chorizontal\u201d line on the rotated grid\npopMatrix();\t\t//restore our grid coordinatesEither way works but this second method lends itself to \u201cping\u201d intervals of PI/256 radians.Fading LinesThe fading beam pattern uses a clever technique found at  https://forum.processing.org/two/discussion/13189...The beam is given its own virtual screen. Prior to drawing any line the \u201calpha\u201d (opacity) of all previous lines is reduced by a small amount. Ultimately the earliest lines become invisible which gives the illusion of a fading \u201cfan\u201d pattern.This virtual screen, which is never erased, is then merged with the contents of the main screen whenever the display is refreshed.", "step_imgs": ["https://cdn.instructables.com/FV0/QBP2/JIEU59XA/FV0QBP2JIEU59XA.LARGE.jpg", "https://cdn.instructables.com/FGE/B6EC/JIEU59WE/FGEB6ECJIEU59WE.LARGE.jpg", "https://cdn.instructables.com/FMI/SZ73/JIEU59WF/FMISZ73JIEU59WF.LARGE.jpg", "https://cdn.instructables.com/FA6/7W7I/JIEU59WU/FA67W7IJIEU59WU.LARGE.jpg", "https://cdn.instructables.com/FKG/OEHQ/JIEU59XP/FKGOEHQJIEU59XP.LARGE.jpg", "https://cdn.instructables.com/F5T/UZPC/JIEU59X9/F5TUZPCJIEU59X9.LARGE.jpg"], "step_title": "Step 4: The Display"}, {"step": 5, "steps_text": "The drilling template for a suitable mounting bracket is shown in photo 1.Position the two outer \u201cmount\u201d holes below the transmit (T) and receive (R) sensors. I find that best results are obtained if the sensor rotates around the receive (R) sensor rather than midway between the two sensors. The three holes allows you to experiment.Details of how to \u201ccut and fold\u201d aluminium may be found in my instructable  https://www.instructables.com/id/How-to-Cut-Fold-...", "step_imgs": ["https://cdn.instructables.com/FR3/DDYI/JIEU5AEG/FR3DDYIJIEU5AEG.LARGE.jpg"], "step_title": "Step 5: Mounting Bracket"}, {"step": 6, "steps_text": "USB cable-holeDo not try and drill a cable-hole for the USB connector though the side of the plastic container as plastic tends to split and chip. Instead, melt a hole using the tip of a hot soldering iron then trim with a sharp knife. Take care not to breath the fumes.Shaft-extenderReplace one of the 4mm \u201cgrub-screws\u201d in the shaft-extender with a 4mm x 10mm bolt. This bolt is used to activate the micro-switch.Micro-switchPosition the micro-switch such that it is activated by the 4mm bolt when the shaft rotates in a clockwise direction. I used two turns of 20 gauge copper wire to attach the micro-switch to the case as 2mm nuts and bolts were not readily available.Remaining componentsLayout is not critical. The motor shaft was positioned centrally. The Arduino and motor controller were mounted on nylon spacers which allow the wires to be tucked underneath.Mounting the sensorPhoto 1 shows the sensor assembly. The HY-SR0F-5 socket has been fashioned from a female-header socket. All unwanted pins have been removed and a 3mm hole drilled through the plastic. The header is then attached to the bracket by means of a 3mm nut and bolt.Photo 2 shows a side view of the sensor assembly. The wires from the header are cable-tied to the bracket. This \u201cstrain-relief\u201d prevents unwanted cable movement as the sensor rotates. Note also the \u201cgrey\u201d wire attached to pin 10 of IC1. This wire is optional and feeds the secondary echos to the Arduino.Attach the sensor assembly to the shaft extender after the micro-switch has operated following power-up. The shaft is then in its \u201chome\u201d position.", "step_imgs": ["https://cdn.instructables.com/F8U/PTT7/JIEU5AGR/F8UPTT7JIEU5AGR.LARGE.jpg", "https://cdn.instructables.com/FWI/IH1V/JIEU5AGP/FWIIH1VJIEU5AGP.LARGE.jpg"], "step_title": "Step 6: Assembly"}, {"step": 7, "steps_text": "Install the following code in this order:Arduino IDEDownload and install the Arduino IDE (integrated development environement) from  https://www.arduino.cc/en/main/software  if not already installed.Processing 3Download and install Processing 3 from  https://processing.org/download/Acoustic Radar Sender [1]Copy the contents of the attached file, \u201cacoustic_radar_sender_2.ino\u201d, into an Arduino \u201csketch\u201d, save, then upload it to your Arduino Uno R3. Close the Ardino IDE but leave the USB cable connected.Acoustic Radar ReceiverCopy the contents of the attached file, \u201cacoustic_radar_receiver.pde\u201d into a Processing \u201cSketch\u201d.Bugfix[1]\"acoustic_radar_sender_2.ino\"  fixes a \"scan-creep\" bug in \"acoustic_radar_sender_1.ino\" . My thanks to https://www.instructables.com/member/newtoeu/instr... for pointing it out.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 7: Software Installation"}, {"step": 8, "steps_text": "Click the top left \u201cRun\u201d button in your Processing window and your project will burst into life. Try detecting different objects:Nearby objects require the transmit (T) sensor to be low to prevent the \"beam\" passing over the top.  More distant objects require a larger surface area as much of the acoustic energy is lost as the beam spreads ... plus the return echo also spreads.  Experiment with the three mounting holes.  You may wish to try mounting the sensor vertically so that the transmit and receive beam-widths overlap.\u00a0\u00a0Click here\u00a0\u00a0 to view my other instructables.", "step_imgs": [], "step_title": "Step 8: Testing"}], "channel": "Arduino"}, {"category": "technology", "description": "\n          I recently needed to use the Arduino to control a stereo system, so rather than hack open the remote and wire into it, I decided to simply clone the signal. This was incredibly easy to do. Basically, I read the signal from the remote with a 38khz receiver, and then played it back with an IR LED.\nTo start, I went to the IR Sensor Tutorial on Adafruit.com and loaded the following script onto my Arduino:/* Raw IR decoder sketch!\n \n This sketch/program uses the Arduno and a PNA4602 to \n decode IR received. This can be used to make a IR receiver\n (by looking for a particular code)\n or transmitter (by pulsing an IR LED at ~38KHz for the\n durations detected \n \n Code is public domain, check out www.ladyada.net and adafruit.com\n for more tutorials! \n */\n \n// We need to use the 'raw' pin reading methods\n// because timing is very important here and the digitalRead()\n// procedure is slower!\n//uint8_t IRpin = 2;\n// Digital pin #2 is the same as Pin D2 see\n// http://arduino.cc/en/Hacking/PinMapping168 for the 'raw' pin mapping\n#define IRpin_PIN      PIND\n#define IRpin          2\n \n// the maximum pulse we'll listen for - 65 milliseconds is a long time\n#define MAXPULSE 65000\n \n// what our timing resolution should be, larger is better\n// as its more 'precise' - but too large and you wont get\n// accurate timing\n#define RESOLUTION 20 \n \n// we will store up to 100 pulse pairs (this is -a lot-)\nuint16_t pulses[100][2];  // pair is high and low pulse \nuint8_t currentpulse = 0; // index for pulses we're storing\n \nvoid setup(void) {\n  Serial.begin(9600);\n  Serial.println(\"Ready to decode IR!\");\n}\n \nvoid loop(void) {\n  uint16_t highpulse, lowpulse;  // temporary storage timing\n  highpulse = lowpulse = 0; // start out with no pulse length\n \n \n//  while (digitalRead(IRpin)) { // this is too slow!\n    while (IRpin_PIN & _BV(IRpin)) {\n     // pin is still HIGH\n \n     // count off another few microseconds\n     highpulse++;\n     delayMicroseconds(RESOLUTION);\n \n     // If the pulse is too long, we 'timed out' - either nothing\n     // was received or the code is finished, so print what\n     // we've grabbed so far, and then reset\n     if ((highpulse >= MAXPULSE) && (currentpulse != 0)) {\n       printpulses();\n       currentpulse=0;\n       return;\n     }\n  }\n  // we didn't time out so lets stash the reading\n  pulses[currentpulse][0] = highpulse;\n \n  // same as above\n  while (! (IRpin_PIN & _BV(IRpin))) {\n     // pin is still LOW\n     lowpulse++;\n     delayMicroseconds(RESOLUTION);\n     if ((lowpulse >= MAXPULSE)  && (currentpulse != 0)) {\n       printpulses();\n       currentpulse=0;\n       return;\n     }\n  }\n  pulses[currentpulse][1] = lowpulse;\n \n  // we read one high-low pulse successfully, continue!\n  currentpulse++;\n}\n \nvoid printpulses(void) {\n  Serial.println(\"\\n\\r\\n\\rReceived: \\n\\rOFF \\tON\");\n  for (uint8_t i = 0; i < currentpulse; i++) {\n    Serial.print(pulses[i][0] * RESOLUTION, DEC);\n    Serial.print(\" usec, \");\n    Serial.print(pulses[i][1] * RESOLUTION, DEC);\n    Serial.println(\" usec\");\n  }\n}", "title": "Clone a Remote With Arduino", "url": "https://www.instructables.com/id/Clone-a-Remote-with-Arduino/", "section": "technology", "steps": [], "channel": "Arduino"}, {"category": "technology", "description": "If you would like to make your own rc plane or copter you have to learn how to control brushless motor. Most of work will ESC(Electronic Speed Control) do for us, but not all. Someone have to control ESC(I will use Arduino).I used it to make plane but you can use it to whatever you want.Ok, it seems easy. Let's get to work!", "title": "How to Buy and Control Brushless Motor", "url": "https://www.instructables.com/id/How-to-Buy-and-Control-Brushless-Motor/", "section": "technology", "steps": [{"step": 1, "steps_text": "All you need is:Arduino(I use Nano),brushless motor,ESC,battery(I use three 800mAh 3.7V Li-po connected in series),potentiometer,some wires,wooden plank,some screwsand propeller(optional).", "step_imgs": ["https://cdn.instructables.com/F9Q/DSXN/IJG47XWK/F9QDSXNIJG47XWK.LARGE.jpg"], "step_title": "Step 1: Parts List"}, {"step": 2, "steps_text": "Let's start by choosing motor(you can see some on HobbyKing). First, enviroment - where will you use it. If your robot(or drone) will be used inside use inrunner, but if it will be sed outside choose outrunner. Second, size(you can skip this if it doesn't matter but if you are making for example plane it's really important to look at it) - choose size proper to your requirements. Next, Kv(RPM/V) - rotates per volt. If you would like to make fast plane you should have about 2000 RPM/V or higher but if you would like to make a quad copter you should have lower than 1000 RPM/V(check some examples to match yours). Last one(but not least important), power - so how strong should your motor be. For copters your motor should have more power than for planes and of course for bigger planes it should have more power than for smaller.Now if you choosed your motor go to its datasheet and check number of cells(there also you can check model weight). There you can check to how many li-po(or either type you use but I strongly recomend you to choose li-po battery) cells in series(I'll tell you more about batteries later) you can connect your motor. Check also what's your max current(in A) and choose a little bit bigger ESC(it's to avoid burn of your ESC). In ESC's datasheet check if number of celles is the same or bigger than in your motor(for example if you can connect your motor to 2-3 cells you can buy ESC which you can connect to 2-4 cells like I did).OK. You've got motor and ESC, now batteries. You can buy whole battery pack or buy single cells and connect it together to create a pack(like I did). If you would like to buy pack you have to note some things. First, S - how many cells are connected in series. As I mentioned before you cann't connect as many cells in series as you want becouse it will burn your motor or ESC. So if you can connect your motor to 2-3 cells you have to buy 2S or 3S battery pack. Second, capacity(mAh) - in really big shortcut it's time of flight. If you get bigger(more capacity) batteries you will fly longer. To estimate which capacity is the best multiply average motor current by flight time in hours. Also check the letter C. In batteries datasheet there is number and after that big letter C. It means how much bigger current you can take from li-po batteries. For example if current(current = capacity/time) of your battery is 1000mA and there is 20C that means you can take from this battery 1 000mA * 20 = 20 000mA = 20A. So you can connect motor which it's max current is equal or lower than 20A.If you didn't choosed battery pack and you have to make one. Buy as many cells as you need(for this example I use 1S cells but you can do this with whole packs) and connect it in series and by that I mean plus(anode, red wire) to other battery minus(cathode, black wire). Now you've greate a pack. It has S as many as you have cells(S is the number of cells), capacity and C is identical as single cell, so if one cell has 1000mAh 20C whole pack has 1000mAh 20C, but voltage is equal single cell voltage(about 3.7V but it could be lower or higher - if you fully charge it its voltage increase to about 4.2V and under load(if you connect to it motor) it would decrease to 3V) * number of cells(you can mesure it using voltmeter). Now you can calculate max rpm: Kv(RPM/V) * voltage. Remeber - if you connect batteries in series capacity stay the same but voltage increase. If you want to increase capacity you should connect batteries parallel. Connect whole pack's(or single cell) minus to other pack's minus and plus to other pack's plus. Now capacity will be equal pack's(or single cell) capacity * number of packs. IMPORTANT: capacity and voltage of all packs that you connect in parralel should be the same. Now if you connect it in parallel capacity increases but voltage stay the same as in single pack. OK, let's connect it together.", "step_imgs": ["https://cdn.instructables.com/FI3/CQO8/IJG47Y1Y/FI3CQO8IJG47Y1Y.LARGE.jpg", "https://cdn.instructables.com/FD0/EC3Z/IJG47Y5W/FD0EC3ZIJG47Y5W.LARGE.jpg"], "step_title": "Step 2: How to Choose Wisely"}, {"step": 3, "steps_text": "First connect your motor to ESC. From motor goes three wires: black, red and middle yellow(or other color), and from ESC goes three thick wires but the same color. Connect(using special connector or just solder) middle one from ESC to middle one from motor. Two left is to change direction of motion so you have to experiment with it(if you have propeller) to switch it to right direction. So motor is connected to ESC. Now let's connect Arduino.Because I'm using Arduino Nano it's easier for me to use breadboard and plug Arduino into it but you don't have to use breadboard(it's just easier). Now as on diagram connect potentiometer to your Arduino: middle pin to A0, and to left to GND and +5V(order doesn't matter). OK, now ESC connection. You control ESC using thin wires much like servo(if you didn't use servo try to play with it a little bit, here is good instructable for it). So as on diagram connect yellow(or white) pin to any PWM pin on Arduino and black(or brown) pin to GND. Middle(red) pin is NOT CONNECTED to Arduino(not like on diagram) if Arduino is connected to computer. Some says that it could destroy your USB port. I didn't check this and I don't encourage you to check this. You should connect this pin to VIN as power supply only if Arduino is not connected to computer. But now don't connect it because soon you'll have to send program to Arduino.Now you have to get connector to your battery pack to easily connect and disconnect your battery pack. If you've got one connect its wires to power wires from ESC(red and black) and connect as normal - red to red and black to black. If you bought battery pack to cut off power supply to motor(it could be useful in some situations) just disconnect whole pack but if you made it(I assume that you didn't done any parallel connections. If you done it I suggest you to connect switch to easily cut off power) you have to disconnect just one cell and it will open circuit.Now attach holder(should be included with motor) to motor and attach it to wooden plank.One WARNING: if you do it for first time don't attach propeller to motor. It could be dangerous. Motor would sometimes turn on unexpectedly. Always if you connect motor to power hold wooden plank motor to avoid overturn of motor and don't touch the motor while there is power supply connected to it.", "step_imgs": ["https://cdn.instructables.com/FRL/CC1V/IJG47YA8/FRLCC1VIJG47YA8.LARGE.jpg", "https://cdn.instructables.com/FEQ/J5BH/IJG47YAE/FEQJ5BHIJG47YAE.LARGE.jpg", "https://cdn.instructables.com/FVK/ZXHI/IJG47YA0/FVKZXHIIJG47YA0.LARGE.jpg", "https://cdn.instructables.com/FEL/JY56/IJG47YCN/FELJY56IJG47YCN.LARGE.jpg"], "step_title": "Step 3: Wiring"}, {"step": 4, "steps_text": "Now let's go to code. If you looked at this you now that we will control ESC by PWM. If you controlled servo you probably used function write(angle) and servo rotates to writen angle. So if you write for example write(0) you actualy send pulse which width is 1ms so 1000us(micro seconds). To do the same work you can use writeMicroseconds(pulse width in microseconds). It's easier to understand in this use. So instead of setting angle you set RPM(rotates per minute). Great tutorial about ESC is here. It's really great but it didn't worked for me. So what's now? You have to do it manually. Read your ESC manual and see what signals send from your ESC means. I don't know how it's with your but my ESC is read when there's starting melody like on video or 1 2 3 and high tone(where 1 is low frequency tone, 2 higher and 3 higher than 2, last high tone is higher and longer than 3). If something is wrong  last tone is the same as 3. There you can also reprogram it(I didn't done this but you can if you want). In my ESC I had to write high signal for more than 2 secs. OK. Download my code(now you set ESC, not use - it might be confusing but I couldn't invent something smarter :), set everything as in comments and send it to Arduino. Open Serial Monitor. Now you have to set throttle. Move potentiometer to the highest position that on Serial Monitor you will see 2000. Now turn on power supply. You should hear wrong melody. Go back to 1000 and you should hear right melody(if it doesn't work disconnect power and go back to 2000 and repeat process, try go faster to 1000 or slower until you hear right melody). Now you set throttle(you can change it later in the same way) but watch out! If you move potentiometer up motor will start rotating. You can play a little bit with it. Now you can go to using ESC and change properly code. Now you will see RPM in %.That's the end. Hope you run your motor :) Soon I'll end my RC plane and I'll make an instructable about it.Hope to see you soon,Simonexc", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 4: Coding"}], "channel": "Arduino"}, {"category": "technology", "description": "THERE MAY BE 9 STEPS BUT I PROMISE THIS ONE IS QUICK AND EASY!\u00a0 In this Instructable I will be showing you how to create a light reactive LED system. In this clip, I used a single color LED strip, but you you can use a single LED, multiple LEDs wired together, single color or RGB LED strip, it just depends on what you are trying to build. The set up is fairly simple, the component list is fairly basic so if you are a tinkerer you should already have the majority of the materials laying around. If not, I will post links to the components I used so you can order parts and get to work!\u00a0 In the following link you will see the entire setup. Obviously you may arrange it anyway you would like, I just kept everything close and compact for the sake of an easy video.\u00a0  \u00a0", "title": "Sound Reactive LED Strip", "url": "https://www.instructables.com/id/Sound-Reactive-LED-strip/", "section": "technology", "steps": [{"step": 1, "steps_text": "For this project you will need the following: 1) LED\u00a0 ~$20 (with shipping)\u00a0 - For this project I used a solid blue LED strip\u00a0which I purchased on amazon. These 5 meter SMD 5050 strips can run around $70 in retail stores so I though I would be taking a chance purchasing something priced under $20, but I was not disappointed in the least. I'm sure there are better quality lights out there, but if you plan on cutting these up and have no real game plan you wont feel any guilt putting these through the ringer. 2) Mini breadboard\u00a0\u00a0$5 3) Arduino Uno\u00a0\u00a0$30 4) Solid core wire\u00a0\u00a0$2.50 - For anything involving breadboarding, do yourself a favor and stay away from any stranded wire. It will just end up getting frayed and hard to manage. Solid core is the way to go. I also like to choose at least two different colors for my wire to keep grounds and powers visibly separate. It makes troubleshooting and wiring easier in the long run when dealing with a lot of components. 5) USB A to B cable\u00a0\u00a0$4 - This will be used to upload your Arduino LED code to the Arduino Uno board 6) Wire cutter/stripper\u00a0$5 \u00a0 7) Parallax Sound Impact Sensor\u00a0$10 8)\u00a0Wall Adapter Power Supply - 9VDC 650mA\u00a0$6 Total cost will be a bout $80 but keep in mind, all of these components are completely reusable. You can recycle them into a multitude of projects in the future so try not to worry about the cost. Think of it as building up your technical tool box :)", "step_imgs": ["https://cdn.instructables.com/FG6/SDH0/HQV6JUUT/FG6SDH0HQV6JUUT.LARGE.jpg"], "step_title": "Step 1: Components"}, {"step": 2, "steps_text": "Breadboards are incredibly helpful when building circuits. They help you keep all of your components organized and laid out in a logical fashion. They also make it easy to confirm that the right wires are making the connections to the proper component leads. If you have never worked with a breadboard before, I'll explain the internal connection layout with the diagram above: The on either side of the breadboard there are two columns, denoted by the blue and red highlights. These columns allow the user to have a common power and ground for components no matter where they are placed on the board. Whether your component is placed at A1 or J30, a common power and ground connection will only be a short distance away. All of the holes are connected vertically, so if you connected your ground (or power if you felt so inclined) to the left \u00a0or right most blue column, your common ground would extend from that column from position 1 all the way down to 30. However, the left and right sides are not connected, so If you wanted both blue columns grounded you would need to make two separate connections on either side.\u00a0 Rows A-E and F-J are where your components will be placed. This part of the board is also split between the left and right side about the center of the board. If a wire is placed in A1, that charge will carry through E1 and stop at the center divide. If a wire is placed in F1 that charge will carry through J1. You do not have to start out at position 1 every time either. If you place a connection at C1 for example, A1, B1, D1 and E1 would all have the same charge.\u00a0TL; DR The first two and last two blue and red columns share a connection vertically. A-E share a connection horizontally F-J share a connection horizontally A-E connections and F-J connections are not bridged across the center.", "step_imgs": ["https://cdn.instructables.com/F8L/R3G5/HQV6J8YI/F8LR3G5HQV6J8YI.LARGE.jpg"], "step_title": "Step 2: Breadboard Basics"}, {"step": 3, "steps_text": "The basic idea behind this component is that it picks up sounds that cross a certain decibel level. At the very top (opposite side of the pins) of the module is a microphone that listens for ambient sounds. This module has a dial (look for the blue and white) which allows the user to fine tune the sensitivity of the microphone, so that way you can have the microphone register very subtle quiet noises or you can decrease the sensitivity to the point where it only listens for louder than average sounds loud claps, shouts, etc. Play around with this dial and experiment with the sensitivity to get the your desired effect. Once the microphone picks up a sound that is above the sensitivity threshold, the sensor sends a high (1) signal from the SIG line to whatever component you are trying to connect.", "step_imgs": ["https://cdn.instructables.com/F2B/SMXR/HQV6JBEP/F2BSMXRHQV6JBEP.LARGE.jpg"], "step_title": "Step 3: Parallax Sound Impact Sensor"}, {"step": 4, "steps_text": "\n          An Arduino Uno is perfect for this project because it can handle the load of the LED strip, you can write multiple programs depending on what particular behavior you would like to see from your LEDs and besides the standard General Purpose Input/Output (GPIO) pins, it also has Pulse-Width Modulation (PWM) pins. PWM pins are great for powering components such as LEDs and electronic motors and although the pulse wave forms may look a bit jumpy (from the pulsating ons and offs) it actually allows you to control aspects such as brightness (when it comes to LEDs) and speed (when it comes to motors) in a very deliberate. smooth fashion, while efficiently utilizing your power.\u00a0 Here is a nice explanation of Pulse-Wave Modulation from the awesome people of MAKE (makezine.com)", "step_imgs": ["https://cdn.instructables.com/F8Q/4KPX/HQV6JBUM/F8Q4KPXHQV6JBUM.LARGE.jpg"], "step_title": "Step 4: Arduino and Pulse-Wave Modulation"}, {"step": 5, "steps_text": "\"The Arduino language is merely a set of C/C++ functions that can be called from your code. Your sketch undergoes minor changes (e.g. automatic generation of function prototypes) and then is passed directly to a C/C++ compiler (avr-g++). All standard C and C++ constructs supported by avr-g++ should work in Arduino.\" - Arduino support page It is fairly straight forward and Arduino has a nice set of references and tutorials listed on their webpage:\u00a0http://arduino.cc/en/Reference/HomePage To begin programming your Arduino, you will need to download the Arduino IDE software: Click here Once you have downloaded the IDE open up a blank document.\u00a0 \u00a0", "step_imgs": ["https://cdn.instructables.com/FBU/7JHJ/HQV6JV72/FBU7JHJHQV6JV72.LARGE.jpg"], "step_title": "Step 5: Arduino IDE"}, {"step": 6, "steps_text": "Copy and paste the following code into the new project window: #define LEDstrip 9 void setup() { \u00a0 pinMode(7,INPUT); //SIG of the Parallax Sound Impact Sensor connected to Digital Pin 7 \u00a0 pinMode(LEDstrip, OUTPUT); } //this function will make the LED dim once the Parallax Sound Impact Sensor sends a 1 signal, and then return to it\u2019s original brightness. void loop() { \u00a0 boolean soundstate = digitalRead(7); \u00a0 if (soundstate == 1) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0analogWrite(LEDstrip, 255); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0delay(10); \u00a0 } \u00a0 else{ \u00a0\u00a0 \u00a0\u00a0\u00a0 analogWrite(LEDstrip,0); \u00a0 } }", "step_imgs": [], "step_title": "Step 6: LED Arduino Code"}, {"step": 7, "steps_text": "The check button is for the compiler. Click it and you should receive a message at the bottom of your screen saying that the code is done compiling.\u00a0 Once that has been verified, use the USB A to B cable to hook up your Arduino to your computer. Be sure you do not simultaneously powering the Arduino with the wall adapter power supply. You can end up frying the microcontroller if it is being powered by both sources simultaneously...I accidentally did this to an Arduino Mega before.\u00a0 Once the Arduino is connected to your computer navigate to Tools > Board to make sure you have the right model board selected. You may also want to navigate to Tools > Serial Port to be sure you have the proper port selected to send your information. Hit the upload icon (looks like a right facing arrow) and it should upload in about 10 seconds. You should see a \"Done Uploading.\" pormpt at the bottom of the window when this is complete. Unplug your Arduino from your computer, it will save the information you just uploaded even when it is in an \"off\" state. *the first figure shows the compilation steps and the second figure shows the upload steps", "step_imgs": ["https://cdn.instructables.com/F32/0DBJ/HQVPZXZK/F320DBJHQVPZXZK.LARGE.jpg", "https://cdn.instructables.com/FXH/T2F9/HQVPZXZP/FXHT2F9HQVPZXZP.LARGE.jpg"], "step_title": "Step 7: Compile and Upload Your Code"}, {"step": 8, "steps_text": "Now it is time to wire your project up! The following diagram shows all of the connections. These are the direct connections for the sake of simplicity, the number of wires on your actual project may vary since you will be using a breadboard and literally connecting wire to wire.\u00a0 *explanation Parallax sound sensor: GND > GND on Arduino 5V > 5V on Arduino SIG > Digital Pin 7 on Arduino LED: Anode (+, long end) > Vin on Arduino Cathode (-, short end) > PWM pin 9 on Arduino *LED strips usually have two wires at one end, black (ground) and red (power), which makes things pretty easy to wire.\u00a0 Use your 9 volt wall adapter to power the Arduino (plug it into the black component on the lower left side of the Arduino)\u00a0", "step_imgs": ["https://cdn.instructables.com/FCK/7G82/HQV6JVON/FCK7G82HQV6JVON.LARGE.jpg"], "step_title": "Step 8: Wiring"}, {"step": 9, "steps_text": "\n          Pick a song with some solid down beats and have some fun watching your LEDs dance to the music!\u00a0 Put them anywhere you think some ambient mood lighting is needed. For example, I placed mine behind my computer monitor:", "step_imgs": ["https://cdn.instructables.com/FSS/FI7W/HQV6JVR7/FSSFI7WHQV6JVR7.LARGE.jpg"], "step_title": "Step 9: Pick a Song!"}], "channel": "Arduino"}, {"category": "technology", "description": "In this tutorial we will create a fully functional laser harp using IR sensors with a serial interface that will allow the user to change the tuning and tone of the instrument. This harp will be the 21st century remake of the age old instrument. The system was created using a Xilinx Zybo development board along with the Vivado Design Suites. What you will need to complete the project:12 IR sensors and emitters (more or less can be used depending on the number of strings)   Zybo Zynq-7000 development board   Free RTOS   Vivado Design Suite   Wire (for connecting the sensors to the board)   3 pieces of PVC pipe ( (2) 18 inch and (1) 8 inch)   2 PVC elbows", "title": "Laser Harp Synthesizer on Zybo Board", "url": "https://www.instructables.com/id/Laser-Harp-Synthesizer-on-Zybo-Board/", "section": "technology", "steps": [{"step": 1, "steps_text": "The FPGA side of this project is based largely on the demo project found here. It uses direct memory access to send data directly from memory that the processor can write to over AXI Stream to an I2S audio block. The following steps will help you get the DMA audio demo project up and running:A new version of the board file for the Zybo board may be necessary. Follow these instructions to obtain new board files for Vivado.  Follow steps 1 and 2 in the instructions on this page to get the demo project open in Vivado. Use the Vivado method, not the SDK hardware handoff.  You may get a message that says some of your ip blocks should be updated. If so, select \"Show IP Status\" and then in the IP status tab select all out of date IP and click \"Upgrade Selected\". When it finishes and a window pops up asking if you want to generate output product, go ahead and click \"Generate\". If you get a critical warning message, ignore it.  Switch from the design to the sources tab in Vivado to see the source files. Right-click the block design \"design_1\" and select \"Create HDL Wrapper\". When prompted select \"copy generated wrapper to allow user edits\". A wrapper file for the project will be generated.  Now that those critical steps that were somehow left out in the other tutorial are completed, you can return to the tutorial previously linked and continue from step 4 to the end and make sure that the demo project runs correctly. If you don't have a way to input audio for it to record then just record with your headphones in and listen for a  5-10 second fuzzy sound when you press the playback button. As long as something comes out of the headphone jack when you press the playback button, it's probably working correctly.", "step_imgs": [], "step_title": "Step 1: Get Digilent's Zybo DMA Audio Demo"}, {"step": 2, "steps_text": "So now you've got Digilent's DMA audio demo working, but that's not at all the end goal here. So we've got to go back to Vivado and make some changes so that our sensors can be plugged into the PMOD headers and we can use their value on the software side.Open up the block diagram in Vivado  Create a GPIO block by right-clicking in empty space in the block diagram and selecting \"Add IP\" from the menu. Find and select \"AXI GPIO\".   Double click the new IP block and in the re-customize IP window go to the IP configuration tab. Select all inputs and set the width to twelve, since we will have 12 \"strings\" on our harp and therefore need 12 sensors. If you want to use fewer or more sensors then adjust this number appropriately. Also set enable interrupt.  Right click the new GPIO IP block and select \"run connection automation\". Check the AXI box and hit okay. This should connect the AXI interface automatically, but leave the outputs of the block unconnected.  In order to make room for the extra interrupt, double click on the xlconcat_0 IP block and change the number of ports from 4 to 5. Then you can connect the ip2intc_irpt pin from the new GPIO block to the new unused port on the xlconcat block.  Right click on the \"GPIO\" output of the new GPIO IP block and select \"make external\". Find where the line goes to and click on the little sideways pentagon and on the left a window should open where you can change the name. Change the name to \"SENSORS\". It is important to use the same name if you want the constraints file we provide to work, otherwise you will have to change the name in the constraints file.  Back in the sources tab, find the constraints file and replace it with the one we provide. You can choose to either replace the file or just copy the contents of our constraints file and paste it over the contents of the old one. One of the important things our constraints file does is enable the pullup resistors on the PMOD headers. This is necessary for the particular sensors we used, however not all sensors are the same. If your sensors require pulldown resistors you can change every instance of \"set_property PULLUP true\" with \"set_property PULLDOWN true\". If they require a different resistor value than the one on the board, then you can remove these lines and use external resistors.The pin names are in the comments in the constraints file, and they correspond to the labels in first diagram in the Zybo Schematics page which can be found here.  If you want to use different pmod pins just match the names in the constraint file to the labels in schematic. We use PMOD header JE and JD, and use six data pins on each, omitting pins 1 and 7. This information is important when hooking up your sensors. As shown in the schematic, pins 6 and 12 on the PMODS are VCC and pins 5 and 11 are ground. Regenerate the HDL wrapper as before, and copy and overwrite the old one. When that's done, generate bitstream and export hardware like before, and relaunch the SDK. If you get asked whether you want to replace the old hardware file, the answer is yes. It's probably best to have the SDK closed when you export hardware so that it gets properly replaced.  Launch the SDK.", "step_imgs": ["https://cdn.instructables.com/FVA/4KYA/JAMTZ2YE/FVA4KYAJAMTZ2YE.LARGE.jpg"], "step_title": "Step 2: Make Some Changes in Vivado"}, {"step": 3, "steps_text": "The next step is to get FreeRTOS running on the Zybo board. If you don't already have a copy, download FreeRTOS here and extract the files.   Import the FreeRTOS Zynq demo located at FreeRTOSv9.0.0\\FreeRTOS\\Demo\\CORTEX_A9_Zynq_ZC702\\RTOSDemo. The import process is pretty much the same as it was for the other demo project, however because the FreeRTOS Zynq demo relies on other files in the FreeRTOS folder, you should not copy the files into your workspace. Instead, you should place the whole FreeRTOS folder inside your project folder.Create a new board support package by going to \"file\" -> \"new\" -> \"board support package\". Make sure standalone is selected and click finish. After a moment a window will pop up, check the box next to lwip141 (this stops one of the FreeRTOS demos from failing to compile) and hit OK. After that completes right click on the RTOSdemo project and go to \"properties\", go to the \"project references\" tab, and check the box next to the new bsp you created. Hopefully it will be recognized but sometimes the Xilinx SDK can be weird about this sort of thing. If you still get an error after this step that xparameters.h is missing or something like that then try repeating this step and maybe exiting and relaunching the SDK. ", "step_imgs": [], "step_title": "Step 3: Get FreeRTOS Running"}, {"step": 4, "steps_text": "Now that FreeRTOS is imported, you can bring the files from the laser harp project into the FreeRTOS demoCreate a new folder under the src folder in the FreeRTOS demo and copy and paste all of the provided c files except for main.c into this folder. Replace the RTOSDemo main.c with the provided main.c. If everything is done correctly, you should be able to run the laser harp code at this point. For testing purposes, the button input that was used in the DMA demo project is now used to play sounds without sensors attached (any of the four main buttons will work). It will play a string each time you press it and cycle through all the strings in the system over multiple presses. Plug in some headphones or speakers to the headphone jack on the Zybo board and make sure you can hear the sounds of the strings coming through when you press a button.", "step_imgs": [], "step_title": "Step 4: Add Laser Harp Code"}, {"step": 5, "steps_text": "Many of you reading this tutorial are likely here to learn how to set up audio or use DMA to do something different, or to create a different musical instrument. For that reason the next few sections are dedicating to describing how the provided code works in conjunction with the hardware previously described to get a working audio output using DMA. If you understand why the code pieces are there then you should be able to adjust them for whatever it is that you want to create.InterruptsFirst I'll mention how interrupts are created in this project. The way we did it was by first creating an interrupt vector table structure which keeps track of the ID, interrupt handler, and a reference to the device for each interrupt. The interrupt IDs come from xparameters.h. The interrupt handler is a function we wrote for the DMA and GPIO, and the I2C interrupt comes from the Xlic I2C driver. The device reference points to instances of each device which we initialize elsewhere. Near the end of the _init_audio function a loop goes through each item in the interrupt vector table and calls two functions, XScuGic_Connect() and XScuGic_Enable() to connect and enable the interrupts. They reference xInterruptController, which is an interrupt controller created in the FreeRTOS main.c by default. So basically we attach each of our interrupts to this interrupt  controller which was already created for us by FreeRTOS.DMAThe DMA initialization code starts in lh_main.c. First a static instance of a XAxiDma structure is declared. Then in the _init_audio() function it gets configured. First the configure function from the demo project gets called, which is in dma.c. It's pretty well documented and comes straight from the demo. Then the interrupt gets connected and enabled. For this project only the master-to-slave interrupt is required, because all data is being sent by the DMA to the I2S controller. If you wish to record audio, you will also need the slave-to-master interrupt. The master-to-slave interrupt gets called when the DMA finishes sending out whatever data you told it to send. This interrupt is incredibly important for our project because every time the DMA finishes sending out one buffer of audio samples it must immediately begin sending out the next buffer, or else an audible delay would occur between sends. Inside the  dma_mm2s_ISR() function you can see how we handle the interrupt. The important part is near the end where we use xSemaphoreGiveFromISR() and portYIELD_FROM_ISR() to notify _audio_task() that it can initiate the next DMA transfer. The way we send constant audio data is by alternating between two buffers. When one buffer is being transmitted to the I2C block the other buffer is having its values calculated and stored. Then when the interrupt comes from the DMA the active buffer switches and the more recently written buffer starts being transferred while the previously transferred buffer starts getting overwritten with new data. The key part of the _audio_task function is where fnAudioPlay() gets called. fnAudioPlay() takes in the DMA instance, the length of the buffer, and a pointer to the buffer from which data will be transferred. A few values are sent to I2S registers to let it know more samples are coming. Then XAxiDma_SimpleTransfer() gets called to initiate the transfer. I2S Audioaudio.c and audio.h are where the I2S initialization takes place. I2S initialization code is a pretty common chunk of code that's floating around in a number of places, you might find slight variations from other sources but this one should work. It's pretty well documented and not much needed to be changed for the harp project. The DMA audio demo which it came from has functions for switching to the mic or line inputs so you can use those if you need that functionality.Sound SynthesisTo describe how the sound synthesis works, I am going to list each of the sound models used in development that led to the final method, as it will give you a sense of why it is done the way it is done.Method 1: One period of sine values is calculated for each string at the corresponding frequency for that string's musical note and stored in an array. For example, the length of the array will be the period of the sine wave in samples, which equals # of samples / cycle. If the sampling rate is 48kHz and the note frequency is 100Hz, then there are 48,000 samples/second and 100 cycles/second leading to 4800 samples per cycle, and the array length will be 4800 samples and will contain the values of one complete sine wave period. When the string is played, the audio sample buffer is filled by taking a value from the sine wave array and putting it into the audio buffer as a sample, then incrementing the index into the sine wave array so that using our previous example over the course of 4800 samples one sine wave cycle is put into the audio buffer. A modulo operation is used on the array index so that it always falls between 0 and the length, and when the array index goes over a certain threshold (like maybe 2 seconds worth of samples) the string is turned off. To play multiple strings at the same time, keep track of each strings' array index separately and add the value from each strings' sine wave together to get each sample.Method 2: To create a more musical tone, we start with the previous model and add harmonics to each fundamental frequency. Harmonic frequencies are frequencies which are integer multiples of the fundamental frequency. Unlike when two unrelated frequencies are summed together, which results in two distinct sounds being played simultaneously, when harmonics are added together it continues to sound like just one sound, but with a different tone. To accomplish this, each time we add the value of the sine wave at location (array index % array length) to the audio sample, we also add (2 * array index % array length), and (3 * array index % array length), and so on for however many harmonics are desired. These multiplied indices will traverse the sine wave at frequencies which are integer multiples of the original frequency. To allow for more control of tone, each harmonic's values are multiplied by a variable which represents the amount of that harmonic in the overall sound. For example, the fundamental sine wave might have it's values all multiplied by 6 to make it more of a factor in the overall sound, while the 5th harmonic might have a multiplier of 1, meaning its values contribute much less to the overall sound.Method 3: Okay, so now we've got very nice tone on the notes, but there's still a pretty crucial problem: they play at a fixed volume for a fixed duration. To sound at all like a real instrument the volume of a string being played should decay smoothly over time. In order to accomplish this, an array is filled with the values of an exponentially decaying function. Now when the audio samples are being created, the sound coming from each string is calculated like in the previous method but before it gets added to the audio sample it gets multiplied by the value at that strings' array index in the exponential decay function array. This makes the sound smoothly dissipate over time. When the array index reaches the end of the decay array, the string is stopped.Method 4: This last step is what really gives the string sounds their realistic string sound. Before they sounded pleasant but clearly synthesized. To try to better emulate a real-world harp string, a different decay rate is assigned to each harmonic. In real strings, when the string is first struck there is a high content of high frequency harmonics that creates the sort of plucking sound we expect from a string. These high frequency harmonics are very briefly the main part of the sound, the sound of the string being struck, but they decay very quickly as the slower harmonics take over. A decay array is created for each harmonic number used in sound synthesis each with its own decay rate. Now each harmonic can be independently multiplied by the value its corresponding decay array at the array index of the string and added to the sound.Overall the sound synthesis is intuitive but calculation heavy. Storing the entire string sound in memory at once would take too much memory, but calculating the sine wave and the exponential function between every frame would take way too long to keep up with the rate of audio playback. A number of tricks are used in the code to speed the calculation up. All math except in the initial creation of the sine and exponential decay tables is done in integer format, which requires spreading out the available numerical space in the 24 bit audio output. For example, the sine table is of amplitude 150 so that it is smooth but not so large that many strings played together can add to be over 24 bits. Likewise, the exponential table values are multiplied by 80 before being rounded to integers and stored. The harmonic weights can take on discrete values between 0 and 10. Also all samples are actually doubled and the sine waves are indexed by 2's, effectively halving the sampling rate. This limits the maximum frequency that can be played, but was necessary for the current number of strings and harmonics to be calculated quickly enough.Creating this sound model and getting it to work took considerable effort on the processor side, and it would've been incredibly difficult to get it working on the fpga side from scratch in the time frame of this project (imagine having to recreate the bitstream every time a piece of verilog was changed to test the sound). However, doing it on the fpga could likely be a better way of doing it, possibly eliminating the issue of not being able to calculate samples quickly enough and allow for more strings, harmonics, and even audio effects or other tasks to be run on the processor side.", "step_imgs": [], "step_title": "Step 5: About the Code"}, {"step": 6, "steps_text": "To create the strings we used IR break beam sensors that will detect when the string is being played. We ordered our sensors from the following link. The sensors have a power, ground, and data wire while the emitters only have a power and ground wire. We used the 3.3 V and ground pins from the PMOD headers to power both the emitters and sensors. To power all the sensors and emitters it is necessary to connect all the sensors and emitter in parallel. The data wires from the sensors will each need to go to their own pmod pin. ", "step_imgs": ["https://cdn.instructables.com/FD1/YYKY/JAMTW096/FD1YYKYJAMTW096.LARGE.jpg"], "step_title": "Step 6: Wiring Up the Sensors"}, {"step": 7, "steps_text": "In order to create the shape of the harp the three pieces are used as a skeleton to place the sensors and emitters on. On one of the two 18 inch pieces of PVC pipe align the sensors and emitters in alternating order 1.5 inches from each other and then tape them down to the pipe. On the other 18 inch PVC pipe align the sensors and emitters in alternating order but make sure to offset the order (i.e. if the first pipe had a sensor first the second should have an emitter first and vice versa). It will be necessary to solder longer wires on the data, power, and ground wires to ensure they will be able to reach the board.", "step_imgs": ["https://cdn.instructables.com/F1Q/BSA6/JAMTW1DW/F1QBSA6JAMTW1DW.LARGE.jpg"], "step_title": "Step 7: Constructing the Skeleton"}, {"step": 8, "steps_text": "This step is optional but it highly recommended. The wood exterior not only makes the harp look nice it also protects the sensors and wires from damage. The wood frame can be created by a hallow rectangular ring from wood. The inside of the rectangle needs to have an opening of at least 1-1/2 inches to fit the pipe and sensor skeleton. Once the frame is constructed drill two holes that will allow the wires from the sensor and emitters out in order to connect them with the board.*Note: It is recommended to add access points to be able to remove and insert the pipe skeleton in case repairs need to be made or slight adjustments need to be made.", "step_imgs": ["https://cdn.instructables.com/FUT/IB4P/JAMTW1ZF/FUTIB4PJAMTW1ZF.LARGE.jpg"], "step_title": "Step 8: Building the Wood Exterior"}, {"step": 9, "steps_text": "Once all the previous steps are finished it is time to construct the harp. First place the pipe skeleton inside the wooden exterior. Then plug in the wires for the sensors and emitters into the correct location on the board. Then open the SDK and click the debug button to program the board. Once the board is programmed plug in a pair of headphones or a speaker. Depending on which sensor ends up in which pmod port your harp's strings will probably be out of order to begin with. Because it can be difficult to tell which wire goes to which sensor when so many wires are involved, we included a way to map string numbers to interrupt bit positions in software. Find \"static int sensor_map[NUM_STRINGS]\" and adjust the values in the array until the strings play from lowest to highest in order. The menu can be used by opening a serial terminal (e.g. RealTerm) and set the baud rate to 115200 and the display to ANSI. The menu can be navigated by using the w and s keys to move up and down and the a and d keys to change the values.", "step_imgs": ["https://cdn.instructables.com/FHG/MVHR/JAMTW24J/FHGMVHRJAMTW24J.LARGE.jpg"], "step_title": "Step 9: Putting All the Pieces Together"}, {"step": 10, "steps_text": "Once the harp is fully functional. Master the harp and listen to the sweet sound of your own music!", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 10: ROCK OUT"}], "channel": "Microcontrollers"}, {"category": "technology", "description": "In our modern day world, sound and light are what makes up society. Everywhere you go light and sound are present, whether in Times Square or at a concert both are there. In an attempt to combine the two, a code was made where LEDs were turned on based on sound frequencies. ", "title": "Microphone Lights LED ", "url": "https://www.instructables.com/id/Microphone-Lights-LED/", "section": "technology", "steps": [{"step": 1, "steps_text": "1. Arduino 2. Wires3. Microphone4. 7 LEDs5. Breadboard6. Resistor*pictures are in order of parts", "step_imgs": ["https://cdn.instructables.com/FT6/ZVIS/JB2S3G35/FT6ZVISJB2S3G35.LARGE.jpg", "https://cdn.instructables.com/FM7/G3GM/JB2S3G3Q/FM7G3GMJB2S3G3Q.LARGE.jpg", "https://cdn.instructables.com/F9A/DVGX/JB2S3G45/F9ADVGXJB2S3G45.LARGE.jpg", "https://cdn.instructables.com/FRV/G98A/JB2S3G4L/FRVG98AJB2S3G4L.LARGE.jpg", "https://cdn.instructables.com/FOU/JUGX/JB2S3G50/FOUJUGXJB2S3G50.LARGE.jpg", "https://cdn.instructables.com/FPX/2NTT/JB2S3G61/FPX2NTTJB2S3G61.LARGE.jpg"], "step_title": "Step 1: Parts "}, {"step": 2, "steps_text": "After the idea of lighting LEDs based on sound was agreed on, a code was needed. In order to make sure each light was independently accounted for a code, we needed to give each light a code as to when they should light up. Based on the sound the microphone measures the lights would respond accordingly. The sound range of our lights varies from 5-1000. This means that every light would light at a certain point between 5-1000. Each light was programmed to their own 'off and on' code. The code goes as such:void setup() {// put your setup code here, to run once:Serial.begin(9600);pinMode(A0, INPUT);pinMode(6, OUTPUT);pinMode(5, OUTPUT);pinMode(7, OUTPUT);pinMode(2, OUTPUT);pinMode(3, OUTPUT);pinMode(4, OUTPUT);}void loop() {// put your main code here, to run repeatedly:int val = analogRead(A0);Serial.println(val);if (val > 750) {digitalWrite(6, HIGH);}if (val < 750) {digitalWrite(6, LOW);}if (val > 850){digitalWrite(5, HIGH);}if (val < 850) {digitalWrite(5, LOW);}if (val > 900) {digitalWrite(7, HIGH);}if (val < 900) {digitalWrite(7, LOW);}if (val > 1000) {digitalWrite(3, HIGH);}if (val < 1000) {digitalWrite(3, LOW);}if (val > 5) {digitalWrite(2, HIGH);}if (val < 5) {digitalWrite(2, LOW);}if (val > 100) {digitalWrite(1, HIGH);}if (val < 100) {digitalWrite(1, LOW);}if (val > 200) {digitalWrite(3, HIGH);}if (val < 200) {digitalWrite(3, LOW);}if (val > 600) {digitalWrite(4, HIGH);}if (val < 600) {digitalWrite(4, LOW);}}", "step_imgs": ["https://cdn.instructables.com/FKU/3X1S/JB2S3GBA/FKU3X1SJB2S3GBA.LARGE.jpg"], "step_title": "Step 2: Coding "}, {"step": 3, "steps_text": "In order to make sure the code and board function perfectly together, it must be built accordingly. *referring to picture 1Explanation: Each wire must correspond one LED and the Arduino. *referring to picture 2Explanation: Be sure to include a resistor *referring to pictures 3 and 4Each wire goes to a specific place on the Arduino so make sure it is followed exactly as the picture shows", "step_imgs": ["https://cdn.instructables.com/FV9/ZSXT/JB2S3FEH/FV9ZSXTJB2S3FEH.LARGE.jpg", "https://cdn.instructables.com/FA3/O23A/JB2S3FDE/FA3O23AJB2S3FDE.LARGE.jpg", "https://cdn.instructables.com/FVW/YRUJ/JB2S3FCB/FVWYRUJJB2S3FCB.LARGE.jpg", "https://cdn.instructables.com/FEQ/26PK/JB2S3FFO/FEQ26PKJB2S3FFO.LARGE.jpg"], "step_title": "Step 3: Building "}], "channel": "LEDs"}, {"category": "technology", "description": "CPE 133, Cal Poly San Luis ObispoProject Creators: Jayson Johnston and Bjorn NelsonIn today\u2019s music industry, one of the most commonly used \u201cinstruments\u201d is the digital synthesizer. Every genre of music, from hip-hop to pop and even country, uses a digital synthesizer in the studio to create the beats and sounds they need to bring their music to life. In this tutorial, we will be creating a very simple synthesizer with the Basys 3 FPGA board.The synthesizer will be able to play four selected quarter notes at a constant number of beats per minute. Users will use the switches to assign each quarter note to a musical pitch. For this project we are using a 4-bit digital to analog converter (DAC) to take the output from the board and convert it into an analog signal. The output from the DAC will then be fed to a standard computer speaker, creating our music. Sixteen discrete pitches are possible. We will restrict our synthesizer to a single octave of 12 notes, which fall between middle C (261.6 Hz) and B4 (493.9 Hz). The user will also have the option of assigning multiple notes at the same time, as well as assigning a rest by hitting assign while having none of the pitch switches shifted upward. As each note is selected and being played, the letter note is shown on the 7-segment display. We will also be using three of the buttons on the board, one for playing and pausing the music, one for resetting the synthesizer and putting it into \u201cselection\u201d mode, and the third for assigning each note a pitch while in selection mode. Once the user is satisfied with their choice of notes, and after pressing the play button, the synthesizer will play each note in succession repeatedly until the user either presses pause or select.Here is a list of the required equipment:Vivado (or any VHDL work space)      Basys 3 or similar FPGA board      Digital to analog converter (min. 4-bits)      Speaker with headphone jack      Wire leads", "title": "4 Step Digital Sequencer", "url": "https://www.instructables.com/id/4-Step-Digital-Sequencer/", "section": "technology", "steps": [{"step": 1, "steps_text": "The following steps are to operate the digital sequencer. The digital sequencer supports the playback of 12 distinct pitches (C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B), which range from 261.6 Hz to 493.9 Hz.1. Press the left button to put the board into selection mode. When in this mode, the leftmost 4 switches (switches 13 to 16) will each be used to store a distinct pitch value.2. To make a selection, flip one of the left switches on, and then use the rightmost 4 switches (switches 1 to 4) to choose a desired pitch. The pitch associated with a specific combination of right switches will be shown on the seven segment display, and the display will update to the new associated pitch whenever the right switches are shifted to a new combination. A rest can be assigned by never assigning a pitch to one of the left switches, or by assigning a pitch shown as 0 on the display to the note. Once the desired pitch has been found and is shown on the display, press the bottom assign button to assign that specific pitch to the note.3. Repeat step 2 for the three remaining notes, by flipping each of the remaining left switches on individually, choosing the respective pitch with the right switches, and pressing the bottom button to assign the pitch to the note. Multiple notes can be assigned the same pitch by shifting more than one of the left switches upward at the same time.4. Now that all of the note pitches have been assigned, the digital sequencer is ready to play. To play the notes on the speaker, simply press the right play/pause button to begin playing the music. The order of the playback sequence mirrors the pitches associated with the left switches, from left to right. The notes will be played at a set number of beats per minute, in the order 1, 2, 3, 4, 1, 2.... The display will show the note that is currently playing as the speakers play the music. To pause the music playback, simply press the right button, and then the music will stop playing and a pause symbol will be shown on the display. Pressing the right button again will resume playback.", "step_imgs": ["https://cdn.instructables.com/FBV/YGI8/JAMU2QAV/FBVYGI8JAMU2QAV.LARGE.jpg"], "step_title": "Step 1: User Operation of Digital Sequencer"}, {"step": 2, "steps_text": "Our synthesizer makes use of many different digital components. Included are finite state machines, registers, multiplexers, clock dividers and more. To build our synthesizer, we used 10 unique modular files. Rather than making each module a component, we broke the modular files down by function. Most modules, as a result, are more than one component. Note the image above shows every block tied together in our top design.We will discuss each module by describing the inputs and outputs, breaking down its components, and explaining its purpose in the overall design. A ZIP file is included at the bottom of the instructable, which contains every VHDL code file used in the project.InputsClk (native clock signal) PP (play/pause) Sel (put synthesizer in selection mode) Assign (assign a step to a pitch) Step (the positional notes) Freq (the switches creating the desired pitch)OutputsAnode (7-segment anodes) Cathode (7-segment cathodes) DAC (4-bits driving the DAC)", "step_imgs": ["https://cdn.instructables.com/FZB/LJLS/JAMTVWBX/FZBLJLSJAMTVWBX.LARGE.jpg"], "step_title": "Step 2: Technical Details"}, {"step": 3, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F11/TH6U/JAMU2QAU/F11TH6UJAMU2QAU.LARGE.jpg"], "step_title": "Step 3: Technical Details"}, {"step": 4, "steps_text": "Our synthesizer makes use of three clock dividers, all producing signals that serve a different purpose in our project. A clock divider takes a native clock signal and produces an altered signal which has a frequency that is less than the original clock signal. The native clock of the Basys 3 is 100 MHz. This is the frequency that our clock dividers utilize. If you are using a different FPGA board with a different native clock frequency, you may have to alter the code.The 7-segment clock divider produces a signal which drives the seg_display file. We will explain how this file works in more detail when we get to its section. Essentially, this clock divider produces a 240 Hz signal that will be used to switch between anodes and cathodes on the display. The signal is 240 Hz because the frequency at which the human eye cannot recognize the absence of light is 60 Hz. We are using two digits, so by doubling this frequency, each digit will oscillate at 60 Hz. Then we double it get to get 240 Hz because the system is only changing when the signal goes high, not when it goes low.To achieve this, the divider takes the native 100 MHz signal and counts up on every rising edge. When the counter reaches 416667, the output will go from low to high, or vice versa.InputsClk (native clock signal)OutputsClk_7seg (to seg_display)ComponentsD register   MUX   Inverter   Adder", "step_imgs": ["https://cdn.instructables.com/FOH/GUYH/JAMTVXTP/FOHGUYHJAMTVXTP.LARGE.jpg"], "step_title": "Step 4: 7-segment Clock Divider"}, {"step": 5, "steps_text": "The BPM clock divider works in a similar manner. This divider produces the clock frequency which drives the switching between the four steps when outputting tones in the play state. We decided on switching between notes at 100 BPM. At 100 BPM, each note will be played for 3/5 of a second. The resulting signal would have a frequency of 1.67 Hz.To produce a signal of this frequency, we again used a counting system, but this time the count was 60 million. Every time the counter hit 60 million, the output signal would toggle high or low. InputsClk (native clock frequency)OutputsClk_BPM (to output_FSM)ComponentsD register   MUX Inverter   Adder", "step_imgs": ["https://cdn.instructables.com/F4B/HD93/JAMTVY64/F4BHD93JAMTVY64.LARGE.jpg"], "step_title": "Step 5: Beats Per Minute Clock Divider"}, {"step": 6, "steps_text": "The Pitches Clock Divider is the largest of our clock dividers. This divider outputs 12 different signals corresponding to the 12 different notes that our synthesizer can play. Using basic knowledge of music theory, we deduced that a bit or bus could oscillate at a rate which corresponds to the frequency of musical notes. To see the frequencies we used, look here. We used the fourth octave of pitches.The same counting system is used here. For the specific values we counted to, see the file labeled Clk_div_pitches.InputsClk (native clock frequency)OutputsC, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B (to output_select)ComponentsD register    MUX    Inverter    Adder", "step_imgs": ["https://cdn.instructables.com/FGF/6NZC/JAMTVYOQ/FGF6NZCJAMTVYOQ.LARGE.jpg"], "step_title": "Step 6: Pitches Clock Divider"}, {"step": 7, "steps_text": "In our project there are two finite state machines (FSM). A FSM is a logic device that can exist in only one state out of a finite amount of states. Using a FSM, a digital circuit can move to a new state based on a combination of inputs. Using input logic, the state of an FSM will change when there is a rising edge of the clock. From the state and inputs into the circuit, you can create output logic that gives outputs that only exist if the FSM is in a certain state.The PPS state machine is the first FSM in our circuit. There are three states in this FSM; Play, Pause, and Selection mode. To move through the different states, we used the PP and Selection buttons. See the state diagram above to see how transitions between states occur. We made this FSM transition on the rising edge of the native 100 MHz clock, so that it would be impossible for the machine to not transition when one of the buttons was pressed, even for a very short amount of time. The present state (P_state) is the only output from this module. InputsClk (native clock frequency)  Sel (left button)  PP (right button)OutputsP_state (present state, to output_FSM, note_assign, seg_dsiplay, final_select)ComponentsMUX  D register", "step_imgs": ["https://cdn.instructables.com/FK2/73QM/JAMU1V66/FK273QMJAMU1V66.LARGE.jpg"], "step_title": "Step 7: Play/Pause/Select State Machine"}, {"step": 8, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FY8/H9M9/JAMU1V7G/FY8H9M9JAMU1V7G.LARGE.jpg"], "step_title": "Step 8: Play/Pause/Select State Machine"}, {"step": 9, "steps_text": "This is the second FSM referenced in the previous section. This FSM serves a different function than the other, but the basis for this one is essentially the same.The output FSM only operates if the present state from the first FSM is \"01\" (the play state). Essentially, this is the enable in for the module. If the state is \"01\", then the FSM is going to switch between states on the rising edge of the BPM clock signal. We do this because the output_FSM is controlling which binary number for the selected pitch gets sent to the output_select and seg_display modules. The FSM has a 16-bit input coming from the note assign module, which will be covered next. In the \"00\" state for the output_FSM, the module will output \"xxxx\" for the first note assigned. Then in \"01\", it will output \"yyyy\" for the second note and so on for each note before rolling back over to the first note. See the state diagram above.This FSM differs from the first because there is no input logic to control switching between states. Instead, the FSM is only going to operate when the state from the first FSM is \"01\", and then this FSM will transition between states only on the rising edge of the clock signal. Another difference is that this module has output logic, meaning it doesn't output the present state, it outputs the binary number for the pitch at that state.InputsClk_BPM (BPM clock signal from clock divider)    FSM1_state (PS from PPS FSM)    Pitch_in (pitches from note_assign)OutputsPitch_out (one pitch at a time, to output_select and seg_display)ComponentsMUX  D register", "step_imgs": ["https://cdn.instructables.com/FWC/MIQY/JAMU1XMP/FWCMIQYJAMU1XMP.LARGE.jpg"], "step_title": "Step 9: Output FSM"}, {"step": 10, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FS2/ID5F/JAMU1XR3/FS2ID5FJAMU1XR3.LARGE.jpg"], "step_title": "Step 10: Output FSM"}, {"step": 11, "steps_text": "The note assign module is responsible for actually assigning a pitch to the positional note, or step. This module is actually quite simple. It first checks if the circuit is in the \"selection\" state and if a step switch (far left) is high. If this is true and the assignment button is pressed, the output of the module will be equal to the binary number represented by the frequency switches (far right). Originally, we had attempted to make a module that would actually save one of the pitch clock signals to the output, but we experienced issues with the output changing to follow the input clock signals. This is the only module used more than once in the final design. Every step has a note_assign module associated with it, and because of that, each instance of the module gets one bit of the Step bus.InputsP_state (present state from PPS FSM)  Sel (left button)  Switch (one step switch)  Freq (far right switches for pitch)  Assign (bottom button, assigns a note)OutputsPitch (binary number, to output_FSM)ComponentsMUX  D resgister", "step_imgs": ["https://cdn.instructables.com/FKQ/PXOC/JAMU1YZA/FKQPXOCJAMU1YZA.LARGE.jpg"], "step_title": "Step 11: Note Assign"}, {"step": 12, "steps_text": "Output select is responsible for taking the binary number for a pitch and connecting that to its respective clock signal. Despite its size, this is also a relatively simple module. Output_select is essentially a binary decoder, decoding the binary number for a pitch to a specific clock signal. Actually assigning the output to a clock frequency worked better here compared to the note_assign module, because all this module had to do was MUX the clock signals with the binary number representing the control input. We apologize for the strange routing, Vivado organized the pitch signals alphabetically for the clk_div_pitches file, but for this file it organized them by ascending binary number, causing the pitches to be in a different order. Also note that if the binary number from the output_FSM was \"0000\" or anything greater than \"1100\", then the MUX sent through a flat '0' signal. InputPitch (from output_FSM);  C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B (pitch clock signals)OutputTone (a single bit which matches the selected clock signal, to square_wave)ComponentsMUX", "step_imgs": ["https://cdn.instructables.com/FLS/9V08/JAMU20LQ/FLS9V08JAMU20LQ.LARGE.jpg"], "step_title": "Step 12: Output Select"}, {"step": 13, "steps_text": "Module square_wave is the generator for the square wave that is outputted from the board to the DAC. Using the tone signal from the previous file, this square_wave inverts the 4 bit number between \"0000\" and \"1111\" on the rising edge of Tone. Tone is a specific pitch frequency, so square_wave produces a wave with a different frequency when output_FSM transitions to another state. The 4-bit output from this module goes to the fin_sel module, where logic dictates whether this bus will be outputted based on the state from PPS FSM.An alternative to this square wave generator is producing a sine wave. While this would most likely produce a better final tone, it is considerably more difficult to implement, so we opted to just generate a square wave.InputsTone (oscillating bit from output_select)OutputsDAC_input (oscillating 4-bit bus that changes at same frequency of tone)ComponentsInverter  D register", "step_imgs": ["https://cdn.instructables.com/FQQ/JNJC/JAMU21SK/FQQJNJCJAMU21SK.LARGE.jpg"], "step_title": "Step 13: Square Wave Gen"}, {"step": 14, "steps_text": "The seg_display module controls the 7-segment display on our basys board. Within the module, two processes occur. The first process decodes Freq when in the \"selection\" state or Pitch when in \"play\" mode. In \"pause\" mode, the module decodes to show the pause symbol. Looking at the VHDL code, you can see that the binary decoder actually decodes the input into two different signals, cathode1 and cathode2. Cathode1 represents the letter corresponding to the pitch to be displayed, and cathode2 represents the flat symbol (b) if there is one. The reason for this relates to the second process done by the seg_display module.On a basys3 board, the segment display has common cathodes. While the anodes control which digit is turned on, the cathodes control which segments are on. Since the display has common cathodes, that means you can only display one set of segments at a time. That poses an issue for this project because we want to display a letter at the first digit and the flat symbol, if necessary, at the same time. Now remember the 7seg clock signal? To get around this issue, we change the anodes and cathodes back and forth on the 7seg clock signal. Because the clock signal is 240 Hz and we're using two digits, each digit will oscillate at 60 Hz. To the human eye, it will look like the digits aren't oscillating at all. Also note that the basys3 board display uses negative logic. This means if an anode or cathode is set to '0', that digit or segment will be on, and vice versa.InputsPitch (binary number for a note, used in play state)  Freq (frequency switches, used when in selection state)  P_state (present state from PPS FSM)  Clk_240Hz (clock signal from Clk_div_7seg, double 120 because we are only using the rising edge)OutputsCathode (bus which controls segments on the display, final output)  Anode (bus which controls digits on the display, final output)ComponentsLatch  MUX  D register", "step_imgs": ["https://cdn.instructables.com/FC8/LSOI/JAMU24RJ/FC8LSOIJAMU24RJ.LARGE.jpg"], "step_title": "Step 14: 7-segment Display"}, {"step": 15, "steps_text": "Final select is the last module used in this project. Another simple module, this module controls the final output that will be going to the DAC. When in the \"selection\" or \"pause\" state, the module is going to output a static \"0000\" so that no music will be played from the speakers. In the \"play\" state, the module will output the oscillating 4-bits as determined by square_wave.InputsP_state (present state from PPS FSM) DAC_input (the oscillating 4-bits from square_wave)OutputsDAC (equals DAC_input in play state, final output)ComponentsMUX", "step_imgs": ["https://cdn.instructables.com/FSP/C65Z/JAMU25OB/FSPC65ZJAMU25OB.LARGE.jpg"], "step_title": "Step 15: Final Select"}, {"step": 16, "steps_text": "A digital to analog converter (DAC) takes a discrete signal and converts it into a continuous signal. Our DAC has four bits and is made from a summing amplifier. By using a ratio of resistors in the supply and feedback loop, we were able to create a system that outputs at 16 different levels creating by the \"summing\" of each branch. Bit0, the top branch, carries the least weight and contributes the smallest potential when high because of that branches higher resistance. The weight increases as you go down the branches. If you were to count in binary up and then back down using the bit inputs, the output voltages would look like a step wise sine wave. The input to the DAC was connected to the one of the PMODs on the board to transfer the 4-bit signal.The DAC was originally assembled for an Electrical Engineering class and was designed and soldered by us, not bought from a store. Above is an image of the design file for creating the printed circuit board. ", "step_imgs": ["https://cdn.instructables.com/FM7/HES5/JAMU270H/FM7HES5JAMU270H.LARGE.jpg"], "step_title": "Step 16: External Devices: DAC"}, {"step": 17, "steps_text": "For this project, you aren't going to want to buy a super nice pair of speakers. As you can tell, the sound is pretty basic. We went and bought a $8 set of computer speakers from Best Buy. Anything with a headphone jack works fine. Monotone works fine as well. You can even use headphones, but you might blow them out! To connect the output of the DAC to the speakers, we used jumper cables and then held the output cable to the tip of the headphone jack and the cable for ground to the base. We tried using electrical tape to hold the cables in place, but it caused a lot of interference. Trying a different style of tape could solve this issue.For our speakers, we turned them to the highest setting and got a decently loud noise.And that is the last step for creating a digital sequencer from a FPGA board! Go to the next two sections to download all our VHDL code and see the sequencer in action.", "step_imgs": ["https://cdn.instructables.com/F5D/0A79/JAMU2RBB/F5D0A79JAMU2RBB.LARGE.jpg"], "step_title": "Step 17: External Devices: Speaker"}, {"step": 18, "steps_text": "This video shows the final version of the working project, including the process of assigning the switches to 4 distinct pitches, and the speakers playing the respective notes.", "step_imgs": [], "step_title": "Step 18: Video Demo"}, {"step": 19, "steps_text": "Here is the code for the entire project, including the constraint and sim files used while building the sequencer. Note that unused design files say so in the architecture.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 19: VHDL Code"}], "channel": "Electronics"}, {"category": "technology", "description": "Hello. Here i am with a new project named O-R-AIt is a RGB LED Matrix wall clock that display :hour:minute   temperature   humidity    current weather condition icon  Google Calendar events and 1h reminder notificationsat a specific time it shows:Google Calendar today and tomorrow events list   weather forecast   breaking newsAddictional functionalities:current date   Magic 8 ball   Kitchen timerFor any functionality the device play a different audio alarm. For all kind of weather conditions there's a corresponding audio file to be played when the functionality is called.The functionalities like Google Calendar list, Weather forecast, RSS breaking news starts at preselected time when device is in \"clock mode\", these can be also called directly operating the switches. Another functionality during \"clock mode\" display current day/month/year. It can be run pressing ENTER button. Pressing CHANGE STATE button and then ENTER button within 3 seconds in \"clock mode\", let you enter into options menu. CHANGE STATE button is sets to scroll inside menu,  ENTER button is to confirm option selected.This project is an evolution of my previous LEGOLED and TEMPO. The RGB led matrix panel has resolution 32x64 now, so it is possible display more intellegible graphics, fixed and scrolling text at the same time. Using TEMPO functionalities the device turn on & off automatically without any button or external timer. A PIR module detect the presence of persons therefore turn on/off display.Weather forecast and calendar data are collected every minute provided by Google Calendar and Open Weather Map .This project is fully customizable starting from a Raspberry PI B+, 2 module 16x64 rgb led matrix and power supply. It can be expanded, like i did, adding USB sound cards, speakers, on/off power circuit. ", "title": "O-R-A  RGB Led Matrix Wall Clock and More", "url": "https://www.instructables.com/id/O-R-A-RGB-Led-Matrix-Wall-Clock-and-More/", "section": "technology", "steps": [{"step": 1, "steps_text": "Raspberry Pi B+ (with built-in wifi or dongle )   2 x 16x64 RGB led matrix or 2 x 32x32   generic frame (40x50 cm & 3 cm depth approximately)   frosted plastic sheet   window solar film   PS 5V 10A   cables    thermosetting sheath (*)     relay module (*)   extra PS for audio amplifier (*)   3W audio amplifier module (*)   speakers (*)   USB sound card (*)   2 x microswitch (*)   PIR (*)   Attiny85 (*)   DS3231 (*)   Mosfet IRF540 (*)   Resistors: 3x1K, 2x10K, 1x2K (*)   terminal block (*)   header strips female (*)    header strips male (*)(*) optional", "step_imgs": [], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "This guide is basically based on Raspbian Jessie Lite, Python 2.7 and RGB LED MATRIX library by Hzeller Github user.First of all update & upgrade RPIInstall git~ $ sudo apt-get install gitDownload RGB LED MATRIX library from Github~ $ git clone https://github.com/hzeller/rpi-rgb-led-matrix.git~ $ cd rpi-rgb-led-matrix~ $ sudo makeblacklist RPI internal soundcard~ $ cat <<EOF | sudo tee /etc/modprobe.d/blacklist-rgb-matrix.conf~ $ blacklist snd_bcm2835~ $ EOF~ $ sudo update-initramfs -uSet external soundcard parameters if needs audio capabilities:~ $ nano /usr/share/alsa/alsa.confchange :defaults.ctl.card 0defaults.pcm.card 0todefaults.ctl.card 1defaults.pcm.card 1then reboot.Now install matrix library~ $ cd /home/pi/rpi-rgb-led-matrix~ $ sudo apt-get update && sudo apt-get install python2.7-dev python-pillow -y~ $ make build-python~ $ sudo make install-pythonand install other libraries needed:~ $ sudo easy_install pip~ $ sudo pip install httplib2Copy samplebase.py script  from ~/rpi-rgb-led-matrix/bindings/python/samples/ to home directoryGet API key registering for free to Open Weather MapInstall now OWM Python wrapper (thanks to CSPARPAGithub user)~ $ sudo pip install pyowmGet Google Calendar credential following instructions at Google calendar API~ $ sudo pip install --upgrade google-api-python-clientMove the credential downloaded file to your home directory and rename it to client_secret.jsonFor audio playing install Pygame~ $ sudo apt-get install python-pygameRSS feeds needs Feedparser installed~ $ sudo pip install feedparsercopy my script ORAeng_131.py (english version) or ORAita_131.py (italian version) to home directorycreate folders for sounds and pictures:mkdir dbsoundsmkdir owmdownload and copy all PNG files to owm folder and mp3 files to dbsounds folder from the following link:https://www.dropbox.com/sh/nemyfcj1a1i18ic/AAB1W7I6lg5EgqL1gJZPWVTxa?dl=0add your OWM credential to line 69 (API_key)set city for weather forecast (check if it's covered by OWM and the correct name accepted) at lines 213, 215obs =owm.weather_at_place('Napoli,IT') fc = owm.three_hours_forecast('Napoli,IT')try the script running~ $ sudo python ORAeng_131.py # or ORAita_131.py for italian versionat first time the script will ask GCAL authorization. Click the link to google api credential. Give permission then, if everthings it's ok, you'll see clock starts.Autostart it :~ $ sudo nano /etc/rc.localadd before exit 0(sleep 20;python /home/pi/ORAeng_131.py) >/dev/null 2>&1 & or '(sleep 20;python /home/pi/ORAita_131.py) >/dev/null 2>&1 &' for italian versiongive permissions to daemon user:~ $ sudo visudochange to:root   ALL=(ALL:ALL) ALLdaemon  ALL=(ALL) NOPASSWD: ALLdue to excessive RAM usage after several hours, i wrote a script that simply restart python script when RAM usage goes over a threshold level. Then copy to home directory the script named memcheck renaming to memcheck.sh and add to crontab -e*/1 * * * * bash /home/pi/memcheck.sh", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Raspberry Pi Setup"}, {"step": 3, "steps_text": "The main script needs to be modified accordingly your needs. Assuming that OWM and Goggle Calendar credentials are set as their respective  API instructions, the most important parameters are:calendar events list performing every hour at minute 2, 32 (see script line 65)weather conditions and forecast performing every hour at minute 7, 37 (see script line 66)breaking news performing every hour at minute 11 (see script line 67)breaking news rss channel. Inside script is set Instructable RSS, but can be changed. (see script line 366)Obviously, the script gives priority to incomings calendar event or reminder notifications. Sometimes clock doesn't perform its features to avoid crossing of functionalities.Attiny85 on/off timer needs to be programmed uploading the sketch Tempo_V1_9_1Mhz_bugfix.ino .This allow to turn on device at 8 in the morning and turn off at 23. See tutorial for more info.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 3: The Scripts"}, {"step": 4, "steps_text": "The circuit has basically 3 sections- power on/off timer handled by DS3231 module, Attiny85 and Mosfet- switch for manual control of clock features- connection section where is cabling for RGB LED Matrix datas and power, audio amplifier and Raspberry PiNot mentioned a resistive voltage divider that allow RPI to read a HIGH/LOW 5V signal from Attiny85Switches are connected to RPI pin an GND directly using internal resistorsAttiny85 timer come from my previous project named TEMPO. Basically, DS3231 sends LOW signal to Attiny85 interrupt pin that wake it from sleep mode. At wake up Attiny85 sends HIGH signal to Mosfet transistor, activating the power supply circuit for RPI, LED Matrix and audio amplifier (if not connected to extra PS thrugh a relay, as my last configuration). To shutdown RPI my script contemplate that RPI listen digital signal on pin 14, when it's HIGH, is called a shutdown command.  Then RPI perform a correct shutdown process, then after one minute, Attiny85 goes back to sleep mode and Mosfet receives a LOW signal that turn off the entire device. This process is rough but effective.PIR module is optional and connected directly to RPI GPIO.My configuration require that following RPI GPIO pins are connected to:15 to PIR14 to Attiny85 pin 3 through voltage divider21 to relay module2 to switch (ENTER BUTTON)3 to switch (CHANGE STATE BUTTON)Issues:- noise due to LED Matrix power supply, solved using a small PS only for the audio amplifier. An optional  relay allow to turn on amplifier only when required. This can cause a bump noise when it turns on/off.The circuit has been etched using copper plate, 3D printer, marker and ferric chloride.", "step_imgs": ["https://cdn.instructables.com/FNQ/LYTT/JJ4ZYGLO/FNQLYTTJJ4ZYGLO.LARGE.jpg", "https://cdn.instructables.com/FCX/SFT5/JJ4ZYGMU/FCXSFT5JJ4ZYGMU.LARGE.jpg", "https://cdn.instructables.com/FR2/H5CZ/JJ4ZYGNI/FR2H5CZJJ4ZYGNI.LARGE.jpg", "https://cdn.instructables.com/F1B/8DSM/JJ4ZYHY5/F1B8DSMJJ4ZYHY5.LARGE.jpg", "https://cdn.instructables.com/FLI/LVIU/JJ4ZYI4D/FLILVIUJJ4ZYI4D.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: The Circuit"}, {"step": 5, "steps_text": "i've adapted a generic  40x50cm frame to this project together 3D printed parts and some optional extras.The glass is shielded by window solar film  and frosted plastic sheet. Led matrix needs to be kept about 1cm to glass to avoid to see the white inside leds. Small screws are necessary as M3 nuts and bolts. Obligatory are cables and thermosetting sheath.Led matrices are screwed on the backside panel of the frame.", "step_imgs": ["https://cdn.instructables.com/FNS/NT9V/JJ4ZYGK6/FNSNT9VJJ4ZYGK6.LARGE.jpg", "https://cdn.instructables.com/FTD/SPTZ/JJ4ZYGKH/FTDSPTZJJ4ZYGKH.LARGE.jpg", "https://cdn.instructables.com/FFK/PXEE/JJ4ZYIHO/FFKPXEEJJ4ZYIHO.LARGE.jpg", "https://cdn.instructables.com/FKP/19MU/JJ4ZYIIP/FKP19MUJJ4ZYIIP.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 5: Assembling"}, {"step": 6, "steps_text": "The next step will be to add a temperature sensor, activation of bluetooth capabilities and, why not, an internet radio player until maximum Raspberry Pi potential.Bye", "step_imgs": ["https://cdn.instructables.com/FN7/BS7L/JJ4ZYJ82/FN7BS7LJJ4ZYJ82.LARGE.jpg", "https://cdn.instructables.com/F9S/D0AL/JJ4ZYJCY/F9SD0ALJJ4ZYJCY.LARGE.jpg"], "step_title": "Step 6: And Now ?"}], "channel": "Raspberry Pi"}, {"category": "technology", "description": "Hi!In this Instructable I will show you how to make a mood lamp that you can turn on by flipping it around, how cool is that!? This project is an exelent beginner project for people that want to get familiar with the ATtiny chip. The project is entered in theLamp Contest and the Led Contest. Please vot for me, I would love to win the 4 in 1 soldering station!", "title": "Turn Me On, an ATtiny RGB Mood Lamp", "url": "https://www.instructables.com/id/Turn-Me-On-an-Attiny-RGB-Mood-Lamp/", "section": "technology", "steps": [{"step": 1, "steps_text": "You need the following materials:Spice jar     RGB led with 4 pins     ATtiny85 IC     8 pin IC socket     Perfboard     Tilt switch     3V coin battery     3V coin battery holderYou need the following tools:Fretsaw      Solder iron with solder     ATTINY85 arduino programming shield (optional)You can make an attiny programming shield for the arduino yourself like I did but it is also possible to program the ATtiny chip with an broadboard. Randofo made an exelent tutorial for doing this.", "step_imgs": ["https://cdn.instructables.com/FPD/YTX7/ITQ32U46/FPDYTX7ITQ32U46.LARGE.jpg", "https://cdn.instructables.com/FJK/7E6L/ITQ32U6C/FJK7E6LITQ32U6C.LARGE.jpg", "https://cdn.instructables.com/FG0/M5ZA/ITQ32UAB/FG0M5ZAITQ32UAB.LARGE.jpg"], "step_title": "Step 1: Materials and Tools"}, {"step": 2, "steps_text": "In order to use a spice jar you have to remove some of the plastic material in order to place the electronics. Please follow the following steps and take a look at  the pictures above.Spice your food to the max to empty a nice spice jar! :)  Remove the grinding mechanism in the lid with the fretsaw (photo 1)   Widen a bid of the lid in order to fit the battery holder (photo 2)   Remove plastic at the top of the spice jar (photo 3)", "step_imgs": ["https://cdn.instructables.com/F54/5Q9E/ITTW6ML8/F545Q9EITTW6ML8.LARGE.jpg", "https://cdn.instructables.com/F4O/5XFC/ITTW6MOV/F4O5XFCITTW6MOV.LARGE.jpg"], "step_title": "Step 2: Prepare the Spice Jar"}, {"step": 3, "steps_text": "The electronics are rather easy. Please follow the four steps:Cut a piece of five by five from the perfboard with the fretsaw    Start with soldering the large components first and finish with the smaller components. Make sure to solder the ATtiny dip socket without ATtiny on the board to prevent thermal shocks.   When all the components are on the board connect the components on the other side of the board with soldering according to the provided Fritzing scheme.    Solder the perfboard to the bottom of the battery holder. Make sure to insert the battery after you finish the soldering.", "step_imgs": ["https://cdn.instructables.com/FUM/TW9H/ITTW6MRV/FUMTW9HITTW6MRV.LARGE.jpg", "https://cdn.instructables.com/F63/ML35/ITQ34B4P/F63ML35ITQ34B4P.LARGE.jpg", "https://cdn.instructables.com/FR0/PDR3/ITTW6MJZ/FR0PDR3ITTW6MJZ.LARGE.jpg"], "step_title": "Step 3: Electronics"}, {"step": 4, "steps_text": "The ATtiny chip is a small arduino with only 5 digital pins that you can use. Before you can use the attiny ship you have to program the ATtiny. There are various ways for doing this. You can use a broadboard and some wires or make your own ATtiny programming shield like I did.There are tons of projects on instructables that provide sketches for fading an RGB led. The best effect you get when the colours smoothly fade. In order to get this result you have to make use of a technique called Pulse Width Modulation. I made use of the following sketch:", "step_imgs": ["https://cdn.instructables.com/FX1/GSWF/ITQ32ZDW/FX1GSWFITQ32ZDW.ANIMATED.LARGE.gif"], "step_title": "Step 4: The Software"}, {"step": 5, "steps_text": "Put a nice sticker on top of the jar to inidcate how the unit can be turned on and test it!Have fun building and learning! Please let me know what you think of this instructable. I would love to make some improvements if necesarry.Regards, Vincent", "step_imgs": [], "step_title": "Step 5: Turn It On!"}], "channel": "LEDs"}, {"category": "technology", "description": "Led wave displau", "title": "LED Wave Display", "url": "https://www.instructables.com/id/LED-Wave-Display/", "section": "technology", "steps": [{"step": 1, "steps_text": "- Arduino Uno ($25)- 32 x 16 LED Matrix ($20)- Breadboard ($5)- Jumper Cables ($5)- USB A to B Cable ($3)- Computer- 5V 2Amp Power Supply ($10)- A basic understanding of coding in CIn order to create this project, many physical materials are necessary, a lot of which will not be found lying around at home. In order to do this project, you should go out to computer stores or look online for these products. Keep in mind that you can upgrade to larger LED boards or faster arduinos, but that would require some modification of this tutorial as the coding, wiring, etc, changes with the addition of different products. Overall, this project is a fun way for you to practice your engineering, circuitry, and computer science skills while making a device that shows off your music taste in a new light.", "step_imgs": ["https://cdn.instructables.com/F1P/ZHM8/IFWTWGB2/F1PZHM8IFWTWGB2.LARGE.jpg", "https://cdn.instructables.com/F1W/L4TS/IFWTWGB1/F1WL4TSIFWTWGB1.LARGE.jpg"], "step_title": "Step 1: Materials"}, {"step": 2, "steps_text": "- Arduino IDE (arduino.cc)- Processing Software (processing.org)- Soundflower (https://rogueamoeba.com/freebies/soundflower/)- Arduino LibrariesAs project is very heavy in coding, it will be necessary to download certain pieces of software to control the Arduino, rout the audio, and perform manipulations on the input tee sound waves. If unfamiliar with these programs, especially the Arduino IDE and the Processing Software, feel free to look ate the documentation beforehand, for help with the syntax and functions of the language. In both of these applications, the language is very similar to c and the logic behind the coding is relatively simple, so the task should not be too hard for someone with a basic understanding of computer science.", "step_imgs": ["https://cdn.instructables.com/F4P/CKQC/IFWRP2NA/F4PCKQCIFWRP2NA.LARGE.jpg", "https://cdn.instructables.com/F3D/UC24/IFWTWKEY/F3DUC24IFWTWKEY.LARGE.jpg"], "step_title": "Step 2: Software"}, {"step": 3, "steps_text": "- download the two necessary libraries:https://github.com/adafruit/RGB-matrix-Panelhttps://github.com/adafruit/Adafruit-GFX-LibraryThis is an important step because the libraries are what is necessary to control the lighting on the board. Libraries are large masses of code written by others that are meant to help make your coding more efficient, so that you do not have to create your own functions. In this case, these libraries were written to be able to control the LED panel. This saves us a great deal of time, because now we can draw something on the board with a few lines of code instead of the countless lines of code that layout the definition of drawLine in the library. In order to make these libraries work, you must place these libraries under documents/Arduino/libraries in your computer and restart your programs to allow it to load. Remember to use #include  and replace libraryname.name with the correct name of the library, in order to allow the code to be compatible with the library. What #include essentially does is it copies and pastes the code found in the library to the very front of the document, giving you access to the numerous functions, variables, and other features that the library provides. ", "step_imgs": ["https://cdn.instructables.com/F0F/1A0K/IFWTWKF1/F0F1A0KIFWTWKF1.LARGE.jpg"], "step_title": "Step 3: Getting the Libraries"}, {"step": 4, "steps_text": "- One of the major steps that needs to be done to complete this project is wiring the Arduino with the LED board, so that the Arduino can send signals to the LED board. Follow the images below to complete the wiring. On the Arduino uno, there are a multitude of pins, each having a label on the right or left side. Similarly, the connector that connects to the LED board has pins as well, just large enough to hold a jumper cable. The jumper cables will be able to make a connection between the two points and relay information without the need for soldering. The breadboard can also be a very helpful tool, preventing the hassle of having to solder. In the pictures below, my wiring is portrayed, with many black and white jumper cables.", "step_imgs": ["https://cdn.instructables.com/FT4/MCJY/IFWTWKEX/FT4MCJYIFWTWKEX.LARGE.jpg", "https://cdn.instructables.com/FAC/Z0QX/IFWTWKEZ/FACZ0QXIFWTWKEZ.LARGE.jpg"], "step_title": "Step 4: Connect the Wiring"}, {"step": 5, "steps_text": "- After completing the lighting, you are must connect the power source to the LED board so that the lights can turn on. The cable for the LED board comes along with the LED board. In order to turn on the power, you must plug this cord into the middle of the board and then attach the 5 volt 2 amp power supply to the two ends of the cord. Finally, you must plug the power supply into an outlet to generate the energy required to power the board.- The science behind the power of the LED board is that the power supply takes the alternating current from the outlet and converts it into a direct current, which the board can use as energy. Specifically, the board needs 5 volts and 2 amos in order to power the LED board at a minimum energy level", "step_imgs": ["https://cdn.instructables.com/FIO/PDD3/IFWTWKFD/FIOPDD3IFWTWKFD.LARGE.jpg", "https://cdn.instructables.com/FZZ/A1HI/IFWTWKFC/FZZA1HIIFWTWKFC.LARGE.jpg"], "step_title": "Step 5: Add the Power Source "}, {"step": 6, "steps_text": "- Now that all of the assembly of the device has been done, it is now time to write the code. First, we will start to write code in processing, creating a pde file. Essentially, what the code that you are going to write is going to do is take an audio input from the computer, which is going to be a song or sound that is played, and transcribe it into a series of waves that can be graphed. The way that this can be done is through the theory of fast Fourier transformations. Essentially, what this theory says is that sound waves can be interpreted with an algorithm and transformed into clean and easily graphable sine and cosine waves. Luckily, in the program that we are using, functions have already been created to help us get past having to code this complex algorithm by hand. If you would like to learn more about this idea read http://mathworld.wolfram.com/FastFourierTransform.html. Next, the information that is found out in the processing code is going to be relayed to the Arduino code, which takes in this input and creates a matrix that is to be displayed on the screen. In the Arduino code, which has a file extension of ino, multiple cases are going to be outlined, with certain heights and colors pertaining to a certain wave that the code is given. Using the libraries that we imported before, we are going to draw lines on the board with a quick refresh interval, to portray the differing waves that the sound creates. Below is a framework of the code, with some of the basic parts started for you. If you get stuck during this step, be sure to look into the library for functions that can be of use as well as the documentation of the c language, if you are unsure of syntax.", "step_imgs": ["https://cdn.instructables.com/F3X/NEAR/IFWTWKF5/F3XNEARIFWTWKF5.LARGE.jpg", "https://cdn.instructables.com/F11/IUHM/IFWTWKF6/F11IUHMIFWTWKF6.LARGE.jpg"], "step_title": "Step 6: Write the Code"}, {"step": 7, "steps_text": "Once all of the code is written in both programs and the code is compiled, without any leftover syntax errors or problems, the next step is to add the code from the Arduino ide onto the Arduino itself. The way to do this is not a complicated process, but it can be confusing if you have not done it before. First, we plug the USB a to b cable into the Arduino, with the a side inside the Arduino and the b side connecting it to the computer, with the LED board and everything else still connected to the Arduino. The next step is to go to the Arduino ide and click upload, the second button on the window. Before doing this though, check at the top of the screen to see if the model of your Arduino and the port line up, otherwise problems may arise. Finally, if you have done all of this correct, then you're should get a message saying \"done uploading\" on your computer.", "step_imgs": ["https://cdn.instructables.com/FLG/1IG3/IFWTWKF8/FLG1IG3IFWTWKF8.LARGE.jpg"], "step_title": "Step 7: Sending the Code"}, {"step": 8, "steps_text": "Now that your device is built and the code is finished and uploaded, all you have to do is test the device out. Before you do this, you need to go back to the Soundflower app that you downloaded earlier. One of the things that the processing code needs to do is to receive and audio input, in order to apply algorithms on the audio it receives. Most likely, your computer is not already set up with the audio output going to the Processing application, specifically under Java Sound.  In order to fix this and have the audio go to the right place, you need to first go to system preferences found by clicking the apple button in the top left corner and scrolling down to system preferences. Once in system preferences, you should navigate to sound, where you will click audio input and output, selecting Soundflower 2ch in the menu for both. After that, you just have to open the Soundflower preferences and route the audio to the processing application and then you are done. Hopefully, if everything is done right, you will have a cool depiction of the sound waves that you are inputting on the board. Keep in mind however that since the audio can only go through one channel, you will not be able to hear the audio yourself, as it is instead being routed to the computer. Though you can get past this by playing the same audio file at the same time.", "step_imgs": ["https://cdn.instructables.com/FCF/N3G0/IFWTWKF7/FCFN3G0IFWTWKF7.LARGE.jpg", "https://cdn.instructables.com/FXG/VYZ7/IFWTWKF9/FXGVYZ7IFWTWKF9.LARGE.jpg"], "step_title": "Step 8: Test It Out"}, {"step": 9, "steps_text": "Don't worry if something didn't work along the way. There are many common mistakes that can be made during the creation of this device. The two most major problems would be that the wiring is not correct or that the coding has an error. If the wiring is incorrect, go back and look and the image of the correct wiring and compare your device to it closely, making sure to try and lay the jumper wires out as similar as possible. Another common and easy to fix mistake would be the fixing of coding. When your coding has an error, it will not compile and warnings will be given on which line number is incorrect. When you get this number, be sure to fix the coding on that line so that the code complies and works well. ", "step_imgs": ["https://cdn.instructables.com/F4S/QE6D/IFWTWKFA/F4SQE6DIFWTWKFA.LARGE.jpg"], "step_title": "Step 9: Troubleshooting"}, {"step": 10, "steps_text": "As a whole, this project demonstrates and models many aspects of waves. Firstly, it uses both sound waves and light waves throughout its running. Sound waves are given as an input through the computer, which is then sent to the Arduino as commands that allow it to draw light, creating light waves. This device uses light waves and sound waves. Another way tang waves are modeled is through the LED display itself and what it is outputting. The whole thing that is being  shown on the board is a depiction of the wave, what is being show is the differing amplitudes, periods, wavelengths, etc. of the sound waves that is being shown, portraying it with light waves. One of the things that can be learned from this device that can help improve an understanding of physics is the ideas of fft, fst fourier transformations and the fact that the amplitude of a wave increases as the volume goes up. This can be demonstrated with the device because, as the volume of the sound grows louder, the amplitude that can be seen on the LED board becomes greater, as amplitude and volume are directly proportional. Another thing that can be learned from the device is the idea of fast Fourier transformations, which low us to take an audio input and turn it into a sine or cosine graph that can be sent into an array, which helps us present it on a LED board. ", "step_imgs": [], "step_title": "Step 10: Physics"}, {"step": 11, "steps_text": "Works Cited\"Adafruit/Adafruit-GFX-Library.\" GitHub. N.p., n.d. Web. 19 Oct. 2015.\"Adafruit/RGB-matrix-Panel.\" GitHub. N.p., n.d. Web. 19 Oct. 2015.\"DevDocs/ C.\" DevDocs. N.p., n.d. Web. 19 Oct. 2015.\"Processing.org.\" Processing.org. N.p., n.d. Web. 19 Oct. 2015.\"WHAT IS ARDUINO?\" Arduino. N.p., n.d. Web. 19 Oct. 2015.", "step_imgs": [], "step_title": "Step 11: Works Cited"}, {"step": 12, "steps_text": "Overall, there were not too many problems when creating this device. However, one of the major obstacles that I had to overcome was finding the right parts to make the device. Originally, I did not know how to do the wiring or which Arduino to choose to connect to the board, not knowing how much power the LED board needs. Eventually, after trial and error and reading the Arduino documentation, I was finally able to get the device to work. Another problem that I encountered along the way was that the lights were originally not showing up, which was because I did not wire the board and the Arduino correctly. I order to get over this obstacle by reading the documentation of Arduino and seeing which each pin is connected to. Overall, for this project the problems that occurred are not too hard to fix as long as you read the documentation and make sure you are doing everything correctly.", "step_imgs": [], "step_title": "Step 12: Problems"}], "channel": "Science"}, {"category": "technology", "description": "Dale Rosen, Carlos Reyes and Rob KochDATT 2000 ", "title": "NeckCrusher ( Guitar Mounted Effect Pedal )", "url": "https://www.instructables.com/id/NeckCrusher-Guitar-Mounted-Effect-Pedal-/", "section": "technology", "steps": [{"step": 1, "steps_text": "Guitar pedals restrict the musician to the pedal platform. Solution: Build and embed a guitar pedals functionality into the guitar itself. This allows the musician to freely move across the stage, using the guitar neck as an interface instead of being restricted to the location of the pedalboard. We will be exploring this concept by creating a bitcrusher/sample rate effect device.", "step_imgs": ["https://cdn.instructables.com/FH3/WFYR/J8AGYF69/FH3WFYRJ8AGYF69.LARGE.jpg"], "step_title": "Step 1: Problem"}, {"step": 2, "steps_text": "There are many guitar pedals used by musicians to manipulate the sound of their guitars. Most of these are usually in rack-based or stomp box units, therefore restricting the control of the effects to the location of the effects unit. Mounting the device on the guitar enables players to control the parameters of the effect anywhere on the stage. This means they will not be restricted and can have the freedom to move around for their performance.Since Arduino is only capable of 8 bit audio, it is impossible to do high fidelity signal processing. This is why we chose the effects we did, as they are based on creating a low fidelity, distorted sound. These are the only effects that are reasonably possible with an Arduino.", "step_imgs": ["https://cdn.instructables.com/F18/2J4B/J8AGX8JC/F182J4BJ8AGX8JC.LARGE.jpg"], "step_title": "Step 2: \u200bProject Context"}, {"step": 3, "steps_text": "\u25cf Impact Drill \u25cf Wire Cutters \u25cf Wire Strippers \u25cf Soldering Iron \u25cf Hot Glue Gun \u25cf Desoldering Pump\u25cf Guitar\u25cf Enclosure \u25cf Solder \u25cf Hot Glue \u25cf Arduino \u25cf Proto Board \u25cf Coated Wire \u25cf Audio Jacks (x2) \u25cf Potentiometers (x3) \u25cf Capacitors: 2.2 uF (x2) \u25cf Exposed Copper Wire \u25cf Screws (M3.5 *8) \u25cf Resistors: 1 k, 10 k, 1.2 k, 1.5 k, 390 k \u25cf * Op Amp (LM358) / * Transistor ( 2N3442)", "step_imgs": ["https://cdn.instructables.com/F78/C73R/J8AGX8JA/F78C73RJ8AGX8JA.LARGE.jpg"], "step_title": "Step 3: \u200bParts / Tools Required"}, {"step": 4, "steps_text": "Internal Circuitry Input/Output We need to convert the audio signal coming from a guitar to something the arduino can use & modify. We will then need to convert the signal coming from the arduino back into an audio signal. Arduino reads voltages from 0V to 5V, audio signals are from -1V to 1V. These conversions are done using resistors. The signal will be converted in the output circuit as well. Arduino Library:  ArduinoDSPProject Description (Interface)Knobs  Knob 1 : Sample Rate  Knob 2 : Bit Crusher  Knob 3 : Bit Shifter", "step_imgs": ["https://cdn.instructables.com/FAT/GS0A/J8AGX8HS/FATGS0AJ8AGX8HS.LARGE.jpg"], "step_title": "Step 4: \u200bTechnical Strategy"}, {"step": 5, "steps_text": "#include \"dsp.h\"#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit)) #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))boolean div32; boolean div16;volatile boolean f_sample; volatile byte badc0; volatile byte badc1; volatile byte ibb;int fx1; int fx2; int fx3; int fx4;int cnta; int icnt; int icnt1; int icnt2; int cnt2; int iw; int iw1; int iw2; byte bb;byte dd[512];  // Audio Memory Array 8-Bitvoid setup() {   setupIO();  // reload wave after 1 second   fill_sinewave();  // set adc prescaler  to 64 for 19kHz sampling frequency   cbi(ADCSRA, ADPS2);   sbi(ADCSRA, ADPS1);   sbi(ADCSRA, ADPS0);   // 8-Bit ADC in ADCH Register   sbi(ADMUX, ADLAR);   sbi(ADMUX, REFS0);   cbi(ADMUX, REFS1);   cbi(ADMUX, MUX0);   cbi(ADMUX, MUX1);   cbi(ADMUX, MUX2);   cbi(ADMUX, MUX3);   // Timer2 PWM Mode set to fast PWM   cbi (TCCR2A, COM2A0);   sbi (TCCR2A, COM2A1);   sbi (TCCR2A, WGM20);   sbi (TCCR2A, WGM21);   //Setup for Timer2   cbi (TCCR2B, WGM22);   // Timer2 Clock Prescaler to : 1   sbi (TCCR2B, CS20);   cbi (TCCR2B, CS21);   cbi (TCCR2B, CS22);   // Timer2 PWM Port Enable   sbi(DDRB, 3);   //cli();   cbi (TIMSK0, TOIE0);   sbi (TIMSK2, TOIE2);   iw1 = badc1;}void loop() {  //check status of the effect potentiometer and rotary switch   readKnobs();  // *************   // ***Normal***   // *************  if (fx1 == 0 && fx2 == 0 && fx3 == 0  && fx4 == 0 ) {     byte input = analogRead(left);     output(left, input);   }  // *************   // ***Phasor***   // *************  if (fx4 > 100) {    fx1 = 0;     fx2 = 0;     fx3 = 0;    while (!f_sample) {        // wait for Sample Value from ADC     }                          // Cycle 15625 KHz = 64uSec     PORTD = PORTD  | 128;     f_sample = false;     bb = badc1;     dd[icnt1] = bb;            // write to buffer     fx4 = iw * badc0 / 255;    // scale delayed sample with potentiometer     iw1 = dd[icnt2] ;          // read the delay buffer     badc0 = badc0 / 20;        // limit value to 512     icnt1++;     icnt2 = icnt1 - badc0;     icnt2 = icnt2 & 511;       // limit index 0..     icnt1 = icnt1 & 511;       // limit index 0..511     iw2 = iw1 + bb;     iw2 = iw2 / 2;     bb = iw2;     OCR2A = bb;                // Sample Value to PWM Output    PORTD = PORTD  ^ 128;     output(left, PORTD);       // Output   }  // *************   // ***Flanger***   // *************   if (fx3 > 100) {    fx1 = 0;     fx2 = 0;     fx4 = 0;    while (!f_sample) {         // wait for Sample Value from ADC     }                           // Cycle 15625 KHz = 64uSec    PORTD = PORTD  | 128;     f_sample = false;     bb = dd[icnt] ;             // read the delay buffer     iw = 127 - bb ;             // substract offset     fx3 = iw * badc0 / 255;     // scale delayed sample with potentiometer     iw1 = 127 - badc1;          // substract offset from new sample     iw1 = iw1 + iw;             // add delayed sample and new sample     if (iw1 < -127) iw1 = -127; // Audio limiter     if (iw1 > 127) iw1 = 127;   // Audio limiter     bb = 127 + iw1;             // add offset     dd[icnt] = bb;              // store sample in audio buffer     icnt++;     icnt = icnt & 511;          // limit bufferindex 0..511     OCR2A = bb;                 // Sample Value to PWM Output    PORTD = PORTD  ^ 128;     output(left, PORTD);        // Output  } }void readKnobs() {   fx1 = analogRead(1);   fx2 = analogRead(2);   fx3 = analogRead(3);   fx4 = analogRead(4);}void fill_sinewave() {   float pi = 3.141592;   float dx ;   float fd ;   float fcnt;   dx = 2 * pi / 512;                  // fill the 512 byte bufferarry   for (iw = 0; iw <= 511; iw++) {     // with  50 periods sinewawe     fd = 127 * sin(fcnt);             // fundamental tone     fcnt = fcnt + dx;                 // in the range of 0 to 2xpi  and 1/512 increments     bb = 127 + fd;                    // add dc offset to sinewawe     dd[iw] = bb;                      // write value into array  } }//****************************************************************** // Timer2 Interrupt Service at 62.5 KHz // here the audio and pot signal is sampled in a rate of:  16Mhz / 256 / 2 / 2 = 15625 Hz ISR(TIMER2_OVF_vect) {  PORTB = PORTB  | 1 ;  div32 = !div32;                     // divide timer2 frequency / 2 to 31.25kHz   if (div32) {     div16 = !div16;     if (div16) {                      // sample channel 0 and 1 alternately so each channel is sampled with 15.6kHz       badc0 = ADCH;                   // get ADC channel 0       sbi(ADMUX, MUX0);               // set multiplexer to channel 1     }     else     {       badc1 = ADCH;                   // get ADC channel 1       cbi(ADMUX, MUX0);               // set multiplexer to channel 0       f_sample = true;     }     ibb++;     ibb--;     ibb++;     ibb--;                            // short delay before start conversion     sbi(ADCSRA, ADSC);                // start next conversion   }}", "step_imgs": ["https://cdn.instructables.com/FQY/8ZED/J8AGYO1E/FQY8ZEDJ8AGYO1E.LARGE.jpg"], "step_title": "Step 5: Code"}, {"step": 6, "steps_text": "Potential Problems \u25cf Pickup is a little too weak to power circuit - need an op amp.  - In the video we used a signal booster. ( The grey box lying on the table. ) ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 6: Video "}], "channel": "Arduino"}, {"category": "technology", "description": "This UHFremote control receiver works in conjunction with the UHF transmitter described in my previous post. Circuit is quite simple but you must observe all recommendations on UHF construction layout (ground plane, stray capacity, inductance etc). For calibration & setup we will only need our trusty RF Sniffer. When properly built & calibrated you will achieve a range of 10 meters without any external antennas and with a transmitter supply voltage  of only 3v. It can be used for DATA or as a simple ON-OFF action.    ", "title": "UHF Remote Control Receiver", "url": "https://www.instructables.com/id/UHF-Remote-Control-Receiver/", "section": "technology", "steps": [{"step": 1, "steps_text": "The RF stage should not be assembled on a solderless breadboard. Use \"Manhattan-style\" construction or a double sided PCB with ground plane.", "step_imgs": ["https://cdn.instructables.com/FUP/YZRP/IHWIPEJZ/FUPYZRPIHWIPEJZ.LARGE.jpg", "https://cdn.instructables.com/FU5/1ECC/IHWIPEK0/FU51ECCIHWIPEK0.LARGE.jpg", "https://cdn.instructables.com/FD6/IRIP/IHWIPEK8/FD6IRIPIHWIPEK8.LARGE.jpg", "https://cdn.instructables.com/FO9/01OD/IHWIPEK5/FO901ODIHWIPEK5.LARGE.jpg", "https://cdn.instructables.com/FC7/WTID/IHWIPEKE/FC7WTIDIHWIPEKE.LARGE.jpg"], "step_title": "Step 1: Overview"}, {"step": 2, "steps_text": "Q1:     2SC-3358high frequency high gain NPN transistor.IC1:    LM358N dual OP-AMP Z1:      3.3v  zener diodeC1:      2.7pF - 7pF  trimmer capacitor (blue color coded)L1:       UHF frequency loop inductor made from 1.5mm diameter copper wire or wide PCB trace.             Large diameter is required to minimize \"skin effect\". Dimensions should match those of transmitter tank coil (which is variable with a shorting bar).L2:       20 turns 30AWG enameled wire on 3mm diameter form. (not critical)Supply voltage: any between 5V and 24v . (for more than 6v adjust value of R6 to minimize dissipation).", "step_imgs": ["https://cdn.instructables.com/FLC/R487/IHWIPEL0/FLCR487IHWIPEL0.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram & Main Components"}, {"step": 3, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FX3/QCVT/IHWIPEL9/FX3QCVTIHWIPEL9.LARGE.jpg"], "step_title": "Step 3: RF Stage"}, {"step": 4, "steps_text": "Resonating frequency of tankL1-C1 should be the same as the carrier frequency of transmitter. Use the RF sniffer to verify (more on this later)", "step_imgs": ["https://cdn.instructables.com/FHV/TPAI/IHWIPELA/FHVTPAIIHWIPELA.LARGE.jpg"], "step_title": "Step 4: Tank "}, {"step": 5, "steps_text": "This circuit is basically a Super Regenerative receiver.", "step_imgs": ["https://cdn.instructables.com/FPB/UX14/IHWIPELB/FPBUX14IHWIPELB.LARGE.jpg"], "step_title": "Step 5: Super-Regenerative Receiver"}, {"step": 6, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FK4/IHOY/IHWIPEM1/FK4IHOYIHWIPEM1.LARGE.jpg"], "step_title": "Step 6: Output Comparator"}, {"step": 7, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F73/KKFR/IHWIPEM2/F73KKFRIHWIPEM2.LARGE.jpg"], "step_title": "Step 7: Quench Frequency Filter"}, {"step": 8, "steps_text": "Our goal is to have the tank resonating at the transmitter frequency with the trimmer cap in its center position. This will give us margin for fine-tuning when it is in-circuit. If it resonates in an extreme position, or doesn\u00b4t resonate at all then the dimensions of L1 are wrong. Tweak until you get the right frequency or else nothing will work at all.", "step_imgs": ["https://cdn.instructables.com/F7F/49K5/IHWIPEM3/F7F49K5IHWIPEM3.LARGE.jpg"], "step_title": "Step 8: Tank L1-C1 Details"}, {"step": 9, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F1A/F1MM/IHWIPEM8/F1AF1MMIHWIPEM8.LARGE.jpg"], "step_title": "Step 9: Verify Tank Frequency Vs Transmitter Frequency"}, {"step": 10, "steps_text": "after tuning, C1 should be close to its center position", "step_imgs": ["https://cdn.instructables.com/FVD/JX73/IHWIPEM9/FVDJX73IHWIPEM9.LARGE.jpg"], "step_title": "Step 10: Tune C1 for Brightest LED"}, {"step": 11, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FI9/U33Q/IHWIPEMC/FI9U33QIHWIPEMC.LARGE.jpg"], "step_title": "Step 11: Understanding Position of C1"}, {"step": 12, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FTX/G7LT/IHWIPEMK/FTXG7LTIHWIPEMK.LARGE.jpg"], "step_title": "Step 12: L2 Details"}, {"step": 13, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FZR/K5C6/IHWIPEMW/FZRK5C6IHWIPEMW.LARGE.jpg"], "step_title": "Step 13: Setup & Calibration"}, {"step": 14, "steps_text": "transmitter modulation is OOK(on off keying). For simple ON-OFF applications tie modulation input of transmitter to +3v and power it through a switch. For multichannel operation, use data encoding-decoding or simpler tone encoding-decoding with 555 and 567 chips. Reduce R7 value to 10k for data rate up to 1000bits/s", "step_imgs": ["https://cdn.instructables.com/FRP/2TG9/IHWIPEMX/FRP2TG9IHWIPEMX.LARGE.jpg"], "step_title": "Step 14: Modulation Options"}, {"step": 15, "steps_text": "", "step_imgs": [], "step_title": "Step 15: For More Details Watch the Video. Thank You!"}], "channel": "Electronics"}, {"category": "technology", "description": "A great beginner's project for the LightBlue Bean from Punch Through Design. Once finished you will have a compact device that can detect the presence or absence of light, monitor temperature and provide audible alerts based on these environmental parameters. This project assumes you are familiar with programming the LightBlue Bean with Arduino sketches -- if you need more information on working with the LightBlue Bean and Arduino please visit http://punchthrough.com/bean/", "title": "Electronic TattleTale / Fridge Monitor", "url": "https://www.instructables.com/id/Electronic-TattleTale-Fridge-Monitor/", "section": "technology", "steps": [{"step": 1, "steps_text": "This project can be built with components from the Maker's Kit that comes with a LightBlue Bean 4-pack; if you don't have a Maker's Kit the components should also be readily available from various electronics suppliers. Components needed: one LightBlue Bean micro controller, two 1k ohm resistors, one phototransistor, one 4.7pF ceramic capacitor and one piezo speaker.NOTE: Before proceeding with the wiring steps remember to remove the battery from the LightBlue Bean to prevent accidentally shorting something while you are working.", "step_imgs": ["https://cdn.instructables.com/FTI/KU3E/I9LZATX4/FTIKU3EI9LZATX4.LARGE.jpg", "https://cdn.instructables.com/FY3/14QJ/I9LZAU1W/FY314QJI9LZAU1W.LARGE.jpg", "https://cdn.instructables.com/FHV/TJRF/I9LZAU34/FHVTJRFI9LZAU34.LARGE.jpg", "https://cdn.instructables.com/FUR/NNMF/I9LZAU0V/FURNNMFI9LZAU0V.LARGE.jpg", "https://cdn.instructables.com/F0D/V421/I9LZAU36/F0DV421I9LZAU36.LARGE.jpg"], "step_title": "Step 1: The Components"}, {"step": 2, "steps_text": "The light sensor is built using a charge-transfer circuit using a resistor, capacitor and phototransistor. The resistor is mounted in a vertical orientation between the Bean's digital pin 5 and the prototyping hole directly below pin 5. The capacitor mounts with one lead sharing the prototyping cell with the resistor and the other lead in the next prototyping hole down. The phototransistor mounts with the collector in the prototyping hole below digital pin 4 and the emitter in the next prototyping hole down. (The phototransistor's emitter should be indicated by a shorter lead and/or a slightly flattened side.)", "step_imgs": ["https://cdn.instructables.com/FTE/1GMD/I9LZAU1Y/FTE1GMDI9LZAU1Y.LARGE.jpg", "https://cdn.instructables.com/F14/DTIU/I9LZAU2A/F14DTIUI9LZAU2A.LARGE.jpg", "https://cdn.instructables.com/F53/YJFM/I9LZAU2E/F53YJFMI9LZAU2E.LARGE.jpg", "https://cdn.instructables.com/FTR/FCDJ/I9LZAU2S/FTRFCDJI9LZAU2S.LARGE.jpg"], "step_title": "Step 2: Wiring the Light Sensor Circuit"}, {"step": 3, "steps_text": "To wire the buzzer circuit, mount the 1k ohm resistor at an angle on the lower-right corner of the Bean. One lead will be in the prototyping hole directly below the capacitor, and the other lead will be in the right-most hole in the bottom row of prototyping holes. The piezo buzzer will connect to the resistor lead in the bottom row of prototyping holes, and then also connect to digital pin 1. The piezo buzzer from the Maker's Kit mounts nicely with one lead in the 2nd hole in the bottom row of the Bean's prototyping area and the other lead two rows up. If you are using a different piezo buzzer find what works best for you. If your piezo buzzer has red and black leads (or is otherwise marked with a positive and negative lead) be sure the positive lead is connected to digital pin 1 and the negative lead to the resistor.", "step_imgs": ["https://cdn.instructables.com/FH3/1HTI/I9LZAU0C/FH31HTII9LZAU0C.LARGE.jpg", "https://cdn.instructables.com/FLL/2XPG/I9LZAU0D/FLL2XPGI9LZAU0D.LARGE.jpg", "https://cdn.instructables.com/F9E/YWB6/I9LZAU0M/F9EYWB6I9LZAU0M.LARGE.jpg"], "step_title": "Step 3: Wiring the Buzzer"}, {"step": 4, "steps_text": "Add a ground wire from GND to the node where the light sensor and speaker circuits meet.", "step_imgs": ["https://cdn.instructables.com/FQQ/V4XX/I9LZAU1A/FQQV4XXI9LZAU1A.LARGE.jpg", "https://cdn.instructables.com/FT9/HEBC/I9LZAU1C/FT9HEBCI9LZAU1C.LARGE.jpg", "https://cdn.instructables.com/FO8/Z53Z/I9LZAU1M/FO8Z53ZI9LZAU1M.LARGE.jpg"], "step_title": "Step 4: Adding a Ground Wire"}, {"step": 5, "steps_text": "We'll start the Arduino sketch by setting up a simple template and some parameters we will need later on. By defining constants for the light sensor and buzzer functions at the top of the sketch it will be easy to adjust these values later if you want to.// Constants for light sensor<br>const int LIGHT_SENSOR_PIN = 5;\nconst uint32_t DARK_DISCHARGE_THRESHOLD = 300;<p>// Constants for buzzer\nconst int BUZZER_PIN = 1;\nconst int OPEN_WARNING_TONE = 500;\nconst int OPEN_WARNING_DURATION_MS = 1000;\nconst int TEMP_WARNING_TONE = 800;\nconst int TEMP_WARNING_DURATION_MS = 500;\nconst int TEMP_WARNING_REPEAT = 3;\n\nvoid setup() {\n  // Initialize Serial comms\n  Serial.begin();\n  \n  // Init Bean LED to off\n  Bean.setLed(0,0,0);\n  \n  // Set light sensor pin mode\n  pinMode(LIGHT_SENSOR_PIN, INPUT_PULLUP);\n}\n\nvoid loop() \n{\n    Bean.sleep(500);\n}\n</p>", "step_imgs": [], "step_title": "Step 5: Starting the Arduino Sketch"}, {"step": 6, "steps_text": "Next we need a function for handling the light sensor charge-transfer circuit. The basics of this function are to briefly set pin 5 high to charge the circuit, then time how long it takes the pin until to go low. The more light hitting the phototransistor the faster the circuit will discharge. The qtTime() function handles this charging and timing. The lightCheck() function uses the qtTime() function to indicate whether the Bean is in the light or dark. Then we will use lightCheck() within loop() to test our light sensor circuit.uint32_t qtTime(int nQTPin, uint32_t nMaxWait)\n{\n    // Charge the capacitor\n    digitalWrite(nQTPin, HIGH);\n    delay(5);\n    // Stop charging\n    digitalWrite(nQTPin, LOW);\n    // Start discharge cycle\n    uint32_t nStart = millis();\n    uint32_t nDuration = 0;\n    // As capacitor discharges through phototransistor sensor\n    // pin will transition from HIGH to LOW\n    while(digitalRead(nQTPin) == HIGH)\n    {\n        // Wait for discharge\n        // In case millis() has rolled over\n        if ( millis() < nStart )\n        {\n            nStart = millis();\n        }\n        // Has duration exceeded the DARK threshold time?\n        nDuration = millis() - nStart;\n        if ( nDuration > nMaxWait )\n        {\n            break;\n        }\n    }\n    \n    // For determining threshold or degugging, output duration\n    String strDuration = \"\";\n    strDuration += String(nDuration);\n    strDuration += \" ms\";\n    Serial.println( strDuration );\n    // Above section can be removed or commented once lightCheck()\n    // is working as desired.\n    \n    return nDuration;\n}String lightCheck() {\n    String strOut = \"LIGHT\";\n    if ( qtTime( LIGHT_SENSOR_PIN, DARK_DISCHARGE_THRESHOLD) >= DARK_DISCHARGE_THRESHOLD )\n    {\n        strOut = \"DARK\";\n    }\n    // Return LIGHT or DARK\n    return strOut;\n}void loop() \n{\n    Serial.println( lightCheck() );\n    Bean.sleep(500);\n}", "step_imgs": [], "step_title": "Step 6: The Light Sensor Code"}, {"step": 7, "steps_text": "Now is a good time to test the light sensor circuit. Insert a coin cell battery into your Bean then compile and upload the sketch to your Bean. After upload, use Bean Loader to activate Virtual Serial for your Bean and then open the Serial Monitor in the Arduino IDE. If you completely cover and uncover your Bean you should see output like the image above. You can adjust the value of the  DARK_DISCHARGE_THRESHOLD constant so that the sketch reports dark only when the Bean is completely in the dark. I adjusted mine such that even if the fridge door is closed enough to turn the light off, but the door isn't sealed it still reports LIGHT; but when the door is sealed tight it reports DARK.", "step_imgs": ["https://cdn.instructables.com/F8E/65ZS/I9NC9BFL/F8E65ZSI9NC9BFL.LARGE.jpg"], "step_title": "Step 7: Testing the Light Sensor"}, {"step": 8, "steps_text": "Once you have the light/dark sensor working how you want it you can create two functions for making the buzzer work. The playTone() function handles the sound output. The warningTone() function calls the playTone() function to output the specific sounds for our circuit. Then to test the sound functions we can modify the loop() function to output different tones for LIGHT and DARK conditions.void playTone(uint8_t nPin, uint16_t nFreq, uint16_t nDuration)\n{\n    // If frequency or duration is zero, stop any tones\n    if ( (nFreq == 0) || (nDuration == 0) )\n    {\n        noTone(nPin);\n    }\n    else\n    {\n        // Output the specified tone for the specified duration\n        tone(nPin, nFreq, nDuration);\n        // Since we need the tone to occur synchronously we wait for it to finish\n        delay(nDuration);\n    }\n}void warningTone( uint16_t nFreq, uint16_t nDuration, uint8_t nCount) \n{\n    // Setup a loop counter\n    int n = 0;\n    // While the loop counter is less than the specified count ...\n    while (n++ < nCount)\n    {\n        // ... play the specified tone.\n        playTone(BUZZER_PIN, nFreq, nDuration);\n        // if we will repeat, pause briefly so the tones don't run together.\n        if (n < nCount)\n        {\n            delay(250);\n        }\n    }\n}void loop() \n{\n    if (lightCheck() == \"LIGHT\")\n    {\n      warningTone( OPEN_WARNING_TONE, OPEN_WARNING_DURATION_MS, 1 );\n    }\n    else\n    {\n      warningTone( TEMP_WARNING_TONE, TEMP_WARNING_DURATION_MS, TEMP_WARNING_REPEAT );\n    }\n    Bean.sleep(500);\n}", "step_imgs": [], "step_title": "Step 8: Making Noise"}, {"step": 9, "steps_text": "Now we need to start tracking how long the Bean is in the LIGHT state. Because the timers on the Bean's Arduino circuit are turned off during Bean.sleep() we need to set up some variables and functions for time tracking.  Above the setup() function create these variables:// Global variables for time tracking\nuint32_t nLoopStart = 0;\nuint32_t nApproxRunTime = 0;Then, create two helper functions for time keeping:uint32_t approxRunTime()\n{  \n  return (nApproxRunTime + (millis() - nLoopStart));\n}\n\nvoid updateApproxRunTimeForSleep( uint32_t nSleepTime )\n{\n  nApproxRunTime += (millis() - nLoopStart) + nSleepTime;\n  nLoopStart = millis(); // Reset nLoopStart since we have added                                              // loop time to nApproxRunTime\n}To keep track of time we need to set nLoopStart at the top of loop(). We also need to adjust nApproxRunTime for the sleep time at the bottom of loop().void loop() {\n    // For time tracking we need to know when the loop() started\n    nLoopStart = millis();\n    \n    // Check the light condition, if LIGHT ...\n    if (lightCheck() == \"LIGHT\")\n    {\n        warningTone( OPEN_WARNING_TONE, OPEN_WARNING_DURATION_MS, 1 );\n    }\n\n    // Output approxRunTime() for testing\n    Serial.print( approxRunTime() );\n    Serial.println( \"ms\" );\n    \n    // Determine our loop sleep time based on conditions\n    int nSleepTime = 15000; // 15 seconds standard sleep time\n    // Before sleep, update approximate run time\n    updateApproxRunTimeForSleep( nSleepTime );\n    // Sleep\n    Bean.sleep(nSleepTime);\n}When you compile/upload these changes the Serial Monitor output should look something like below -- you'll notice our discharge time alternating with our approximate total run time. (Since we are done setting up the light sensor circuit I will comment out the discharge time output.) Note:Be aware that this time keeping will not be super precise; we are approximating the total run time based on loop execution time and how long we tell the Bean to sleep, but we are not accounting for time it takes the Bean to put the arduino to sleep or time it takes to wake-up the arduino. We're also not accounting for the possibility of the arduino being woken up early by Serial input to the Bean.2 ms\n1067ms\n0 ms\n17218ms\n2 ms\n33367ms\n202 ms\n49723ms\n", "step_imgs": [], "step_title": "Step 9: Tracking Time"}, {"step": 10, "steps_text": "Now that we have a way of keeping track of time, we need to keep track of when the fridge door is open (aka when we sense LIGHT). First, we should add some constants near the top of our sketch for our warning parameters:// Constants for warning thresholds and repeat intervals\nconst uint32_t OPEN_WARNING_TIME_SEC = 60;\nconst uint32_t OPEN_WARNING_INTERVAL_SEC = 15;\nWe also need to add some global variables for tracking light state. Add these above setup():// Global variables for warning tracking\nboolean bLightOn = false;\nuint32_t nLightOnStart = 0;\nuint32_t nLastLightOnWarning = 0;And we can update our loop() by replacing// Check the light condition, if LIGHT ...\nif (lightCheck() == \"LIGHT\")\n{\n    warningTone( OPEN_WARNING_TONE, OPEN_WARNING_DURATION_MS, 1 );\n}\n// Output approxRunTime() for testing\nSerial.print( approxRunTime() );\nSerial.println( \"ms\" );with// Check the light condition, if LIGHT ...\nif (lightCheck() == \"LIGHT\")\n{\n    // ... if it was not light last time through loop ...\n    if (!bLightOn)\n    {\n        // ... set light on flag and reset light on duration.\n        bLightOn = true;\n        nLightOnStart = approxRunTime();\n    }\n    else\n    {\n        // If it was light before and the light has been on longer than our warning threshold ...\n        if ( (approxRunTime() - nLightOnStart) >= (OPEN_WARNING_TIME_SEC * 1000) )\n        {\n            // ... and if our last light on warning was longer ago than our interval ...\n            if ( (approxRunTime() - nLastLightOnWarning) >= (OPEN_WARNING_INTERVAL_SEC * 1000) )\n            {\n               // ... then reset our last warning time ...\n                 nLastLightOnWarning = approxRunTime();\n        // ... and play warning tone.\n                warningTone( OPEN_WARNING_TONE, OPEN_WARNING_DURATION_MS, 1 );\n            }\n        }\n    }\n}\nelse\n{\n    // If not LIGHT, ensure light on flag is false.\n    bLightOn = false;\n}And we can adjust our loop's sleep time based on whether the light is on or not. This will save battery by sleeping longer during periods of darkness. So, afterint nSleepTime = 15000; // 15 seconds standard sleep timewe addf (bLightOn)\n{\n    nSleepTime = min(nSleepTime,(OPEN_WARNING_INTERVAL_SEC * 1000));\n}Now if we have detected light for 60+ seconds we should hear a warning beep about every 15 seconds.In case you have any trouble with the code changes, I have attached the current sketch.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 10: Tracking Fridge Open Time"}, {"step": 11, "steps_text": "What we have built so far could be used to monitor access to anyplace that is usually dark; you could create an alarm for your closet, drawer, toolbox, lunchbox, etc. Since we are building a refrigerator monitor and the Bean has an on-board temperature sensor we can upgrade our tattletale to also monitor the refrigerator's internal temperature. We need to add a few constants for temperature monitoring:const int8_t TEMP_WARNING_LOW_CELSIUS = 1;\nconst int8_t TEMP_WARNING_HIGH_CELSIUS = 5;\nconst uint32_t TEMP_WARNING_INTERVAL_SEC = 5;And we also need a couple of global variables for tracking temperature events:boolean bTempProblem = false;\nuint32_t nLastTempWarning = 0;Now create two functions for performing the temperature checks. The temperatureOkay() function checks if the current temperature is within the acceptable range. The checkTemperature() function uses the temperatureOkay() function and gives warning tones as appropriate.boolean temperatureOkay()\n{\n    boolean bTempOkay = true; // Default return value to true\n    // Get the current temperature in degrees Celsius\n    int8_t nTemp = Bean.getTemperature();\n    // If the current temperature is not in the acceptable range ...\n    if ( (nTemp < TEMP_WARNING_LOW_CELSIUS) || (nTemp > TEMP_WARNING_HIGH_CELSIUS) )\n    {\n        // ... set return value to false.\n        bTempOkay = false;\n    }\n    return bTempOkay;\n}void checkTemperature()\n{\n    // If the temperature is out-of-range ...\n    if (!temperatureOkay())\n    {\n        bTempProblem = true;\n        // ... and if our last warning was more than our interval ago ...\n        if ( (approxRunTime() - nLastTempWarning) > (TEMP_WARNING_INTERVAL_SEC * 1000) )\n        {\n            // ... reset our last warning time ...\n            nLastTempWarning = approxRunTime();\n            // ... and give warning tones.\n            warningTone( TEMP_WARNING_TONE, TEMP_WARNING_DURATION_MS, TEMP_WARNING_REPEAT);\n        }\n    }\n    else\n    {\n        bTempProblem = false;\n    }\n}Now we can add the temperature check to loop() after the LIGHT checks and before we prepare to sleep.// Temperature check\ncheckTemperature();We should also adjust our sleep time when we are in a temperature warning condition so warnings will be close to the desired interval.if (bTempProblem)\n{\n    nSleepTime = min(nSleepTime,(TEMP_WARNING_INTERVAL_SEC * 1000));\n}Our sketch should now be complete. You may need to adjust the various warning thresholds to suit your particular fridge, Bean, etc.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 11: Monitoring Temperature"}, {"step": 12, "steps_text": "To keep my tattletale from looking too out-of-place in the fridge I bought a small condiment bottle at Target.  I cut a small window in one side for sound then cut the bottom open to insert my Bean.I hope you have had fun with this project. I don't know how long this project will run on a single CR2032 coin cell battery.  Maybe I will get a chance later to analyze and optimize battery life.", "step_imgs": ["https://cdn.instructables.com/F5D/HGPB/I9LZATYO/F5DHGPBI9LZATYO.LARGE.jpg", "https://cdn.instructables.com/FVT/X8OF/I9LZATXD/FVTX8OFI9LZATXD.LARGE.jpg", "https://cdn.instructables.com/FB5/QWPP/I9LZAU03/FB5QWPPI9LZAU03.LARGE.jpg", "https://cdn.instructables.com/FXC/DBW2/I9NE46MB/FXCDBW2I9NE46MB.LARGE.jpg"], "step_title": "Step 12: At Home in the Refrigerator"}, {"step": 13, "steps_text": "After building my TattleTale I tested it in my fridge.  Initial testing was promising, but after several hours I tested again and got no warning buzzer.  I pulled out my iPhone to try to connect to the Bean, and it was not showing as active.  I found it highly unlikely that the battery could have died in such a short period of time, but that's what appeared to have happened.  I removed the TattleTale from the fridge to replace the battery later.After 10-15 minutes I noticed that the LED on my Bean flashed a few times then remained off.  I then tried to connect to the Bean from my phone and was able to.  The TattleTale had come to life, but battery level reported was a tad low.  Another 5 minutes passed, and I checked again.  The battery was back up to over 2.5 volts.  Evidently the CR2032 battery I have does not operate well at near freezing temperatures (despite the fact all data sheets I can find say that the operating temperature for a CR2032 should go well below freezing).I hooked a 2xAA battery holder up to my TattleTale and placed it back into the fridge.  More than 24 hours later it is still working as intended.", "step_imgs": [], "step_title": "Step 13: Post Build Notes"}], "channel": "Microcontrollers"}, {"category": "technology", "description": "OVERVIEW OF OUR LITTLE SCIENCE EXPERIMENT As the title of this instructable says, we would literally be controlling applications using brain signals. We will look at the design of the hardware, as well as the software, and see how we can design the entire pipeline so that we can control anything we want using our Brain Signals. Motivation for this project?As we will see in this instrucatable, there are many different applications in which such a project can be utilized. However, one of the main motivation behind this project is to give people with various physical disabilities an equal opportunity in the society and to elevate them to a point where they can compete on a level parallel to the rest of the society. Another main highlight of this project was to create a cost effective amplification system that was easily in the affordability range of the general consumer. The results that we obtained from our amplification system were quite satisfactory and gave reliable and accurate results that were comparable to the expensive equipment available in the market. How does this work?Essentially what happens is that our brain generates frequencies of different wavelengths depending on the type of activity that a person is performing. The table above shows this. So, lets suppose if you are in deep sleep, that would mean that on your Frontal Lobe (front of your head) you will be generating Delta Waves that have a frequency range from 0-4 Hz. We make use of this information by extracting it using electrodes, amplifiers and filters. Apply some Digital Signal Processing to it, and VOILA! you're a genius. So without any further wait, lets jump into it. ", "title": "Controlling Applications Using Brain Signals", "url": "https://www.instructables.com/id/Controlling-Applications-Using-Brain-Signals/", "section": "technology", "steps": [{"step": 1, "steps_text": "Hardware for capturing the Brain Signals The type of hardware that we use would depend on the application that we would be building. However, with that said, the general pipeline of hardware required for processing the brain signals would be the same. So you need the following. 1x EEG cap (10-20 electrode system) 1x EEG Gel  1x EEG Gel Syringe  4x OPA2337 2x INA2126UA   Resistors and Capacitors  1x Microcontroller (I used TM4C123GH6PM Tiva C series microcontroller) 1x UART Cable", "step_imgs": ["https://cdn.instructables.com/FIL/Z1BV/J5IFXA02/FILZ1BVJ5IFXA02.LARGE.jpg", "https://cdn.instructables.com/FAF/YWJA/J5IFXBX1/FAFYWJAJ5IFXBX1.LARGE.jpg", "https://cdn.instructables.com/FD5/LKFL/J5IFXC6U/FD5LKFLJ5IFXC6U.LARGE.jpg"], "step_title": "Step 1: A Look at the Hardware Used"}, {"step": 2, "steps_text": "The diagram shows the High Level Overview of our system. Brain Signals are directed from the brain and captured via the EEG cap. From the EEG cap the signals are sent to the Amplification System, this is a combination of both amplifiers and filters. From here we then send the signals to our microcontroller.", "step_imgs": ["https://cdn.instructables.com/FXS/V393/J5IFXCLD/FXSV393J5IFXCLD.LARGE.jpg"], "step_title": "Step 2: Design of the Hardware"}, {"step": 3, "steps_text": "Instrumentation amplifier is a precision instrumentation amplifier for accurate, low noise differential signal acquisition. It has a very high common mode rejection ratio (CMRR) and very high input resistance. These characteristics made it suitable for EEG applications. Its gain can be varied by just changing the value of external resistor.", "step_imgs": ["https://cdn.instructables.com/FTL/7M8Y/J5IFXFJO/FTL7M8YJ5IFXFJO.LARGE.jpg"], "step_title": "Step 3: Design of Instrumentation Amplifier"}, {"step": 4, "steps_text": "Some DC offset (about 400-600mV) is always present at the output of the amplifier due to the high gain. So, in order to remove this offset, a high pass RC filter of cut off 0.20 Hz is used which blocks this DC offset and stops the shifting of the signal.", "step_imgs": ["https://cdn.instructables.com/FQW/QNM4/J5IFXFLA/FQWQNM4J5IFXFLA.LARGE.jpg"], "step_title": "Step 4: Design of High Pass Filter"}, {"step": 5, "steps_text": "This is the second stage of our signal amplification. We are operating the operational amplifier in non-inverting mode. The gain from second stage is also 100. So, the total gain we get is about 10000.", "step_imgs": ["https://cdn.instructables.com/FVG/4O1G/J5IFXH88/FVG4O1GJ5IFXH88.LARGE.jpg"], "step_title": "Step 5: Design of Operational Amplifier"}, {"step": 6, "steps_text": "The region of interest of our EEG signal is in the range 0-30 Hz. So, we have used a simple RC low pass filter of cut off 27 Hz. This will attenuate the unwanted frequencies from the signal", "step_imgs": ["https://cdn.instructables.com/FGM/VKPT/J5IFXHAN/FGMVKPTJ5IFXHAN.LARGE.jpg", "https://cdn.instructables.com/FMQ/I9M8/J5IFXHLS/FMQI9M8J5IFXHLS.LARGE.jpg"], "step_title": "Step 6: Design of the Low Pass Filter"}, {"step": 7, "steps_text": "Once that we have designed the Amplification System it is now time to design the PCB layout for it. The diagram shows the end product that got developed using the Eagle Software.", "step_imgs": ["https://cdn.instructables.com/FMQ/I9M8/J5IFXHLS/FMQI9M8J5IFXHLS.LARGE.jpg"], "step_title": "Step 7: Putting It All Together"}, {"step": 8, "steps_text": "After that the PCB is ready, it was then time to make it a reality and have it ready with all the components added on to it. As it can be seen in the diagram above.", "step_imgs": ["https://cdn.instructables.com/FAF/YWJA/J5IFXBX1/FAFYWJAJ5IFXBX1.LARGE.jpg"], "step_title": "Step 8: And the Amplifier Is Ready"}, {"step": 9, "steps_text": "We are using Tiva microcontroller from TI for ADC sampling and UART. It has two 16 bit timers, fast 12 bit ADC converter, eight 8 bit UART modules DMA, two PWM modules, 48 GPIO pins, I2C.", "step_imgs": ["https://cdn.instructables.com/FD5/LKFL/J5IFXC6U/FD5LKFLJ5IFXC6U.LARGE.jpg"], "step_title": "Step 9: Tiva C Series Microcontroller"}, {"step": 10, "steps_text": "We have used expansion board for transmitting data to the COM port for Matlab. The board has RS232 protocol jack and we have used RS232 to USB converter for transferring our data to the Matlab. The board also have 7 segments displays, LDR and LCD space to incorporate it in the board", "step_imgs": ["https://cdn.instructables.com/FNK/1455/J5IFXIGF/FNK1455J5IFXIGF.LARGE.jpg"], "step_title": "Step 10: The Expansion Board"}, {"step": 11, "steps_text": "We have used relay circuit module for controlling various applications. It has optocouplers which isolates the supplies of controller and the relay circuit module. ", "step_imgs": ["https://cdn.instructables.com/FWS/LATE/J5IFXIPX/FWSLATEJ5IFXIPX.LARGE.jpg"], "step_title": "Step 11: Relay Circuit Module"}, {"step": 12, "steps_text": "Once that we have everything we need, its time to neatly place it inside of a box, which would prevent the hardware designed from scattering all over the place.", "step_imgs": ["https://cdn.instructables.com/FHM/A744/J5IFXJ25/FHMA744J5IFXJ25.LARGE.jpg"], "step_title": "Step 12: Putting It All Together in a Box"}, {"step": 13, "steps_text": "For the visualization of data a GUI was created in MATLAB. The GUI played the role of a building bridge between the data coming from the microcontroller and the user. The user could not only see the data coming in real time but also see its real time Fast Fourier Transform along with the results of the correlation, if being taken. The way the GUI communicated with the microcontroller was through the UART interface using the RS 232 protocol. For this communication to take place the GUI was incorporated with the option of selecting the port to which the UART was connected to, along with ability to select the baud rate. Furthermore, the GUI gave the option of closing and opening the selected port.", "step_imgs": ["https://cdn.instructables.com/FHR/SCNL/J5IFXJ90/FHRSCNLJ5IFXJ90.LARGE.jpg"], "step_title": "Step 13: The MatLab GUI"}, {"step": 14, "steps_text": "For the visualization of data, the user was given the option to either start or stop the display of the real time data. The user could also see the real time values of the real time data being plotted, its FFT and correlation. Corresponding to this, a small display panel was also created that showed the detected signal. A major feature of this GUI was the ability to select the application to be controlled. A drop down menu was created for this purpose, which upon selection of an option ran the back end code corresponding to the selection", "step_imgs": ["https://cdn.instructables.com/F8T/P88C/J5IFXJKW/F8TP88CJ5IFXJKW.LARGE.jpg"], "step_title": "Step 14: The Control Panel"}, {"step": 15, "steps_text": "The main motivation behind this project was the development of applications that we are able to be controlled through brain signals reliably and with such an accuracy so that person with disabilities could use them with ease. In this project we have controlled different hardware and software applications with the help of the following signals acquired from the brain \u2022 Eye Blinks \u2022 Alpha Waves \u2022 Theta Waves", "step_imgs": ["https://cdn.instructables.com/FXK/ZPH0/J5IFXM1A/FXKZPH0J5IFXM1A.LARGE.jpg"], "step_title": "Step 15: Lets Do Some Science!"}, {"step": 16, "steps_text": "Eye blink signals are emitted from the frontal part of human brain. Eye blinks produce an upward detection by means of changing electric field as the cornea gets nearer to the frontal lobe during eye blink. It can be used to control different machines which can help disable people to do their routine tasks", "step_imgs": [], "step_title": "Step 16: An Introduction to Eye Blinks"}, {"step": 17, "steps_text": "To record eye blinks we have placed electrodes at Fp1 and Fp2 according to 10-20 electrode system. The ground electrode is placed on the ear lobe. We are obtaining the differential signal from these two points. Due to the differential amplifier being used, the blinks from the two eyes are opposite in polarity. One will be called as left-blink and the other as right-blink. The plots for real time right and left blink is shown below.", "step_imgs": ["https://cdn.instructables.com/FAD/SI7S/J5IFXLQI/FADSI7SJ5IFXLQI.LARGE.jpg", "https://cdn.instructables.com/F43/4HTA/J5IFXLQW/F434HTAJ5IFXLQW.LARGE.jpg"], "step_title": "Step 17: Recording of Eye Blinks"}, {"step": 18, "steps_text": "To detect eye blinks we have used two methods.Threshold Detection This is quite a simple and easy method to detect eye blinks. Noting the maximum value of left eye blink and minimum value of right eye blink we can distinguish the two blinks using if-else statements in the software. However, there is certain weakness of accuracy associated with this method. If for example due to some reason (e.g. dryness of gel, improper electrode placement) the signal strength weakens, then the previously defined threshold may not work and hence, a new threshold has to be set. Moreover, due to the plethora of artifacts present, both of high frequency and amplitude, they can also be mistakenly be detected as an eye blink. The signature of the eye blink, as shown above, was made using Microsoft Excel. Ten different samples of an eye blink were obtained and then averaged out, the result of this averaging gave us the final signature. Once this signature has been obtained, we then correlate the signature with the real time data. If it matches, then the eye blink is detected, otherwise it is discarded as an artifact. The advantage of this method is that it is more reliable becauseCorrelation DetectionA more reliable method is detection through correlation. In this method we take multiple samples of an eye blink and then average them out to make a signature eye blink. The signature of the eye blink was made using Microsoft Excel. Ten different samples of an eye blink were obtained and then averaged out, the result of this averaging gave us the final signature. Once this signature has been obtained, we then correlate the signature with the real time data. If it matches, then the eye blink is detected, otherwise it is discarded as an artifact. The advantage of this method is that it is more reliable because even if the signal strength weakens, its shape remains more or less same and hence, we are still able to extract the eye blink. An interesting thing to note here is that, since the left and right eye blinks are simply the reciprocal of each other, we need the signature of either one of the two eye blinks. ", "step_imgs": ["https://cdn.instructables.com/FCJ/8G9S/J5IFXMHW/FCJ8G9SJ5IFXMHW.LARGE.jpg"], "step_title": "Step 18: Detection of Eye Blinks"}, {"step": 19, "steps_text": "The idea of creating such an application was to give a demonstration of some form of cursor control. This is an imperative application for the disabled as it will give them the capability of using devices such as a laptop or even a mobile phone. The signals that we use for this application are eye blinks. Each blink corresponds to a different action being performed. In the case of the snake game, the snake changes its direction corresponding to the blink detected. Hence, using a combination of blinks, the user can guide the snake towards its goal. Since we were using MATLAB, we had to import a JAVA Robot class into MATLAB to give it the capability to move the cursor. A snake game developed in MATLAB was used for this purpose. The game had four separate buttons each corresponding to a different movement of the snake. The positioning of these buttons were mapped to eye blinks using the JAVA Robot class. Using trial and error, the positioning of the cursor were declared into MATLAB.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 19: Snake Game Using Eye Blinks"}, {"step": 20, "steps_text": "Another software application created using MATLAB integrated with the JAVA Robot Class was a PDF reader. The PDF reader allowed the user the move the page up and down with the help of eye blinks. The left blink moved the page up, while the right blink moved the page down. The cursor coordinations used for this are universal. This means that they can be used for almost any windows application such as an internet browser, a word file or as in this case, a PDF reader", "step_imgs": [], "step_title": "Step 20: PDF Reader Using Eye Blinks"}, {"step": 21, "steps_text": "Apart from the software applications built. A few hardware based applications were also developed to show the power of Application Control through Brain Computer Interface. This again is extremely imperative in the eyes of someone who is disabled as it will allow them the control of any home appliance or something similar to a wheel chair. To demonstrate how the control of a wheelchair would work, we controlled a small toy car. The car was controlled using a transmitter and a receiver. The transmitter of the car was attached to the microcontroller via an optocoupler. The optocoupler was used for the protection of the microcontroller. Finally, Eye blinks were mapped to different movements of the car, hence, corresponding to a particular eye blink the car was able to be controlled in a particular direction.", "step_imgs": [], "step_title": "Step 21: Toy Car Using Eye Blinks"}, {"step": 22, "steps_text": "Alpha waves are associate with the relaxed state of a person, with closed eyes. Their frequency range lies in the band of 8-13 Hz and are dominant when the person\u2019s eyes are closed. When the eyes are opened, alpha waves fades away rapidly.", "step_imgs": [], "step_title": "Step 22: Move on to THE ALPHA WAVES"}, {"step": 23, "steps_text": "Alpha waves are recorded from the occipital region of the brain (back side). For the measurement, recording electrodes were placed at sites O1 and O2 according to 10-20 system. Ground electrode was placed on the ear lobe. Differential signal was taken from the two recording electrodes. Below is the real time plot of alpha waves.", "step_imgs": ["https://cdn.instructables.com/FWY/RU3U/J5IFXNRR/FWYRU3UJ5IFXNRR.LARGE.jpg"], "step_title": "Step 23: Recording of Alpha Waves"}, {"step": 24, "steps_text": "Real time Fourier Transform of the data was taken in MATLAB. Alpha waves were detected when the 10 Hz frequency showed values much greater than the other frequency values. The figure below shows FFT of alpha waves.", "step_imgs": ["https://cdn.instructables.com/F9N/30IK/J5IFXO6J/F9N30IKJ5IFXO6J.LARGE.jpg"], "step_title": "Step 24: Detection of Alpha Waves"}, {"step": 25, "steps_text": "Once that we had detected Alpha Waves, we decided to make an application which tried to solve an existing problem of drowsy driving. Drowsy driving is becoming a serious problem. In this, the driver of the car because of being stressed or some other reason closes his eyes, and hence, this distraction results in an accident to take place. In order to prevent such a thing from occurring, we came up with a system that we call Car Alert. In Car Alert when the user closes his eyes, the car begins to slow down, an alarm sounds in order to wake the driver up and an emergency light is turned on to alert the other drivers. For demonstration purposes, we controlled a small toy car using the same transmitter receiver method described above. When the subject closed his eyes, alpha waves were generated. On the detection of these alpha waves, the transmitter and the led light were turned on and off using the relay circuit. The alarm sound was produced using MATLAB by importing a .wav file.", "step_imgs": [], "step_title": "Step 25: Car Alert Using Alpha Waves"}, {"step": 26, "steps_text": "Eyes closed in a relaxed state results in the alpha waves of higher magnitude being produced. Under this condition if the subject came under some sort of stress the magnitude of these alpha waves decreased. In order to show this in a more tangible form a small red led was connected. This led was associated with the magnitude of the alpha waves. When the magnitude of the alpha waves was above a certain threshold the led lit up, and otherwise it remained off. The subject was asked to close his eyes, which resulted in the led light to be turned on. Now, in order to put the subject under stress he was asked a series of difficult questions. It was observed that while the subject was in the thought process of answering these questions the led light turned . off, meaning that the magnitude of the alpha waves had decreased and the subject was under stress. And the moment the subject gave the answer and was relieved of this task, the led light turned on again.", "step_imgs": [], "step_title": "Step 26: Stress Detection Using Alpha Waves"}, {"step": 27, "steps_text": "Theta waves are rightly known as the bridge between the conscious and subconscious mind. They are one of the slower waves and hence are found in the lower frequency band of about 4-7 Hz. These waves are associated with meditation, intuition and memory. The way we acquired these waves were that we asked the subject to relax and close his eyes. After a while, the Alpha waves started to fade away and theta waves began to appear. The FFT shown below clearly shows the frequency lying in the theta range. All the applications that were controlled through Alpha waves can be controlled through theta waves as well.", "step_imgs": ["https://cdn.instructables.com/FSF/KKKW/J5IFXYC2/FSFKKKWJ5IFXYC2.LARGE.jpg", "https://cdn.instructables.com/FVD/WT2E/J5IFXYC3/FVDWT2EJ5IFXYC3.LARGE.jpg"], "step_title": "Step 27: Finally, Some Theeta Waves!"}], "channel": "Assistive Tech"}, {"category": "technology", "description": "Timer interrupts allow you to perform a task at very specifically timed intervals regardless of what else is going on in your code.  In this instructable I'll explain how to setup and execute an interrupt in Clear Timer on Compare Match or CTC Mode.  Jump straight to step 2 if you are looking for sample code.Normally when you write an Arduino sketch the Arduino performs all the commands encapsulated in the loop() {} function in the order that they are written, however, it's difficult to time events in the loop().  Some commands take longer than others to execute, some depend on conditional statements (if, while...) and some Arduino library functions (like digitalWrite or analogRead) are made up of many commands.  Arduino timer interrupts allow you to momentarily pause the normal sequence of events taking place in the loop() function at precisely timed intervals, while you execute a separate set of commands.  Once these commands are done the Arduino picks up again where it was in the loop().Interrupts are useful for:Measuring an incoming signal at equally spaced intervals (constant sampling frequency)\nCalculating the time between two events\nSending out a signal of a specific frequency\nPeriodically checking for incoming serial data\nmuch more...There are a few ways to do interrupts, for now I'll focus on the type that I find the most useful/flexible, called Clear Timer on Compare Match or CTC Mode.  Additionally, in this instructable I'll be writing specifically about the timers to the Arduino Uno (and any other Arduino with ATMEL 328/168... Lilypad, Duemilanove, Diecimila, Nano...).  The main ideas presented here apply to the Mega and older boards as well, but the setup is a little different and the table below is specific to ATMEL 328/168.", "title": "Arduino Timer Interrupts", "url": "https://www.instructables.com/id/Arduino-Timer-Interrupts/", "section": "technology", "steps": [{"step": 1, "steps_text": "The Uno has three timers called timer0, timer1, and timer2.\u00a0 Each of the timers has a counter that is incremented on each tick of the timer's clock.\u00a0 CTC timer interrupts are triggered when the counter reaches a specified value, stored in the compare match register.\u00a0 Once a timer counter reaches this value it will clear (reset to zero) on the next tick of the timer's clock, then it will continue to count up to the compare match value again.\u00a0 By choosing the compare match value and setting the speed at which the timer increments the counter, you can control the frequency of timer interrupts.\nThe first parameter I'll discuss is the speed at which the timer increments the counter.\u00a0 The Arduino clock runs at 16MHz, this is the fastest speed that the timers can increment their counters.\u00a0 At 16MHz each tick of the counter represents 1/16,000,000 of a second (~63ns), so a counter will take 10/16,000,000 seconds to reach a value of 9 (counters are 0 indexed), and 100/16,000,000 seconds to reach a value of 99.\nIn many situations, you will find that setting the counter speed to 16MHz is too fast.\u00a0 Timer0 and timer2 are 8 bit timers, meaning they can store a maximum counter value of 255.\u00a0 Timer1 is a 16 bit timer, meaning it can store a maximum counter value of 65535.\u00a0 Once a counter reaches its maximum, it will tick back to zero (this is called overflow).\u00a0 This means at 16MHz, even if we set the compare match register to the max counter value, interrupts will occur every 256/16,000,000 seconds (~16us) for the 8 bit counters, and every 65,536/16,000,000 (~4 ms) seconds for the 16 bit counter.\u00a0 Clearly, this is not very useful if you only want to interrupt once a second.\nInstead you can control the speed of the timer counter incrementation by using something called a prescaler.\u00a0 A prescaler dictates the speed of your timer according the the following equation:(timer speed (Hz)) = (Arduino clock speed (16MHz)) / prescaler\nSo a 1 prescaler will increment the counter at 16MHz, an 8 prescaler will increment it at 2MHz, a 64 prescaler = 250kHz, and so on.\u00a0 As indicated in the tables above, the prescaler can equal 1, 8, 64, 256, and 1024.\u00a0 (I'll explain the meaning of CS12, CS11, and CS10 in the next step.)\u00a0\nNow you can calculate the interrupt frequency with the following equation:interrupt frequency (Hz) = (Arduino clock speed 16,000,000Hz) / (prescaler * (compare match register + 1))\nthe +1 is in there because the compare match register is zero indexed\nrearranging the equation above, you can solve for the compare match register value that will give your desired interrupt frequency:compare match register = [ 16,000,000Hz/ (prescaler * desired interrupt frequency) ] - 1\nremember that when you use timers 0 and 2 this number must be less than 256, and less than 65536 for timer1\nso if you wanted an interrupt every second (frequency of 1Hz):\ncompare match register = [16,000,000 / (prescaler * 1) ] -1\nwith a prescaler of 1024 you get:\ncompare match register = [16,000,000 / (1024 * 1) ] -1\n= 15,624\nsince 256 < 15,624 < 65,536, you must use timer1 for this interrupt.", "step_imgs": ["https://cdn.instructables.com/F3T/TIKL/H3WSA4V7/F3TTIKLH3WSA4V7.LARGE.jpg", "https://cdn.instructables.com/F8G/35IH/HFD1FIKF/F8G35IHHFD1FIKF.LARGE.jpg", "https://cdn.instructables.com/FY3/SNSN/HFD1FIKG/FY3SNSNHFD1FIKG.LARGE.jpg"], "step_title": "Step 1: Prescalers and the Compare Match Register"}, {"step": 2, "steps_text": "\nTimer setup code is done inside the setup(){} function in an Arduino sketch.\nThe code involved for setting up timer interrupts is a little daunting to look at, but it's actually not that hard.\u00a0 I pretty much just copy the same main chunk of code and change the prescaler and compare match register to set the correct interrupt frequency.\nThe main structure of the interrupt setup looks like this:\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n\nvoid setup(){\n\ncli();//stop interrupts\n\n//set timer0 interrupt at 2kHz\n  TCCR0A = 0;// set entire TCCR0A register to 0\n  TCCR0B = 0;// same for TCCR0B\n  TCNT0  = 0;//initialize counter value to 0\n  // set compare match register for 2khz increments\n  OCR0A = 124;// = (16*10^6) / (2000*64) - 1 (must be <256)\n  // turn on CTC mode\n  TCCR0A |= (1 << WGM01);\n  // Set CS01 and CS00 bits for 64 prescaler\n  TCCR0B |= (1 << CS01) | (1 << CS00);   \n  // enable timer compare interrupt\n  TIMSK0 |= (1 << OCIE0A);\n\n//set timer1 interrupt at 1Hz\n  TCCR1A = 0;// set entire TCCR1A register to 0\n  TCCR1B = 0;// same for TCCR1B\n  TCNT1  = 0;//initialize counter value to 0\n  // set compare match register for 1hz increments\n  OCR1A = 15624;// = (16*10^6) / (1*1024) - 1 (must be <65536)\n  // turn on CTC mode\n  TCCR1B |= (1 << WGM12);\n  // Set CS10 and CS12 bits for 1024 prescaler\n  TCCR1B |= (1 << CS12) | (1 << CS10);  \n  // enable timer compare interrupt\n  TIMSK1 |= (1 << OCIE1A);\n\n//set timer2 interrupt at 8kHz\n  TCCR2A = 0;// set entire TCCR2A register to 0\n  TCCR2B = 0;// same for TCCR2B\n  TCNT2  = 0;//initialize counter value to 0\n  // set compare match register for 8khz increments\n  OCR2A = 249;// = (16*10^6) / (8000*8) - 1 (must be <256)\n  // turn on CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set CS21 bit for 8 prescaler\n  TCCR2B |= (1 << CS21);   \n  // enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n\nsei();//allow interrupts\n\n}//end setup\nNotice how the value of OCR#A (the compare match value) changes for each of these timer setups.\u00a0 As explained in the last step, this was calculated according to the following equation:\ncompare match register = [ 16,000,000Hz/ (prescaler * desired interrupt frequency) ] - 1\nremember that when you use timers 0 and 2 this number must be less than 256, and less than 65536 for timer1\nAlso notice how the setups between the three timers differ slightly in the line which turns on CTC mode:\nTCCR0A |= (1 << WGM01);//for timer0\nTCCR1B |= (1 << WGM12);//for timer1\nTCCR2A |= (1 << WGM21);//for timer2\nThis follows directly from the datasheet of the ATMEL 328/168.\nFinally, notice how the setup for the prescalers follows the tables in the last step (the table for timer 0 is repeated above),\nTCCR2B |= (1 << CS22);\u00a0 // Set CS#2 bit for 64 prescaler for timer 2\nTCCR1B |= (1 << CS11);\u00a0 // Set CS#1 bit for 8 prescaler for timer 1\nTCCR0B |= (1 << CS02) | (1 << CS00);\u00a0 // Set CS#2 and CS#0 bits for 1024 prescaler for timer 0\nNotice in the last step that there are different prescaling options for the different timers.\u00a0 For example, timer2 does not have the option of 1024 prescaler.\nThe commands you want to execute during these timer interrupts are located in the Arduino sketch encapsulated in the following:\nISR(TIMER0_COMPA_vect){\u00a0 //change the 0 to 1 for timer1 and 2 for timer2\n\u00a0\u00a0 //interrupt commands here\n}\nThis bit of code should be located outside the setup() and loop() functions.\u00a0 Also, try to keep the interrupt routine as short as possible, especially if you are interrupting at a high frequency.\u00a0 It may even be worth addressing the ports/pins of the ATMEL chip directly instead of using the digitalWrite() and digitalRead() functions.\u00a0 You can find more info about that here.\nExample- the following sketch sets up and executes 3 timer interrupts:\n//timer interrupts\n//by Amanda Ghassaei\n//June 2012\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\n//timer setup for timer0, timer1, and timer2.\n//For arduino uno or any board with ATMEL 328/168.. diecimila, duemilanove, lilypad, nano, mini...\n\n//this code will enable all three arduino timer interrupts.\n//timer0 will interrupt at 2kHz\n//timer1 will interrupt at 1Hz\n//timer2 will interrupt at 8kHz\n\n//storage variables\nboolean toggle0 = 0;\nboolean toggle1 = 0;\nboolean toggle2 = 0;\n\nvoid setup(){\n  \n  //set pins as outputs\n  pinMode(8, OUTPUT);\n  pinMode(9, OUTPUT);\n  pinMode(13, OUTPUT);\n\ncli();//stop interrupts\n\n//set timer0 interrupt at 2kHz\n  TCCR0A = 0;// set entire TCCR2A register to 0\n  TCCR0B = 0;// same for TCCR2B\n  TCNT0  = 0;//initialize counter value to 0\n  // set compare match register for 2khz increments\n  OCR0A = 124;// = (16*10^6) / (2000*64) - 1 (must be <256)\n  // turn on CTC mode\n  TCCR0A |= (1 << WGM01);\n  // Set CS01 and CS00 bits for 64 prescaler\n  TCCR0B |= (1 << CS01) | (1 << CS00);   \n  // enable timer compare interrupt\n  TIMSK0 |= (1 << OCIE0A);\n\n//set timer1 interrupt at 1Hz\n  TCCR1A = 0;// set entire TCCR1A register to 0\n  TCCR1B = 0;// same for TCCR1B\n  TCNT1  = 0;//initialize counter value to 0\n  // set compare match register for 1hz increments\n  OCR1A = 15624;// = (16*10^6) / (1*1024) - 1 (must be <65536)\n  // turn on CTC mode\n  TCCR1B |= (1 << WGM12);\n  // Set CS12 and CS10 bits for 1024 prescaler\n  TCCR1B |= (1 << CS12) | (1 << CS10);  \n  // enable timer compare interrupt\n  TIMSK1 |= (1 << OCIE1A);\n\n//set timer2 interrupt at 8kHz\n  TCCR2A = 0;// set entire TCCR2A register to 0\n  TCCR2B = 0;// same for TCCR2B\n  TCNT2  = 0;//initialize counter value to 0\n  // set compare match register for 8khz increments\n  OCR2A = 249;// = (16*10^6) / (8000*8) - 1 (must be <256)\n  // turn on CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set CS21 bit for 8 prescaler\n  TCCR2B |= (1 << CS21);   \n  // enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n\nsei();//allow interrupts\n\n}//end setup\n\nISR(TIMER0_COMPA_vect){//timer0 interrupt 2kHz toggles pin 8\n//generates pulse wave of frequency 2kHz/2 = 1kHz (takes two cycles for full wave- toggle high then toggle low)\n  if (toggle0){\n    digitalWrite(8,HIGH);\n    toggle0 = 0;\n  }\n  else{\n    digitalWrite(8,LOW);\n    toggle0 = 1;\n  }\n}\n\nISR(TIMER1_COMPA_vect){//timer1 interrupt 1Hz toggles pin 13 (LED)\n//generates pulse wave of frequency 1Hz/2 = 0.5kHz (takes two cycles for full wave- toggle high then toggle low)\n  if (toggle1){\n    digitalWrite(13,HIGH);\n    toggle1 = 0;\n  }\n  else{\n    digitalWrite(13,LOW);\n    toggle1 = 1;\n  }\n}\n  \nISR(TIMER2_COMPA_vect){//timer1 interrupt 8kHz toggles pin 9\n//generates pulse wave of frequency 8kHz/2 = 4kHz (takes two cycles for full wave- toggle high then toggle low)\n  if (toggle2){\n    digitalWrite(9,HIGH);\n    toggle2 = 0;\n  }\n  else{\n    digitalWrite(9,LOW);\n    toggle2 = 1;\n  }\n}\n\n\nvoid loop(){\n  //do other things here\n}\n\nThe images above show the outputs from these timer interrupts.\u00a0 Fig 1 shows a square wave oscillating between 0 and 5V at 1kHz (timer0 interrupt), fig 2 shows the LED attached to pin 13 turning on for one second then turning off for one second (timer1 interrupt),\u00a0 fig 3 shows a pulse wave oscillating between 0 and 5V at a frequency of 4khz (timer2 interrupt).\n        ", "step_imgs": ["https://cdn.instructables.com/FBX/1C17/H3Z3SUCT/FBX1C17H3Z3SUCT.LARGE.jpg", "https://cdn.instructables.com/FK9/L3PY/H3Z3C64Y/FK9L3PYH3Z3C64Y.LARGE.jpg", "https://cdn.instructables.com/F90/L1JK/H3Z3TWLR/F90L1JKH3Z3TWLR.LARGE.jpg", "https://cdn.instructables.com/FHI/YRBY/HFD189ZY/FHIYRBYHFD189ZY.LARGE.jpg"], "step_title": "Step 2: Structuring Timer Interrupts"}, {"step": 3, "steps_text": "\n          In this example I made an arduino powered bike speedometer.\u00a0 It works by attaching a magnet to the wheel and measuring the amount of time it takes to pass by a magnetic switch mounted on the frame- the time for one complete rotation of the wheel.\nI set timer 1 to interrupt every ms (frequency of 1kHz) to measure the magnetic switch.\u00a0 If the magnet is passing by the switch, the signal from the switch is high and the variable \"time\" gets set to zero.\u00a0 If the magnet is not near the switch \"time\" gets incremented by 1.\u00a0 This way \"time\" is actually just a measurement of the amount of time in milliseconds that has passed since the magnet last passed by the magnetic switch.\u00a0 This info is used later in the code to calculate rpm and mph of the bike.\nHere's the bit of code that sets up timer1 for 1kHz interrupts\ncli();//stop interrupts\n//set timer1 interrupt at 1kHz\nTCCR1A = 0;// set entire TCCR1A register to 0\nTCCR1B = 0;// same for TCCR1B\nTCNT1\u00a0 = 0;//initialize counter value to 0\n// set timer count for 1khz increments\nOCR1A = 1999;// = (16*10^6) / (1000*8) - 1\n//had to use 16 bit timer1 for this bc 1999>255, but could switch to timers 0 or 2 with larger prescaler\n// turn on CTC mode\nTCCR1B |= (1 << WGM12);\n// Set CS11 bit for 8 prescaler\nTCCR1B |= (1 << CS11);\u00a0\u00a0\n// enable timer compare interrupt\nTIMSK1 |= (1 << OCIE1A);\nsei();//allow interrupts\nHere's the complete code if you want to take a look://bike speedometer\n//by Amanda Ghassaei 2012\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*/\n\n//sample calculations\n//tire radius ~ 13.5 inches\n//circumference = pi*2*r =~85 inches\n//max speed of 35mph =~ 616inches/second\n//max rps =~7.25\n\n#define reed A0//pin connected to read switch\n\n//storage variables\nfloat radius = 13.5;// tire radius (in inches)- CHANGE THIS FOR YOUR OWN BIKE\n\nint reedVal;\nlong time = 0;// time between one full rotation (in ms)\nfloat mph = 0.00;\nfloat circumference;\nboolean backlight;\n\nint maxReedCounter = 100;//min time (in ms) of one rotation (for debouncing)\nint reedCounter;\n\n\nvoid setup(){\n  \n  reedCounter = maxReedCounter;\n  circumference = 2*3.14*radius;\n  pinMode(1,OUTPUT);//tx\n  pinMode(2,OUTPUT);//backlight switch\n  pinMode(reed,INPUT);//redd switch\n  \n  checkBacklight();\n  \n  Serial.write(12);//clear\n  \n  // TIMER SETUP- the timer interrupt allows preceise timed measurements of the reed switch\n  //for mor info about configuration of arduino timers see http://arduino.cc/playground/Code/Timer1\n  cli();//stop interrupts\n\n  //set timer1 interrupt at 1kHz\n  TCCR1A = 0;// set entire TCCR1A register to 0\n  TCCR1B = 0;// same for TCCR1B\n  TCNT1  = 0;//initialize counter value to 0;\n  // set timer count for 1khz increments\n  OCR1A = 1999;// = (16*10^6) / (1000*8) - 1\n  // turn on CTC mode\n  TCCR1B |= (1 << WGM12);\n  // Set CS11 bit for 8 prescaler\n  TCCR1B |= (1 << CS11);   \n  // enable timer compare interrupt\n  TIMSK1 |= (1 << OCIE1A);\n  \n  sei();//allow interrupts\n  //END TIMER SETUP\n  \n  Serial.begin(9600);\n}\n\nvoid checkBacklight(){\n  backlight = digitalRead(2);\n  if (backlight){\n    Serial.write(17);//turn backlight on\n  }\n  else{\n    Serial.write(18);//turn backlight off\n  }\n}\n\nISR(TIMER1_COMPA_vect) {//Interrupt at freq of 1kHz to measure reed switch\n  reedVal = digitalRead(reed);//get val of A0\n  if (reedVal){//if reed switch is closed\n    if (reedCounter == 0){//min time between pulses has passed\n      mph = (56.8*float(circumference))/float(time);//calculate miles per hour\n      time = 0;//reset timer\n      reedCounter = maxReedCounter;//reset reedCounter\n    }\n    else{\n      if (reedCounter > 0){//don't let reedCounter go negative\n        reedCounter -= 1;//decrement reedCounter\n      }\n    }\n  }\n  else{//if reed switch is open\n    if (reedCounter > 0){//don't let reedCounter go negative\n      reedCounter -= 1;//decrement reedCounter\n    }\n  }\n  if (time > 2000){\n    mph = 0;//if no new pulses from reed switch- tire is still, set mph to 0\n  }\n  else{\n    time += 1;//increment timer\n  } \n}\n\nvoid displayMPH(){\n  Serial.write(12);//clear\n  Serial.write(\"Speed =\");\n  Serial.write(13);//start a new line\n  Serial.print(mph);\n  Serial.write(\" MPH \");\n  //Serial.write(\"0.00 MPH \");\n}\n\nvoid loop(){\n  //print mph once a second\n  displayMPH();\n  delay(1000);\n  checkBacklight();\n}\n\n\n", "step_imgs": ["https://cdn.instructables.com/FTA/IXO8/H3NN9MP6/FTAIXO8H3NN9MP6.LARGE.jpg", "https://cdn.instructables.com/FF6/VLYP/H3XN364W/FF6VLYPH3XN364W.LARGE.jpg", "https://cdn.instructables.com/FPN/QG5O/H3Q4SDBL/FPNQG5OH3Q4SDBL.LARGE.jpg"], "step_title": "Step 3: Example 1: Bike Speedometer"}, {"step": 4, "steps_text": "\n          This project is a 4x4 backlit button pad.\u00a0 The project connects to my computer via usb, it sends information about the buttons to the computer and receives information about how to light up the LEDs. Here is a video:\nFor this project, I used timer2 interrupts to periodically check if there was any incoming serial data, read it, and store it in the matrix \"ledData[]\".\u00a0 If you take a look at the code you will see that the main loop of the sketch is what is actually responsible for using the info in ledData to light up the correct LEDs and checking on the status of the buttons (a function called \"shift()\").\u00a0 The interrupt routine is as short as possible- just checking for incoming bytes and storing them appropriately.\nHere is the setup for timer2:\ncli();//stop interrupts\n//set timer2 interrupt every 128us\nTCCR2A = 0;// set entire TCCR2A register to 0\nTCCR2B = 0;// same for TCCR2B\nTCNT2\u00a0 = 0;//initialize counter value to 0\n// set compare match register for 7.8khz increments\nOCR2A = 255;// = (16*10^6) / (7812.5*8) - 1 (must be <256)\n// turn on CTC mode\nTCCR2A |= (1 << WGM21);\n// Set CS21 bit for 8 prescaler\nTCCR2B |= (1 << CS21);\u00a0\u00a0\n// enable timer compare interrupt\nTIMSK2 |= (1 << OCIE2A);\nsei();//allow interrupts\nHere's the complete Arduino sketch://BUTTON TEST w/ 74HC595 and 74HC165 and serial communication\n//by Amanda Ghassaei\n//June 2012\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n*/\n\n//this firmware will send data back and forth with the maxmsp patch \"beat slicer\"\n\n//pin connections\n#define ledLatchPin A1\n#define ledClockPin A0\n#define ledDataPin A2\n#define buttonLatchPin 9\n#define buttonClockPin 10\n#define buttonDataPin A3\n\n//looping variables\nbyte i;\nbyte j;\nbyte k;\nbyte ledByte;\n\n//storage for led states, 4 bytes\nbyte ledData[] = {0, 0, 0, 0};\n//storage for buttons, 4 bytes\nbyte buttonCurrent[] = {0,0,0,0};\nbyte buttonLast[] = {0,0,0,0};\nbyte buttonEvent[] = {0,0,0,0};\nbyte buttonState[] = {0,0,0,0};\n//button debounce counter- 16 bytes\nbyte buttonDebounceCounter[4][4];\n\n\nvoid setup() {\n  DDRC = 0xF7;//set A0-2 and A4-5 output, A3 input\n  DDRB = 0xFF;//digital pins 8-13 output\n  \n  Serial.begin(57600);\n  \n  cli();//stop interrupts\n\n  //set timer2 interrupt every 128us\n  TCCR2A = 0;// set entire TCCR2A register to 0\n  TCCR2B = 0;// same for TCCR2B\n  TCNT2  = 0;//initialize counter value to 0\n  // set compare match register for 7.8khz increments\n  OCR2A = 255;// = (16*10^6) / (7812.5*8) - 1 (must be <256)\n  // turn on CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set CS21 bit for 8 prescaler\n  TCCR2B |= (1 << CS21);   \n  // enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n  \n  sei();//allow interrupts\n  \n}\n\n// buttonCheck - checks the state of a given button.\n//this buttoncheck function is largely copied from the monome 40h firmware by brian crabtree and joe lake\nvoid buttonCheck(byte row, byte index)\n{\n  if (((buttonCurrent[row] ^ buttonLast[row]) & (1 << index)) &&   // if the current physical button state is different from the\n  ((buttonCurrent[row] ^ buttonState[row]) & (1 << index))) {  // last physical button state AND the current debounced state\n\n    if (buttonCurrent[row] & (1 << index)) {                      // if the current physical button state is depressed\n      buttonEvent[row] = 1 << index;              // queue up a new button event immediately\n      buttonState[row] |= (1 << index);                         // and set the debounced state to down.\n  }\n    else{\n      buttonDebounceCounter[row][index] = 12;\n    }  // otherwise the button was previously depressed and now\n    // has been released so we set our debounce counter.\n  }\n  else if (((buttonCurrent[row] ^ buttonLast[row]) & (1 << index)) == 0 &&  // if the current physical button state is the same as\n  (buttonCurrent[row] ^ buttonState[row]) & (1 << index)) {        // the last physical button state but the current physical\n    // button state is different from the current debounce \n    // state...\n    if (buttonDebounceCounter[row][index] > 0 && --buttonDebounceCounter[row][index] == 0) {  // if the the debounce counter has\n      // been decremented to 0 (meaning the\n      // the button has been up for \n      // kButtonUpDefaultDebounceCount \n      // iterations///\n\n      buttonEvent[row] = 1 << index;    // queue up a button state change event\n\n      if (buttonCurrent[row] & (1 << index)){          // and toggle the buttons debounce state.\n        buttonState[row] |= (1 << index);\n      }\n      else{\n        buttonState[row] &= ~(1 << index);\n      }\n    }\n  }\n}\n\n\nvoid shift(){\n  \n  for (i=0;i<4;i++){\n    \n    buttonLast[i] = buttonCurrent[i];\n    \n    byte dataToSend = (1 << (i+4)) | (15 & ~ledData[i]);\n      \n    // set latch pin low so the LEDs don't change while sending in bits\n    digitalWrite(ledLatchPin, LOW);\n    // shift out the bits of dataToSend\n    shiftOut(ledDataPin, ledClockPin, LSBFIRST, dataToSend);  \n    //set latch pin high so the LEDs will receive new data\n    digitalWrite(ledLatchPin, HIGH);\n      \n    //once one row has been set high, receive data from buttons\n    //set latch pin high\n    digitalWrite(buttonLatchPin, HIGH);\n    //shift in data\n    buttonCurrent[i] = shiftIn(buttonDataPin, buttonClockPin, LSBFIRST) >> 3;\n    //latchpin low\n    digitalWrite(buttonLatchPin, LOW);\n    \n    for (k=0;k<4;k++){\n      buttonCheck(i,k);\n      if (buttonEvent[i]<<k){\n        if (buttonState[i]&1<<k){\n          Serial.write(((3-k)<<3)+(i<<1)+1);\n        }\n        else{\n          Serial.write(((3-k)<<3)+(i<<1)+0);\n        }\n        buttonEvent[i] &= ~(1<<k);\n      }\n    }\n  }\n}\n\n\nISR(TIMER2_COMPA_vect) {\n  do{\n    if (Serial.available()){\n      ledByte = Serial.read();//000xxyys\n      boolean ledstate = ledByte & 1;\n      byte ledy = (ledByte >> 1) & 3;\n      byte ledx = (ledByte >> 3) & 3;\n      if (ledstate){\n        ledData[ledy] |= 8 >> ledx;\n      }\n      else{\n        ledData[ledy] &= ~ (8 >> ledx);\n      }\n    }//end if serial available\n  }//end do\n while (Serial.available() > 8);\n}    \n\n\nvoid loop() {\n  shift();//updates leds and receives data from buttons\n}\n\n\ndownload the MaxMSP patch below (it will run in Max Runtime as well).\n        ", "step_imgs": ["https://cdn.instructables.com/FEO/NR9H/H4AGIFI0/FEONR9HH4AGIFI0.LARGE.jpg", "https://cdn.instructables.com/FMN/85D5/H4AGJH3W/FMN85D5H4AGJH3W.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Example 2: Serial Communication"}, {"step": 5, "steps_text": "\n          In this project I used a timer interrupt to output a sine wave of a specific frequency from the Arduino. I soldered a simple 8 bit R2R DAC to digital pins 0-7.\u00a0 This DAC was constructed from 10k and 20k resistors arranged in a multi-leveled voltage divider.\u00a0 I'll be posting more about the construction of the DAC in another instructable, for now I've included the photo's above.\nI connected the output from the DAC up to an oscilloscope.\u00a0 If you need help understanding how to use/read the oscilloscope check out this tutorial.\u00a0 I loaded the following code onto the Arduino://63Hz sine wave\n//by Amanda Ghassaei 2012\n//https://www.instructables.com/id/Arduino-Timer-Interrupts/\n\n/*\n* This program is free software; you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation; either version 3 of the License, or\n* (at your option) any later version.\n*\n*/\n\n//sends 63Hz sine wave to arduino PORTD DAC\nfloat t = 0;\n\nvoid setup() {\n  //set port/pin  mode. see http://www.arduino.cc/en/Reference/PortManipulation for more info\n  DDRD = 0xFF;//port d (digital pins 0-7) all outputs\n \n  cli();//stop interrupts\n\n  //set timer2 interrupt at 40kHz\n  TCCR2A = 0;// set entire TCCR2A register to 0\n  TCCR2B = 0;// same for TCCR2B\n  TCNT2  = 0;//initialize counter value to 0\n  // set compare match register for 40khz increments\n  OCR2A = 49;// = (16*10^6) / (8*40000)-1\n  // turn on CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set CS21 bit for 8 prescaler\n  TCCR2B |= (1 << CS21);  \n  // enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n \n  sei();//allow interrupts\n}\n\nISR(TIMER2_COMPA_vect) {\n  //increment t\n  t+=1;\n  if (t==628){//40kHz/628 =~ 63Hz\n    t=0;\n  }\n}\n\n\nvoid loop(){\n  //sine wave of frequency ~63Hz\n  //send sine values to PORTD between 0 and 255\n  PORTD=byte(127+127*sin(t/100));\n}\n\n\n\nI set up a timer interrupt that increments the variable t at a frequency of 40kHz.\u00a0 Once t reaches 627 it resets back to zero (this happens with a frequency of 40,000/628 = 63Hz).\u00a0 Meanwhile, in the main loop the Arduino sends a value between 0 (00000000 in binary) and 255 (11111111 in binary) to digital pins 0 through 7 (PORTD).\u00a0 It calculates this value with the following equation:PORTD=byte(127+127*sin(t/100));\nSo as t increments from 0 to 627 the sine function moves through one complete cycle.\u00a0 The value sent to PORTD is a sine wave with frequency 63Hz and amplitude 127, oscillating around 127.\u00a0 When this is sent through the 8 bit resistor ladder DAC it outputs an oscillating signal around 2.5V with an amplitude of 2.5V and frequency of 63Hz.\nThe frequency of the sine wave can be doubled by multiplying the (t/100) term by 2, quadrupled by multiplying by 4, and so on...\nAlso notice that if you increase the frequency of the timer interrupt too much by decreasing the prescaler or OCR2A the sine wave will not output correctly.\u00a0 This is because the sin() function is computationally expensive, and at high interrupt frequencies it does not have enough time to execute.\u00a0 If you are using high frequency interrupts, instead of performing a computation during the interrupt routine, considering storing values in an array and simply calling these values using some kind of index.\u00a0 You can find an example of that in my arduino waveform generator- by storing 20,000 values of sin in an array, I was able to output sine waves with a sampling frequency of 100kHz.", "step_imgs": ["https://cdn.instructables.com/FYY/B8JH/H4AGKE5L/FYYB8JHH4AGKE5L.LARGE.jpg", "https://cdn.instructables.com/FPY/2TJ4/H2WEWMIS/FPY2TJ4H2WEWMIS.LARGE.jpg", "https://cdn.instructables.com/FLI/SAXX/H2WEQJBZ/FLISAXXH2WEQJBZ.LARGE.jpg", "https://cdn.instructables.com/FAL/P9EO/H337JN9F/FALP9EOH337JN9F.LARGE.jpg", "https://cdn.instructables.com/FBB/KP59/H2WEWLS2/FBBKP59H2WEWLS2.LARGE.jpg"], "step_title": "Step 5: Example 3: DAC"}, {"step": 6, "steps_text": "One last thing to note- certain timer setups will actually disable some of the Arduino library functions.\u00a0 Timer0 is used by the functions millis() and delay(), if you manually set up timer0, these functions will not work correctly.\nAdditionally, all three timers underwrite the function analogWrite().\u00a0 Manually setting up a timer will stop analogWrite() from working.\nIf there is some portion of your code that you don't want interrupted, considering using cli() and sei() to globally disable and enable interrupts.\nYou can read more about this on the Arduino website.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FR8/2QNL/H4AFSO5L/FR82QNLH4AFSO5L.LARGE.jpg"], "step_title": "Step 6: Timer and Arduino Functions"}], "channel": "Arduino"}, {"category": "technology", "description": "This Instructable will walk you through my process of making a Slot Machine costume with addressable leds controlled with an arduino!", "title": "Led Slot Machine Costume", "url": "https://www.instructables.com/id/Led-Slot-Machine-Costume/", "section": "technology", "steps": [{"step": 1, "steps_text": "Shirt Parts:\nPlain white T-Shirt\nOld or new white shirt to cut\n1 meter addressable led strip from Adafruit\u00a0\nArduino (I used an uno smd)\nSewing gauge (or other\u00a0measuring\u00a0device)\n1 pkg Heat-N-Bond\u00a0ultra hold\u00a0\nBattery holder for 4 AA's\u00a0\n4 AA's rechargeable 1500mah\u00a0\nIron on transfer paper\nHat parts:\nHot glue gun\nHat\nFlashing led kit\u00a0( I got mine from the shack, but it's also avil online elsewhere)\n2 Basic night lights\n2 Lg washers\n9V Batt\nClear tape", "step_imgs": ["https://cdn.instructables.com/FXC/DC8Z/H742FG9A/FXCDC8ZH742FG9A.LARGE.jpg", "https://cdn.instructables.com/FKU/5EDP/H742FG91/FKU5EDPH742FG91.LARGE.jpg", "https://cdn.instructables.com/F1M/2E1N/H742FG93/F1M2E1NH742FG93.LARGE.jpg", "https://cdn.instructables.com/FBX/T5L7/H742FG95/FBXT5L7H742FG95.LARGE.jpg", "https://cdn.instructables.com/F55/CBCI/H742FG96/F55CBCIH742FG96.LARGE.jpg", "https://cdn.instructables.com/FXP/G8KM/H742FG97/FXPG8KMH742FG97.LARGE.jpg", "https://cdn.instructables.com/FL3/LHXP/H742FG98/FL3LHXPH742FG98.LARGE.jpg", "https://cdn.instructables.com/FWA/D0JV/H742FG9B/FWAD0JVH742FG9B.LARGE.jpg", "https://cdn.instructables.com/FCN/7W8Y/H742FG9D/FCN7W8YH742FG9D.LARGE.jpg", "https://cdn.instructables.com/FJH/OAIN/H742FG9E/FJHOAINH742FG9E.LARGE.jpg", "https://cdn.instructables.com/FMT/5NIU/H742FGA2/FMT5NIUH742FGA2.LARGE.jpg", "https://cdn.instructables.com/FQJ/GFVU/H7ANSLCQ/FQJGFVUH7ANSLCQ.LARGE.jpg"], "step_title": "Step 1: The Parts List"}, {"step": 2, "steps_text": "Picture set up:\nI found my slot picture online that the best graphic that when enlarged would stay nice and clear. Be sure to follow the directions on the iron on transfer paper when printing and\u00a0transferring. Print the picture to full page 8.5 by 11 HINT: Turn off\u00a0border less\u00a0printing or it will cut off part of the pic. I forgot and end cut part off the pic.\u00a0\nLay out the transfer paper and mark the edges with pins ( see pic 1 ) \u00a0and check to be sure it is centered. Once you are happy with the lay out you can go ahead and lay the transfer back down and remove the pins.\u00a0\nStart the transfer process following the iron on transfer instructions. Let it cool\u00a0completely\u00a0before attempting to remove. If you notice the transfer not bonding as you lift , reheat it\u00a0until\u00a0it bonds.\nLight holders: \u00a0\nWe need a way for the addressable leds to stay in place. I chose to use Heat-N-Bond with some extra fabric.\u00a0\nCut fabric strips about 2 1/2\" wide and 2\" longer then each side ( you should end up with 4 strips for all sides) (See Pic 2)\nCut the Heat-N-Bond to the size of the strips and attach following the instructions provided with the\u00a0package. (See Pic 3)\nCut some more fabric strips to 1 1/2\" wide by as long as the other strips you just made. (See Pic 4)\nCut 2\" by 2\" fabric squares and iron them to the ends of the strips. (See Pic 5)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Attach the light holder strips:\nTurn the shirt inside out and position the 1 1/2\" (See pic 4a ) strips along the picture outline. Peal the backing off the Heat-N-Bond of the wider strips and lay facing down on top of small strips being sure it is centered. \u00a0(See pic 4b)\nIron on following the instructions provided in\u00a0package.\nYou should now have long pockets along the\u00a0perimeter of the picture with 2\" ends that can be lifted ( these will later be used for access to solder the lights then bonded down) \u00a0(See pic 6)\n\u00a0\n\u00a0", "step_imgs": ["https://cdn.instructables.com/FCN/7W8Y/H742FG9D/FCN7W8YH742FG9D.LARGE.jpg", "https://cdn.instructables.com/FXP/G8KM/H742FG97/FXPG8KMH742FG97.LARGE.jpg", "https://cdn.instructables.com/FL3/LHXP/H742FG98/FL3LHXPH742FG98.LARGE.jpg", "https://cdn.instructables.com/FWA/D0JV/H742FG9B/FWAD0JVH742FG9B.LARGE.jpg", "https://cdn.instructables.com/FH6/0SAB/H742FGE5/FH60SABH742FGE5.LARGE.jpg", "https://cdn.instructables.com/F6T/RRJR/H742FGE6/F6TRRJRH742FGE6.LARGE.jpg", "https://cdn.instructables.com/FDQ/PB1P/H742FGE7/FDQPB1PH742FGE7.LARGE.jpg", "https://cdn.instructables.com/F06/RTXI/H742FGE8/F06RTXIH742FGE8.LARGE.jpg", "https://cdn.instructables.com/FP1/XCL6/H742FGE9/FP1XCL6H742FGE9.LARGE.jpg"], "step_title": "Step 2: Lets Get Started"}, {"step": 3, "steps_text": "Adding the lights:\nCut the light strips so there is 6 leds on two strips and 10 leds on two more strips ( 4 strips total)\nInsert the two longer strips into the bottom and top of the light holders (see pic A) Making sure to keep track of \u00a0the in and out of each section.\nThen insert the other two strips.\nPlace some foil under the end of the strip so you don't burn the shirt while soldering. These can be soldered on the front or the back either way will do. But be sure to keep track of the 5v+, 5v-, DI, CI lines they must match. It is important that the out put end connects to the input line!! (See Pic B)\nLeave one end unconnected (I chose bottom right) The end of the short strip can be left untouched, However the longer bottom strip with the input will need some pins soldered. ( See Pic C)\nTESTING!! \u00a0Must test before closing up fabric ends.\u00a0\nLoad the arduino sketch and connect to make sure all lights and connections are in working order.\nConnect the Di of the led strip to arduino pin 11\nConnect the Ci of the led strip to arduino pin 13\nConnect the -5V of the led strip to arduino ground\nConnect the +5v of the led strop to arduino +5v\nClose it all up:\nOnce you have determined all is working we can now close up the extra fabric flaps. Lay them all flat and determine if there is any extra you want to trim. Cut a slit where the pins will\u00a0protrude from and mark the the - and +( See pic D)\u00a0\nNow cut some small strip of Heat-N-bond and iron it the the shirt just under the flaps, peal the backing and lay the fabric flap over and iron. \u00a0( See pic E for finished look)\nAttach cable of choice again be sure to keep track of the wire layout.\u00a0", "step_imgs": ["https://cdn.instructables.com/F62/AKYC/H742FGDP/F62AKYCH742FGDP.LARGE.jpg", "https://cdn.instructables.com/FC6/M39S/H742FGDR/FC6M39SH742FGDR.LARGE.jpg", "https://cdn.instructables.com/FPP/HMKL/H742FGDU/FPPHMKLH742FGDU.LARGE.jpg", "https://cdn.instructables.com/FP1/C23O/H7ANSL5R/FP1C23OH7ANSL5R.LARGE.jpg", "https://cdn.instructables.com/FZG/4FXI/H7ANSL5S/FZG4FXIH7ANSL5S.LARGE.jpg", "https://cdn.instructables.com/FAK/MFDK/H7ANSL5T/FAKMFDKH7ANSL5T.LARGE.jpg", "https://cdn.instructables.com/FSY/L4TO/H7ANSL6F/FSYL4TOH7ANSL6F.LARGE.jpg", "https://cdn.instructables.com/FQH/4W7D/H7ANSL6G/FQH4W7DH7ANSL6G.LARGE.jpg"], "step_title": "Step 3: Moving on to the Next Phase"}, {"step": 4, "steps_text": "For the enclosure I used a plastic box I had laying around and It fit just right. An altoids tin will work just as well.\u00a0\nConnect some wire to four pins and make a small hole in the side of the enclosure (See pic A1) On the inside of the enclosure slit the wire so you have 2 sets of 2 . Take 2 pins and bend at a 90o angle and solder the +5v and -5v to these. Next take 3pins beld at a 90o angle and solder the Di and Ci wires to each end.\u00a0\nBatteries:\nI used a battery holder for 4 AA's it has two wires and a switch. Chose the location of the battery holder and cut a small hole for the switch. Connect 2 pins bet at a 90o angle and solder to the end. ( These will connect to the VIN and gnd on the arduino\nThe enclosure is now complete!!", "step_imgs": ["https://cdn.instructables.com/FI3/22A8/H7ANSL9O/FI322A8H7ANSL9O.LARGE.jpg", "https://cdn.instructables.com/FVP/XTGI/H7ANSL9Q/FVPXTGIH7ANSL9Q.LARGE.jpg", "https://cdn.instructables.com/FXC/DC8Z/H742FG9A/FXCDC8ZH742FG9A.LARGE.jpg", "https://cdn.instructables.com/F3Q/MA1D/H7ANSL9N/F3QMA1DH7ANSL9N.LARGE.jpg", "https://cdn.instructables.com/FS6/KI9Y/H7ANSL9P/FS6KI9YH7ANSL9P.LARGE.jpg"], "step_title": "Step 4: The Enclosure"}, {"step": 5, "steps_text": "Building the hat light:\nStart heating up the glue gun:\nBuild the flashing led kit. Then remove \u00a0the covers from 2 nightlights and trace the outline from the bottom of the covers on a piece of cardboard (this will\u00a0separate\u00a0and hold the led kit in place). (pic C1)\nThe cardboard will need to be trimmed a bit more as needed so as it holds it in the center. (pic C2)\nHold one nightlight on the front of the hat with the washer inside on the bottom slightly to one side of the center of the hat and place some glue in the center of the washer and hold till it dries. Remove the light cover and repeat for the second washer. (pic C3)\u00a0\nNow assemble the light with the cardboard and flasher kit inside under both washers and place a piece of clear tape over the seam.(pic C4) \u00a0 \u00a0 Make a small hole in the hat by the seam of the brim and face to run the wire inside. Now on the inside add a switch and battery clip.(pic C5, C6) \u00a0 \u00a0 Glue the switch behind the sweat band so it can easily be reached. Glue the 9V batt to the side of the hat where it will be\u00a0comfortable. I chose the the top front where the hat sticks out the most.\u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/F2F/N6TO/H7ANSLCI/F2FN6TOH7ANSLCI.LARGE.jpg", "https://cdn.instructables.com/FF5/ATBC/H7ANSLCK/FF5ATBCH7ANSLCK.LARGE.jpg", "https://cdn.instructables.com/FQJ/GFVU/H7ANSLCQ/FQJGFVUH7ANSLCQ.LARGE.jpg", "https://cdn.instructables.com/F6I/1O5L/H7ANSLCR/F6I1O5LH7ANSLCR.LARGE.jpg", "https://cdn.instructables.com/F2V/YL4K/H7ANSLCS/F2VYL4KH7ANSLCS.LARGE.jpg", "https://cdn.instructables.com/FHM/YTG8/H7ANSLCV/FHMYTG8H7ANSLCV.LARGE.jpg", "https://cdn.instructables.com/FDH/S1I8/H7ANSLCX/FDHS1I8H7ANSLCX.LARGE.jpg", "https://cdn.instructables.com/FQG/ZNW0/H7ANSLCY/FQGZNW0H7ANSLCY.LARGE.jpg", "https://cdn.instructables.com/FWR/INZQ/H7ANSLCZ/FWRINZQH7ANSLCZ.LARGE.jpg", "https://cdn.instructables.com/FLI/KRUO/H7ANSLD1/FLIKRUOH7ANSLD1.LARGE.jpg"], "step_title": "Step 5: Hat Light"}, {"step": 6, "steps_text": "  #include \"LPD8806.h\"  #include   // Example to control LPD8806-based RGB LED Modules in a strip  //digital in pin 11  //clock in pin 13  /*****************************************************************************/  // The LED strips are 32 LEDs per meter but you can extend/cut the strip  LPD8806 strip = LPD8806(32); // Set the first variable to the NUMBER of pixels. 32 = 32 pixels in a row  void setup() {  \u00a0 // Start up the LED strip  \u00a0 strip.begin();  \u00a0 // Update the strip, to start they are all 'off'  \u00a0 strip.show();  }  void loop() {  \u00a0 randomSparkleUpSegment(strip.Color(25,0,0),15,10,101,152); //color, density, delay, low point, high point  \u00a0 turnSegmentOn(strip.Color(25,0,0),1000, 101, 152); //color, delay, start of segment, end of segment  \u00a0 randomSparkleUpSegment(strip.Color(0,25,0),15,10,0,100); //color, density, delay, low point, high point  \u00a0 turnSegmentOn(strip.Color(0,25,0),200,0,100); //color, delay, start of segment, end of segment  \u00a0 delay(500);  \u00a0 turnAllOff;  \u00a0 fillUpTheStar(strip.Color(0,0,25),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(0,0,25),30); //color, delay  \u00a0 fillUpTheStar(strip.Color(25,0,0),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(25,0,0),30); //color, delay  \u00a0 fillUpTheStar(strip.Color(0,25,0),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(0,25,0),30); //color, delay  \u00a0 fillUpTheStar(strip.Color(25,25,25),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(25,25,25),30); //color, delay  \u00a0  \u00a0 turnAllOn(strip.Color(25,0,0),200); //color, delay - turn all pixels one color  \u00a0 dither(strip.Color(0,25,0), 50); //color, delay - random fills up the strip  \u00a0 fadeDown(0,25,0,30); //red, green, blue, delay - fade down all pixels one color  \u00a0 dither(strip.Color(25,0,0), 50); //color, delay - random fills up the strip  \u00a0 fadeDown(25,0,0,30); //red, green, blue, delay - fade down all pixels one color  \u00a0\u00a0\u00a0  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(25,0,0),400); //color, delay - turn all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400); //color, delay - turn all pixels one color  \u00a0 chaseBetweenLToH(strip.Color(25,25,25),20,0,100); //color, delay, low, high - chase led between two locations progressing up the chain  \u00a0 chaseBetweenHToL(strip.Color(25,25,25),20,103,152); //color, delay, low, high - chase led between two locations progressing down the chain  \u00a0  \u00a0 turnAllOff(); //turn all pixels off  \u00a0 fadeUp(25,0,0,20); //red, green, blue, delay - fade up all pixels one color  \u00a0 fadeDown(25,0,0,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 fadeUp(0,25,0,20); //red, green, blue, delay - fade up all pixels one color  \u00a0 fadeDown(0,25,0,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 turnAllOff();  \u00a0  \u00a0 /// strobe effect r/g rg  \u00a0 randomSparkle(strip.Color(25,0,0),20, 30); //color, density, delay - random sparkles in one color  \u00a0 randomSparkle(strip.Color(0,25,0),20, 30); //color, density, delay - random sparkles in one color  \u00a0 twoColorSparkle(strip.Color(25,0,0), strip.Color(0,25,0), 20, 10); //color 1, color 2, density, delay - random sparkles in two colors  \u00a0 rainbow(20);  \u00a0 turnAllOff();  \u00a0 randomColorSparkle(30); //delay - random color sparkles  \u00a0  \u00a0 turnAllOn(strip.Color(0,0,25),1000); //color, delay - turn all pixels one color  \u00a0 chaseBetweenLToH(strip.Color(25,25,25),1,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0 chaseBetweenLToH(strip.Color(0,25,0),0,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0 chaseBetweenHToL(strip.Color(25,0,0),0,0,159); //color, delay, low, high - chase leds between two locations progressing down the chain  \u00a0 chaseBetweenHToL(strip.Color(0,25,0),0,0,159); //color, delay, low, high - chase leds between two locations progressing down the chain  \u00a0 chaseToCenter(strip.Color(25,0,0),25,1,0,159); //color, number of leds in line, delay, low, high - chase lines to the center  \u00a0 chasePastCenter(strip.Color(25,0,0),25,1,0,159); //color, number of leds in line, delay, low, high - chase lines past the center  \u00a0 chaseBetweenLToH(strip.Color(50,50,25),1,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0 chaseBetweenLToH(strip.Color(25,0,0),0,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0 chaseBetweenLToH(strip.Color(0,25,0),0,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0 chaseLineHToL(strip.Color(25,0,0),50,0,0,159); //color, number of leds in line, delay, low, high - chase leds in a line progressing up the chain  \u00a0 chaseLineLToH(strip.Color(0,25,0),50,0,0,159); //color, delay, low, high - chase leds between two locations progressing up the chain  \u00a0  \u00a0 rainbowCycle(0);\u00a0 // make it go through the cycle fairly fast  \u00a0 turnAllOff();  \u00a0  \u00a0 //red and green segments around perimeter, center blue  \u00a0 int i;  \u00a0 for(i=1; i<=4; i++){  \u00a0 delay(1000);  \u00a0 fadeDown(25,25,25,40); //red, green, blue, delay - fade down all pixels one color  \u00a0 }  \u00a0  \u00a0 turnAllOn(strip.Color(0,0,25),200);  \u00a0 dither(strip.Color(25,0,0), 20); //color, delay - random fills up the strip  \u00a0 fadeDown(25,0,0,30); //red, green, blue, delay - fade down all pixels one color  \u00a0  \u00a0 turnSegmentOn(strip.Color(0,0,25),10,104,159); //color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,0,25),10,0,103); //color, delay, start of segment, end of segment\u00a0\u00a0  \u00a0 chaseUpTheStar(strip.Color(25,0,0),30); //color, delay  \u00a0 chaseUpCenterStar(strip.Color(25,0,0),30); //color, delay  \u00a0 turnSegmentOn(strip.Color(0,25,0),10,0,159); //color, delay, start of segment, end of segment  \u00a0 chaseUpTheStar(strip.Color(25,0,0),30); //color, delay  \u00a0 turnAllOff();  \u00a0  \u00a0 fillUpTheStar(strip.Color(25,0,0),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(0,25,0), 30); //color, delay  \u00a0 fillUpTheStar(strip.Color(0,25,0),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(25,0,0),30); //color, delay  \u00a0 fillUpTheStar(strip.Color(25,25,25),30); //color, delay  \u00a0 fillUpCenterStar(strip.Color(25,25,25),30); //color, delay  \u00a0  \u00a0 turnAllOff();  \u00a0 dither(strip.Color(0,25,25), 10); //color, delay - random fills up the strip  \u00a0 fadeDown(0,25,25,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 turnAllOff();  \u00a0 scanner(25,0,0,10); //red, green, blue, delay\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0 turnAllOff();  \u00a0 wave(strip.Color(25,0,0),5,0,200); //color, cycles, delay, repetitions  \u00a0 fadeDown(25,0,0,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 wave(strip.Color(0,25,0),5,0,200); //color, cycles, delay, repetitions  \u00a0 turnAllOff();  \u00a0  \u00a0  \u00a0 randomSparkleUpStrip(strip.Color(25,25,25),15,10); //color, density, wait  \u00a0 turnAllOn(strip.Color(25,25,25),500);  \u00a0 fadeDown(25,25,25,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 randomSparkleUpStrip(strip.Color(20,20,25),15,10);  \u00a0 turnAllOn(strip.Color(20,20,25),500);  \u00a0 fadeDown(20,20,25,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 randomSparkleUpStrip(strip.Color(25,50,25),15,10);  \u00a0 turnAllOn(strip.Color(25,50,25),500);  \u00a0 fadeDown(25,50,25,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 randomSparkleUpStrip(strip.Color(20,25,39),15,10);  \u00a0 turnAllOn(strip.Color(20,127,39),500);  \u00a0 fadeDown(20,25,39,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 randomSparkleUpStrip(strip.Color(10,10,25),15,10);  \u00a0 turnAllOn(strip.Color(10,10,25),500);  \u00a0 fadeDown(10,10,25,20); //red, green, blue, delay - fade down all pixels one color  \u00a0 turnAllOn(strip.Color(0,25,0),400);  \u00a0 chaseBetweenLToH(strip.Color(25,0,0),20,0,100); //color, delay, low, high - chase led between two locations progressing up the chain  \u00a0 chaseBetweenHToL(strip.Color(25,0,0),20,103,152); //color, delay, low, high - chase led between two locations progressing down the chain  //green to red wave\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0 wave(strip.Color(0,25,0),5,0,100); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(20,25,0),10,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(40,25,0),15,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(80,25,0),20,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,25,0),25,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,80,0),35,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,40,0),35,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,20,0),35,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,0,0),35,0,100); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,0,0),35,0,50); //color, cycles, delay, repetitions  \u00a0  \u00a0 turnAllOff();  \u00a0 wave(strip.Color(0,25,0),35,0,100); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(20,107,0),35,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(40,87,0),35,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(80,47,0),30,0,50); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(107,27,0),20,0,100); //color, cycles, delay, repetitions  \u00a0 wave(strip.Color(25,0,0),5,0,200); //color, cycles, delay, repetitions  \u00a0  \u00a0 int j;  \u00a0 for(j=1; j<=15; j++){  \u00a0 turnSegmentOn(strip.Color(0,0,25),0, 60, 100);//red 1 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,0,0),0, 147, 152); //blue 1 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,0,0),200, 103, 109); //blue 1 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,25,0),0, 44, 59); //red 4 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,25,0),0, 110, 121); //blue 4 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,0,25),0, 0, 15); //red 2 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,0,0),200, 135, 146); //blue 2 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,25,0),0, 60, 100); //red 1 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,25,0),0, 147, 152); // blue 1 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,25,0),0, 103, 109); //blue 1 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,0,25),0, 16, 43); //red 3 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,0,0),200, 122, 134); //blue 3 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,25,0),0, 0, 15); //red 2 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,25,0),0, 135, 146); //blue 2 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,0,25),0, 44, 59); //red 4 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,0,0),200, 110, 121); //blue 4 on - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(25,25,0),0, 16, 43); //red 3 off - color, delay, start of segment, end of segment  \u00a0 turnSegmentOn(strip.Color(0,25,0),0, 122, 134); //blue 3 off - color, delay, start of segment, end of segment  \u00a0 }  \u00a0  \u00a0  \u00a0 chaseMultipleLinesLToH(10,10,0,152); //number of leds in line, delay, low, high - chase multiple lines progressing up the chain  }  // An \"ordered dither\" fills every pixel in a sequence that looks  // sparkly and almost random, but actually follows a specific order.  void dither(uint32_t c, uint8_t wait) {  \u00a0 // Determine highest bit needed to represent pixel index  \u00a0 int hiBit = 0;  \u00a0 int n = strip.numPixels() - 1;  \u00a0 for(int bit=1; bit < 0x8000; bit <<= 1) {  \u00a0\u00a0\u00a0 if(n & bit) hiBit = bit;  \u00a0 }  \u00a0 int bit, reverse;  \u00a0 for(int i=0; i<(hiBit << 1); i++) {  \u00a0\u00a0\u00a0 // Reverse the bits in i to create ordered dither:  \u00a0\u00a0\u00a0 reverse = 0;  \u00a0\u00a0\u00a0 for(bit=1; bit <= hiBit; bit <<= 1) {  \u00a0\u00a0\u00a0\u00a0\u00a0 reverse <<= 1;  \u00a0\u00a0\u00a0\u00a0\u00a0 if(i & bit) reverse |= 1;  \u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.setPixelColor(reverse, c);  \u00a0\u00a0\u00a0 strip.show();  \u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  \u00a0 delay(250); // Hold image for 1/4 sec  }  // \"Larson scanner\" = Cylon/KITT bouncing light effect  void scanner(uint8_t r, uint8_t g, uint8_t b, uint8_t wait) {  \u00a0 int i, j, pos, dir;  \u00a0 pos = 0;  \u00a0 dir = 1;  \u00a0 for(i=0; i<((strip.numPixels()-1) * 8); i++) {  \u00a0\u00a0\u00a0 // Draw 5 pixels centered on pos. setPixelColor() will clip  \u00a0\u00a0\u00a0 // any pixels off the ends of the strip, no worries there.  \u00a0\u00a0\u00a0 // we'll make the colors dimmer at the edges for a nice pulse  \u00a0\u00a0\u00a0 // look  \u00a0\u00a0\u00a0 strip.setPixelColor(pos - 2, strip.Color(r/4, g/4, b/4));  \u00a0\u00a0\u00a0 strip.setPixelColor(pos - 1, strip.Color(r/2, g/2, b/2));  \u00a0\u00a0\u00a0 strip.setPixelColor(pos, strip.Color(r, g, b));  \u00a0\u00a0\u00a0 strip.setPixelColor(pos + 1, strip.Color(r/2, g/2, b/2));  \u00a0\u00a0\u00a0 strip.setPixelColor(pos + 2, strip.Color(r/4, g/4, b/4));  \u00a0\u00a0\u00a0 strip.show();  \u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0 // If we wanted to be sneaky we could erase just the tail end  \u00a0\u00a0\u00a0 // pixel, but it's much easier just to erase the whole thing  \u00a0\u00a0\u00a0 // and draw a new one next time.  \u00a0\u00a0\u00a0 for(j=-2; j<= 2; j++)  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(pos+j, strip.Color(0,0,0));  \u00a0\u00a0\u00a0 // Bounce off ends of strip  \u00a0\u00a0\u00a0 pos += dir;  \u00a0\u00a0\u00a0 if(pos < 0) {  \u00a0\u00a0\u00a0\u00a0\u00a0 pos = 1;  \u00a0\u00a0\u00a0\u00a0\u00a0 dir = -dir;  \u00a0\u00a0\u00a0 } else if(pos >= strip.numPixels()) {  \u00a0\u00a0\u00a0\u00a0\u00a0 pos = strip.numPixels() - 2;  \u00a0\u00a0\u00a0\u00a0\u00a0 dir = -dir;  \u00a0\u00a0\u00a0 }  \u00a0 }  }  // Sine wave effect  #define PI 3.14159265  void wave(uint32_t c, int cycles, uint8_t wait, int repetitions) {  \u00a0 float y;  \u00a0 byte r, g, b, r2, g2, b2;  \u00a0 // Need to decompose color into its r, g, b elements  \u00a0 g = (c >> 16) & 0x7f;  \u00a0 r = (c >> 8) & 0x7f;  \u00a0 b = c & 0x7f;  \u00a0 for(int x=0; x \u00a0 {  \u00a0\u00a0\u00a0 for(int i=0; i \u00a0\u00a0\u00a0\u00a0\u00a0 y = sin(PI * (float)cycles * (float)(x + i) / (float)strip.numPixels());  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 y = 1.0 - y; // Translate Y to 0.0 (top) to 1.0 (center)  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 r2 = (byte)((float)r * y);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 g2 = (byte)((float)g * y);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b2 = (byte)((float)b * y);  \u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, r2, g2, b2);  \u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.show();  \u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  }  void chaseUpTheStar(uint32_t c, uint8_t wait) {  \u00a0 int i,j;  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = 1; i <= 20; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80+i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80-i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80+i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80-i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (j=0; j<=29; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(59-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(j, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(59-j, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseUpCenterStar(uint32_t c, uint8_t wait) {  \u00a0 int i,j;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = 1; i <= 6; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(146+i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(147-i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(146+i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(147-i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (j=0; j<=18; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(103+j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(140-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(103+j, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(140-j, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void fillUpTheStar(uint32_t c, uint8_t wait) {  \u00a0 int i,j;  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = 1; i <= 20; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80+i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(80-i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (j=0; j<=29; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(59-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void fillUpCenterStar(uint32_t c, uint8_t wait) {  \u00a0 int i,j;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = 1; i <= 6; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(146+i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(147-i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (j=0; j<=18; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(103+j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(140-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseBetweenLToH(uint32_t c, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = pointL; i <= pointH; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseBetweenHToL(uint32_t c, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i = pointH; i >= pointL; i--) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseLineLToH(uint32_t c, uint8_t lineNumber, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i, j;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(i = pointL; i < pointH+lineNumber; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(j = 0; j < lineNumber; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseLineHToL(uint32_t c, uint8_t lineNumber, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i, j;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(i = pointH; i > pointL; i--) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(j = 0; j \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void chaseToCenter(uint32_t c, uint8_t lineNumber, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i, j, k;  \u00a0 i = pointL;  \u00a0 k = pointH;  \u00a0 while(i < k && k > i) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(j = 0; j < lineNumber; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(k+j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0 delay(wait);  \u00a0 i++;  \u00a0 k--;  \u00a0 turnAllOff();  \u00a0 }  }  void chasePastCenter(uint32_t c, uint8_t lineNumber, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i, j, k;  \u00a0 i = pointL;  \u00a0 k = pointH;  \u00a0 while(i < pointH && k > pointL) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(j = 0; j < lineNumber; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i-j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(k+j, c);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0 delay(wait);  \u00a0 i++;  \u00a0 k--;  \u00a0 turnAllOff();  \u00a0 }  }  void turnAllOn(uint32_t c, uint32_t wait) {  \u00a0 int i;\u00a0  \u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0 strip.setPixelColor(i, c);\u00a0 // turn all pixels on  \u00a0 }  \u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0 delay(wait);  }  void turnSegmentOn(uint32_t c, uint32_t wait, uint8_t startofseg, uint8_t endofseg) {  \u00a0 int i;\u00a0  \u00a0 for (i=startofseg; i <= endofseg; i++) {  \u00a0\u00a0\u00a0 strip.setPixelColor(i, c);\u00a0 // turn all pixels on  \u00a0 }  \u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0 delay(wait);  }  void fadeUpSeg(uint32_t r, uint32_t g, uint32_t b, uint32_t wait, uint8_t startofseg, uint8_t endofseg) {  \u00a0 int i, j;  \u00a0 for (j=0; j <= 100; j++) {  \u00a0\u00a0\u00a0 for (i=startofseg; i<=endofseg; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color((r*j)/100,(g*j)/100,(b*j)/100));  \u00a0\u00a0\u00a0 }  \u00a0 strip.show();  \u00a0 }  \u00a0 delay(wait);  }  void fadeDownSeg(uint32_t r, uint32_t g, uint32_t b, uint32_t wait, uint8_t startofseg, uint8_t endofseg) {  \u00a0 int i, j;  \u00a0 for (j=100; j >= 0; j--) {  \u00a0\u00a0\u00a0 for (i=startofseg; i<=endofseg; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color((r*j)/100,(g*j)/100,(b*j)/100));\u00a0 // turn all pixels on  \u00a0\u00a0\u00a0 }  \u00a0 strip.show();  \u00a0 }  \u00a0 delay(wait);  }  void fadeUp(uint32_t r, uint32_t g, uint32_t b, uint32_t wait) {  \u00a0 int i, j;  \u00a0 for (j=0; j <= 100; j++) {  \u00a0\u00a0\u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color((r*j)/100,(g*j)/100,(b*j)/100));  \u00a0\u00a0\u00a0 }  \u00a0 strip.show();  \u00a0 }  \u00a0 delay(wait);  }  void fadeDown(uint32_t r, uint32_t g, uint32_t b, uint32_t wait) {  \u00a0 int i, j;  \u00a0 for (j=100; j >= 0; j--) {  \u00a0\u00a0\u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color((r*j)/100,(g*j)/100,(b*j)/100));\u00a0 // turn all pixels on  \u00a0\u00a0\u00a0 }  \u00a0 strip.show();  \u00a0 }  \u00a0 delay(wait);  }  void chaseMultipleLinesLToH(uint8_t lineNumber, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i, j;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(i = pointL; i <= pointH; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for(j = 0; j < lineNumber; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, strip.Color(0,0,127));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(2*lineNumber), strip.Color(25,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(3*lineNumber), strip.Color(0,25,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(4*lineNumber), strip.Color(25,25,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(5*lineNumber), strip.Color(0,25,25));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(6*lineNumber), strip.Color(25,0,25));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(7*lineNumber), strip.Color(0,0,25));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(8*lineNumber), strip.Color(25,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i+j+(9*lineNumber), strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0  }  void turnAllOff() {  \u00a0 int i;\u00a0  \u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0 strip.setPixelColor(i, 0);\u00a0 // turn all pixels off  \u00a0 }  \u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  }  void randomSparkleUpSegment(uint32_t c, uint32_t density, uint8_t wait, uint8_t pointL, uint8_t pointH) {  \u00a0 int i,j,location;  \u00a0\u00a0\u00a0 for (j=pointL; j<=pointH; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 for (i=0; i <= density; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 location = random(pointL,j);  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 }\u00a0  }  void randomSparkleUpStrip(uint32_t c, uint32_t density, uint8_t wait) {  \u00a0 int i,j,location;  \u00a0\u00a0\u00a0 for (j=density; j \u00a0\u00a0\u00a0\u00a0\u00a0 for (i=0; i <= density; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 location = random(0,j);  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 }\u00a0  }  void randomSparkle(uint32_t c, uint32_t density, uint8_t wait) {  \u00a0 int i,j,location;  \u00a0 for (j=0; j < 200; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 for (i=0; i <= density; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location = random(0,strip.numPixels()); //random location in first 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  }  void randomColorSparkle(uint8_t wait) {  \u00a0 int i;  \u00a0 int location1, location2, location3, location4, location5;  \u00a0 int color1, color2, color3;  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for (i=0; i < 200; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location1 = random(0,32); //random location in first 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location2 = random(33,64); //random location in 2nd 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location3 = random(65,96); //random location in 3rd 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location4 = random(97,128); //random location in 4th 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location5 = random(129,159); //randon location in last 5th of strip  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 color1 = random(25);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 color2 = random(25);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 color3 = random(25);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location1, strip.Color(color1,color2,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location2, strip.Color(color3,0,color1));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location3, strip.Color(0,color2,color3));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location4, strip.Color(color1,color2,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location5, strip.Color(color3,0,color1));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location1, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location2, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location3, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location4, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location5, strip.Color(0,0,0));  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  }  void twoColorSparkle(uint32_t c1, uint32_t c2, uint32_t density, uint8_t wait) {  \u00a0 int i,j,location1,location2;  \u00a0 for (j=0; j < 200; j++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 for (i=0; i <= density; i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location1 = random(0,strip.numPixels()); //random location number 1  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 location2 = random(0,strip.numPixels()); //random location number 2  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location1, c1);  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(location2, c2);  \u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0\u00a0\u00a0 turnAllOff();  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }  }  void rainbow(uint8_t wait) {  \u00a0 int i, j;  \u00a0\u00a0  \u00a0 for (j=0; j < 384; j++) {\u00a0\u00a0\u00a0\u00a0 // 3 cycles of all 384 colors in the wheel  \u00a0\u00a0\u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, Wheel( (i + j) % 384));  \u00a0\u00a0\u00a0 }\u00a0  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  }  // Slightly different, this one makes the rainbow wheel equally distributed  // along the chain  void rainbowCycle(uint8_t wait) {  \u00a0 uint16_t i, j;  \u00a0  \u00a0 for (j=0; j < 384 * 5; j++) {\u00a0\u00a0\u00a0\u00a0 // 5 cycles of all 384 colors in the wheel  \u00a0\u00a0\u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 // tricky math! we use each pixel as a fraction of the full 384-color wheel  \u00a0\u00a0\u00a0\u00a0\u00a0 // (thats the i / strip.numPixels() part)  \u00a0\u00a0\u00a0\u00a0\u00a0 // Then add in j which makes the colors go around per pixel  \u00a0\u00a0\u00a0\u00a0\u00a0 // the % 384 is to make the wheel cycle around  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, Wheel( ((i * 384 / strip.numPixels()) + j) % 384) );  \u00a0\u00a0\u00a0 }\u00a0  \u00a0\u00a0\u00a0 strip.show();\u00a0\u00a0 // write all the pixels out  \u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  }  // fill the dots one after the other with said color  // good for testing purposes  void colorWipe(uint32_t c, uint8_t wait) {  \u00a0 int i;  \u00a0  \u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();  \u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  }  // Chase a dot down the strip  // good for testing purposes  void colorChase(uint32_t c, uint8_t wait) {  \u00a0 int i;  \u00a0  \u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0 strip.setPixelColor(i, 0);\u00a0 // turn all pixels off  \u00a0 }  \u00a0  \u00a0 for (i=0; i < strip.numPixels(); i++) {  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i, c);  \u00a0\u00a0\u00a0\u00a0\u00a0 if (i == 0) {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(strip.numPixels()-1, 0);  \u00a0\u00a0\u00a0\u00a0\u00a0 } else {  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 strip.setPixelColor(i-1, 0);  \u00a0\u00a0\u00a0\u00a0\u00a0 }  \u00a0\u00a0\u00a0\u00a0\u00a0 strip.show();  \u00a0\u00a0\u00a0\u00a0\u00a0 delay(wait);  \u00a0 }  }  /* Helper functions */  //Input a value 0 to 384 to get a color value.  //The colours are a transition r - g -b - back to r  uint32_t Wheel(uint16_t WheelPos)  {  \u00a0 byte r, g, b;  \u00a0 switch(WheelPos / 128)  \u00a0 {  \u00a0\u00a0\u00a0 case 0:  \u00a0\u00a0\u00a0\u00a0\u00a0 r = 25 - WheelPos % 128;\u00a0\u00a0 //Red down  \u00a0\u00a0\u00a0\u00a0\u00a0 g = WheelPos % 128;\u00a0\u00a0\u00a0\u00a0\u00a0 // Green up  \u00a0\u00a0\u00a0\u00a0\u00a0 b = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //blue off  \u00a0\u00a0\u00a0\u00a0\u00a0 break;  \u00a0\u00a0\u00a0 case 1:  \u00a0\u00a0\u00a0\u00a0\u00a0 g = 25 - WheelPos % 128;\u00a0 //green down  \u00a0\u00a0\u00a0\u00a0\u00a0 b = WheelPos % 128;\u00a0\u00a0\u00a0\u00a0\u00a0 //blue up  \u00a0\u00a0\u00a0\u00a0\u00a0 r = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //red off  \u00a0\u00a0\u00a0\u00a0\u00a0 break;  \u00a0\u00a0\u00a0 case 2:  \u00a0\u00a0\u00a0\u00a0\u00a0 b = 25 - WheelPos % 128;\u00a0 //blue down  \u00a0\u00a0\u00a0\u00a0\u00a0 r = WheelPos % 128;\u00a0\u00a0\u00a0\u00a0\u00a0 //red up  \u00a0\u00a0\u00a0\u00a0\u00a0 g = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //green off  \u00a0\u00a0\u00a0\u00a0\u00a0 break;  \u00a0 }  \u00a0 return(strip.Color(r,g,b));  }  \u00a0", "step_imgs": [], "step_title": "Step 6: Code and Video"}], "channel": "Arduino"}, {"category": "technology", "description": "A friend gifted us a teddy bear with two embedded buttons at our housewarming, presumably for our toddler. A kind gesture, but as it turns out, once the button for either English or Spanish alphabet is pressed, it sings the entire thing, and the only way to turn it off is to rip open the back of the bear and flip the switch on the little white box they included. My first thought was, \"Great! I'll try to circuit bend this!\" But after opening up the electronics box, I didn't see any timing circuitry and most of the components were covered in that hardened black goop. So, I decided to make it into a wireless sound and light controller.\nMaterials:Smart Pal \u00a0(or other electronic toy with buttons)\u00a0FIO Arduino  and Battery3-Axis Accelerometer XBee Radio  for FIO\nXBee Radio with Serial or USB connection for computer *\nassorted wires, headers, sockets\nlead-free solder\nsoldering iron\nhelpful spouse or friend to watch the kids while you're working on this \u00a0\nComputer with Pure Data installed to generate sound\nSaikoLED Saiko5 fixture or other LED setup to generate light\u00a0\nI had these parts lying around from other projects, and the bear was a gift. If you bought all the parts for the wireless system new from Spark fun, it would probably cost $150, which is less than some electronic toys but still a lot!\n* I am going to be investigating using the Seeedstudios Bluetooth Bee instead of XBee radios which would drop the cost by $50. If anyone knows of a cheaper accelerometer (short of etching your own board) please let me know in the comments.", "title": "Upgrading a Smart Pals Learning Bear", "url": "https://www.instructables.com/id/Upgrading-a-Smart-Pals-Learning-Bear/", "section": "technology", "steps": [{"step": 1, "steps_text": "Open up the velcro on the back of your bear.\nPull out the white box far enough to find all four wires going into the body of the bear.\nThese go to the bear's foot-buttons.\nIn my bear, each pair of wires was a different color. That made it easier to tell them apart.", "step_imgs": ["https://cdn.instructables.com/FSH/VMEY/GSVJV81W/FSHVMEYGSVJV81W.LARGE.jpg", "https://cdn.instructables.com/FFP/MLFQ/GSVJV81V/FFPMLFQGSVJV81V.LARGE.jpg"], "step_title": "Step 1: Remove Annoying Alphabet Box"}, {"step": 2, "steps_text": "Strip all four wires.\nSeparate the paired wires so that you have one wire from each button.\nConnect two wires together, one from each button, and connect that to an extension wire that will go to the board.\nKeep the other pair electrically isolated, so extend them individually if you'd like to make it easier to work with.\n----\nThere are a few ways to make these connections. The most structural and hardest to change later would be to twist and solder each junction. Another option is to use a small wire nut or to tin the ends of the wires (to keep them from fraying) and use jumper cables to connect them to pins on the Arduino.\u00a0\nI\u00a0chose a hybrid approach. I cut a jumper in half, using the twist and solder method to connect it to the buttons' wires. If later on I feel like experimenting, it's easy to change the connections around on the FIO or even connect them to wires on a protoboard.", "step_imgs": ["https://cdn.instructables.com/FEF/OWVL/GSVJV81U/FEFOWVLGSVJV81U.LARGE.jpg", "https://cdn.instructables.com/FY8/K7WD/GSVJV8FG/FY8K7WDGSVJV8FG.LARGE.jpg"], "step_title": "Step 2: Prepare Button Wires for Re-purposing"}, {"step": 3, "steps_text": "If you are using breakaway headers, now is the time to attach them to your Funnel and/or accelerometer breakout boards.\nI wanted to save space, so I connected the accelerometer directly to the FIO via headers on the analog input pins, and routed wires to power and ground.\nConnections for the accelerometer are as follows:\nbreakout pins - FIO pins\nX - A5\u00a0\nY - A6\nZ - A7\u00a0\nGND - GND\nVCC - 3V3\nConnections for the button are as follows:\nbutton wires - FIO pins\nleft button, wire1 - 3V3\nright button, wire1 - 3V3\nleft button, wire2 - D7\nright button, wire2 - D8\nBEFORE INSTALLING THE XBEE IN THE FUNNEL SOCKET\nConfigure the XBee that will be inside the bear as an \"End device\"\nConfigure the XBee connected to the computer as the Coordinator\nMore detailed instructions are here:\nhttp://funnel.cc/Hardware/FIO\nThis doesn't matter much for the serial communication, but it does matter for the wireless programming.\nYes, you can reprogram your bear without opening it up!", "step_imgs": ["https://cdn.instructables.com/FN3/2JWH/GSVJV81T/FN32JWHGSVJV81T.LARGE.jpg", "https://cdn.instructables.com/FST/SFMH/GSVJV81J/FSTSFMHGSVJV81J.LARGE.jpg", "https://cdn.instructables.com/FKG/WDXW/GSVJV81P/FKGWDXWGSVJV81P.LARGE.jpg"], "step_title": "Step 3: Connect Components to Funnel"}, {"step": 4, "steps_text": "Thats it for the hardware!\nIf you had a project box that was small enough to fit in the bear, now would be the time to put the components into it.\u00a0If you used jumper cables, routing through small holes drilled in a case would be easy. I used a plastic bubblewrap bag. I thought about using a static-proof bag, but I was afraid the conductivity would mess with the sensing circuitry, and the ICs are pretty far away from the bag itself.\nA plastic bag has the added benefit that if your child starts pulling out the electronics, you'll hear the crinkle noises. With bubble wrap, perhaps he'll even get distracted from the potentially dangerous lithium battery! \u00a0A better option would be a light sensor that sounds an alarm when the back is opened. Make sure the alarm is not too fun and exciting or the kids'll be opening it all the time!", "step_imgs": ["https://cdn.instructables.com/FLV/2Q1C/GSVJV81I/FLV2Q1CGSVJV81I.LARGE.jpg", "https://cdn.instructables.com/FSH/VMEY/GSVJV81W/FSHVMEYGSVJV81W.LARGE.jpg"], "step_title": "Step 4: Connect the Battery, Velcro Up the Bear"}, {"step": 5, "steps_text": "Download Arduino IDE if you don't already have it. It should come with FTDI drivers if you need them.\nPlug in the XBee radio breakout to the computer.\nA new serial port should show up in your Arduino IDE's menu if you have the FTDI drivers (in the usb case).\nOtherwise, just select the serial port to which it is connected.\nFor the newer FIO boards, there is an option for \"Arduino FIO\" under \"boards.\"\nMy funnel is a bit older, so I needed to choose \"Arduino Pro or Pro Mini (3.3V 8Mhz) with ATMega168.\"\nIn the code that follows, I've provided some debugging options to turn on an LED when a button is pressed (you'll need to open the bear to see it). Uncomment both the pinMode line and the if statements near the bottom to use it.\nHere is the code:\nfile: remoteBear.pde\n// Arduino Funnel code for ADXL335 triple axis accelerometer sensor.\n// Use with setting 'Arduino Pro or Pro Mini (3.3V 8Mhz) with ATMega168'\nchar str[512];\nvoid setup() {\n\u00a0 pinMode(7,INPUT);\n\u00a0 pinMode(8,INPUT);\n// pinMode(13, OUTPUT);\nSerial.begin(19200);\n}\nvoid loop() {\nbyte x = analogRead(7)/4;\ndelay(10);\nbyte y = analogRead(6)/4;\ndelay(10);\nbyte z = analogRead(5)/4;\nbyte d1 = 1;\nbyte d2 = 1;\nif (digitalRead(7) == HIGH){\nd1 = 2;\n}\nif (digitalRead(8) == HIGH){\nd2 = 2;\n}\n/*if (d2+d1 >= 1)\ndigitalWrite(13, HIGH); // set the LED on\nelse\ndigitalWrite(13, LOW); // set the LED on\n*/\nsprintf(str, \"%c%c%c%c%c\", x, y, z,d1,d2);\nSerial.println(str);\ndelay(80);\u00a0 \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FGF/M2KW/GSVJV81F/FGFM2KWGSVJV81F.LARGE.jpg"], "step_title": "Step 5: Funnel IO (Arduino) Programming"}, {"step": 6, "steps_text": "Download Pd-extended. Pure Data is a cross-platform visual programming language, much like MaxMSP.\nBelow I've attached a simple serial receive patch. Use it to ensure you are getting and unpacking data from the FIO, then download this patch\u00a0to see an example of how the audio and/or light outputs work.\nFor light output, you will need an OSC-compatible light and the MrPeach extension pack for PureData. MrPeach IS included in pd-extended, but I had to enable it by adding the path to the library, adding 'mrpeach' to the list of extensions to load on startup, and restarting PD.\nThe audio output is a simple pitch shifted tone based on the example audio output code PD provides. PD is great in that you can right-click any element and see help where an example of the element is used. That's where I got the audio patch, it is not particularly complex, but many of the elements send messages to each other in a way not visible unless you right click on an element to view it's properties. Message-passing is a great tool in a language, but it could be a little more visible....\nThe light output is a simple call to Open Sound Control output over the network. The Saiko 5 light I have makes it easy by setting up an ad-hoc wireless network for the computer to connect to. Saiko 5 is open source and open hardware, based on an Arduino, so it is completely hackable.\nHere is the serial receive example which should not require any extensions:\nfile: SimpleSerial.pd\n#N canvas 527 99 450 300 10;\n#X obj 45 -176 comport 3 19200;\n#X floatatom 28 -56 5 0 0 0 - - -;\n#X floatatom 85 -55 5 0 0 0 - - -;\n#X floatatom 142 -56 5 0 0 0 - - -;\n#X floatatom 205 -55 5 0 0 0 - - -;\n#X msg 40 -202 close;\n#X msg 102 -197 open 3;\n#X obj 78 -95 unpack f f f f f;\n#X obj 45 -155 sel 10 13;\n#X obj 79 -127 zl group 22;\n#X floatatom 269 -55 5 0 0 0 - - -;\n#X connect 0 0 8 0;\n#X connect 5 0 0 0;\n#X connect 6 0 0 0;\n#X connect 7 0 1 0;\n#X connect 7 1 2 0;\n#X connect 7 2 3 0;\n#X connect 7 3 4 0;\n#X connect 7 4 10 0;\n#X connect 8 1 9 0;\n#X connect 8 2 9 0;\n#X connect 9 0 7 0;", "step_imgs": [], "step_title": "Step 6: PureData Programming"}, {"step": 7, "steps_text": "Here is my son Liam, demoing it for me:\nHe was a very good actor, \u00a0but was bored with the toy by the end of the take. He's also seen it before.\u00a0Oh well, guess I'll need to improve the sound and light responses to make it more fun!\nYay! My first Instructable! Thanks for reading!", "step_imgs": ["https://cdn.instructables.com/FS5/LJHT/GSVJV81Y/FS5LJHTGSVJV81Y.LARGE.jpg"], "step_title": "Step 7: That's It, We're All Done!"}], "channel": "Arduino"}, {"category": "technology", "description": "Do you have a pesky sibling or pet that sneaks up on you? Are cars always in your blind spot? Create a proximity alarm that alerts you to approaching objects. This simple guide will teach you how to create a proximity alarm that will light up and make noise when something approaches. An ultrasonic rangefinder and Arduino microcontroller will check for nearby objects and if need be, alert you with a piezo-buzzer and RGB LED. Learn about these components using electronics lab simulations and eventually design, code, simulate, and build the proximity alarm itself! This is great if you are looking for a quick project to learn about digital electronics. ", "title": "Simple and Fun Proximity Alarm", "url": "https://www.instructables.com/id/Simple-and-Fun-Proximity-Alarm/", "section": "technology", "steps": [{"step": 1, "steps_text": "To sense distance, we will use the Parallax PING))) ultrasonic rangefinder. To sense distance, the rangefinder rapidly sends out ultrasonic sound waves. Each wave will travel outwards, and if there is an object in its path, it will collide and bounce back to the rangefinder. The time it takes for the wave to bounce back determines the distance of that object. The Parallax PING))) can only sense objects from around 2 inches to 10 ft.The PING))) has onboard ICs (integrated circuits) that do most of the heavy lifting. All we need to do is send the rangefinder a quick 5V pulse from the Arduino and use the pulseIn() function to check the time it took for the wave to bounce back. See the 'Code' step for more information on how to code the rangefinder. ", "step_imgs": ["https://cdn.instructables.com/FO4/AJA8/IR3U30T1/FO4AJA8IR3U30T1.LARGE.jpg", "https://cdn.instructables.com/F1C/MBN1/IR3ZSWRG/F1CMBN1IR3ZSWRG.LARGE.jpg"], "step_title": "Step 1: Ultrasonic Rangfinder"}, {"step": 2, "steps_text": "To alert the user we will use a piezo buzzer. This device will emit a click sound when a DC voltage is applied. To make a tone, we can use the Arduino tone() function. This will cause the device to emit an annoying sound at that tone. String enough of these tones together and you can create music!Change the frequency in the simulation below to see how the tone changes:", "step_imgs": ["https://cdn.instructables.com/FUS/YZEC/IR3U320B/FUSYZECIR3U320B.LARGE.jpg"], "step_title": "Step 2: Piezo-Buzzer"}, {"step": 3, "steps_text": "RGB LEDs are light emitting diodes that can output a range of color combinations (using red, green, blue). They come in two configurations: common anode, and common cathode. See the second picture in this step (thanks moderndevice.com). Common Anode: The common lead, the longest lead, is positive (anode means positive lead). This lead should be connected to a positive voltage. To make the LED green, you would apply a 0V (aka GND) to the green lead. The same holds for the other colors. Different combinations of voltages on these three pins can create a range of colors. \nCommon Cathode: The common lead, the longest lead, is negative (cathode means negative lead). This type is more intuitive and works just like a regular LED. The long lead is connected to GND and the other three leads can be connected to a positive voltage (depending on what color you want to make).Remember that LEDs might need a resistor in series to limit the current through the device (so it won't blow up). It is easiest to put the resistor in series with the common lead (so you only need one, rather than putting a resistor in series with the red lead, green lead, and blue lead). Move the dials in the simulation below to make different colors:", "step_imgs": ["https://cdn.instructables.com/FRC/J1P8/IR3ZSWQG/FRCJ1P8IR3ZSWQG.LARGE.jpg", "https://cdn.instructables.com/FJZ/H5E0/IR3ZS8WK/FJZH5E0IR3ZS8WK.LARGE.jpg"], "step_title": "Step 3: RGB LED"}, {"step": 4, "steps_text": "To make the blind spot detector you will need the following:1x Parallax PING))) Ultrasonic Rangefinder1x Microcontroller1x Breadboard1x RGB LED1x Piezo Buzzer 1x 9V ConnectorBreadboard Wires1x 9V BatterySome of the above links include extra pieces but you should only need one of each part. ", "step_imgs": ["https://cdn.instructables.com/FRE/1YWX/IR3U30SI/FRE1YWXIR3U30SI.LARGE.jpg", "https://cdn.instructables.com/FPV/H034/IR3U30JU/FPVH034IR3U30JU.LARGE.jpg", "https://cdn.instructables.com/FXJ/5R07/IR3U30DW/FXJ5R07IR3U30DW.LARGE.jpg", "https://cdn.instructables.com/FE1/46HQ/IR3U30RE/FE146HQIR3U30RE.LARGE.jpg", "https://cdn.instructables.com/F5P/KYKZ/IR3U30W3/F5PKYKZIR3U30W3.LARGE.jpg"], "step_title": "Step 4: Parts List:"}, {"step": 5, "steps_text": "Now lets put the pieces together! We have a power system, distance sensor, alert system, and microcontroller. Use the following guide to connect the various parts to the Arduino microcontroller: Power System: Since this is a low powered, mobile project, we can use a 9V to power the Arduino which will then regulate down the power for the other components.  Battery + ---> Arduino Vin Battery - ---> Arduino GNDDistance Sensor:Rangefinder GND ---> Arduino GND Rangefinder 5V ---> Arduino 5V Rangefinder SIG ---> Arduino Analog Pin 5Alert System: Our system to alert the user is made up of two devices: the piezo-buzzer, and the RGB LED. This triggers one's auditory and visual senses.  Piezo: Piezo Buzzer Black Wire ---> Arduino GND Piezo Buzzer Red Wire ---> Arduino Digital Pin 13 RGB LED RGB LED Long Lead ---> 330 ohm resistor ---> Arduino GND RGB LED Red Lead ---> Arduino Digital Pin 12 RGB LED Green Lead ---> Arduino Digital Pin 10 RGB LED Blue Lead ---> Arduino Digital Pin 11Try out the simulation below to see it in action. Click on rangefinder and move the dot to simulate an object: Using this breadboard simulation as a guide, go ahead and build it!", "step_imgs": ["https://cdn.instructables.com/F1B/4BKL/IR3HKYUB/F1B4BKLIR3HKYUB.LARGE.jpg", "https://cdn.instructables.com/FYQ/4L0M/IR3HKYTU/FYQ4L0MIR3HKYTU.LARGE.jpg", "https://cdn.instructables.com/FEA/70MQ/IR3U30WK/FEA70MQIR3U30WK.LARGE.jpg"], "step_title": "Step 5: Design, Simulate, Build"}, {"step": 6, "steps_text": "The code starts with a bunch of define statements that connect the note to its respective frequency in hertz. We use a bunch of define statements because it is easier to think of music in terms of notes, rather than its frequency representation. #define NOTE_B0  31 //NOTE_B0 = 31 Hz\nNext we define the two arrays that hold our music. The first holds the notes, the second holds the 'note duration'. The example here has a snippet of the James Bond theme song (thanks GarageLab for the song code).  int jb_m[] = { //this pattern of notes is a snippet from james bond\n   /*NOTE_E4,NOTE_F4,NOTE_F4,NOTE_F4,NOTE_F4,NOTE_E4,NOTE_E4,NOTE_E4,\n   NOTE_E4,NOTE_G4,NOTE_G4,NOTE_G4,NOTE_G4,NOTE_E4,NOTE_E4,NOTE_E4,*/\n   NOTE_E4,NOTE_F4,NOTE_F4,NOTE_F4,NOTE_F4,NOTE_E4,NOTE_E4,NOTE_E4,\n   NOTE_E4,NOTE_G4,NOTE_G4,NOTE_G4,NOTE_G4,NOTE_E4,NOTE_E4,NOTE_E4,\n   NOTE_DS5,NOTE_D5,NOTE_B4,NOTE_A4,NOTE_B4,\n   /*NOTE_E4,NOTE_G4,NOTE_DS5,NOTE_D5,NOTE_G4,NOTE_B4,\n   NOTE_B4,NOTE_FS5,NOTE_F5,NOTE_B4,NOTE_D5,NOTE_AS5,\n   NOTE_A5,NOTE_F5,NOTE_A5,NOTE_DS6,NOTE_D6,NO_SOUND*/\n};\n\nint jb_n[] = { //the corresponding note durations \n   /*8,16,16,8,4,8,8,8,\n   8,16,16,8,4,8,8,8,*/\n   8,16,16,8,4,8,8,8,\n   8,16,16,8,4,8,8,8,\n   8,2,8,8,1,\n   /*4,8,4,8,8,\n   8,8,4,8,4,8,\n   4,8,4,8,3*/\n};\nNow that we have the song defined, we can start to write the code that actually does the stuff! The Boolean variable 'change' keeps track of the red zone. We only want the song to play when something enters the red zone. The variable 'change' will only be true when something enters the red zone. If that object stays in the red zone, 'change' will remain false and the song will not play.Its important that the 'change', 'red', 'blue', 'green', 'buzzer', and 'distance' variables all be global variables because we will use them throughout many functions.bool change=false; //variable to check if something entered the red zone\n\ndouble duration; //duration is used to determine the distance sensed from the rangefinder\nint distance; //the distance found from the rangefinder\n\n//the corresponding pins for the RBG LED\nint red = 12;\nint blue = 11;\nint green = 10;\n\nint buzzer = 13; //the corresponding pin for the buzzer\nWhen the Arduino starts up, the setup function will start by initializing the serial monitor (baud rate 9600). It will make the RBG LED and buzzer pins outputs so we can control them.void setup() {\n  Serial.begin(9600); //enable the serial monitor at a 9600 baud rate\n  \n  //make the LED and buzzer an output from the Arduino\n  pinMode(red,OUTPUT);\n  pinMode(blue,OUTPUT);\n  pinMode(green,OUTPUT);\n  pinMode(buzzer,OUTPUT);\n}\nOur infinite loop does nothing but call other functions and wait. It starts by getting the distance of any object in the rangefinder's path. It waits a short amount of time and then alerts the user based on the newly found distance.void loop() { \n  getDistance(); //find the distance of any object (if there even is an object)\n  delay(10); //wait for the computer to catch up\n  alert(); //let the user know what distance we found\n}\nTo get the distance from the ultrasonic rangefinder we send out ultrasonic sound pulses. The amount of time it takes to bounce off an object and return to the rangefinder will correspond to the object's distance. The getDistance() function places the found distance in the global variable 'distance'.void getDistance(){\n  pinMode(A5, OUTPUT); //set the rangefinder pin to be an output in preparation to send a pulse \n\n  analogWrite(A5, 0); //start with no output, start with a clean slate\n  delayMicroseconds(2); //let the computer catch up\n  analogWrite(A5, 256); //send out the pulse\n  delayMicroseconds(5); //wait 5 ms before turning off the pulse\n  analogWrite(A5, 0); //turn off the pulse\n\n  pinMode(A5, INPUT); //set rangefinder pin back to input to be ready to catch the bounced sound wave \n  \n  duration = pulseIn(A5, HIGH); //pulseIn() function reads the time it took for wave to bounce back\n  distance = duration/72/2; //converts the found time to distance (using physics and math)\n  delay(10); //this slows down the rate at which we take distance measurements\n\n  //Serial.println(distance); //debugging\n}\nNow that we have our distance, lets let the user know! Start by turning off all the LEDs to give us a clean slate. If the object is far away then we will make the LED green. If the object is not too close or too far, we will make the LED blue. Lastly, if the object gets close to the rangefinder, we turn the LED red and play the music (if the object just entered the red zone). void alert(){\n  //turn off all the LEDs\n  digitalWrite(red,LOW);\n  digitalWrite(green,LOW);\n  digitalWrite(blue,LOW);\n  \n  if(distance > 120){ //if object is far away, LED set to green and allow change to be true\n    digitalWrite(green,HIGH);\n  }\n  if(distance < 115 && distance > 85){ //if the object not too far or too close, \n    digitalWrite(blue,HIGH);           //make LED blue and allow change to be true\n    change = true;\n  }\n  if(distance < 80){ //if the object gets close, make the LED red\n    digitalWrite(red,HIGH);\n    if(change) music(jb_m,jb_n,1500,sizeof(jb_n)/2); //if the object was not previously in the red zone\n    change = false; //disable change                 //then play the music\n  }\n}\nThe music() function takes in the melody, note duration, pace, and length of song. This function is a loop that goes through and plays the buzzer for all of the set notes for their corresponding time durations. The 'pace' variable lets us speed or slow down the music. 'length' tells the for loop how many notes to play.void music(int melody[],int noteDuration[],int pace,int length){\n  for (int Note = 0; Note < length; Note++){ //loop through the length of the music)\n    int duration = pace/noteDuration[Note]; //take into account the pace\n    tone(buzzer, melody[Note],duration); //play the note using the tone() function\n    delay(duration*1.2); //let the note run for the corresponding duration \n  }\n}\n", "step_imgs": ["https://cdn.instructables.com/F3Q/Z4BW/IR3U3354/F3QZ4BWIR3U3354.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 6: Code"}, {"step": 7, "steps_text": "You should now have a functioning proximity alarm to watch your back! If you are looking to improve your project and skills, consider soldering the design onto a proto-board. This is a great project to learn soldering or enhance your current skills. If you would like to do this I would recommend using this proto-board. Using a proto-board is a more permanent solution; it will keep the components and wires securely in place. The first picture in this step shows what the proximity alarm looks like when soldered onto a proto-board. If you are more advanced you could design your own PCB proximity alarm. This would allow you to make a compact, secure, and high quality product. Using Autodesk Circuit's PCB tool you can create and order a PCB. The second picture on this step shows a possible PCB design or you could follow this link to view the PCB project itself.Whether you make a breadboard, proto-board, or PCB based proximity alarm, I hope you enjoyed the process and learned more about electronics! ", "step_imgs": ["https://cdn.instructables.com/F81/MDBM/IR3U318X/F81MDBMIR3U318X.LARGE.jpg", "https://cdn.instructables.com/F08/5BN0/IR3HKYTR/F085BN0IR3HKYTR.LARGE.jpg"], "step_title": "Step 7: Conclusions and Future Improvments"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          Waveform generators (also called function generators) are useful for testing and debugging circuits.\u00a0 I often use them to test the frequency response of electronics components like op amp and sensors.\u00a0 This waveform generator is powered by an Arduino.\u00a0 It outputs four waveshapes: sine, triangle, pulse, and saw, each waveshape ranges in frequency from 1Hz-50kHz.\u00a0 The frequency, pulse width, and overall amplitude (gain) of the waveforms is controlled by three potentiometers.\u00a0 I've also included (optional) indicator LEDs that let you know which type of wave is currently being sent to the output.\nParts List:\n(4x) Mini SPST 1.5-Amp Momentary Pushbutton Switch (2 packages) Radioshack #275-1556\n(8x) 10K Ohm 1/4-Watt Carbon Film Resistor\u00a0 (2 packages) Radioshack #271-1335\n(9x) 20K Ohm 1/4-Watt Carbon Film Resistor (2 packages)\n(1x) 50K-Ohm Linear-Taper Potentiometer Radioshack #271-1716\n(1x) 10K-Omh Audio-Taper Potentiometer Radioshack #271-1721\n(1x) 10K-Ohm Audio Control Potentiometer with SPST Switch Radioshack #271-215\n(1x) 1/8\" Stereo In-Line Audio Jack Radioshack #274-274\n(1x) 10.01\u00b5f 50V Ceramic Disc Capacitor Radioshack #55047551\n(1x) 4.7K Ohm 1/4-Watt Carbon Film Resistor Radioshack #271-1330\n(1x) 8 Pin Socket Radioshack #276-1995\n(1x) LM386 Low Voltage Audio Power Amplifier Radioshack #276-1731\n(2x) 220\u00b5F 35V 20% Radial-lead Electrolytic Capacitor (or anything between 200 and 300 uF) Radioshack #272-1029\n(1x) Arduino Uno REV 3 Radioshack #276-128\n(1x) Arduino Proto Shield Radioshack #276-140\n(4x) White Super-bright LED Indicator Radioshack #55050633\n(4x) 740 ohm 1/4W 5% Carbon Film Resistor (1 package) Radioshack 271-1317\n(1x) 300Ohm resistor\nAdditional Materials:\nHeat Shrink Radioshack #278-1611\n22 Gauge Wire Radioshack #278-1224\nSolder Radioshack #64-013\nDrill\nHot Glue\nGlue\nBlack diffusor material (tissue paper, plastic, etc)", "title": "Arduino Waveform Generator", "url": "https://www.instructables.com/id/Arduino-Waveform-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "The Arduino Proto Shields are a convenient way to attach circuits to an Arduino, but I like to trim them down a little bit first so they do not take up so much room in the project enclosure.\u00a0\u00a0 Start by trimming the pins down with a pair of wire cutters.\u00a0 Next, cut off the six pin socket.\u00a0 Finally, cut the sockets from the top of the board.", "step_imgs": ["https://cdn.instructables.com/F47/9BJJ/H0FLRO45/F479BJJH0FLRO45.LARGE.jpg", "https://cdn.instructables.com/FF7/WLIR/H0FLRO46/FF7WLIRH0FLRO46.LARGE.jpg", "https://cdn.instructables.com/FYI/3OEL/H0FLRO47/FYI3OELH0FLRO47.LARGE.jpg", "https://cdn.instructables.com/FHI/OWYF/H0FLBLJO/FHIOWYFH0FLBLJO.LARGE.jpg", "https://cdn.instructables.com/FGS/U2GL/H0FLRO48/FGSU2GLH0FLRO48.LARGE.jpg"], "step_title": "Step 1: Prepare Arduino Proto Shield"}, {"step": 2, "steps_text": "I decided to laser cut a custom enclosure for my project.\u00a0 I designed the enclosure using AutoCAD, Autodesk 123D Make, and Corel Draw, and I've included corel draw and adobe illustrator 2D files as well as the STL, and DWG files from this process below.\u00a0 If you do not have access to a laser cutter, you can use my 2D files a guide and drill the necessary holes in a project enclosure of some kind.\u00a0 Figure 4 shows the holes that should be drilled on the front panel:\n(3x) 7mm holes for gain, freq, and PWM pots\n(3x) 7mm holes for four push buttons- sin, saw, tri, and pulse\n(1x) 10mm hole for audio out\nI cut out shapes of all four waveforms in the front of the enclosure so that I could backlight them with indicator LEDs, you may choose to just drill four 5mm holes for these LEDs in the front panel of the enclosure, place one LED under each momentary switch.\nAlso include a rectangular (11mm tall, 12mm wide) cutout somewhere on the side of the enclosure for the arduino's usb port.\nI made my project enclosure out of wood, so I had to glue all the pieces (except the bottom) together with wood glue.\u00a0 I will attach the bottom panel on later in this instructable.", "step_imgs": ["https://cdn.instructables.com/F5K/IKSN/H1EMHXEN/F5KIKSNH1EMHXEN.LARGE.jpg", "https://cdn.instructables.com/F1L/M0E9/H1EN042T/F1LM0E9H1EN042T.LARGE.jpg", "https://cdn.instructables.com/FC0/LQYB/H1EN042W/FC0LQYBH1EN042W.LARGE.jpg", "https://cdn.instructables.com/F6F/RPLN/H1ERN09W/F6FRPLNH1ERN09W.LARGE.jpg", "https://cdn.instructables.com/FF8/CY87/H1EN6W6P/FF8CY87H1EN6W6P.LARGE.jpg", "https://cdn.instructables.com/F5H/5XO9/H1EN0483/F5H5XO9H1EN0483.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Enclosure"}, {"step": 3, "steps_text": "Solder a 10kOhm resistor to one lead of each of the four push buttons.\u00a0 As shown in the second image, solder a green wire to the junction between the button and the resistor and a red wire to the other end of the resistor.\u00a0 Solder a black wire the the second lead of the push button.\u00a0 It's a good idea to cover these connections with a bit of heat shrink to prevent short circuits (fig 2).", "step_imgs": ["https://cdn.instructables.com/FZY/GVPY/H142A3TQ/FZYGVPYH142A3TQ.LARGE.jpg", "https://cdn.instructables.com/FBG/OPQN/H1426G3L/FBGOPQNH1426G3L.LARGE.jpg", "https://cdn.instructables.com/F7X/9QIS/H142A3UU/F7X9QISH142A3UU.LARGE.jpg"], "step_title": "Step 3: Solder Button Leads"}, {"step": 4, "steps_text": "Unscrew the plastic casing from the audio jack.\u00a0 Solder a red wire to the two stereo out pins and solder a black wire to the ground pin (fig 3).\u00a0 I used hot glue to prevent short circuiting the jack and to give the soldering joints some extra support.\u00a0 Finally, mount the audio jack in the enclosure with super glue.", "step_imgs": ["https://cdn.instructables.com/FYR/EDJV/H0KL4FHY/FYREDJVH0KL4FHY.LARGE.jpg", "https://cdn.instructables.com/FAC/OUI4/H0KR942R/FACOUI4H0KR942R.LARGE.jpg", "https://cdn.instructables.com/FPD/1ZZK/H1EN6W6Q/FPD1ZZKH1EN6W6Q.LARGE.jpg", "https://cdn.instructables.com/FK3/BLOX/H1EMHXFS/FK3BLOXH1EMHXFS.LARGE.jpg", "https://cdn.instructables.com/F5C/5LVW/H1EMHXI9/F5C5LVWH1EMHXI9.LARGE.jpg"], "step_title": "Step 4: Install Audio Jack"}, {"step": 5, "steps_text": "Snap the top of the button off and fit them into the wooden enclosure.\u00a0 Secure with hot glue.\u00a0 Once dried, snap the black button tops back on.", "step_imgs": ["https://cdn.instructables.com/FS5/BPOD/H1G700GC/FS5BPODH1G700GC.LARGE.jpg", "https://cdn.instructables.com/F4U/VBE2/H1YOHHBQ/F4UVBE2H1YOHHBQ.LARGE.jpg"], "step_title": "Step 5: Install Buttons"}, {"step": 6, "steps_text": "Solder eight 20kOhm resistors to the arduino protoshield. \u00a0One end of each resistor should connect to digital pins 0-7.", "step_imgs": ["https://cdn.instructables.com/FR6/NWYD/H1YOAYLM/FR6NWYDH1YOAYLM.LARGE.jpg", "https://cdn.instructables.com/F1X/KPX7/H1YONE0Y/F1XKPX7H1YONE0Y.LARGE.jpg"], "step_title": "Step 6: R2R DAC on Arduino Shield: Part 1"}, {"step": 7, "steps_text": "Solder 7 10kOhm resistors to the protoboard so that they bridge the leads of the 8 20kPhm resistors you have just soldered.", "step_imgs": ["https://cdn.instructables.com/F5I/FOV9/H1YOAYLN/F5IFOV9H1YOAYLN.LARGE.jpg", "https://cdn.instructables.com/F3I/RYFE/H1YOKGMI/F3IRYFEH1YOKGMI.LARGE.jpg"], "step_title": "Step 7: R2R DAC on Arduino Shield: Part 1"}, {"step": 8, "steps_text": "Solder a 20kOhm resistor to the protoshield so that one end is connected to the 10kOhm resistor attached to digital pin 0 and the other \u00a0end is connected to a jumper wire to ground.", "step_imgs": ["https://cdn.instructables.com/FO5/9AIQ/H1YOKGLO/FO59AIQH1YOKGLO.LARGE.jpg", "https://cdn.instructables.com/F7J/RZC6/H1ZG6M3O/F7JRZC6H1ZG6M3O.LARGE.jpg"], "step_title": "Step 8: R2R DAC on Arduino Shield: Part 3"}, {"step": 9, "steps_text": "It's a good idea to use sockets for your ICs, this way you won't risk burning the IC with your soldering iron and you can \u00a0easily replace the IC if it breaks. \u00a0Solder an 8 pin socket to the protoboard as shown in the image.", "step_imgs": ["https://cdn.instructables.com/F03/D4VV/H1YOAYLQ/F03D4VVH1YOAYLQ.LARGE.jpg", "https://cdn.instructables.com/FMQ/MXO5/H1YOHIAY/FMQMXO5H1YOHIAY.LARGE.jpg"], "step_title": "Step 9: IC Socket"}, {"step": 10, "steps_text": "Use a resistor and capacitor in series to create a low pass filter.\u00a0 Low pass filters let low frequencies pass through and silence (attenuate) high frequencies.\u00a0 Connecting a low pass filter to the output from the dac will smooth out the steps in the wave.\nHere's how I calculated the value of the components in my low pass filter:\ncorner frequency = 1/(2*pi*R*C)\nAccording to Nyquist's Theorum, signals cannot contain frequencies higher than half their sampling rate.\u00a0 If I used a sampling rate of 100kHz, then the highest frequency I can produce is 50kHz.\nif I use a 300Ohm resistor and I want a corner frequency of 50kHz:\n50000 = 1/(6.28*300*C)\nC = 1.06*10^-8 F\nround this to:\nC = 0.01uF\nConnect one end of the the 300Ohm resistor to the 10kOhm resistor connected to digital pin 7. \u00a0Connect the capacitor to the other end of the 300Ohm resistor. \u00a0The other side of the cap should connect to ground.", "step_imgs": ["https://cdn.instructables.com/FBU/EK6X/H2073J6J/FBUEK6XH2073J6J.LARGE.jpg", "https://cdn.instructables.com/FEO/OQ8N/H1YOHIB9/FEOOQ8NH1YOHIB9.LARGE.jpg"], "step_title": "Step 10: Low Pass Filter"}, {"step": 11, "steps_text": "Connect the positive lead of the 220uF capacitor to the junction between the resistor and capacitor of the low pass filter. \u00a0The other end of the 220uF capacitor connects to a 20kOhm resistor that is connected to pin 3 of the IC socket. \u00a0A 4.7kOhm resistor bridges pins 3 and 4 of the IC socket.", "step_imgs": ["https://cdn.instructables.com/F63/XKSG/H1YOKGMC/F63XKSGH1YOKGMC.LARGE.jpg", "https://cdn.instructables.com/FBI/PHQC/H1YOAYLX/FBIPHQCH1YOAYLX.LARGE.jpg", "https://cdn.instructables.com/F0G/OU8N/H1YOAYLZ/F0GOU8NH1YOAYLZ.LARGE.jpg", "https://cdn.instructables.com/FCR/EEF9/H1YOHN7K/FCREEF9H1YOHN7K.LARGE.jpg"], "step_title": "Step 11: Amplifier: Part 1"}, {"step": 12, "steps_text": "Connect ground to pin 4 of the IC socket.", "step_imgs": ["https://cdn.instructables.com/FNO/N6BX/H2073J6L/FNON6BXH2073J6L.LARGE.jpg", "https://cdn.instructables.com/F25/VRYW/H1YOKGMD/F25VRYWH1YOKGMD.LARGE.jpg"], "step_title": "Step 12: Amplifier: Part 2"}, {"step": 13, "steps_text": "Connect the positive lead of a second 200uF capacitor to pin 5 of the IC socket. \u00a0The other end of the cap will be connected to the gain pot in a later step.", "step_imgs": ["https://cdn.instructables.com/F0N/X6BH/H1YOHIBC/F0NX6BHH1YOHIBC.LARGE.jpg", "https://cdn.instructables.com/FO1/QW4G/H1YONE15/FO1QW4GH1YONE15.LARGE.jpg"], "step_title": "Step 13: Amplifier: Part 3"}, {"step": 14, "steps_text": "Connect pin 6 of the IC socket to Vin, pin 2 to ground, and snap the IC into the socket.", "step_imgs": ["https://cdn.instructables.com/FPZ/C1NY/H1ZG6LVK/FPZC1NYH1ZG6LVK.LARGE.jpg", "https://cdn.instructables.com/FPG/3LSB/H1YONE16/FPG3LSBH1YONE16.LARGE.jpg", "https://cdn.instructables.com/FYP/2CNA/H1YOKGMF/FYP2CNAH1YOKGMF.LARGE.jpg"], "step_title": "Step 14: Amplifier: Part 4"}, {"step": 15, "steps_text": "Volume or gain of the audio signal will be controlled with the 10k audio taper pot with switch.\u00a0 Connect the audio out from the amplifier and ground to either side of the potentiometer as indicated in the picture.\u00a0 The middle is audio out, it will be hooked up directly to the audio jack.\nAlso connect a wire to the bottom and left leads on the back of the pot (figure 2).\u00a0 This is the switch that will be used to connect to power in the next step.", "step_imgs": ["https://cdn.instructables.com/F8G/DI75/H1YOKHRJ/F8GDI75H1YOKHRJ.LARGE.jpg", "https://cdn.instructables.com/FR5/NQ8Y/H1YOKHRK/FR5NQ8YH1YOKHRK.LARGE.jpg", "https://cdn.instructables.com/FWO/FLZ4/H1YOAZFD/FWOFLZ4H1YOAZFD.LARGE.jpg"], "step_title": "Step 15: Wire Gain Pot"}, {"step": 16, "steps_text": "Connect the black wire from the battery clip to ground on the Arduino Shield. \u00a0Connect one lead from the gain pot switch to the red wire \u00a0from the battery clip and connect the other gain pot lead to Vin on the Arduino Shield.\nLeave the battery disconnected for now.", "step_imgs": ["https://cdn.instructables.com/F7G/BWO3/H2073JG4/F7GBWO3H2073JG4.LARGE.jpg"], "step_title": "Step 16: Connect to Battery"}, {"step": 17, "steps_text": "Connect the output from the amplifier (the negative lead of the cap connected to the IC at pin 5) to the red wire we attached to the gain potentiometer in an earlier step.\u00a0 Connect the green wire from the amplitude pot to the red wire connected to the audio jack.\u00a0 Connect the black wire from the audio jack and the black wire from the pot to ground on the Arduino Shield.", "step_imgs": ["https://cdn.instructables.com/F1H/SVCQ/H1YOAZFE/F1HSVCQH1YOAZFE.LARGE.jpg"], "step_title": "Step 17: Connect Output to Headphone Jack"}, {"step": 18, "steps_text": "Connect all read leads from the button to 5V and all the black wires to ground on the arduino shield (fig 1). \u00a0Connect the green wires to analog in 0-3 in the following order:\nanalog 0 \u00a0 = \u00a0 pulse\nanalog 1 \u00a0 = \u00a0 triangle\nanalog 2 \u00a0 = \u00a0 saw\nanalog 3 \u00a0 = \u00a0 sine", "step_imgs": ["https://cdn.instructables.com/F6F/BOEJ/H1YONEOR/F6FBOEJH1YONEOR.LARGE.jpg", "https://cdn.instructables.com/FB0/339Y/H1YOHIZ9/FB0339YH1YOHIZ9.LARGE.jpg", "https://cdn.instructables.com/FYA/EH0V/H2073JG5/FYAEH0VH2073JG5.LARGE.jpg"], "step_title": "Step 18: Wire Buttons"}, {"step": 19, "steps_text": "Connect a red, black, and green wire to the 10kOhm and 50kOhm potentiometers as shown in the images. \u00a0Connect the red lead to 5V and the black leads to ground on the arduino shield. \u00a0Connect the center green wires to analog \u00a0pins 4 (PWM) and 5 (frequency).", "step_imgs": ["https://cdn.instructables.com/F2I/WYJE/H1KHAYU7/F2IWYJEH1KHAYU7.LARGE.jpg", "https://cdn.instructables.com/F7T/UE0X/H1KHAYU9/F7TUE0XH1KHAYU9.LARGE.jpg", "https://cdn.instructables.com/F70/2JTU/H1YOAZFG/F702JTUH1YOAZFG.LARGE.jpg"], "step_title": "Step 19: Wire Frequency and PWM Pots"}, {"step": 20, "steps_text": "Remove the side tab on all of the pots before installing in the enclosure, this will allow them to sit flush against the wood.\u00a0 Remove washer and nut from each of the pots, place pot through hole in enclosure, and secure with nut. \u00a0Install all three pots in the enclosure.", "step_imgs": ["https://cdn.instructables.com/FNG/Y9FG/H2073JG7/FNGY9FGH2073JG7.LARGE.jpg", "https://cdn.instructables.com/FZU/RK65/H0OJ5RV4/FZURK65H0OJ5RV4.LARGE.jpg", "https://cdn.instructables.com/F1W/C3K2/H0OJ2DNO/F1WC3K2H0OJ2DNO.LARGE.jpg"], "step_title": "Step 20: Install Pots"}, {"step": 21, "steps_text": "Attach a 470Ohm resistor to the cathode of each of the four LEDs.\u00a0 Solder a black wire to the other end of the resisotr and a red wire to the anode of the LED.\u00a0 Cover these connections with shrink wrap to prevent short circuiting.", "step_imgs": ["https://cdn.instructables.com/FL5/EDR8/H1YOHWYG/FL5EDR8H1YOHWYG.LARGE.jpg", "https://cdn.instructables.com/FI7/4LWO/H1YOB2J5/FI74LWOH1YOB2J5.LARGE.jpg"], "step_title": "Step 21: Wire LEDs: Part 1"}, {"step": 22, "steps_text": "Solder the black leads from all four LEDs to ground on the arduino shield.\u00a0 Solder the red leads to digital pins 8-11.", "step_imgs": ["https://cdn.instructables.com/FO9/LGNP/H21MJHRX/FO9LGNPH21MJHRX.LARGE.jpg", "https://cdn.instructables.com/FZ4/T3KP/H1YOKNXL/FZ4T3KPH1YOKNXL.LARGE.jpg"], "step_title": "Step 22: Wire LEDs: Part 2"}, {"step": 23, "steps_text": "Glue a light diffusing material behind the wave cutouts in the front panel.\u00a0 I used a piece of a black plastic garbage bag.", "step_imgs": ["https://cdn.instructables.com/F9C/PA8G/H21CGJ6J/F9CPA8GH21CGJ6J.LARGE.jpg"], "step_title": "Step 23: Black Diffuser"}, {"step": 24, "steps_text": "Glue the LEDs in the enclosure so that they are each pointed towards one of the cutout symbols on the front panel.\u00a0 Here is a table for reference:\ndigital 8\u00a0 \u00a0 =\u00a0\u00a0 pulse\ndigital 9 \u00a0\u00a0 = \u00a0 triangle\ndigital 10\u00a0 =\u00a0\u00a0 saw\ndigital 11\u00a0 =\u00a0\u00a0 sine", "step_imgs": ["https://cdn.instructables.com/FHX/LQ7P/H27LREIS/FHXLQ7PH27LREIS.LARGE.jpg"], "step_title": "Step 24: Glue LEDs"}, {"step": 25, "steps_text": "Upload the code at the bottom of this step onto the Arduino.\u00a0 The code uses a timer interrupt at a frequency of 100kHz to send new data out to the DAC.\u00a0 The rest of the code monitors the state of the buttons and knobs and adjusts variables accordingly.\u00a0 Since the interrupts occur at such a high frequency, I had to keep the interrupt routine, the piece of code encapsulated in the ISR(TIMER1_COMPA_vect){} as short as possible. Time intensive operations like mathematical operations with floats and using the sin() function take too much time to complete.\u00a0 I used several work around to get by this:\nFor triangle and saw I created the variables sawByte, triByte, sawInc, and triInc.\u00a0 Every time the frequency changed I calculated the amount that the triangle and saw function would have to increment at a sampling rate of 100kHz:triInc = 511/period;\nif (triInc==0){\n\u00a0\u00a0 triInc = 1;\n}\nsawInc = 255/period;\nif (sawInc==0){\n\u00a0\u00a0 sawInc = 1;\n}\nthen all the needed to be done in the interrupt routine was some simple math:case 1://triangle\nif((period-t) > t);\n\u00a0\u00a0\u00a0 if (t == 0){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 triByte = 0;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 triByte += triInc;\n\u00a0\u00a0\u00a0 }\n}\nelse{\n\u00a0\u00a0\u00a0 triByte -= triInc;\n}\nif (triByte>255){\n\u00a0\u00a0\u00a0 triByte = 255;\n}\nelse if (triByte<0){\n\u00a0\u00a0\u00a0 triByte = 0;\n}\nwave = triByte;\nbreak;\ncase 2://saw\nif (t=0){\n\u00a0\u00a0 sawByte=0;\n}\nelse{\n\u00a0\u00a0\u00a0 sawByte+=sawInc;\n}\nwave = sawByte;\nbreak;\nFor the sine function, I wrote a simple python script which outputs 20000 values of 127+127sin(x) for one complete cycle:import math\nfor x in range(0, 20000):\n\u00a0\u00a0\u00a0 print str(int(127+127*math.sin(2*math.pi*x*0.00005)),)+str(\",\"),\nI stored this array in the Arduino's memory called sine20000[] and recalled the values I needed to send to the DAC.\u00a0 This is much faster than calculating the values individually.", "step_imgs": ["https://cdn.instructables.com/F57/OWUR/H1ZG6MSQ/F57OWURH1ZG6MSQ.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 25: Firmware"}, {"step": 26, "steps_text": "Plug the Arduino into your shield.\u00a0 Connect a 9V battery to the battery clip.\u00a0 Secure these items inside the enclosure.\u00a0 Make sure that the Arduino's usb port is accessible from the outside of the enclosure.\u00a0 Upon startup you should see the sine wave LED light up.", "step_imgs": ["https://cdn.instructables.com/FBC/41ZV/H1YONF73/FBC41ZVH1YONF73.LARGE.jpg", "https://cdn.instructables.com/FZ3/WZWN/H1YOKNZ1/FZ3WZWNH1YOKNZ1.LARGE.jpg", "https://cdn.instructables.com/F57/BX1O/H1YOKNZJ/F57BX1OH1YOKNZJ.LARGE.jpg"], "step_title": "Step 26: Last Few Connections"}, {"step": 27, "steps_text": "Drill four holes in the back panel and secure with screws.", "step_imgs": ["https://cdn.instructables.com/F4F/NR3B/H4AFSEVM/F4FNR3BH4AFSEVM.LARGE.jpg"], "step_title": "Step 27: Screw Back Panel"}, {"step": 28, "steps_text": "Screw knobs on the three potentiometers.", "step_imgs": ["https://cdn.instructables.com/FFL/7Q4N/H1ZG8ODC/FFL7Q4NH1ZG8ODC.LARGE.jpg"], "step_title": "Step 28: Add Knobs"}, {"step": 29, "steps_text": "Turn up the gain knob to turn on the function generator.\u00a0 Plug an eighth inch jack into the output and hook up the function generator to an oscilloscope.\u00a0 Test out each of the waveforms and adjust the frequency and gain to make sure they are working properly.\u00a0 Switch the output to pulse and check if the pulse width modulation knob works (figs 4-6).\nYou will notice that the pulse wave is the only wave which truly ranges from 1Hz to 50kHz.\u00a0 Since the sampling rate is 100kHz, the sine, triangle, and saw waves start to become somewhat unrecognizable at about 25kHz (they are only comprised of 4 samples per cycle- 100kHz/25kHz).\u00a0 The saw and triangle waves only go down to about 100Hz, this is because the values of triInc and sawInc get so low that they are rounded to zero below this frequency.\u00a0 The sine wave reaches all the way to 1 HZ but the resolution stays the same for anything under 5Hz, since the Arduino only has enough memory to store about 20 thousand samples.", "step_imgs": ["https://cdn.instructables.com/FF7/XVJJ/H4VQ6AFK/FF7XVJJH4VQ6AFK.LARGE.jpg", "https://cdn.instructables.com/FBJ/3MZB/H51ASJOU/FBJ3MZBH51ASJOU.LARGE.jpg", "https://cdn.instructables.com/FDN/QKO7/H4VQNRAO/FDNQKO7H4VQNRAO.LARGE.jpg", "https://cdn.instructables.com/FY1/DHW2/H4ZN5CHT/FY1DHW2H4ZN5CHT.LARGE.jpg", "https://cdn.instructables.com/FJ4/VQZI/H4ZN5CSV/FJ4VQZIH4ZN5CSV.LARGE.jpg", "https://cdn.instructables.com/FYF/9L09/H4VQKNPC/FYF9L09H4VQKNPC.LARGE.jpg"], "step_title": "Step 29: Test"}], "channel": "Arduino"}, {"category": "technology", "description": "This Bunny was made a while ago for a Physical Computing class. It triggers motion with a PIR sensor located in the nose, and then randomly selects and plays a very loud creepy sound. While the sound is playing, the Rabbit's eyes blink and the ears move. The Arduino Uno board controls the system.This project is based on other works, such as Shaun The Noisy Sheep by Paulys and the Adafruit's Pumpkin project. Although the working principles are very similar, I added some new features, such as a different kind of sensor, servo motors for the ears, portability and sound amplification. I hope someone else will come up with other improvements, such as head rotation, sudden jumping, zombie walk, or... you name it.Happy making everyone!", "title": "The Hell Rabbit", "url": "https://www.instructables.com/id/The-Hell-Rabbit/", "section": "technology", "steps": [{"step": 1, "steps_text": "Project Components:1 x Arduino Uno microcontroller;  1 x Laptop with Arduino IDE installed; 1 x USB A/B cable (usually comes with Arduino);  1 x Adafruit Wave Shield for Arduino (allows the Arduino to play sounds);  1 x 1GB FAT16 Standard SD Card (for the Wave Shield to store your audio files);  1 x Card reader (or other means to connect your SD card to the laptop) 1 x Smokey Amplifier (connected to the Wave Shield, amplifies the sound);  1 x 1/8\" TS Male to 1/4\" TS Male Audio Cable, 3ft (Smokey Amp to Wave Shield interface);  1 x 15\" Stuffed Bunny (dog toy) - make sure it is big enough to fit all the components inside);  1 x PIR motion sensor (to trigger motion);  2 x Micro Servos (moving ears);  2 x Super Bright Red LEDs (blinking eyes);  1 x 1K resistor (for the LEDs);1 x 9V battery pack w/ON/OFF switch (to power up the Arduino);  2 x 9V batteries (one for Arduino, one for Smokey Amp);  1 spool of 22 gauge electrical wire;  Velcro (to allow quick access to the components inside the Rabbit);  2 x Straws (connected to servo motors shafts to allow ear motion);  1 x Empty bottle of 32 oz Gatorade (for the skull);Tools:Soldering iron and solder;  Wire cutters;  Wire strippers;  Scissors;  Needle and thread;  Electrical tape;  Packing tape;  Sharpie;  Cardboard;  Breadboard (for circuit prototyping);  Jumper wires (for circuit prototyping);", "step_imgs": ["https://cdn.instructables.com/F7X/RWF4/INI7SRRH/F7XRWF4INI7SRRH.LARGE.jpg", "https://cdn.instructables.com/F1J/GWAA/INI7SRRN/F1JGWAAINI7SRRN.LARGE.jpg", "https://cdn.instructables.com/FNU/RL6J/INI7SRRO/FNURL6JINI7SRRO.LARGE.jpg", "https://cdn.instructables.com/FSI/6FA0/INI7SRRV/FSI6FA0INI7SRRV.LARGE.jpg", "https://cdn.instructables.com/FTB/INQ5/INM7KHGA/FTBINQ5INM7KHGA.LARGE.jpg", "https://cdn.instructables.com/FIG/GZ26/INNGL8CB/FIGGZ26INNGL8CB.LARGE.jpg"], "step_title": "Step 1: Parts and Tools"}, {"step": 2, "steps_text": "Unpack the Wave Shield Kit, check whether all the components are there, then solder everything using these step by step instructions. The shield has only one surface mount component - SD card slot, so soldering is not too hard. If you are unfamiliar with the process, here is a great instructable on this topic. I bought the Wave Shield kit together with the SDHC SD card and a 3\" speaker, but ended up not using any of these. The AF_Wave library used in the Arduino code for this project works only with Standard SD cards (not SDHC) and only formatted for FAT 16 (not FAT 32). After a quick research I was able to buy a Standard SD card on ebay for $2. As for the 3\" speaker, the Wave Shield wasn't loud enough for me, so I decided to use a Smokey Amp instead (it is used as both an amplifier and a speaker). ", "step_imgs": ["https://cdn.instructables.com/FHO/0L8W/INI7SRRP/FHO0L8WINI7SRRP.LARGE.jpg", "https://cdn.instructables.com/F6Y/OSFP/INI7SRRQ/F6YOSFPINI7SRRQ.LARGE.jpg", "https://cdn.instructables.com/FXL/L5AY/INI7SRRR/FXLL5AYINI7SRRR.LARGE.jpg", "https://cdn.instructables.com/FPV/8FM1/INI7SRRU/FPV8FM1INI7SRRU.LARGE.jpg"], "step_title": "Step 2: Wave Shield Assembly "}, {"step": 3, "steps_text": "The Wave Shield is designed to play a very specific type of audio \u2013 22kHz max, 16-bit, mono .WAV files. It will not work with MP3, AIFF or any other formats. You have to convert the sounds you wish to play to the format mentioned above. Here is a good explanation of this process. I used iTunes method, because it was the easiest one for me.After you're done converting, rename your files \"01.WAV\", \"02.WAV\" etc. Then put them onto the SD card (make sure it is formatted for FAT16 filesystem; FAT32 will not work with this project's code).  Insert the card into the slot on the Wave Shield and connect the shield to the Arduino. Then connect the Arduino board to the laptop and open the IDE. If you don't have this software, you can download it for free from here. Next, I recommend to download the WaveHC library and test the Wave Shield using an example code and the following set of instructions. NOTE: In this project we will use a different library - AF_Wave, which is older than WaveHC. The reason for this is very simple - I spent a lot of time trying to modify the code for the newer library (WaveHC), and got nowhere. If anyone can do it, it would be great, because WaveHC library is much better than AF_Wave and is written for SDHC SD cards (e.g. virtually every consumer grade SD card). Until then let's stick with good ol' stuff.", "step_imgs": ["https://cdn.instructables.com/FCY/3JCX/INI7SRS7/FCY3JCXINI7SRS7.LARGE.jpg"], "step_title": "Step 3: Sound Conversion and Naming"}, {"step": 4, "steps_text": "The next step is to upload the \"Hell Rabbit's\" code to the Arduino. First, download and extract the AF_Wave and Servo_Timer2 librariesattached below. Then download the \"Hell_Bunny\" code, connect the Arduino to the computer and upload the sketch. NOTE: Current version of the code uses 4 audio files named \"01.WAV\" through \"04.WAV\". If you wish to use more files (or a different naming convention), modify the code accordingly.", "step_imgs": ["https://cdn.instructables.com/FCM/0T7W/INPCRCAW/FCM0T7WINPCRCAW.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Code Uploading and Testing"}, {"step": 5, "steps_text": "The next step will be to breadboard and test the entire circuit.On the attached schematics the Wave Shield is shown as a regular Arduino board, because there is no correct symbol for it in Fritzing. The PIR sensor symbol should be also slightly different.Connect the wires as follows: Common Ground \u2013 to the GND pin; common Voltage \u2013 to the 5V pin; PIR signal \u2013 to pin 6; 1st servo signal \u2013 to pin 7; 2nd servo signal \u2013 to pin 9, LEDs \u2013 to the Analog pin 4 (=digital 18) through a 1K resistor.After making sure everything is connected properly, upload the \"Hell Bunny Code\" to the Arduino. You should get something similar to the above video.", "step_imgs": ["https://cdn.instructables.com/F90/2F11/INUV2PYR/F902F11INUV2PYR.LARGE.jpg"], "step_title": "Step 5: Circuit Prototyping "}, {"step": 6, "steps_text": "Now it is time to put the working system inside the Rabbit. Make a hole along the seam under the Bunny's right foot, then take out half of the body stuffing and all the head stuffing. Next, cut a small hole in Bunny's nose for the PIR sensor, insert the sensor from inside, then sew it into the nose through 2 side holes on the sensor.The hardest thing is to figure out how to secure two servo motors inside the bunny\u2019s head. The head is very soft and the servos have a pretty high torque. I sewed two straws to the servo's shafts through the little holes on the shafts, then used some cardboard and packing tape to hold everything together. I inserted the straws into the Rabbit's ears and hoped for the best.Next, cut the top part of an empty Gatorade bottle (it will be the Bunny's skull), and make two holes for the eyes. Solder the LEDs and 1K resistor together as shown on the photo (LABEL EVERYTHING!), and insert the skull assembly into the Rabbit's head. Test the LEDs when installed by connecting jumpers to the appropriate pins on the Wave Shield and running the sketch;After that, solder long jumper wires to the PIR sensor, label them and test them after installation; Next, secure servo motors inside the Bunny\u2019s head (I used some packing tape and cardboard), attach long jumper wires, label them and test the system. Then do the following:- Solder all ground wires together (LEDs, 2 servos and PIR sensor grounds) and test - Solder all voltage wires together (PIR sensor and 2 servos voltages) and test the system;- Solder all remaining wires to the Wave Shield according to the code and the schematics and test the system;If everything works fine, you will be very close to Step 7. The last thing will be to sew some velcro tape along the seam (to allow a quick access to the Bunny's guts). Then insert a 9V battery into the battery holder, plug it to the Arduino board and put the enclosure into the Rabbit's foot. Connect 1/8\" jack of the audio cable to the Wave Shield, and 1/4\" jack to the Smokey Amp. ", "step_imgs": ["https://cdn.instructables.com/FQ7/YVHA/INI7SRS6/FQ7YVHAINI7SRS6.LARGE.jpg", "https://cdn.instructables.com/F2P/CBI0/INI7SRRZ/F2PCBI0INI7SRRZ.LARGE.jpg", "https://cdn.instructables.com/FZS/HKJS/INI7SRS3/FZSHKJSINI7SRS3.LARGE.jpg", "https://cdn.instructables.com/FTF/MHB6/INI7SRS2/FTFMHB6INI7SRS2.LARGE.jpg", "https://cdn.instructables.com/FQJ/P9CA/INI7UQ8W/FQJP9CAINI7UQ8W.LARGE.jpg", "https://cdn.instructables.com/FXI/C5M5/INI7UQ8X/FXIC5M5INI7UQ8X.LARGE.jpg"], "step_title": "Step 6: Circuit Integration and Final Soldering"}, {"step": 7, "steps_text": "Put the Bunny somewhere in the room and enjoy your friends' (or enemies) reaction!", "step_imgs": [], "step_title": "Step 7: Done!"}], "channel": "Arduino"}, {"category": "technology", "description": "SingAlong is a quick and easy way to enjoy music visually. It uses the Arduino shield found at https://breadware.com/store/  along with a few of the Breadware modules. The Breadware shield is incredibly versatile and comes with a range of sensors. I recommend any DIY nut to play around with it. Many home projects can be created in a matter of minutes thanks to the diversity of sensors available (I.E. Temperature, Humidity, Acceleration and more).  Save 10% on a Breadware purchase by entering the code byars17 at checkout.Press the button to activate or deactivate the code. Turn the knob to adjust the LED brightness.Although I set the music to change the LEDs RGB values randomly, you might like to create ascending RGB values or some other pleasant pattern.", "title": "SingAlong", "url": "https://www.instructables.com/id/SingAlong/", "section": "technology", "steps": [{"step": 1, "steps_text": "Arduino MegaMega-B Bread\u2122BoardBreadware Modules:1 Button3 RGB LEDs1 Knob1 Microphone", "step_imgs": [], "step_title": "Step 1: Bill of Materials"}, {"step": 2, "steps_text": "Go to https://dev.breadware.com/login and login or create an account.Once signed in, press New Project on the bar on the left side of the webpage. Select the Mega-B Board and Blank Template.", "step_imgs": ["https://cdn.instructables.com/FL8/66VD/J44FL4ET/FL866VDJ44FL4ET.LARGE.jpg"], "step_title": "Step 2: Create the Project"}, {"step": 3, "steps_text": "When the project first opens, there will be an empty board on the screen with Breadware modules to the right. We will be setting the modules onto the board. You can drag them onto any of the available spots, but make sure the physical board mirrors the positions you use in the program. I positioned them as shown in the image.As the components are placed on the board, you will be asked to name them. I used the default names given (led_0, led_1, led_2, button_0, microphone_0, and knob_0). Feel free to name them anything you like. You will have to replace the names in the code if you do choose unique names,though. ", "step_imgs": ["https://cdn.instructables.com/FHZ/8AAX/J44FL5MJ/FHZ8AAXJ44FL5MJ.LARGE.jpg"], "step_title": "Step 3: Prepare the Board"}, {"step": 4, "steps_text": "Go to the Write Firmware tab, shown in the image. Copy the code below into the loop tab (remember to change the names in the code if you didn't use mine).**Note** You might have to play around with the if statement values. The values represent decibels, so depending on how loud you have your speaker you may have to adjust the values. I used Serial.println to show the decibel values being read. You can adjust the if statement values by looking at the serial monitor and deciding what range of decibels will work well for your music.Code (comments in bold):while(!button_0.is_pressed()); //wait for button presswhile(button_0.is_pressed());  //wait for button releasewhile(!button_0.is_pressed()){   //adjust brightness of LED's using the knob     int brightness=knob_0.read();     //knob values range from 0 to 100, but the LEDs are from 0 to 255     //the map function takes the knob value and proportionally gives it a new      //value between 0 and 255   brightness = map(brightness, 0, 100, 0, 255);          double level=microphone_0.read();     // set random RGB values (between 0 and brightness)     int k=random(0,brightness);     int j=random(0,brightness);     int i=random(0,brightness);     Serial.println(level); //Change LEDs based on decibel valuesif(level<70){     led_0.setRGB(i,j,k);     } if(level>=70 || level<90){     led_1.setRGB(k,j,i);     } if(level>=90){     led_2.setRGB(i,k,j);     } delay(100); //delay so LEDs don't change too quickly }led_0.off(); led_1.off(); led_2.off(); while(button_0.is_pressed()); //when button is released, loop may restart", "step_imgs": ["https://cdn.instructables.com/FYF/U0XP/J44FL5Q3/FYFU0XPJ44FL5Q3.LARGE.jpg"], "step_title": "Step 4: Write the Firmware"}, {"step": 5, "steps_text": "Press the save button (shown in first image) and then the download button (the blue button to its right).Create a new folder anywhere you'd like and unzip the downloaded files into this new folder. The folder can be named anything you'd like, but you must change the .ino file among the unzipped files to match the folder's name. For instance, I named my folder SingAlong so I had to rename the .ino file to SingAlong.ino. Once this is done, open the .ino file. **Note** You will need the Arduino IDE installed to do this. The download is located at  https://www.arduino.cc/en/Main/Software  Connect the Arduino Mega to your computer and upload the code onto the board.", "step_imgs": ["https://cdn.instructables.com/FAV/CCTZ/J44FL42R/FAVCCTZJ44FL42R.LARGE.jpg", "https://cdn.instructables.com/F3V/9PDD/J44FL5TF/F3V9PDDJ44FL5TF.LARGE.jpg"], "step_title": "Step 5: Upload the Code"}, {"step": 6, "steps_text": "Press the button to start the program and watch as the LEDs change based on the music playing. Remember that the knob changes the LED brightness.Also, I suggest setting the LEDs inside plastic covers so that their light is more dispersed. To do this attach the LED modules to the Breadware board with wires instead of directly connecting them in. This would also allow you to set the lights in different places around your room. As seen in the image, the pins on the LEDs from left to right say VCC, GND, <blank>, <blank> ,GPIO. The two blank pins don't need to be wired. Insure that the wires go into the same slots that they would have if you'd directly connected the LEDs to the board as I did.", "step_imgs": ["https://cdn.instructables.com/FE6/3B9G/J44FLR0N/FE63B9GJ44FLR0N.LARGE.jpg"], "step_title": "Step 6: Have Fun Listening!"}], "channel": "Arduino"}, {"category": "technology", "description": "Imagine you want to measure a tiny signal  buried in noise that is much stronger. Check out the video for a quick run through on how to do it, or carry on reading for the details.", "title": "Measure Tiny Signals Buried in Noise on Your Oscilloscope (Phase Sensitive Detection)", "url": "https://www.instructables.com/id/Measure-Tiny-Signals-Buried-in-Noise-on-Your-Oscil/", "section": "technology", "steps": [{"step": 1, "steps_text": "Imagine you want to measure the light reflected from a laser spot using only a photo diode with no optics and a crude amplifier. You can see the signal that we get is dominated by the room lights as well as the 50 Hz noise picked up by the amp.Simply averaging your signal will not work here as the background changes (say you moved your hand) is far more significant the the effect of blocking out the laser to measure the difference.This is a terrible setup because you are trying to measure a signal at DC, and this is a very noisy area of the spectrum. But as you go further into the AC the noise generally decreases because the main source of noise is called pink noise: www.wikipedia.org/wiki/Pink_noiseSo the solution is to move our signal into the AC, away from the noise sources.", "step_imgs": ["https://cdn.instructables.com/FK4/G9V7/JNSR3TIS/FK4G9V7JNSR3TIS.LARGE.jpg", "https://cdn.instructables.com/FUK/N2O0/JNSR3TJT/FUKN2O0JNSR3TJT.LARGE.jpg"], "step_title": "Step 1: Example"}, {"step": 2, "steps_text": "You can move the signal into the AC by pulsing the laser, and the way i've done that here is by powering it from a digital pin on the arduino. The arduino is running a blink sketch which makes a 5khz square wave to power the laser directly. you can then hook up another probe onto this pin to tell the oscilloscope the exact frequency of the laser.Now that the signal is in the AC you can AC couple channel 1 to get rid of the dc offset and maximise the dynamic range of the ADC.Then you want to set the trigger for channel 2 as this will be the exact same frequency as the light emitted from the laser.Now we can see that there is a tiny square wave in the noise. This is the light from the laser!And because we are triggering at the same frequency we can average out the signal: anything that is not the same frequency as our signal, or random noise, will average out to 0. Our signal which is always in phase with the reference channel will average out to a constant waveform.", "step_imgs": ["https://cdn.instructables.com/F14/JZOY/JNSR3UKD/F14JZOYJNSR3UKD.LARGE.jpg", "https://cdn.instructables.com/FJ3/FM4V/JNSR3UOU/FJ3FM4VJNSR3UOU.LARGE.jpg"], "step_title": "Step 2: Solution"}, {"step": 3, "steps_text": "You can see that we have dug out our signal from all that noise! this is essential making a band pass filter which gets narrower as you include more averages.The signal is around 50 mV and it was buried in 1 V (peak to peak) of noise! amazing that we can still measure it!The result can be justified by blocking out the laser which forces the signal to disappear.This technique is called phase sensitive detection and has many uses, for one it is pretty much the backbone for all RF communication in the world!.There are instrument called lock in amplifiers which can extract nV signals buried in V's of noise using this method. For a more comprehensive explanation and for ways to build circuits using this have a look at this analog devices article:https://www.analog.com/en/analog-dialogue/articles...I hope you have enjoyed this quick hack, if you have  any questions i'd be happy to answer them in the comments.If you found this useful you can give me a vote :)", "step_imgs": ["https://cdn.instructables.com/F4A/UUNP/JNSR3UQR/F4AUUNPJNSR3UQR.LARGE.jpg", "https://cdn.instructables.com/F4K/IGCS/JNSR3VH7/F4KIGCSJNSR3VH7.LARGE.jpg", "https://cdn.instructables.com/FX5/I7LN/JNSR3URN/FX5I7LNJNSR3URN.LARGE.jpg"], "step_title": "Step 3: Results"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          Though this is not a step by step instructable, I hope you can get the gist of what I did and I will try to answer any questions as best I can.\nMy son is a big fan of The Simpsons ( and I suppose, so am I). \u00a0I created this as a gift for him for Christmas.\nWhat we have here is a Simpson's lunch box that , when the red switch is pressed, will play randomly one of 413 wav files that are stored on the SD card which is used by the Adafruit waveshield.\nA video of it in use follows.\nThe materials used are:\n- Arduino UNO\n- Adafruit Wave Shield Kit v1.1\n- 2GB SD card\n- Simpsons lunch box - from Amazon.com\n- 2 9 volt batteries and 2 holders - radio shack\u00a0\n- 3 LEDs\n- an 8 ohm speaker\n- a DPDT switch\n- a couple of capacitors , resistors and a LM386 chip for a small amplifier \u00a0as the sound out of the wave shield is not loud enough for the speaker.\n- some wires\nAlso I used an SD card reader and a program called Switch-it to decompress the wav files .\nSteps :\n1. \u00a0 bought a Arduino Uno - \u00a0many sources for this - about $25.00 \u00a0\n2. \u00a0Bought an Adafruit Waveshield Kit - about 22.00 \u00a0.\nThis needs to be assembled and the instructions are here :http://www.ladyada.net/make/waveshield/make.html\u00a0\n(These are easy to follow instructions with many good pictures)\n3. bought a 2gb SD card \u00a0to be used in the wave shield\n4. \u00a0did a \u00a0internet \u00a0search for : \"Simpsons wav\" and found a couple of sites that had quite a good collection of wav file excerpts from the Simpsons. \u00a0 I was able to(with aid of my son) download over 400 files and save them to the SD card.\n- note the wave shield does not like compressed files so some of the files needed to be uncompressed which I did using a freeware software called \"Switch-it\" .\n5. Since the sound output of the wave shield is OK for headphones but was not loud enough for the speaker, I have sent the output from the wave shield to a small LM386 amp that I built using the following instructions.http://www.rason.org/Projects/icamps/icamps.htm\n6 . \u00a0Added LEDs to indicate the power is on(side switch) and to indicate when it is ok to ask for a new file.\n(note - \u00a0I added a feature which when one depresses the red switch when the green LED is blinking, all the wave files will be played) \u00a0\n7. Some other observations :\n- \u00a0basically the code waits for the red switch to be pressed.\u00a0\nit then generates a randow number beween 1 and 413 ( the number of wave files) . \u00a0It then reads thru the wave files and increments a counter until the random number is reached. \u00a0It then plays that file. \u00a0 This does mean the number of files is hard coded into the code. \u00a0Probably there is some way to have the code figure out how many files there are.\n- sometimes it fails to play a file I think because it also does not like stereo files .\n\u00a0\n8. the code:\n- copied from various sources and indicated so in the code. \u00a0Specifically,I started with code that is on the Adafruit site and modified as needed. \u00a0\n/*\nidea is to play a random wav file each time the button is press\n// v2 now trying to add button and other code\n// v2 works good\nv3 - add ability to play all the songs by holding the button down \u00a0 \u00a0during the blinking\n*/\u00a0\n#include \n#include \nSdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card\nFatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card\nFatReader root;\u00a0\u00a0 // This holds the information for the volumes root directory\nWaveHC wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // This is the only wave (audio) object, since we will only play one at a time\nuint8_t dirLevel; // indent level for file/dir names\u00a0\u00a0\u00a0 (for prettyprinting)\ndir_t dirBuf;\u00a0\u00a0\u00a0\u00a0 // buffer for directory reads\n#define DEBOUNCE 5\u00a0 // button debouncer\nconst int buttonPin = 8;\u00a0\u00a0\u00a0\u00a0 // the number of the pushbutton pin\nint buttonState = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // variable for reading the pushbutton status\n// for rsndom play\nlong randNumber;\nlong ct = 0;\n// needed for playing all\n\u00a0 int playAll = 0;\nint numPress\u00a0 = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // variable for reading the pushbutton status\nint xx = 0;\nlong firstTime = 1;\n// need to change this to equal numberr of wav files on sd card\nlong numWavs = 413;\n\u00a0 const int ledPin = 7;\u00a0\u00a0\u00a0\u00a0\u00a0 // the number of the LED pin\n// Variables will change:\n//\u00a0 int ledState = HIGH;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // ledState used to set the LED\n/*\n* Define macro to put error messages in flash memory\n*/\n#define error(msg) error_P(PSTR(msg))\n// Function definitions (we define them here, but the code is below)\nvoid play(FatReader &dir);\n// this handy function will return the number of bytes currently free in RAM, great for debugging!\u00a0\u00a0\nint freeRam(void)\n{\n\u00a0 extern int\u00a0 __bss_end;\n\u00a0 extern int\u00a0 *__brkval;\n\u00a0 int free_memory;\n\u00a0 if((int)__brkval == 0) {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)&__bss_end);\n\u00a0 }\n\u00a0 else {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)__brkval);\n\u00a0 }\n\u00a0 return free_memory;\n}\n//////////////////////////////////// SETUP\nvoid setup() {\n\u00a0 // Serial.begin(9600);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // set up Serial library at 9600 bps for debugging\n\u00a0 // if analog input pin 0 is unconnected, random analog\n\u00a0 // noise will cause the call to randomSeed() to generate\n\u00a0 // different seed numbers each time the sketch runs.\n\u00a0 // randomSeed() will then shuffle the random function.\n\u00a0 randomSeed(analogRead(3));\n// initialize the pushbutton pin as an input:\n\u00a0\u00a0 pinMode(buttonPin, INPUT);\u00a0\u00a0\u00a0\u00a0\n// set the digital pin as output:\n\u00a0\u00a0 pinMode(ledPin, OUTPUT);\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0 //\u00a0\u00a0\u00a0 digitalWrite(ledPin,HIGH);\n\u00a0\n\u00a0 putstring_nl(\"\\nWave test!\");\u00a0 // say we woke up!\n\u00a0\n\u00a0 putstring(\"Free RAM: \");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // This can help with debugging, running out of RAM is bad\n//\u00a0 Serial.println(FreeRam());\n\u00a0 if (!card.init()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //play with 8 MHz spi (default faster!)\u00a0\n\u00a0\u00a0\u00a0 error(\"Card init. failed!\");\u00a0 // Something went wrong, lets print out why\n\u00a0 }\n\u00a0\n\u00a0 // enable optimize read - some cards may timeout. Disable if you're having problems\n\u00a0 card.partialBlockRead(true);\n\u00a0\n\u00a0 // Now we will look for a FAT partition!\n\u00a0 uint8_t part;\n\u00a0 for (part = 0; part < 5; part++) {\u00a0\u00a0 // we have up to 5 slots to look in\n\u00a0\u00a0\u00a0 if (vol.init(card, part))\n\u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // we found one, lets bail\n\u00a0 }\n\u00a0 if (part == 5) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if we ended up not finding one\u00a0 :(\n\u00a0\u00a0\u00a0 error(\"No valid FAT partition!\");\u00a0 // Something went wrong, lets print out why\n\u00a0 }\n\u00a0\n\u00a0 // Lets tell the user about what we found\n\u00a0 putstring(\"Using partition \");\n//\u00a0\u00a0 Serial.print(part, DEC);\n\u00a0 putstring(\", type is FAT\");\n//\u00a0\u00a0 Serial.println(vol.fatType(), DEC);\u00a0\u00a0\u00a0\u00a0 // FAT16 or FAT32?\n\u00a0\n\u00a0 // Try to open the root directory\n\u00a0 if (!root.openRoot(vol)) {\n\u00a0\u00a0\u00a0 error(\"Can't open root dir!\");\u00a0\u00a0\u00a0\u00a0\u00a0 // Something went wrong,\n\u00a0 }\n\u00a0\n\u00a0 // Whew! We got past the tough parts.\n\u00a0 putstring_nl(\"Files found (* = fragmented):\");\n\u00a0 // Print out all of the files in all the directories.\n\u00a0 root.ls(LS_R | LS_FLAG_FRAGMENTED);\n\u00a0\n\u00a0\n//\u00a0\u00a0 digitalWrite(ledPin,HIGH);\n}\n//////////////////////////////////// LOOP\nvoid loop() {\n\u00a0 // short loop for 3 seconds tyhe first time only\n\u00a0 // if button pressed more than once, p[lay all waves\n// Serial.println( firstTime);\n//\u00a0 delay(1000);\n\u00a0\u00a0 if (firstTime == 1){\n\u00a0 do\n{\n\u00a0\u00a0 digitalWrite(ledPin,HIGH);\n\u00a0\u00a0 delay(250);\n\u00a0\u00a0\u00a0 digitalWrite(ledPin,LOW);\n\u00a0\u00a0\u00a0 delay(250);\n\u00a0\u00a0\u00a0\n\u00a0 numPress\u00a0 = digitalRead(buttonPin);\n\u00a0\u00a0 if (numPress == HIGH) {\n\u00a0\u00a0\u00a0\u00a0 playAll++;\n\u00a0 //\u00a0\u00a0 firstTime ++;\n\u00a0\u00a0 }\u00a0\u00a0\u00a0\u00a0\n\u00a0 xx++;\n// Serial.println( xx);\n} while (xx < 10);\nfirstTime ++;\n\u00a0\u00a0 }\n\u00a0\n\u00a0\u00a0 Serial.println( firstTime);\n\u00a0\u00a0 Serial.println( playAll);\n\u00a0\u00a0\u00a0 delay(1000);\n\u00a0\n\u00a0\n\u00a0 // read the state of the pushbutton value:\n\u00a0 buttonState = digitalRead(buttonPin);\n\u00a0\u00a0 digitalWrite(ledPin,HIGH);\n\u00a0 // check if the pushbutton is pressed.\n\u00a0 // if it is, the buttonState is HIGH:\n\u00a0 if (buttonState == HIGH) {\nct = 0;\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 // play a wav file\u00a0 ie continue with the code\u00a0\u00a0\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 digitalWrite(ledPin,LOW);\n\u00a0\n\u00a0 // print a random number from 1 to 60\n\u00a0 randNumber = random(1, numWavs);\n//\u00a0\u00a0 Serial.println(randNumber);\n\u00a0 delay(50);\n\u00a0\n\u00a0\n\u00a0 root.rewind();\n\u00a0 play(root);\n\u00a0 }\n\u00a0 else {\n\u00a0\u00a0\u00a0 // do nothing\n\u00a0\u00a0\u00a0\n\u00a0 }\n}\n/////////////////////////////////// HELPERS\n/*\n* print error message and halt\n*/\nvoid error_P(const char *str) {\n\u00a0 PgmPrint(\"Error: \");\n\u00a0 SerialPrint_P(str);\n\u00a0 sdErrorCheck();\n\u00a0 while(1);\n}\n/*\n* print error message and halt if SD I/O error, great for debugging!\n*/\nvoid sdErrorCheck(void) {\n\u00a0 if (!card.errorCode()) return;\n\u00a0 PgmPrint(\"\\r\\nSD I/O error: \");\n//\u00a0 Serial.print(card.errorCode(), HEX);\n\u00a0 PgmPrint(\", \");\n//\u00a0 Serial.println(card.errorData(), HEX);\n\u00a0 while(1);\n}\n/*\n* play recursively - possible stack overflow if subdirectories too nested\n*/\nvoid play(FatReader &dir) {\n\u00a0 FatReader file;\n\u00a0 while (dir.readDir(dirBuf) > 0) {\u00a0\u00a0\u00a0 // Read every file in the directory one at a time\n\u00a0\n\u00a0\u00a0\u00a0 // Skip it if not a subdirectory and not a .WAV file\n\u00a0\u00a0\u00a0 if (!DIR_IS_SUBDIR(dirBuf)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 && strncmp_P((char *)&dirBuf.name[8], PSTR(\"WAV\"), 3)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 continue;\n\u00a0\u00a0\u00a0 }\n\u00a0 //\u00a0 Serial.println();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // clear out a new line\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 for (uint8_t i = 0; i < dirLevel; i++) {\n\u00a0\u00a0\u00a0 //\u00a0\u00a0 Serial.write(' ');\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // this is for prettyprinting, put spaces in front\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 if (!file.open(vol, dirBuf)) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // open the file in the directory\n\u00a0\u00a0\u00a0\u00a0\u00a0 error(\"file.open failed\");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // something went wrong\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 if (file.isDir()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // check if we opened a new directory\n\u00a0\u00a0\u00a0\u00a0\u00a0 putstring(\"Subdir: \");\n\u00a0\u00a0\u00a0\u00a0\u00a0 printEntryName(dirBuf);\n//\u00a0\u00a0\u00a0\u00a0 Serial.println();\n\u00a0\u00a0\u00a0\u00a0\u00a0 dirLevel += 2;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // add more spaces\n\u00a0\u00a0\u00a0\u00a0\u00a0 // play files in subdirectory\n\u00a0\u00a0\u00a0\u00a0\u00a0 play(file);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // recursive!\n\u00a0\u00a0\u00a0\u00a0\u00a0 dirLevel -= 2;\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else {\n\u00a0\u00a0\u00a0\u00a0\u00a0 // Aha! we found a file that isnt a directory\n\u00a0\u00a0\u00a0\u00a0\u00a0 putstring(\"Playing \");\n\u00a0\u00a0\u00a0\u00a0\u00a0 printEntryName(dirBuf);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print it out\n\u00a0\u00a0\u00a0\u00a0\u00a0 if (!wave.create(file)) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Figure out, is it a WAV proper?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 putstring(\" Not a valid WAV\");\u00a0\u00a0\u00a0\u00a0 // ok skip it\n\u00a0\u00a0\u00a0\u00a0\u00a0 } else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println();\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Hooray it IS a WAV proper!\n\u00a0\u00a0 ct++;\n\u00a0 //\u00a0\u00a0 Serial.println(randNumber);\u00a0\u00a0\n\u00a0\u00a0 //\u00a0\u00a0 Serial.println(ct);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0 // here is where we play the file\n\u00a0\u00a0\u00a0\u00a0 // however only want the one wav file which is selected by random number\n\u00a0\u00a0\u00a0\u00a0 if(( randNumber == ct) || (playAll > 1)){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 wave.play();\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // make some noise!\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 uint8_t n = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 while (wave.isplaying) {// playing occurs in interrupts, so we print dots in realtime\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 putstring(\".\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (!(++n % 32))Serial.println();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delay(100);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(ledPin,HIGH);\n\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sdErrorCheck();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // everything OK?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if (wave.errors)Serial.println(wave.errors);\u00a0\u00a0\u00a0\u00a0 // wave decoding errors\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0 }\n}", "title": "Lunch Box That Plays Excerpts From \"The Simpsons\"", "url": "https://www.instructables.com/id/Lunch-box-that-plays-excerpts-from-The-Simpsons/", "section": "technology", "steps": [], "channel": "Arduino"}, {"category": "technology", "description": "INTRODUCTION Controlling the home appliance and electronic gadgets through an infrared remote control is now general. But the same controlling task can be done more easily. Primary motive of purposing the new system of hand gesture remote control is to remove the need to look in to the hand held remote and to search for a specific key for specific function mainly for older ones. This  project presents a novel system to control home appliance through hand gesture as a remote control device. The project will be referred to as flickremote in this report. It uses an ultrasonic rangefinder to determine the user's gesture and outputs an IR signal, Microcontroller Developer Board Arduino Uno.", "title": "FlickMote", "url": "https://www.instructables.com/id/FlickMote/", "section": "technology", "steps": [{"step": 1, "steps_text": "HARDWARE COMPONENT1. An Arduino UNO.   2. An HC-SR04 ultrasonic module        3. An Infra-red LED        4. An appropriate resistor for your Infra-red LED (220R)          5. An RGB LED          6. A breadboard and wires", "step_imgs": ["https://cdn.instructables.com/FEG/147K/IPTJIJ3N/FEG147KIPTJIJ3N.LARGE.jpg"], "step_title": "Step 1: HARDWARE REQUIRED"}, {"step": 2, "steps_text": "HOW IT WORKS :This Project uses an ultrasonic rangefinder to determine the user's gesture and outputs an IR signal to a TV on the command given..The distance or inches can be edited in the code which matches your convinience - High swipe (> 10in) = Channel Up - Low swipe = Channel Down - High hold (> 10in) = Volume Up - Low hold = Volume Down - Cover sensor (< 3in) = Turn On / Off", "step_imgs": [], "step_title": "Step 2: HOW IT WORKS"}, {"step": 3, "steps_text": "CONSTRUCTION :1. Connect the IR LED to pin 3 via an appropriate resistor, and then connect the cathode to GND. 2. Connect the ultrasonic sensor to 5v and GND where the pins specify. Connect the trigger pin to pin 8 and the echo pin to 7. You can configure these pins in the program 3. Connect the RGB LED to GND and pins 11 (red), 10 (green), 9 (blue). These pins are also configurable.", "step_imgs": [], "step_title": "Step 3: CONSTRUCTION"}, {"step": 4, "steps_text": "CONTROLS Power Swiping over the sensor within 3 inches will cause the LED to flash purple. This is the confirmation that a 'turn on / off' signal is ready to be sent. To prevent it accidentally turning the TV off I have made the sketch wait for a second swipe within 5 seconds of the first to confirm. At this point the signal is sent to the TV to turn on or off.          Channel Swiping within 10 inches of the sensor (but not within 3)  will cause the channel to change down. Swiping between 10 and 20 inches will cause the channel to change up.          Volume Holding your hand within 10 inches of the sensor (but not within 3)  will cause the volume to change down. Holding between 10 and 20 inches will cause the volume to change up. The volume will continue to change (up or down) until your hand is removed", "step_imgs": [], "step_title": "Step 4: CONTROLS"}, {"step": 5, "steps_text": "ADVANTAGES AND IMPROVEMENT :Will Remove the need to look in to the hand held remote and to search for a specific key for specific function A Solution to control the gadget (TV) for blinds and physically challenged persons The Project can be improved by adding more functionality to control all home appliance using same method", "step_imgs": [], "step_title": "Step 5: \u200bADVANTAGES AND IMPROVEMENT :"}, {"step": 6, "steps_text": "/* Swipe Remote Control This sketch uses an ultrasonic rangefinder to determine the user's gesture and outputs an IR signal to a sony TV based on the command given. - High swipe (> 10in) = Channel Up - Low swipe = Channel Down - High hold (> 10in) = Volume Up - Low hold = Volume Down - Cover sensor (< 3in) = Turn On / OffCreated by Vignesh JaishankarThis code uses the IRremote library (https://github.com/shirriff/Arduino-IRremote)*/ #include // Defines for control functions #define CONTROL_CH 1 // Channel change #define CONTROL_VOL 2 // Volume #define CONTROL_POW 3 // Power#define CONTROL_UP 1 #define CONTROL_DOWN -1#define DIST_MAX 20 // Maximum distance in inches, anything above is ignored. #define DIST_DOWN 10 // Threshold for up/down commands. If higher, command is \"up\". If lower, \"down\". #define DIST_POW 3 // Threshold for power command, lower than = power on/off// IR PIN const int irPin = 3; // this is defined in the library, this var is just a reminder. CHANGING THIS WILL NOT CHANGE PIN IN LIBRARY // 2 Pin Ping Sensor const int pingPin = 8; const int echoPin = 7; // Confirmation LED Pins const int led = 13; //internal LED for up/down debugging const int ledR = 11; const int ledG = 10; const int ledB = 9; // LED on timer unsigned long timer; // IR transmitter object IRsend irsend; // Power confirmation flag (needs two swipes to send signal) boolean powerConfirmed = false;void setup() {   // initialize serial communication and set pins   Serial.begin(9600);   pinMode(led, OUTPUT);   pinMode(ledR, OUTPUT);   pinMode(ledG, OUTPUT);   pinMode(ledB, OUTPUT);    pinMode(pingPin, OUTPUT);   pinMode(echoPin, INPUT);   timer = millis(); }void loop() {   //  Serial.println(millis());   long duration, inches;   int value;  // Check for a reading   duration = doPing();     // Timer to confirm actions (currently only power)   if (timer && timer < (millis() - 5000) && (millis() > 5000))   {     Serial.println(\"timer reset\");     timer = false;   }   digitalWrite(led, LOW);    setColor(0, 0, 0); // off    // convert the time into a distance    inches = microsecondsToInches(duration);  // If less than max inches away, act   if (inches < DIST_MAX)   {     // Debug output     Serial.print(inches);     Serial.println(\"in\");         // If very close, it is a \"power\" signal     if (inches < DIST_POW)     {       Serial.println(timer);       // on or off       if (timer)       {         doIR(CONTROL_POW, 0);         timer = false;         delay(2000); // don't want to be sending this more than once. 2 second delay       }       else       {         Serial.println(\"power flag set\");         timer = millis();         setColor(255,50,50);         delay(500);       }     }     else // is volume or channel     {       // Distance determines control direction       value = handleDist(inches);       // wait half a second       delay(300);       // check again, has hand disappeared?       if (microsecondsToInches(doPing()) > DIST_MAX)       {         doIR(CONTROL_CH, value); // swipe       }       else       {         // volume         int d = 500; // first delay is longer for single volume change         // repeat until hand is removed         while (inches < DIST_MAX)         {           value = handleDist(inches); // is up or down?           doIR(CONTROL_VOL, value); // fire off IR signal           delay(d); // wait           inches = microsecondsToInches(doPing()); // check for hand again           d = 100; // delays are shorter for quick multiple volume adjustment         }         delay(500); // this stops accidental channel change after volume adjustment       }     }   }   delay(50); // Short enough to detect all swipes. } /* * If distance is within threshold, mark as 'up' and turn on corresponding LED. */ int handleDist(int inches) {   if (inches > DIST_DOWN)   {     digitalWrite(led, HIGH);     return CONTROL_UP;   }   else   {     digitalWrite(led, LOW);     return CONTROL_DOWN;   } }/* * Fire off correct IR code */ void doIR(int control, int val) {   switch(control)   {   case CONTROL_POW:     // power     Serial.println(\"power on / off 0xa90\");     for (int i = 0; i < 3; i++)     {       setColor(255, 0, 0);       irsend.sendSony(0xa90, 12); // Sony TV power code       delay(40);     }     break;   case CONTROL_CH:     setColor(0, 255, 0);     // output 'channel up / down' depending on val     if (val == CONTROL_UP)     {       digitalWrite(led, HIGH);       for (int i = 0; i < 3; i++)       {         irsend.sendSony(0x90, 12);         delay(40);       }       Serial.println(\"channel up 0xD00A\");     }     else // down     {       for (int i = 0; i < 3; i++)       {         irsend.sendSony(0x890, 12);         delay(40);       }       Serial.println(\"channel down 0x3002\");     }     break;   case CONTROL_VOL:     setColor(0, 0, 255);     // output 'volume up / down' depending on val     if (val == CONTROL_UP)     {       digitalWrite(led, HIGH);       for (int i = 0; i < 3; i++)       {         irsend.sendSony(0x490, 12);         delay(40);       }       Serial.println(\"volume up 0x490\");     }     else //down     {       for (int i = 0; i < 3; i++)       {         irsend.sendSony(0xC90, 12);         delay(40);       }       Serial.println(\"volume down 0xC90\");     }     break;   } } void setColor(int red, int green, int blue) {   analogWrite(ledR, red);   analogWrite(ledG, green);   analogWrite(ledB, blue); }long doPing() {   digitalWrite(pingPin, LOW);   delayMicroseconds(2);   digitalWrite(pingPin, HIGH);   delayMicroseconds(5);   digitalWrite(pingPin, LOW);   return pulseIn(echoPin, HIGH); }long microsecondsToInches(long microseconds) {      return microseconds / 74 / 2; }long microsecondsToCentimeters(long microseconds) {      return microseconds / 29 / 2;", "step_imgs": [], "step_title": "Step 6: CODE"}], "channel": "Arduino"}, {"category": "technology", "description": "Disclaimer: No old rotary phones were hurt in this project!\u00a0\u00a0 I had bought a lot of rotary phones from an estate sale and included in this purchase was a box of broken phones and phone parts.\u00a0 It is from this box that I got my raw materials not from a working rotary phone.\u00a0 \nThis is not a full Instructable as I failed to take the proper pictures along the way but I hope to make another one of these(better I hope) and will document better at that time.\nI saw the following Instructable\u00a0 by guidomax: (thanks guidomax!!!) \u00a0 https://www.instructables.com/id/Interface-a-rotary-phone-dial-to-an-Arduino/ and having a collection of rotary phones/parts, I wanted to see what I could do with them.\n\u00a0I decide I would try to make the bat phone with the signal and present it as a gift to my daughter for the holidays.\nHere is a short video of it working .\u00a0 The music is much louder in person.\nmy steps:\n1. First I referred to the above Instructable to see if I could get the interface working and as suggested in the Instructable, it was pretty easy to do so.\n2. I took an old phone body and primed and spray painted red.\u00a0 I did the handset also and the cord.\n3. I wanted the Arduino code to play the theme from Batman and produce a bat signal when \"B\",\"A\",\"T\",\"M\",\"A\",\"N\" was dialed on the phone.\u00a0\nThe code was just taking the code from guidomax\u00a0 and modifing it so instead of a serial output to the computer, it just checked for the proper string of numbers being dialed.\u00a0 For exanple BATMAN is \"228626\" . When the Arduino saw this string, it started the song and turned on the bat signal.\nThe song:\u00a0 I had a Adafruit Wave Shield which I had never used and saw this as an opportunity to check it out. It took a good day for me to build it (it comes as a kit) and then there is a procedure that must be followed to get your wav file onto the shield.\u00a0 It is an easy procedure if you use iTunes.\u00a0 Just buy the song and convert it as required using the iTunes menus and drag to the shield. Without iTunes it is more involved but the Adafruit page walks you thru it.\nThe Bat Signal: Several other Instructables show how to make a signal and I took what I could from them but it was more or less trial and error before I came up with the end idea.\u00a0 I cut a water bottle about in half and put a small hole in the screw cap. I inserted a red LED into the small hole. I painted the bottle cap black.\u00a0 To get the image to show up pretty good, I needed to cut a small bat symbol and attach it in front of the bottle.\u00a0 That worked but I think there must be a neater way.\u00a0\u00a0 I hot glued the bottle to an opening I made in the back of the phone(Hot Glue is wonderful!!).\nThe code:\u00a0 My original idea was to have several super heros be in the code. ie if you dialed Batman, you got the theme music and the signal, if you dialed SUPERMAN, you got different music, etc.\u00a0 So you will see some code that is there for that purpose but I never got that far.\u00a0 It is just BATMAN.// Batmanv2\n// This an attempt to have multiple wav files and play the proper one\n// based on the sequence of numbers dialed on the phone\n// if 228626b then play the batman theme\n\u00a0#include <FatReader.h>\n#include <SdReader.h>\n#include <avr/pgmspace.h>\n#include \"WaveUtil.h\"\n#include \"WaveHC.h\"\nSdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card\nFatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card\nFatReader root;\u00a0\u00a0 // This holds the information for the filesystem on the card\nFatReader f;\u00a0\u00a0\u00a0\u00a0\u00a0 // This holds the information for the file we're play\nWaveHC wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // This is the only wave (audio) object, since we will only play one at a time\n#define DEBOUNCE 100\u00a0 // button debouncer\n// -- from V1 -----\n// -----------------\nint needToPrint = 0;\nint count;\n// mine\nint redLed = 8;\nint in_from_dial = 7;\nint lightOn = 6;\nint craddleUp = 9;\nint val = LOW;\u00a0\u00a0\u00a0\u00a0 // variable to store the read value\n//\nint lastState = LOW;\nint trueState = LOW;\nlong lastStateChangeTime = 0;\nint cleared = 0;\n// constants\nint dialHasFinishedRotatingAfterMs = 100;\nint debounceDelay = 10;\n// strings\nString newstring;\nchar Tester[ ] =\u00a0 \"123\" ;\nchar Batman[ ] =\u00a0 \"228626\" ;\nchar Spiderman[ ] =\u00a0 \"774337626\" ;\nchar Superman[ ] =\u00a0 \"78737626\" ;\nchar Batgirl[ ] =\u00a0 \"2284475\" ;\n\u00a0\n\u00a0// - end from V!----------\n\u00a0\nvoid setup() {\n\u00a0 // set up serial port\n\u00a0 Serial.begin(9600);\n\u00a0 putstring_nl(\"WaveHC with select songs\");\n\u00a0\n\u00a0\u00a0 putstring(\"Free RAM: \");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // This can help with debugging, running out of RAM is bad\n\u00a0 Serial.println(freeRam());\u00a0\u00a0\u00a0\u00a0\u00a0 // if this is under 150 bytes it may spell trouble!\n\u00a0\n\u00a0 // Set the output pins for the DAC control. This pins are defined in the library\n\u00a0 pinMode(2, OUTPUT);\n\u00a0 pinMode(3, OUTPUT);\n\u00a0 pinMode(4, OUTPUT);\n\u00a0 pinMode(5, OUTPUT);\n\u00a0\n// from V1\u00a0\u00a0\n\u00a0 pinMode(in_from_dial, INPUT);\u00a0 // 12\npinMode(lightOn, OUTPUT);\u00a0\u00a0\u00a0 // 11\npinMode(craddleUp,INPUT);\u00a0 // 9\npinMode(redLed,OUTPUT);\u00a0 // 9\n// end v1\n\u00a0\n\u00a0 // pin13 LED\n\u00a0 pinMode(13, OUTPUT);\n\u00a0\n\u00a0\n\u00a0\n\u00a0 //\u00a0 if (!card.init(true))\u00a0\u00a0 //play with 4 MHz spi if 8MHz isn't working for you\n\u00a0 if (!card.init()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //play with 8 MHz spi (default faster!)\u00a0\n\u00a0\u00a0\u00a0 putstring_nl(\"Card init. failed!\");\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 sdErrorCheck();\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // enable optimize read - some cards may timeout. Disable if you're having problems\n\u00a0 card.partialBlockRead(true);\n\u00a0\n// Now we will look for a FAT partition!\n\u00a0 uint8_t part;\n\u00a0 for (part = 0; part < 5; part++) {\u00a0\u00a0\u00a0\u00a0 // we have up to 5 slots to look in\n\u00a0\u00a0\u00a0 if (vol.init(card, part))\n\u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // we found one, lets bail\n\u00a0 }\n\u00a0 if (part == 5) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if we ended up not finding one\u00a0 :(\n\u00a0\u00a0\u00a0 putstring_nl(\"No valid FAT partition!\");\n\u00a0\u00a0\u00a0 sdErrorCheck();\u00a0\u00a0\u00a0\u00a0\u00a0 // Something went wrong, lets print out why\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Lets tell the user about what we found\n\u00a0 putstring(\"Using partition \");\n\u00a0 Serial.print(part, DEC);\n\u00a0 putstring(\", type is FAT\");\n\u00a0 Serial.println(vol.fatType(),DEC);\u00a0\u00a0\u00a0\u00a0 // FAT16 or FAT32?\n\u00a0\n\u00a0 // Try to open the root directory\n\u00a0 if (!root.openRoot(vol)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Can't open root dir!\"); // Something went wrong,\n\u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing!\n\u00a0 }\n\u00a0\n\u00a0 // Whew! We got past the tough parts.\n\u00a0 putstring_nl(\"Ready!\");\n}\n// idea here is\n// the looping will continue until the reciever is pickerd up\n// then the sequence of dialing is recorded and checked\n// if a hit is found, then turn on light (for Batman) and /or\n// play the song\nvoid loop() {\n\u00a0\n\u00a0\n\u00a0\u00a0 // wait for the reciever to be lifted\n\u00a0// once lifted, then the dialing can be checked\n\u00a0// turn on red led to show the phone is alive\n\u00a0val = digitalRead(craddleUp);\u00a0\u00a0 // read the input pin\n\u00a0\n\u00a0\u00a0\n\u00a0if (val == HIGH) {\n\u00a0\u00a0\n\u00a0digitalWrite(redLed, HIGH);\n\u00a0\n\u00a0\nint reading = digitalRead(in_from_dial);\nif ((millis() - lastStateChangeTime) > dialHasFinishedRotatingAfterMs) {\n// the dial isn't being dialed, or has just finished being dialed.\nif (needToPrint) {\n// if it's only just finished being dialed, we need to send the number down the serial\n// line and reset the count. We mod the count by 10 because '0' will send 10 pulses.\nSerial.println(count % 10, DEC);\n// now need to add the count to the test string and then test it against the\n// required string to get a hit\nnewstring.concat(count);\n// if string equals Batman, turn on light and start wav file\n//\u00a0 Serial.println(newstring);\n//\u00a0 delay(2000);\n\u00a0// --------------------\n\u00a0// -------------- Batman -----------------\nif ((newstring.equals(Batman)) || (newstring.equals(Tester))) {\n\u00a0 digitalWrite(lightOn, HIGH);\n\u00a0\u00a0\n\u00a0 playcomplete(\"BATMAN.WAV\");\n\u00a0\u00a0 digitalWrite(lightOn,LOW);\n\u00a0\u00a0\n}\n\u00a0// -------------- Spiderman----------------\nif (newstring.equals(Spiderman)) {\n\u00a0// bat_signal();\n\u00a0 playcomplete(\"1.WAV\");\n}\n\u00a0// --------------Superman -----------------\nif (newstring.equals(Superman)) {\n\u00a0// bat_signal();\n\u00a0 playcomplete(\"1.WAV\");\n}\n\u00a0// -------------- BatGirl -----------------\nif (newstring.equals(Batgirl)) {\n\u00a0// bat_signal();\n\u00a0 playcomplete(\"1.WAV\");\n}\nneedToPrint = 0;\ncount = 0;\ncleared = 0;\n}\n}\nif (reading != lastState) {\nlastStateChangeTime = millis();\n}\nif ((millis() - lastStateChangeTime) > debounceDelay) {\n// debounce - this happens once it's stablized\nif (reading != trueState) {\n// this means that the switch has either just gone from closed->open or vice versa.\ntrueState = reading;\nif (trueState == HIGH) {\n// increment the count of pulses if it's gone high.\ncount++;\nneedToPrint = 1; // we'll need to print this number (once the dial has finished rotating)\n}\n}\n}\nlastState = reading;\n}\nelse\n{\nnewstring\u00a0 = \"\";\ndigitalWrite(lightOn, LOW);\ndigitalWrite(redLed,LOW);\n}\n}\n\u00a0\n\u00a0\n// Plays a full file from beginning to end with no pause.\nvoid playcomplete(char *name) {\n\u00a0 // call our helper to find and play this name\n\u00a0 playfile(name);\n\u00a0 while (wave.isplaying) {\n\u00a0 // do nothing while its playing\n\u00a0 }\n\u00a0 // now its done playing\n}\nvoid playfile(char *name) {\n\u00a0 // see if the wave object is currently doing something\n\u00a0 if (wave.isplaying) {// already playing something, so stop it!\n\u00a0\u00a0\u00a0 wave.stop(); // stop it\n\u00a0 }\n\u00a0 // look in the root directory and open the file\n\u00a0 if (!f.open(root, name)) {\n\u00a0\u00a0\u00a0 putstring(\"Couldn't open file \"); Serial.print(name); return;\n\u00a0 }\n\u00a0 // OK read the file and turn it into a wave object\n\u00a0 if (!wave.create(f)) {\n\u00a0\u00a0\u00a0 putstring_nl(\"Not a valid WAV\"); return;\n\u00a0 }\n\u00a0\n\u00a0 // ok time to play! start playback\n\u00a0 wave.play();\n}\n// this handy function will return the number of bytes currently free in RAM, great for debugging!\u00a0\u00a0\nint freeRam(void)\n{\n\u00a0 extern int\u00a0 __bss_end;\n\u00a0 extern int\u00a0 *__brkval;\n\u00a0 int free_memory;\n\u00a0 if((int)__brkval == 0) {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)&__bss_end);\n\u00a0 }\n\u00a0 else {\n\u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)__brkval);\n\u00a0 }\n\u00a0 return free_memory;\n}\nvoid sdErrorCheck(void)\n{\n\u00a0 if (!card.errorCode()) return;\n\u00a0 putstring(\"\\n\\rSD I/O error: \");\n\u00a0 Serial.print(card.errorCode(), HEX);\n\u00a0 putstring(\", \");\n\u00a0 Serial.println(card.errorData(), HEX);\n\u00a0 while(1);\n}\nThe Arduino I used was an UNO\nAgain, I wish I had more pictures and better documentation. Next time.\nMy daughter thought is a neat gift and she seemed happy but that is what daughters do. :)", "title": "Bat Phone From Old Rotary Phone", "url": "https://www.instructables.com/id/Bat-Phone-from-old-rotary-phone/", "section": "technology", "steps": [], "channel": "Arduino"}, {"category": "technology", "description": "Infra Red remote control blaster using esp8266Transmits remote control codes received from Web supporting multiple output devices.Built in simple web page mainly for testing. Normal use is via POST messages which can come from web pages or from IFTTT / Alexa voice control.Supports an Amazon Echo/Dot activate detector to mute / quieten as soon as activate word is spoken.Commands are either single commands or sequences. Sequences can be stored as named macros which can then be used as commands or in other sequences.Recent history and list of macros may be obtained via the web interfaceSupports OTA uploading of new firmware and uses WifiManager library for initial wifi set up ", "title": "ESP-12 Infra Red Blaster", "url": "https://www.instructables.com/id/ESP-12-Infra-Red-Blaster/", "section": "technology", "steps": [{"step": 1, "steps_text": "Uses following componentsESP-12F module   3.3V regulator (MP2307 mini buck regulator)   MOSFET switches (AO3400)   Infra Red emitter (3mm)   Light Dependent Resistor GL2258 (Optional Alexa activity detector)   Resistors   Decoupling capacitor (20uF)   USB female socket (preferably solder friendly with sleeve   3 pin IC socket strip for Alexa detector   Mechanical parts (can be 3D printed)Can be assembled into ESP-12F  project boxAttach regulator to USB connector and insert into box   Make up IR driver onto small piece of vero board (3 wires, +5V, 0V gate input)   Connect IR driver to USB +5V, 0V   Insert 3 pin IC socket into project box if using Alexa detector. Connect to +3.3V, 0V and wire for input   Make up ESP-12F with 2.2K from GPIO15 to GND, EN to Vdd, 4K7 GPIO13 to Vdd, Alexa input to GPIO13, IR driver to GPIO14 , 0V and Vdd to 3.3V  Make up Alexa detector and support buffer if required.Note it can be easier to program ESP-12F first if you have some sort of serial programming facility or temporary breadboarding facility like  this to connect to the serial ports.Subsequent programming can be done using the built in OTA update.", "step_imgs": ["https://cdn.instructables.com/FM7/5QXS/J2KPAN79/FM75QXSJ2KPAN79.LARGE.jpg", "https://cdn.instructables.com/FR2/0N2K/J2KPAN7T/FR20N2KJ2KPAN7T.LARGE.jpg"], "step_title": "Step 1: Hardware"}, {"step": 2, "steps_text": "The ir Blaster uses an Arduino sketch available on githubThis needs to adjusted to suit local conditions and then compiled in a esp8266 Arduino environment.The following libraries needed, most are standard or can be added. The last two are included in the git.ESP8266WiFi   ESP8266WebServerFS.hDNSServerESP8266mDNSESP8266HTTPUpdateServerArduinoJsonBitTx (included in Git)BitMessages (included in Git)Items in the sketch to be changed  includeAuthorisation code for web access AP_AUTHID    Wfi manager password WM_PASSWORDfirmware OTA password update_password    New IR devices / button codes (see later)Once this is done then it should first be uploaded using conventional serial upload.As SPIFFS is used then the memory should be prepared by installing and using the arduino ESP8266 Sketch Data upload tool. This will upload the data folder as initial SPIFFS contentWhen the device can't connect to the local network (as will happen first time) then Wifi manager will create an access point (192.168.4.1). Connect to this network from a phone or tablet then browse to 192.168.4.1 You will get a web interface to connect to the local wifi. Subsequent accesses will use this. If local network changes then it will switch back to this config mode.Subsequent update may be done by compiling an export binary in Arduino environment and then accessing the OTA interface at ip/firmware.", "step_imgs": [], "step_title": "Step 2: Software"}, {"step": 3, "steps_text": "Note: This section has changed from previous method where configuration which was previously compiled into the code. It now uses files which are loaded from SPIFFs filing system. This makes it much easier to upload new definitions.The button definitions are included in the buttonnames.txt file. It is a global list of names across all remotes in use as many names tend to be common. As supplied this contains details for the remotes I use. New entries can be added. There is space for a total of 160 names but this can be increased by adjusting constants in bitMessages.h and recompiling. The names defined here are the names to be used when sending commands.Each remote device is defined in a file called dev_remotename. It consists of a config section at the top and then a mapping table from buttonnames to codes which are hex strings containing the bits to be sent. Only the buttonnames required need to be defined.The config section at the beginning of a device file contains parameters to be used when sending a code. The first entry is the devicename which is used when sending a command. Other parameters are described in the readme on the code site.Most remotes belong to one of 3 protocol categories (nec, rc5 and rc6). nec is probably the most common and has a simple header structure and bit timing. There is a slight variant of this which differs only in the header pulse timing. rc5 and rc6 are protocols defined by Philips but also used by some other manufacturers. They are a little more complicated and rc6 in particular has a special timing requirement for one of the bits.To capture the codes for a new remote I use a IR receiver (TSOP) commonly used with plug in remote receivers. This does the basic decoding and gives a logic level output. They normally come with a 3.5mm jack with +5V, GND, DATA connections. I sacrificed one, shortened the lead and put it through an inverting 3.3V buffer to feed a GPIO pin on a Raspberry Pi.I then use a python tool rxir.py (in git tools folder) to capture codes. To make it easier to  use to capture a large number of buttons then the tool uses a text definition file to define the buttons on the remote and is just the names of the buttons in a group on the remote. For example, one might have a new Sony remote and one sets up 3 text files called sonytv-cursor, sonytv-numbers, sonytv-playcontrols each with the relevant button names in. The tool will prompt for the device (sonytv), the section (cursor) and which protocol to use (nec, nec1, rc5, rc6). It will then prompt sequentially for each button press and write results to a sonytv-ircodes file. Sections can be repeated if required to check captures are good. Bits from the .ircodes file can be edited into the BitDevices tables. ", "step_imgs": [], "step_title": "Step 3: Add Device / Button Codes"}, {"step": 4, "steps_text": "The basic web control is either a single get or a json post which may contain a sequence.The get to /ir has 6 parametersauth - containing the authorisation code  device - the name of the remote device  parameter - the name of the button  bits - an optional bit count  repeat - an optional repeat count  wait - a delay in mseconds before the next command can be executed.The device can also be 'null' to get just a delay,  'macro' to use the macro referred to by the parameter, or 'detect' to use the Alexa detect feature (see later).The post to /irjson consists of a json structure like<p>{</p><p>   \"auth\":\"1234\",</p><p>   \"commands\": [</p><p>        { \"device\":\"yamahaAV\",\"parameter\":\"hdmi4\",\"wait\":\"5000\",\"bits\":\"0\",\"repeat\":\"1\"},</p><p>        { \"device\":\"yamahaAV\",\"parameter\":\"mute\", \"wait\":\"100\", \"bits\":\"0\",\"repeat\":\"1\"}</p><p>    ]</p><p>}</p>The sequence can be any length and devices may be macro references.The same structure may be used to define macros. Just include macro:\"macroname\", at the top level e.g. after auth. THe actual contents are stored in a file called macroname.txtMacros can be deleted by defining them with no \"commands\".Other web commands/recent (lists recent activity) /check (shows basic status)/    (loads a web form to send commands manually)/edit (loads a web form to view file list and delete/ upload files)/edit?file=filename (view contents of a specific file)/reload (reloads buttonnames and device files. Use after changing any of these)", "step_imgs": [], "step_title": "Step 4: Web Control and Macros"}, {"step": 5, "steps_text": "The simplest way to use the ir Blaster with Alexa is to use IFTTT as a gateway.First port forward the port used to your blaster in your router so it is accessible from the internet. It can be good to use a dns service like freedns to give your routers external ip a name and make it easier to handle if this ip changes.Set up an IFTTT account and enable the Maker Webhooks channel and the Alexa channel. You will need to logon to the Amazon site when you do this to enable the IFTT access.Create a IF trigger using the IFTTT Alexa channel, choose the action based on a phrase and enter the phrase you want (E.g. volume up).Create the action by choosing the Maker webhooks channel. Enter into the URL field something likehttp://myip:port/irjson?plain={\"auth\":\"1234\",\"comm...This action will be sent to the ir blaster where it will try to execute the macro volumeup. One can be specific device/buttons in here if wanted but I find it better to define and use macros because then the action sequence can be easily changed just by redefining the macro.A separate IFTTT applet is needed for each command.", "step_imgs": [], "step_title": "Step 5: Alexa Voice Control Using IFTTT"}, {"step": 6, "steps_text": "Instead of IFTTT one can build a custom skill inside Alexa development. This centralises all the processing in one place and means you don't have to create separate actions for each button.You need to get register as an Amazon Alexa developer and you need to register with the Amazon AWS console lambda service. You will also need to look at the tutorials to understand the process a bit.On the Alexa developer side you need to create a new custom skill, enter its trigger word and create a list of command words like volume up, guide, etc.Alexa then send the phrase to a program running on the lamda service which interprets the phrase and makes a URL call to the Ir blaster to action it.I have included the Alexa intent schema and the console lambda function I use in the git. The URL will need to be modified to reference the appropriate ip and have the right authorisation. To keep it simple the lambda functions calls a macro which has a space stripped lower case version of the phrase. It also tries to remove the trigger keyword which can sometimes be included.  E.g. blaster VOLUME up will call a macro called volumeup if the trigger word was blaster.", "step_imgs": [], "step_title": "Step 6: Native Alexa Voice Skill"}, {"step": 7, "steps_text": "Although the Echo / Dot voice recognition is good it can sometimes get confused if the sound is playing from say a TV unless you get close and speak loudly.To improve this I added an activate detector to my Dot. As soon as the keyword (Alexa is said) the ring of LEDs light up. The detector feeds this into the blaster where it will use the alexaon macro to mute the TV, similarly at the end of processing a command the lights go off and the alexaoff macro restores the sound.The 'detect' command can also be used to turn this on and off. So for example I use the initial turnon macro to enable the detection and the turnoff macro to disable it. This can also be used within the action macros to support a real mute and unmute coomand which would otherwise be problematic.The physical detector is an light dependent resistor which the circuit supports. I mount mine on the Dot with a 3D printed bracket", "step_imgs": [], "step_title": "Step 7: Alexa Activate Detector"}], "channel": "Remote Control"}, {"category": "technology", "description": "\n          Bring Touch Control to the Arduino. Use interesting touch sensors like Carrots or Beets to make a \"Beetbox\".\nIn this instructable you will learn:\n* How to use the Cap Sense library to make Arduino responsive to touch\n* How adding a Wave Shield (and some root vegetables), you can make a \"Beetbox\"", "title": "Just Veggin With an Arduino Beetbox", "url": "https://www.instructables.com/id/Just-Veggin-with-an-Arduino-Beetbox/", "section": "technology", "steps": [{"step": 1, "steps_text": "For the Touch Sensor part you will need:\n* Arduino UNO\n* A 4.7M Ohm resistor\u00a0 (or a value similar to that) (one for each sense channel)\n* Breadboard for wiring up e.g. (http://goo.gl/1E1iI)\n* Some Wires\nFor an initial experiment to show how touch sensing works:\n* An LED\n* a 560 Ohm resistor\nFor the \"Beetbox\" part:\n* Some Root Vegetables (such as a Beet)\n* An Adafruit Wave Shield as shown\u00a0 http://goo.gl/KUUZz\n* The WaveHC library for Arduino (http://www.ladyada.net/make/waveshield/download.html)", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: You Will Need"}, {"step": 2, "steps_text": "For the Beetbox we use three sense channels.\nTo start we'll implement one touch sense channel and activate an LED when Arduino senses touch.\nWire up the circuit as shown in the Fritzing diagrams and photo's.\nGet and Install the Capacitive Sense library for Arduino from here: http://goo.gl/EpSX0", "step_imgs": ["https://cdn.instructables.com/FBH/QG6F/HCJOGYJ6/FBHQG6FHCJOGYJ6.LARGE.jpg", "https://cdn.instructables.com/FE6/3AIN/HCRVRFU8/FE63AINHCRVRFU8.LARGE.jpg", "https://cdn.instructables.com/FQC/G6LW/HCJOSCRD/FQCG6LWHCJOSCRD.LARGE.jpg", "https://cdn.instructables.com/FKG/7GUO/HCJO5MSW/FKG7GUOHCJO5MSW.LARGE.jpg"], "step_title": "Step 2: The Principles of Capacitive Touch Sensing"}, {"step": 3, "steps_text": "The Cap Sense circuit is made by the resistor between Arduino pins 6 and 9, and also the capacitance to ground on the Touch Sensor. When the CapacitiveSensor arduino library is asked to read the sensor value, pulses are Output on Pin 9 and Input into pin 6. The library routine measures the delay between when the pulses are transmitted and when they are received.\nThe measured delay is proportional\u00a0 to the Resistor value R and the Capacitance C. i.e.\u00a0\u00a0 Delay = R*C\n(strictly speaking there's a scaling factor too depending on the voltage level you're measuring from, but that's just a detail for us).\nThe Capacitance on the sensor varies as you bring your finger close to the sensor and as you touch it. Touching the sensor gives you the largest capacitance and the longest delay. In order to make the delay large enough to be detected by Arduino you need a large resistor e.g. 4.7Meg Ohms.", "step_imgs": ["https://cdn.instructables.com/F32/PT43/HCJO5N25/F32PT43HCJO5N25.LARGE.jpg"], "step_title": "Step 3: Here's How the Capacitor Sense Works"}, {"step": 4, "steps_text": "There are a couple of Key Concepts in the Arduino code.\n1. Activate an LED when the sensor is touched.\nTo do that we need to measure the delay (total1) and compare it to a Threshold value e.g.\n=============void setup()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\n....some setup stuff....\n}\nvoid loop()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0 total1 =\u00a0 cs_9_6.capacitiveSensor(30);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Measure the Cap Sense Value from the Sensor\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 if (total1 > THRESHOLD) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, HIGH);\n\u00a0\u00a0\u00a0 }\u00a0\u00a0\n\u00a0\u00a0\u00a0 else {\n\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin,LOW);\n\u00a0\u00a0\u00a0 }\n}\n=======\nThat's pretty straightforward. But what should the THRESHOLD value be?\nThe total1 value of delay we read back varies from day to day because it's very sensitive to capacitance (which is the whole idea), but it means we can't just put in any fixed THRESHOLD value because it will be different under different conditions.\nTo make sure we have an appropriate THRESHOLD value, we need to measure the THRESHOLD value during a calibration sequence at the start of the code.\nWe do this as follows. We initialise i=0 during setup() and calibrate for the first 50 iterations of loop(). The LED flashes during calibration and we need to touch the sensor to determine the appropriate THRESHOLD value.\n=======void loop()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\u00a0\n\u00a0\u00a0\u00a0 total1 =\u00a0 cs_9_6.capacitiveSensor(30);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Measure the Cap Sense Value from the Sensor\n// Touch the Sensor while the LED is HIGH to Calibrate the TOUCH value\u00a0\u00a0\u00a0 if (i<50) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Calibrate Sensor baseline to Start\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, HIGH);\n\u00a0\u00a0\u00a0\u00a0\u00a0 calVal1= 0.1*float(total1) + 0.9*calVal1;\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(calVal1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print calibartion value during calibration cycle\u00a0\u00a0\u00a0\u00a0\u00a0 delay(50);\n\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, LOW);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(50);\n\u00a0\u00a0\u00a0\u00a0\u00a0 i++;\n\u00a0\u00a0\u00a0 }\n}\n=======\nThe code:calVal1= 0.1*float(total1) + 0.9*calVal1;\nimplements a digital filter. It works by weighting it's output 90% in favour of old outputs;\u00a0 new data only accounts for a 10% weighting . This gives us a reliable calibration value, calVal1 by filtering out any noise on the readings.\nIn the code we print the calVal1 to the Serial Monitor. Take a look at it to see how it increases smoothly towards the total1 value.\nThe Next Step shows the Full Arduino Code for this Experiment", "step_imgs": [], "step_title": "Step 4: Arduino Code: Key Concepts"}, {"step": 5, "steps_text": "#include <CapacitiveSensor.h>\n/*\n* Uses a high value resistor e.g. 10M between send pin and receive pin\n* Resistor effects sensitivity, experiment with values, 50K - 50M. Larger resistor values yield larger sensor values.\n* Receive pin is the sensor pin.\n*/#define error(msg) error_P(PSTR(msg))\nCapacitiveSensor\u00a0\u00a0 cs_9_6 = CapacitiveSensor(9,6);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 10M resistor between pins 9 & 6, pin 6 is sensor pin, add a wire and or foil if desired\nfloat calVal1 = 0.0;\nfloat total1 = 0.0;\nint i = 0;\nint LedPin = 2;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Pin the LED is connected tovoid setup()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0 Serial.begin(9600);\n\u00a0 cs_9_6.reset_CS_AutoCal();\u00a0 // autocalibrate channel 1\u00a0 cs_9_6.set_CS_AutocaL_Millis(0x00001000);\u00a0\u00a0\u00a0\u00a0 // autocalibrate interval on channel 1\u00a0 pinMode(LedPin, OUTPUT);\n\u00a0 i = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Initialise some values\u00a0 calVal1 = 0.0;\n}\nvoid loop()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\u00a0\n\u00a0\u00a0\u00a0 total1 =\u00a0 cs_9_6.capacitiveSensor(30);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Measure the Cap Sense Value from the Sensor\n// Touch the Sensor while the LED is HIGH to Calibrate the TOUCH value\u00a0\u00a0\u00a0 if (i<50) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Calibrate Sensor baseline to Start\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, HIGH);\n\u00a0\u00a0\u00a0\u00a0\u00a0 calVal1= 0.1*float(total1) + 0.9*calVal1;\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(calVal1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print calibration value during calibration cycle\u00a0\u00a0\u00a0\u00a0\u00a0 delay(50);\n\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, LOW);\n\u00a0\u00a0\u00a0\u00a0\u00a0 delay(50);\n\u00a0\u00a0\u00a0\u00a0\u00a0 i++;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Calibration is Over\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.print(calVal1);\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.print(\"\\t\");\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(total1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0 if (total1 > 0.8*calVal1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin, HIGH);\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0 else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(LedPin,LOW);\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 }\n}", "step_imgs": [], "step_title": "Step 5: Arduino Code (Experiment)"}, {"step": 6, "steps_text": "\n          If we want to go further and add sound, attach the Wave Shield to the Arduino.\nI've used three Cap Sense Channels on pins 6,7 and 8.\nPut some .wav files on the sound card. I used \"BUFF1.WAV\" etc.. as shown in the code.\nAdd some vegetables of choice and off you go.....\nFull Arduino Code in the Next Step.\nIt's very similar to the one channel example with some routines added for SD card file reading and playback.\nThe code uses the #define DEBUG construct to add in some Serial Monitor output for debug. Uncomment that line for debug.\nThe calibration cycle in this version is as follows:\n1. LED ON : Touch channel 1 sensor\n2. LED OFF : Touch Channel 2 sensor\n3. LED ON : Touch channel 3 sensor\n4. Enjoy playing your beetbox", "step_imgs": [], "step_title": "Step 6: Adding Sound With the Wave Shield"}, {"step": 7, "steps_text": "#include <CapacitiveSensor.h>\n#include <WaveHC.h>\n#include <WaveUtil.h>\n/*\n* Uses a high value resistor e.g. 10M between send pin and receive pin\n* Resistor effects sensitivity, experiment with values, 50K - 50M. Larger resistor values yield larger sensor values.\n* Receive pin is the sensor pin.\n*/SdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card\nFatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card\nFatReader root;\u00a0\u00a0 // This holds the information for the volumes root directory\nFatReader file;\u00a0\u00a0 // This object represent the WAV file for a pi digit or period\nWaveHC wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // This is the only wave (audio) object, since we will only play one at a time\nchar filename[13];\n// Uncomment next line to enable Debug Serial.print() statements\n//#define DEBUG\u00a0\u00a0\u00a0\u00a0\u00a0#define error(msg) error_P(PSTR(msg))\nCapacitiveSensor\u00a0\u00a0 cs_9_6 = CapacitiveSensor(9,6);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 10M resistor between pins 9 & 6, pin 6 is sensor pin, add a wire and or foil if desired\nCapacitiveSensor\u00a0\u00a0 cs_9_7 = CapacitiveSensor(9,7);\nCapacitiveSensor\u00a0\u00a0 cs_9_8 = CapacitiveSensor(9,8);\nfloat calVal1 = 0.0;\nfloat calVal2 = 0.0;\nfloat calVal3 = 0.0;\nfloat total1 = 0.0;\nfloat total2 = 0.0;\nfloat total3 = 0.0;\nint i = 0;\nvoid setup()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0 Serial.begin(9600);\n\u00a0\n\u00a0 if (!card.init()) {\n\u00a0\u00a0\u00a0 error(\"Card init. failed!\");\n\u00a0 }\n\u00a0 if (!vol.init(card)) {\n\u00a0\u00a0\u00a0 error(\"No partition!\");\n\u00a0 }\n\u00a0 if (!root.openRoot(vol)) {\n\u00a0\u00a0\u00a0 error(\"Couldn't open dir\");\n\u00a0 }\n\u00a0 PgmPrintln(\"Files found:\");\n\u00a0 root.ls();\n\u00a0\n\u00a0 cs_9_6.reset_CS_AutoCal();\u00a0 // autocalibrate channel 1\n\u00a0 cs_9_7.reset_CS_AutoCal();\u00a0 // autocalibrate channel 2\n\u00a0 cs_9_8.reset_CS_AutoCal();\u00a0 // autocalibrate channel 3\n\u00a0\n\u00a0 cs_9_6.set_CS_AutocaL_Millis(0x00001000);\u00a0\u00a0\u00a0\u00a0 // autocalibrate interval on channel 1\n\u00a0 cs_9_7.set_CS_AutocaL_Millis(0x00001000);\u00a0\u00a0\u00a0\u00a0 // autocalibrate interval on channel 2\n\u00a0 cs_9_8.set_CS_AutocaL_Millis(0x00001000);\u00a0\u00a0\u00a0\u00a0 // autocalibrate interval on channel 3\n\u00a0 pinMode(14, OUTPUT);\n}\nvoid loop()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n{\u00a0\n\u00a0\u00a0\u00a0 total1 =\u00a0 cs_9_6.capacitiveSensor(30);\n\u00a0\u00a0\u00a0 total2 =\u00a0 cs_9_7.capacitiveSensor(30);\n\u00a0\u00a0\u00a0 total3 =\u00a0 cs_9_8.capacitiveSensor(30);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 if (i<60) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0 // Calibrate Sensor baseline\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(14, HIGH);\n\u00a0\u00a0\u00a0\u00a0\u00a0 calVal1= 0.1*float(total1) + 0.9*calVal1;\n\u00a0\u00a0\u00a0\u00a0\u00a0 i++;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else if (i<120) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Calibrate Sensor baseline\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(14, LOW);\n\u00a0\u00a0\u00a0\u00a0\u00a0 calVal2= 0.1*float(total2) + 0.9*calVal2;\n\u00a0\u00a0\u00a0\u00a0\u00a0 i++;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else if (i<180) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Calibrate Sensor baseline\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(14, HIGH);\n\u00a0\u00a0\u00a0\u00a0\u00a0 calVal3= 0.1*float(total3) + 0.9*calVal3;\n\u00a0\u00a0\u00a0\u00a0\u00a0 i++;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else {\n\u00a0\u00a0\u00a0\u00a0\u00a0 digitalWrite(14,LOW);\n\u00a0\u00a0\u00a0 }\n#ifdef DEBUG\u00a0\n\u00a0\u00a0\u00a0 Serial.print(total1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 1\u00a0\u00a0\u00a0 Serial.print(\"\\t\");\n\u00a0\u00a0\u00a0 Serial.print(total2);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 2\u00a0\u00a0\u00a0 Serial.print(\"\\t\");\n\u00a0\u00a0\u00a0 Serial.println(total3);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 3\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 Serial.print(\"CAL: \\t\");\n\u00a0\u00a0\u00a0 Serial.print(calVal1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 1\u00a0\u00a0\u00a0 Serial.print(\"\\t\");\n\u00a0\u00a0\u00a0 Serial.print(calVal2);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 2\u00a0\u00a0\u00a0 Serial.print(\"\\t\");\n\u00a0\u00a0\u00a0 Serial.println(calVal3);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // print sensor output 3#endif\n\u00a0\u00a0\u00a0 if (total1 > 0.8*calVal1 && total2 > 0.8*calVal2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 strcpy_P(filename, PSTR(\"BUFF1.WAV\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(filename);\n\u00a0\u00a0\u00a0\u00a0\u00a0 playfile(filename);\n\u00a0\u00a0\u00a0 }\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 else if (total2 > 0.8*calVal2 && total3 > 0.8*calVal3) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 strcpy_P(filename, PSTR(\"HAT.WAV\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(filename);\n\u00a0\u00a0\u00a0\u00a0\u00a0 playfile(filename);\n\u00a0\u00a0\u00a0 }\u00a0\u00a0\n\u00a0\u00a0\u00a0 else if (total1 > 0.8*calVal1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 strcpy_P(filename, PSTR(\"CLICK1.WAV\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(filename);\n\u00a0\u00a0\u00a0\u00a0\u00a0 playfile(filename);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else if (total2 > 0.8*calVal2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 strcpy_P(filename, PSTR(\"BOOM1.WAV\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(filename);\n\u00a0\u00a0\u00a0\u00a0\u00a0 playfile(filename);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 else if (total3 > 0.8*calVal3) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 strcpy_P(filename, PSTR(\"BOOMHAA1.WAV\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(filename);\n\u00a0\u00a0\u00a0\u00a0\u00a0 playfile(filename);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\n//\u00a0\u00a0 delay(10);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // arbitrary delay to limit data to serial port}\n/////////////////////////////////// HELPERS\n/*\n* print error message and halt\n*/void error_P(const char *str) {\n\u00a0 PgmPrint(\"Error: \");\n\u00a0 SerialPrint_P(str);\n\u00a0 sdErrorCheck();\n\u00a0 while(1);\n}\n/*\n* print error message and halt if SD I/O error\n*/void sdErrorCheck(void) {\n\u00a0 if (!card.errorCode()) return;\n\u00a0 PgmPrint(\"\\r\\nSD I/O error: \");\n\u00a0 Serial.print(card.errorCode(), HEX);\n\u00a0 PgmPrint(\", \");\n\u00a0 Serial.println(card.errorData(), HEX);\n\u00a0 while(1);\n}\n/*\n* Play a file and wait for it to complete\n*/void playcomplete(char *name) {\n\u00a0 playfile(name);\n\u00a0 while (wave.isplaying);\n\u00a0\n\u00a0 // see if an error occurred while playing\u00a0 sdErrorCheck();\n}\n/*\n* Open and start playing a WAV file\n*/void playfile(char *name) {\n\u00a0 if (wave.isplaying) {// already playing something, so stop it!\u00a0\u00a0\u00a0 wave.stop(); // stop it\u00a0 }\n\u00a0 if (!file.open(root, name)) {\n\u00a0\u00a0\u00a0 PgmPrint(\"Couldn't open file \");\n\u00a0\u00a0\u00a0 Serial.print(name);\n\u00a0\u00a0\u00a0 return;\n\u00a0 }\n\u00a0 if (!wave.create(file)) {\n\u00a0\u00a0\u00a0 PgmPrintln(\"Not a valid WAV\");\n\u00a0\u00a0\u00a0 return;\n\u00a0 }\n\u00a0 // ok time to play!\u00a0 wave.play();}", "step_imgs": [], "step_title": "Step 7: Full Arduino Beetbox Code"}, {"step": 8, "steps_text": "Why not expand on capacitive touch sensing?\n* Use a higher resistor value to sense when you are close to the sensor, not just touching it.\n* Make a sound that varies in pitch as you got closer to the sensor.\n* Use a Matrix of sensors arranged to sense the postion of your finger on a surface (a smart phone touch screen works like this)", "step_imgs": [], "step_title": "Step 8: Next Steps"}], "channel": "Arduino"}, {"category": "play", "description": "http://youtu.be/16c64j-qkog This is a fun and relatively simple prank that is ideal to use in a busy restroom. It is fairly simple to create with minimal Arduino skills. I didn't include a step by step because of the simplicity and that every situation can require a different design. Most of my design consists of items I had on hand. \u00a0The restroom I installed this in is VERY BUSY, so speed and ease of setup was important to my design.", "title": "Arduino Fart-o-matic Toilet Humor Prank", "url": "https://www.instructables.com/id/Arduino-Fart-o-matic-toilet-humor-prank/", "section": "play", "steps": [{"step": 1, "steps_text": "\n          This list is the exact list of pieces that I used in my design but is easily alter-able for use in your own situation. Parts:   Arduino - this one is an Uno     Adafruit's Wave shield and SD card     Parallax PIR sensor     3 pin lead - \u00a0female to male     a power source (more on that later)     goose neck laptop light     a container (this is from a Johnson & Johnson brand mini first aid kit)     a strong magnet or other mounting device     a small speaker     a compartment to help amplify the speaker (I used a lid to a spray paint can)     cable mounts     a pin from a breakaway pin header     heat shrink tubing     various screws & nuts ", "step_imgs": ["https://cdn.instructables.com/F19/YXRK/HTIWJ8ZD/F19YXRKHTIWJ8ZD.LARGE.jpg"], "step_title": "Step 1: Parts"}, {"step": 2, "steps_text": "\u00a0Assemble the wave shield as directed in the manufacturers tutorial and run some of the sample sketches to confirm that everything is working properly, also test the PIR sensor using some of the example sketches available (there are many here on Instructables). Solder the wires for the speaker to the provided spots in the circuit board of the wave shield. \u00a0Once you've made sure all the pieces work find some audio files that are appropriate for your prank and convert them to the necessary format for the Wave shield (there are instructions on how to do this at the Adafruit website). \u00a0I originally chose to power my project with a 9 volt battery because of it's compactness but this isn't a very good option to power an Arduino, I found out that I'd get optimum battery life using 4 AA batteries instead. \u00a0I put all my parts into a Johnson & Johnson Brand mini first aid kit box and cut out the spots for the pins, speaker wires, and battery wires. I drilled a hole and mounted the magnet to the back. The stalls in the intended restroom are metal so a magnet is ideal, this might require a change in design to fit your situation (although, I don't recommend using suction cups since it's a restroom and people tend to lick suction cups, yuck!). \u00a0I used the goose neck laptop light just for the goose neck portion because I wanted something that would be quickly adjustable. I mounted the PIR sensor to the \"light\" end of this and mounted the other end to my box using cable mounts. \u00a0The 3 pin female to male lead is plugged into the sensor and on the male end of the lead I left the pins for ground and power intact and clipped the wire for the signal pin from the plug. I soldered a breakaway pin to the end of the signal wire and covered the connection with heat shrink. It would be a good idea to leave two or more pins attached so that it would make a more stable \"plug\" when attached to the wave shield but I only did one pin. The speaker is hot glued to the spray paint cap and the cap is then hot glued to the box. \u00a0When connecting you sensor to the wave shield you can use any pin you want provided it isn't one of the pins needed for the wave shield, pins 2 3 4 and 5 and 10 11 12 13 are all needed for either the wave shield or the SD card, leaving pins 6 through 9 and all the analog pins available. I chose pin seven, but you can use any of the available ones just remember to alter the sketch to that pin.", "step_imgs": ["https://cdn.instructables.com/F0D/701Z/HTIWJ8ZN/F0D701ZHTIWJ8ZN.LARGE.jpg", "https://cdn.instructables.com/FVU/MKMT/HTIWJ90H/FVUMKMTHTIWJ90H.LARGE.jpg", "https://cdn.instructables.com/F5Y/HQ8G/HTIWJ8YC/F5YHQ8GHTIWJ8YC.LARGE.jpg", "https://cdn.instructables.com/FKT/KD10/HTIWJ8ZU/FKTKD10HTIWJ8ZU.LARGE.jpg", "https://cdn.instructables.com/FN9/BO7E/HTIWJ91K/FN9BO7EHTIWJ91K.LARGE.jpg", "https://cdn.instructables.com/FS1/RSKT/HTIWJ937/FS1RSKTHTIWJ937.LARGE.jpg"], "step_title": "Step 2: Preparing the Arduino and Wave Shield and Putting Things Together"}, {"step": 3, "steps_text": "I'd love to claim to have written the sketch from scratch but I found one already written that I could alter to serve my purposes. I've included the altered sketch but the original sketch is from the Instructable \"How to have a talking dog\"\u00a0by Schmidtn, and is worth checking out in it's unaltered form, and anyway, who doesn't want a talking dog? The sketch can be changed so that more audio clips can be added, just continue with the same pattern -case: 35 playcomplete (filename) break. You will also need to change the number of files listed in the randNum line, here it says random(1, 22); , so for example if you had 35 files it should say random(1,35);. The audio files on the SD card can be named anything you want, I just numbered them, just be sure to replace the numbered file names with your own file names, an example of this is in this sketch it says - playcomplete (\"49.WAV\") and say your file is named \"bob\", \u00a0you'd need to change the 49.WAV in the sketch to say \u00a0(\"bob.WAV\"). \u00a0The finished prank is programmed so that any time there is motion sensed, it plays a random audio file (mine were all gross sounds, it is a restroom after all). As you can see in the photo the device is positioned so that it can't be seen but the motion detector can sense motion anytime someone approaches the urinal. I placed some boots with a pair of pants over them to make the stall look occupied. The restroom I used it in has a pretty steady flow of people, using the magnet mount and goose neck it was possible to put this in place in a matter of seconds. It wasn't until mid-afternoon that my co-workers finally got suspicious and investigated, they loved it so much that they didn't reveal the prank and enjoyed their newly found secret for the rest of the day. #include <FatReader.h> #include <SdReader.h> #include <avr/pgmspace.h> #include \"WaveUtil.h\" #include \"WaveHC.h\" SdReader card;\u00a0\u00a0\u00a0 // This object holds the information for the card FatVolume vol;\u00a0\u00a0\u00a0 // This holds the information for the partition on the card FatReader root;\u00a0\u00a0 // This holds the information for the filesystem on the card FatReader f;\u00a0\u00a0\u00a0\u00a0\u00a0 // This holds the information for the file we're play WaveHC wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // This is the only wave (audio) object, since we will only play one at a time #define TRIGGER 7 #define LED 13 int val = 0; int potvalue = 0; long randNum; // this handy function will return the number of bytes currently free in RAM, great for debugging!\u00a0\u00a0 int freeRam(void) { \u00a0 extern int\u00a0 __bss_end; \u00a0 extern int\u00a0 *__brkval; \u00a0 int free_memory; \u00a0 if((int)__brkval == 0) { \u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)&__bss_end); \u00a0 } \u00a0 else { \u00a0\u00a0\u00a0 free_memory = ((int)&free_memory) - ((int)__brkval); \u00a0 } \u00a0 return free_memory; } void sdErrorCheck(void) { \u00a0 if (!card.errorCode()) return; \u00a0 putstring(\"\\n\\rSD I/O error: \"); \u00a0 Serial.print(card.errorCode(), HEX); \u00a0 putstring(\", \"); \u00a0 Serial.println(card.errorData(), HEX); \u00a0 while(1); } void setup() { \u00a0 \u00a0 // set up serial port \u00a0 Serial.begin(9600); \u00a0 pinMode(TRIGGER, INPUT); \u00a0 pinMode(LED, OUTPUT); \u00a0 randomSeed(analogRead(0)); \u00a0 \u00a0 putstring(\"Free RAM: \");\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // This can help with debugging, running out of RAM is bad \u00a0 Serial.println(freeRam());\u00a0\u00a0\u00a0\u00a0\u00a0 // if this is under 150 bytes it may spell trouble! \u00a0 \u00a0 // Set the output pins for the DAC control. This pins are defined in the library \u00a0 pinMode(2, OUTPUT); \u00a0 pinMode(3, OUTPUT); \u00a0 pinMode(4, OUTPUT); \u00a0 pinMode(5, OUTPUT); \u00a0 \u00a0 //\u00a0 if (!card.init(true)) { //play with 4 MHz spi if 8MHz isn't working for you \u00a0 if (!card.init()) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //play with 8 MHz spi (default faster!)\u00a0 \u00a0\u00a0\u00a0 putstring_nl(\"Card init. failed!\");\u00a0 // Something went wrong, lets print out why \u00a0\u00a0\u00a0 sdErrorCheck(); \u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing! \u00a0 } \u00a0 \u00a0 // enable optimize read - some cards may timeout. Disable if you're having problems \u00a0 card.partialBlockRead(true); // Now we will look for a FAT partition! \u00a0 uint8_t part; \u00a0 for (part = 0; part < 5; part++) {\u00a0\u00a0\u00a0\u00a0 // we have up to 5 slots to look in \u00a0\u00a0\u00a0 if (vol.init(card, part)) \u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // we found one, lets bail \u00a0 } \u00a0 if (part == 5) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // if we ended up not finding one\u00a0 :( \u00a0\u00a0\u00a0 putstring_nl(\"No valid FAT partition!\"); \u00a0\u00a0\u00a0 sdErrorCheck();\u00a0\u00a0\u00a0\u00a0\u00a0 // Something went wrong, lets print out why \u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing! \u00a0 } \u00a0 \u00a0 // Lets tell the user about what we found \u00a0 putstring(\"Using partition \"); \u00a0 Serial.print(part, DEC); \u00a0 putstring(\", type is FAT\"); \u00a0 Serial.println(vol.fatType(),DEC);\u00a0\u00a0\u00a0\u00a0 // FAT16 or FAT32? \u00a0 \u00a0 // Try to open the root directory \u00a0 if (!root.openRoot(vol)) { \u00a0\u00a0\u00a0 putstring_nl(\"Can't open root dir!\"); // Something went wrong, \u00a0\u00a0\u00a0 while(1);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // then 'halt' - do nothing! \u00a0 } \u00a0 \u00a0 // Whew! We got past the tough parts. \u00a0 putstring_nl(\"Ready!\"); \u00a0 /*\u00a0 TCCR2A = 0; \u00a0 TCCR2B = 1<<CS22 | 1<<CS21 | 1<<CS20; \u00a0 //Timer2 Overflow Interrupt Enable \u00a0 TIMSK2 |= 1<<TOIE2; */ } void loop() { \u00a0 val = digitalRead(TRIGGER); \u00a0 potvalue = analogRead(1); \u00a0 Serial.println(potvalue, DEC); \u00a0 \u00a0 if (val == HIGH && potvalue >= 0 && potvalue <= 1023) \u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0 randNum = random(1, 22); \u00a0\u00a0\u00a0\u00a0\u00a0 delay(1000); switch (randNum) { \u00a0\u00a0 case 1: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(1); \u00a0 playcomplete(\"49.WAV\"); \u00a0 break; \u00a0\u00a0 case 2: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(2); \u00a0 playcomplete(\"50.WAV\"); \u00a0 break; \u00a0\u00a0 case 3: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(3); \u00a0 playcomplete(\"51.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 4: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(4); \u00a0 playcomplete(\"52.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 5: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(5); \u00a0 playcomplete(\"53.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 6: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(6); \u00a0 playcomplete(\"54.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 7: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(7); \u00a0 playcomplete(\"55.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 8: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(8); \u00a0 playcomplete(\"56.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 9: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(9); \u00a0 playcomplete(\"57.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 10: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(10); \u00a0 playcomplete(\"58.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 11: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(11); \u00a0 playcomplete(\"59.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 12: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(12); \u00a0 playcomplete(\"60.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 13: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(13); \u00a0 playcomplete(\"61.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 14: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(14); \u00a0 playcomplete(\"62.WAV\"); \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 15: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(15); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"63.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 16: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(16); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"64.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 17: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(17); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"65.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 18: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(18); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"66.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 19: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(19); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"67.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 20: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(20); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"68.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 21:\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(21);\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"69.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case 22: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Serial.println(22); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 playcomplete(\"70.WAV\"); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 break;\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 default: \u00a0 break; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0 \u00a0 } // Plays a full file from beginning to end with no pause. void playcomplete(char *name) { \u00a0 // call our helper to find and play this name \u00a0 playfile(name); \u00a0 while (wave.isplaying) { \u00a0 // do nothing while its playing \u00a0 } \u00a0 // now its done playing } void playfile(char *name) { \u00a0 // see if the wave object is currently doing something \u00a0 if (wave.isplaying) {// already playing something, so stop it! \u00a0\u00a0\u00a0 wave.stop(); // stop it \u00a0 } \u00a0 // look in the root directory and open the file \u00a0 if (!f.open(root, name)) { \u00a0\u00a0\u00a0 putstring(\"Couldn't open file \"); Serial.print(name); return; \u00a0 } \u00a0 // OK read the file and turn it into a wave object \u00a0 if (!wave.create(f)) { \u00a0\u00a0\u00a0 putstring_nl(\"Not a valid WAV\"); return; \u00a0 } \u00a0 \u00a0 // ok time to play! start playback \u00a0 wave.play(); }", "step_imgs": ["https://cdn.instructables.com/FOH/2IF9/HTIWJ96F/FOH2IF9HTIWJ96F.LARGE.jpg", "https://cdn.instructables.com/FDN/W2DE/HTIWJ969/FDNW2DEHTIWJ969.LARGE.jpg", "https://cdn.instructables.com/FWN/6NBM/HTIWJ94W/FWN6NBMHTIWJ94W.LARGE.jpg"], "step_title": "Step 3: The Sketch"}], "channel": "Pranks and Humor"}, {"category": "play", "description": "Hello there! Today I'll be explaining how I made a Arduino lasertag gun for a project at the HKU School of Arts at Utrecht, The Netherlands. ", "title": "Arduino Lasertag Project", "url": "https://www.instructables.com/id/Arduino-Lasertag-Project/", "section": "play", "steps": [{"step": 1, "steps_text": "Step 1.I started this project by buying some Infrared LED's and and Infrared Sensor that function at 33khz (you can use 38khz aswell). Most lasertag guns use infrared to send data, as it is much more reliable to send data with. With infrared you won't have any interference from other lightsources such as the sun. For this project I used:a Piezo buzzer.  a simple button component..  a 128x64 adafruit lcd screen.  a red led light for visual feedback.  a laser diode module (laserpointer).  a infrared led (33khz).  a infrared receiver (33khz).  some transistors and gauge wires.  a soldering iron and some lead.  sticky tape.  a glue gun.a Arduino Uno and a Usb B cable.The first thing I did was to make a basic setup for my lightgun (see pictures).", "step_imgs": ["https://cdn.instructables.com/FON/860H/JR0YJFPK/FON860HJR0YJFPK.LARGE.jpg", "https://cdn.instructables.com/FPI/F3YT/JQWT2HL2/FPIF3YTJQWT2HL2.LARGE.jpg", "https://cdn.instructables.com/F86/R1KU/JR0YJEFG/F86R1KUJR0YJEFG.LARGE.jpg"], "step_title": "Step 1: Get Yourself an Arduino and Some Infrared Leds and Sensors (plus Some More Stuff)."}, {"step": 2, "steps_text": "After I setup my electronics on a breadboard I used this code to get it to work (make sure you have 2 arduino's to test the device).The code:<p>/* IR Lightgun Arduino code by Tim Peeters 2018-19<br> *  \n * Made with the 'Building an Arduino-based laser game tutorial'\n * by Duane O'Brien at https://www.ibm.com/developerworks/opensource/tutorials/os-arduino1/\n * \n * V3.0 \n */\n \n#include <Wire.h>\n#include <Adafruit_SSD1306.h>\n#include <Adafruit_GFX.h></p><p>// OLED display TWI address\n#define OLED_ADDR   0x3C</p><p>// reset pin not used on 4-pin OLED module\nAdafruit_SSD1306 display(-1);  // -1 = no reset pin</p><p>//Game Setup variables.\nint maxPlayers = 10; //max players in game.\nconst int playerID = 1; //player number of this instance. (MUST BE BETWEEN 1 and 10!)\nbool useSound = true;</p><p>int maxLives = 3;\nint currentLives;</p><p>//Gun variables-------------|\nbool isShooting = false;\nint shotDelayTime = 100;</p><p>//Bullet Count\nint currentBullets = 0;\nint maxBullets = 100;</p><p>//Hardware variables\nconst int buttonPin = 6;\nconst int ledPin = 9;</p><p>const int speakerPin = 8;\nconst int laserPin = 2;\nconst int lcdClockPin = A5;\nconst int lcdSerialPin = A4;</p><p>const int sendPin = 3;\nconst int receiverPin = 5;</p><p>//The following variables declare the pulse lengths of the IR Code being send.\nconst int startBit   = 2000;   // This pulse sets the threshold for a transmission start bit\nconst int endBit     = 3000;   // This pulse sets the threshold for an end bit\nconst int one        = 1000;   // This pulse sets the threshold for a transmission that \n                               // represents a 1\nconst int zero       = 400;    // This pulse sets the threshold for a transmission that \n                               // represents a 0\n                               \nconst int waitTime = 300;      // The amount of time to wait between pulses</p><p>//The following array holds the decoded IR data.\nint ret[2];</p><p>bool hasDied = false;</p><p>void setup() {\n  \n  //Input Sensors\n  pinMode(buttonPin, INPUT);</p><p>  //Output Sensors\n  pinMode(ledPin, OUTPUT);\n  pinMode(speakerPin, OUTPUT);\n  pinMode(laserPin, OUTPUT);</p><p>  pinMode(lcdClockPin, OUTPUT);\n  pinMode(lcdSerialPin, OUTPUT);\n  \n  //IR Sensors\n  pinMode(sendPin, OUTPUT);\n  pinMode(receiverPin, INPUT);\n  \n  //Serial Debug (for feedback)\n  Serial.begin(9600);</p><p>  \n  //Startup Sound\n  for (int i = 1;i < 4;i++) {\n    digitalWrite(ledPin, HIGH);\n    playTone(1000/i, 100);\n    digitalWrite(ledPin, LOW);\n  }\n  \n  Serial.println(\"Gun Setup\");\n  \n  //Game Setup\n  currentLives = maxLives;\n  currentBullets = maxBullets;\n  Serial.println(currentBullets);</p><p>  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);\n  display.clearDisplay();\n  display.display();</p><p>  display.setTextSize(1);\n  display.setTextColor(WHITE);  \n  display.setCursor(10,10);\n  display.print(\"Player: \" + String(playerID));\n  display.setCursor(10,40);\n  display.print(\"Lives: \" + String(currentLives) + \" / \" + String(maxLives));\n  display.setCursor(10,55);\n  display.print(\"Bullets: \" + String(currentBullets) + \" / \" + String(maxBullets));\n  display.display();</p><p>  digitalWrite(laserPin, HIGH);\n}</p><p>void loop() {</p><p>  if(hasDied == false){\n    SenseIR();\n    Trigger();\n  }</p><p>  if(ret[0] != -1 && ret[0] != 0){\n    playTone(1000, 50);\n    Serial.print(\"Player: \");\n    Serial.print(ret[0]);\n    Serial.print(\" Message: \");\n    Serial.println(ret[1]);</p><p>    DoDamage();\n  }</p><p>  \n  if(ret[0] == -1){\n    //Serial.println(\"ERROR: Unknown Signal\");\n    //playTone(3000, 300);\n  }\n}</p><p>void DoDamage(){\n  if(ret[0] != playerID|| ret[0] != -1){\n    if(currentLives > 1){\n      currentLives--;</p><p>      digitalWrite(ledPin, HIGH);\n      delay(100);\n      digitalWrite(ledPin, LOW);\n      \n      for(int i = 0; i < 4; i++){\n        playTone(10000 - i*100, 100/i);\n      }  </p><p>      display.clearDisplay();\n    \n      display.setTextSize(1);\n      display.setTextColor(WHITE);  \n      display.setCursor(10,10);\n      display.print(\"Player: \" + String(playerID));\n      display.setCursor(10,40);\n      display.print(\"Lives: \" + String(currentLives) + \" / \" + String(maxLives));\n      display.setCursor(10,55);\n      display.print(\"Bullets: \" + String(currentBullets) + \" / \" + String(maxBullets));\n      display.display();\n    }\n    else{\n      GameOver();\n      hasDied = true;\n    }\n  }\n}</p><p>void GameOver(){\n  if(hasDied == false){\n      display.clearDisplay();\n    \n      display.setTextSize(2);\n      display.setTextColor(WHITE);  \n      display.setCursor(10,20);\n      display.print(\"GAME OVER\");\n      display.display();</p><p>      digitalWrite(ledPin, HIGH);\n      digitalWrite(laserPin, LOW);\n      playTone(10000, 2500);\n  }\n}</p><p>void Trigger(){\n  int buttonState = digitalRead(buttonPin);\n  \n  if(buttonState == 1 && isShooting == false){\n    isShooting = true;\n    \n    if(currentBullets > 0){\n      fireShot();\n      Serial.println(currentBullets);\n      \n    }\n    else{\n      Serial.println(\"Out of bullets.\");\n    }\n  }\n  if(buttonState == LOW){\n    isShooting = false;\n  }\n}</p><p>void fireShot(){\n    currentBullets--;\n    \n    \n    \n    //Send IR data\n    encodeIRpulse(playerID, 1);</p><p>    \n    //enable the laser and led.\n    digitalWrite(ledPin, HIGH);\n    digitalWrite(laserPin, LOW);\n    delay(200);\n    digitalWrite(ledPin, LOW);\n    digitalWrite(laserPin, HIGH);</p><p>    //Shooting sound\n    playTone(4500, 300);\n    playTone(4000, 200);\n    \n    //Update LCD Display\n    display.clearDisplay();\n    \n    display.setTextSize(1);\n    display.setTextColor(WHITE);  \n    display.setCursor(10,10);\n    display.print(\"Player: \" + String(playerID));\n    display.setCursor(10,40);\n    display.print(\"Lives: \" + String(currentLives) + \" / \" + String(maxLives));\n    display.setCursor(10,55);\n    display.print(\"Bullets: \" + String(currentBullets) + \" / \" + String(maxBullets));\n    display.display();</p><p>    \n}</p><p>//The function for playing a single tone with a certain duration.\nvoid playTone(int tone, int duration) {\n  if(useSound == true){\n  for (long i = 0; i < duration * 1000L; i += tone * 2) {\n    digitalWrite(speakerPin, HIGH);\n    delayMicroseconds(tone);\n    digitalWrite(speakerPin, LOW);\n    delayMicroseconds(tone);\n  }\n }\n}</p><p>//IR Led receiver function.\nvoid SenseIR(){\n  \n  //We will be sending a 8bit signal with IR, the first 4 bits define the sender of the signal. \n  //The other 4 bits define the message of the signal.\n  int sender[4];\n  //int message[4];\n  int endPulse;</p><p>  \n  if (pulseIn(receiverPin, LOW, 10000) < startBit) {\n    ret[0] = -1;\n    return;\n  }</p><p>  //Assignment of pulses to bit array------||\n  \n  //sender bits\n  sender[0]   = pulseIn(receiverPin, LOW);\n  sender[1]   = pulseIn(receiverPin, LOW);\n  sender[2]   = pulseIn(receiverPin, LOW);\n  sender[3]   = pulseIn(receiverPin, LOW);</p><p>  //message bits\n  //message[0]  = pulseIn(receiverPin, LOW);\n  //message[1]  = pulseIn(receiverPin, LOW);\n  //message[2]  = pulseIn(receiverPin, LOW);\n  //message[3]  = pulseIn(receiverPin, LOW);</p><p>  endPulse = pulseIn(receiverPin, LOW);\n  //---------------------------------------||</p><p>  \n  for(int i = 0; i <= 3; i++){\n    Serial.println(sender[i]);\n    //Serial.println(message[i]);\n  }\n  </p><p>  //sender bit (player ID) decoding\n  for(int i = 0; i <= 3; i++){\n    //Serial.println(sender[i]);\n    if(sender[i] > one && sender[i] < startBit) {\n      sender[i] = 1;\n    } \n    else if (sender[i] > zero && sender[i]) {\n      sender[i] = 0;\n    } \n    else \n    {\n      //When the data is not a one or a zero, it is an unknown signal.\n      ret[0] = -1;\n      return;\n    }\n  }</p><p>  ret[0]=convert(sender);\n  //Serial.println(ret[0]);</p><p>  /*\n  //message bit decoding\n  for(int i=0;i<=3;i++) {\n    //Serial.println(message[i]);\n    if(message[i] > one) {\n      message[i] = 1;\n    } else if (message[i] > zero) {\n      message[i] = 0;\n    } else {\n      // Since the data is neither zero or one, we have an error\n      Serial.println(\"unknown action\");\n      ret[0] = -1;\n      return;\n    }\n  }\n  ret[1]=convert(message);\n  //Serial.println(ret[1]);\n  */\n  \n  return;\n  </p><p>}</p><p>void encodeIRpulse(int player, int message){\n  int encoded[4];</p><p>  for (int i=0; i<4; i++) {\n    encoded[i] = player>>i & B1;   //encode data as '1' or '0'\n    \n  }</p><p>  /*\n  for (int i=4; i<8; i++) {\n    encoded[i] = player>>i & B1;\n  }\n  */\n  \n  //Start of data stream.\n  dataPulse(sendPin, startBit);\n  digitalWrite(sendPin, HIGH);\n  delayMicroseconds(waitTime);\n   \n  //Sending of data.\n  for (int i=3; i>=0; i--) {\n    if (encoded[i] == 0) {\n     dataPulse(sendPin, zero);\n    } else {\n     dataPulse(sendPin, one);\n    }\n    \n    digitalWrite(sendPin, HIGH);\n    delayMicroseconds(waitTime);\n  } </p><p>  //End of data stream.\n  dataPulse(sendPin, endBit);\n}</p><p>void dataPulse(int pin, int pulseTime){\n  for(int i = 0; i <= pulseTime/26; i++) {\n    digitalWrite(pin, HIGH);\n    delayMicroseconds(13);\n    digitalWrite(pin, LOW);\n    delayMicroseconds(13);\n  }\n}</p><p>int convert(int bits[]) {\n  int result = 0;\n  int seed   = 1;\n  for(int i=3;i>=0;i--) {\n    if(bits[i] == 1) {\n      result += seed;\n    }\n    seed = seed * 2;\n  }\n  \n  return result;\n}</p>", "step_imgs": [], "step_title": "Step 2: Use This Code for the Gun."}, {"step": 3, "steps_text": "After I got my software and hardware to work I used old Nerf gun I had lying around to function as the housing of the Arduino and it's hardware.", "step_imgs": ["https://cdn.instructables.com/FHI/IFXG/JQWT2HM5/FHIIFXGJQWT2HM5.LARGE.jpg", "https://cdn.instructables.com/FRJ/L8HD/JQWT2HLZ/FRJL8HDJQWT2HLZ.LARGE.jpg"], "step_title": "Step 3: Take That Dusty Old Nerf Gun Out of Your Drawer (or Buy One)."}, {"step": 4, "steps_text": "After I dusted of the gun, I took it apart and had a look inside. I planned out where the different parts of the gun would come and where I would place the Arduino Uno. I took out all the lose parts and the old firing mechanism and painted the gun. After this I made some modifications on the inside so I could fit the arduino inside the old magazine chamber of the gun.", "step_imgs": ["https://cdn.instructables.com/FRA/K40H/JQWT2HNK/FRAK40HJQWT2HNK.LARGE.jpg"], "step_title": "Step 4: Modify the Nerf Gun."}, {"step": 5, "steps_text": "After I modified and painted the gun it was time for me to solder all my components to seperate breadboards. Shortly after that, I glued them into the gun and I was ready to go test it!", "step_imgs": ["https://cdn.instructables.com/FO6/UT14/JQWT2HQR/FO6UT14JQWT2HQR.LARGE.jpg", "https://cdn.instructables.com/FZF/R7LY/JQWT2HPA/FZFR7LYJQWT2HPA.LARGE.jpg", "https://cdn.instructables.com/FDO/0YEE/JQWT2HOA/FDO0YEEJQWT2HOA.LARGE.jpg", "https://cdn.instructables.com/FQP/JFFY/JQWT2HNE/FQPJFFYJQWT2HNE.LARGE.jpg"], "step_title": "Step 5: Solder Your Components and Glue Them Into the Gun."}, {"step": 6, "steps_text": "Eventually the lasertag gun turned out like this. You can shoot, receive and decode IR messages with the code. Whilst everything is connected in a neatly modified nerf gun. Just connect the powerbank to the arduino and you are ready to go :)", "step_imgs": ["https://cdn.instructables.com/FH5/AIM3/JQWT2HVX/FH5AIM3JQWT2HVX.LARGE.jpg", "https://cdn.instructables.com/FDS/U7ZJ/JQWT2HVV/FDSU7ZJJQWT2HVV.LARGE.jpg"], "step_title": "Step 6: Tadaa!"}], "channel": "Nerf"}, {"category": "technology", "description": "My xmas-box project consists of an internet\u00a0controlled Christmas lights and music show. A Christmas\u00a0song can be requested on-line which is then put in a queue and played in the order it was requested. The music is transmitted on an FM station within a 300 ft radius from my house.\u00a0\nThe xmas-box has\u00a08 Channels \u00a0(power outlets) where different light modes can be played: vu meter style, ascending, descending, split, merge, sequence and random. During each song one of these modes is used randomly every 10 seconds (to make the show less monotonous).\nI started my research right after Halloween and I came across a couple different options, but I\u00a0settled with the following combination of hardware : arduino + adafruit wave shield + ioBridge + wifi bridge + solid state relays (SSRs).\nThe xmas-box is enclosed in a small plastic tool box. I have place it on my deck under a roof ( it is not completely weather proof). The tool box has \"3 levels.\" The bottom is where all the SSRs and AC wiring are located. The middle (the inside tray) contains the wall warts for the arduino (9v), ioBridge (5v) and Wifi Bridge with power. The top level contains the Arduino board, the ioBridge module and the FM transmitter.\nThis is the first time I lit my house so I was just able to put 3,300 mini lights, 3 spotlights,1 LED Rope, 4 LED (40 led each) branch trees and 1 reindeer. I hope the lights last so I can keep adding each year.", "title": "Xmas-box: Arduino/ioBridge Internet Controlled Christmas Lights and Music Show", "url": "https://www.instructables.com/id/xmas-box-ArduinoioBridge-internet-controlled-Chr/", "section": "technology", "steps": [{"step": 1, "steps_text": "\n          Here is the list of materials I used for the xmas-box:Arduino DuemilanoveAdafruit Wave Shield for Arduino Kit - v1.1ioBridge IO-204 Monitor & Control Module\u00a0ioBridge Smart Serial BoardSD card (up to 1 GB)PPA Digital FM Transmitter10 K resistor2N2222 transistorLinksys WET11 Wireless Bridge\u00a08\u00a0Solid State Relays\u00a0(I got mine from ebay for $5 each!)2\u00a0PowerSquid Power Multiplier\u00a0Plastic Tool BoxElectric CableWire ConnectorsAt least 8 sets of Christmas lights (mini lights, C7, C9, or LED sets)", "step_imgs": ["https://cdn.instructables.com/FPV/K8ZD/G2HDZLRG/FPVK8ZDG2HDZLRG.LARGE.jpg", "https://cdn.instructables.com/FXP/R4K7/G2HDZLRF/FXPR4K7G2HDZLRF.LARGE.jpg", "https://cdn.instructables.com/FKK/6S1G/G2HDZLRE/FKK6S1GG2HDZLRE.LARGE.jpg", "https://cdn.instructables.com/FTR/L7Z1/G2HDZLRD/FTRL7Z1G2HDZLRD.LARGE.gif", "https://cdn.instructables.com/FKB/ER3I/G2HDZLRA/FKBER3IG2HDZLRA.LARGE.jpg", "https://cdn.instructables.com/F4D/9U41/G2HDZLR9/F4D9U41G2HDZLR9.LARGE.jpg", "https://cdn.instructables.com/FX9/DBDR/G2HDZLRB/FX9DBDRG2HDZLRB.LARGE.jpg", "https://cdn.instructables.com/FRK/GUMQ/G2HDZLRC/FRKGUMQG2HDZLRC.LARGE.jpg"], "step_title": "Step 1: BoM - Bill of Materials"}, {"step": 2, "steps_text": "----------------------------------------------------------WARNING----------------------------------------------------------------You will be dealing with AC power.  If you don't feel comfortable or you are not sure how to handle AC, please consult a licensed electrician before starting to wire the relays.----------------------------------------------------------------------------------------------------------------------------------------A great advantage of using SSRs instead of mechanical relays is that I did not have to add any diodes, transistors, or resistors. Also since there there is no mechanical dependency the switching will be smoother. I would advise to use a breadboard with 1k resistors and different color LEDs during your prototyping. Then when you are ready you can use the SSRs and real Christmas lights.The connections are pretty\u00a0straight\u00a0forward. I daisy chained the ground coming from the Arduino to each of the 8 SSRs. Then 8 digital outputs from the Arduino were connected to each positive of the 8 SSRs.I gutted the PowerSquid Power Multiplier and removed the 10 outgoing outlets (5 per PowerSquid) as well as the AC plugs. The 5 outgoing outlets came nicely attached together so I cut one from each that used to power the arduino, ioBridge and Wifi bridge.I connected all the Neutrals (white) together, all the Grounds (green) and then I took the Live (black) and daisy chained to each of the 8 SSRs. Then I individually wired each SSR Live wires to one of the 8 outlets.I decided to have two power plugs to make the wiring a bit nicer and less bulky. So basically the SSRs on the left are connected to one wall outlet and the SSRs on the right to the other.", "step_imgs": ["https://cdn.instructables.com/FY5/WVIA/G2HDZZ34/FY5WVIAG2HDZZ34.LARGE.jpg", "https://cdn.instructables.com/F6X/2ZQB/G2HDZM07/F6X2ZQBG2HDZM07.LARGE.jpg", "https://cdn.instructables.com/F6N/007W/G2HDZLXP/F6N007WG2HDZLXP.LARGE.jpg", "https://cdn.instructables.com/F9A/UQW8/G2HDZLR8/F9AUQW8G2HDZLR8.LARGE.jpg", "https://cdn.instructables.com/FX9/DBDR/G2HDZLRB/FX9DBDRG2HDZLRB.LARGE.jpg", "https://cdn.instructables.com/F35/G9QH/G2HDZSTP/F35G9QHG2HDZSTP.LARGE.jpg"], "step_title": "Step 2: Relay Setup"}, {"step": 3, "steps_text": "You can download the Arduino Sketch from the bottom of this page (xmas_box.pde).\n\u00a0You will need the following Arduino Libraries:\n- AF_Wave and Wave\n- String (formerly TextString)\nHere is a run down for the pin connections on the Arduino with WAVE shield on top.Communication\nD0(RX) -> ioBridge Serial Board TX\nD1(TX )-> ioBridge Serial Board RXD2-D5 are used by the WAVE shield (they could be changed)\nD2 -> LCS\nD3 -> CLK\nD4 -> DI\nD5 -> LATxmas-box first 3 channels\nD6 -> Channel 1\nD7 -> Channel 2\nD8 -> Channel 3FM transmitter ON/OFF\nD9 -> 10k resistor -> 2N2222 Base -- Collector and Emitter to FM transmitter switchWAVE shield\nD10 ->\u00a0CCSSD card WAVE shield communication (cannot be changed)\nD11\nD12\nD13Power\nGnd[0] -> Relay daisy chain.\n5v pin -> FM transmitter positive\nGnd[1] -> FM transmitter ground\nGnd[2] -> ioBridge Smart Serial BoardVu Meter\nA0 -> R7 1.5K on the WAVE shield to measure output from amplifier. See image.Analog pins 1-5 are used as digital out for xmas-box channels\nA1 = D15 -> Channel 4\nA2 = D16 -> Channel 5\nA3 = D17 -> Channel 6\nA4 = D18 -> Channel 7\nA5 = D19 -> Channel 8Wave shield speaker (mono) to FM transmitter input", "step_imgs": ["https://cdn.instructables.com/FUZ/LSDJ/G2HDZNTT/FUZLSDJG2HDZNTT.LARGE.jpg", "https://cdn.instructables.com/FPV/K8ZD/G2HDZLRG/FPVK8ZDG2HDZLRG.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Arduino Sketch"}, {"step": 4, "steps_text": "The ioBridge configuration is a breeze! All you have to do is Serial.print the current track number being played to the ioBridge Serial Board. The serial board will hold the track number and have it available to be retrieved by the Data Feed API in JSON format (LastSerialOutput).I also created a series of widgets with predefined xmas-box commands for a one-click input. Here is the syntax to communicate with the xmas-box through serial communication.\u00a0 The semi-colon indicates the end of the command.Next trackn;Put on queueq(1-99);Put on queuewith specific light modeq(1-99)m(1-8);Change light modexxxm(1-7);Turn all lights on/offxxxm8{1/0);Turn individual channel on/offxxxm9(1-8)(1/0);", "step_imgs": ["https://cdn.instructables.com/FJS/CYEU/G2L3BMFR/FJSCYEUG2L3BMFR.LARGE.jpg", "https://cdn.instructables.com/FWT/11SC/G2HDZPL7/FWT11SCG2HDZPL7.LARGE.gif"], "step_title": "Step 4: IoBridge Configuration"}, {"step": 5, "steps_text": "I was hoping to find a Belkin TuneCast II since I have found a lot of information online (including this instructable) but I had to settle with the PPA Digital FM Transmitter and it worked out pretty well! The only modifications I had to do were to desolder the stereo mini plug and connect 2 wires coming from the WAVE shield speaker output and desolder the mini barrel plug to connect power directly from the Arduino.I'm powering the FM transmitter with the 5v coming out from the Arduino. This would probably not be a good idea if I was powering the Arduino with a 9v battery but since I'm using a wall wart I'm not too concerned.I am bypassing the ON/OFF switch by connecting a 2N2222 transistor connected to a 10k resistor coming from a digital output from the Arduino. To turn on I just send a fast HIGH/delay/LOW and that's all I need to start the FM transmitter.I also soldered a wire as an antenna to the ground of the battery power pin. ", "step_imgs": ["https://cdn.instructables.com/FIA/BW31/G2L3BMCY/FIABW31G2L3BMCY.LARGE.jpg", "https://cdn.instructables.com/F5W/WOKO/G2L3BMD5/F5WWOKOG2L3BMD5.LARGE.jpg"], "step_title": "Step 5: FM Transmitter"}, {"step": 6, "steps_text": "I decided to leave the job of song queuing to a web application. I am using Oracle Application Express (APEX) for http://xmas-box.com since this is my favorite rapid web application development tool. But this can also be managed by any database oriented web solution (ie\u00a0 Linux/Apache/MySQL/PHP -\u00a0 LAMP). I have 2 main tables:SONGS - It stores the name and artist of the songQUEUE - it stores the song requestsThe web app uses jQuery to retrieve the ioBridge JSON Data Feeed API to determine the current song being played. Using Javascript I retrieve LastSerialOutput node that holds the number of the current track. Then another jQuery calls my web application REST service and sends the track number. The REST service returns the song name,artists and name of the person that requested the song.If the song was not on the queue it means that its just looping through the play list. So in this case the requester will be Santa Claus itself! And it will show Santa's current location by retrieving it from http://www.noradsanta.org/ feed.The page might have a live view and live sound, but I'm still working on that...", "step_imgs": ["https://cdn.instructables.com/FD1/U90K/G2HDZQ5H/FD1U90KG2HDZQ5H.LARGE.jpg"], "step_title": "Step 6: Web Interface"}, {"step": 7, "steps_text": "During my research I stumbled upon a few mentionable resources. My requirements became more tight since I wanted a computer-free solution, a stand-alone application and that is why I went with the WAVE shield . Another possible way is to get a cheap mp3 player and build an op amp low filter to detect beats on the music, but then again the WAVE shield is actually pretty inexpensive so it worked out better.Beat detectionOne of the easiest ways to do an Arduino based light/sound show is by using a combination of Proccessing + Minim+ Firmata. All you need is to have serial communication from your pc to your arduino.\u00a0 These instructables rely on Minim's beat detection and could be adapted for Christmas lights:LED Dance RoomMusic Synchronized LED Pumpkin Relay board fabricationYou can follow the Arduino Christmas Light Controller Instructable if you prefer to build your own relay board. Note that this will be using mechanical relays instead of SSRs.Internet communicationAnother alternative for the web control part is to have a secondary Arduino with a Ethernet shield or a wi-fi shield (it will be absolutely necessary to have a second Arduino board). But as a side note I really like using the ioBridge module. Their servers manage all incoming/outgoing connections and the Data Feeds and APIs offers great flexibility.Commercial/Hobby productsdiylightanimation.com (Linx)animatedlighting.com (they got a Christmas In A Box 4 channel for $500!!)Ligh-O-Rama", "step_imgs": ["https://cdn.instructables.com/F0R/9JQV/G2HDZO6G/F0R9JQVG2HDZO6G.LARGE.jpg"], "step_title": "Step 7: Alternatives"}], "channel": "Arduino"}, {"category": "technology", "description": "Filters are a very important component to know for circuitry. A filter is used to filter out a certain range of frequencies to reduce noise or other signals coming into a system. Typical a system will have multiple filters to get a very specific frequency through. To see what frequencies a filter gets ride of we can plug them into an Analog Discovery and check using the Network Analyzer. For this demo there will be 4 different filters to show some how the filters actually work. ", "title": "Analog Discovery Network Analyzer", "url": "https://www.instructables.com/id/Analog-Discovery-Network-Analyzer/", "section": "technology", "steps": [{"step": 1, "steps_text": "A high pass filter will only allows high frequencies from it's cut-off frequency to infinity to pass through. A low pass filter will do the opposite of the high pass and allow frequencies lower then the cut off frequency. typically a high pass filter is made with a capacitor in series with a resistor. Those components need to be in that order. So the low pass filter needs to have a resistor in series with a capacitor. The values of the resistor and capacitor will determine where the cut off frequency is.The cut off frequency for a high pass filter can be defined as:1/(2*pi*R*C)This cut off frequency will define what the lowest frequency that can pass through this filter and still be used. Any frequency below this, for the high pass, will not effect the circuit. Any frequencies above the cut off frequency, for the low pass, will not go through the system.I made an example circuit for both the low and high pass filter. The high pass circuit uses a 1.0 nF capacitor and a 10k Ohm resistor. The low pass filter is very similar just the position of the resistor and the capacitor are flipped. I used a 1k Ohm resistor and 10 nF capacitor.", "step_imgs": ["https://cdn.instructables.com/FYM/8LMB/IKRNQB1C/FYM8LMBIKRNQB1C.LARGE.jpg", "https://cdn.instructables.com/F0Y/5X37/IKRNQB28/F0Y5X37IKRNQB28.LARGE.jpg", "https://cdn.instructables.com/FSC/UVTP/IKRNQB36/FSCUVTPIKRNQB36.LARGE.jpg", "https://cdn.instructables.com/FRV/QU23/IKRNQB3U/FRVQU23IKRNQB3U.LARGE.jpg"], "step_title": "Step 1: High Pass and Low Pass Filters"}, {"step": 2, "steps_text": "The next set of filters are also opposites of each other. A band pass filter is constructed out of two RC circuits or out of an RLC circuit. I made a band pass filter using the RLC method. I had a capacitor, and inductor and a resistor is series in that order. I had my output coming from the resistor part. For the band stop filter I had a resistor, an inductor and a capacitor in series in that order. My out put for that filter was coming off of the inductor and capacitor.These filters are used to get a specific range of frequencies. The band pass filter will only allow the specified range to pass through the system. The band stop filter will do the opposite. The band pass filter will only allow frequencies outside of the specified range to pass through the system. The example circuits I created for the band pass filter used 1nF capacitor, a 1 mH inductor, and a 1k Ohm resisitor. The band stop filter used a 10k ohm resistor, a 1mH inductor and a 1nF capacitor.", "step_imgs": ["https://cdn.instructables.com/FUZ/2EK9/IKRNQB78/FUZ2EK9IKRNQB78.LARGE.jpg", "https://cdn.instructables.com/FIE/7HPU/IKRNQB7X/FIE7HPUIKRNQB7X.LARGE.jpg", "https://cdn.instructables.com/FTV/LMCN/IKRNQB86/FTVLMCNIKRNQB86.LARGE.jpg", "https://cdn.instructables.com/F7M/2JJS/IKRNQB8E/F7M2JJSIKRNQB8E.LARGE.jpg"], "step_title": "Step 2: Band Pass and Band Stop Filter"}, {"step": 3, "steps_text": "Once you have all your filters built it is time to connect them to the Analog Discovery. I am using an Analog Discovery 2 for this project. I added several pins around the circuits and connected them to wear I wanted my input, outputs and grounds to be.Take the Wavegenerator 1 lead of the AD and connect it to the input side of the circuit. Connect the Channel 2 lead to the output pin of the circuit. Finally connect one of the ground leads to the ground pin of the AD. You can also hook up the Channel 1 lead to the input pin to see the signal before it is passed through the system.To see how a filter works it is best to use the Network Analyzer of the Waveforms 2015 program. Open up the Network Analyzer to get started. Select the Network tab to get the Network Analyzer open. Once your circuit is hooked up you can select run and see what your waveform does. You may have to change the frequency range you wish you see along with how many Decibels are viewed at a time to see what is happening to your signal as it goes through the system.I kept my freq range at 500 Hz to 2 MHz and then my Decibel range at 50 Db and the top being 10 Db.If you look at the signals you can see that what each filter is doing what it should be doing. In the high pass filter the wave form is plateauing at the cut-off frequency of the system. In the low pass filter the waveform is dropping off just after the cut-off frequency. The band pass filter is allowing only a single frequency to pass through as seen by the rise and fall of the waveform at the exact point. The band stop filter is not allowing a certain frequency though as seen by the converging at the exact point in the waveform.", "step_imgs": ["https://cdn.instructables.com/FOL/VSPZ/IKRNQB24/FOLVSPZIKRNQB24.LARGE.jpg", "https://cdn.instructables.com/FG1/WV4Z/IKRNQB2W/FG1WV4ZIKRNQB2W.LARGE.jpg", "https://cdn.instructables.com/F35/LU73/IKRNQB84/F35LU73IKRNQB84.LARGE.jpg", "https://cdn.instructables.com/FGX/M9GO/IKRNQB8M/FGXM9GOIKRNQB8M.LARGE.jpg"], "step_title": "Step 3: Analog Discovery"}, {"step": 4, "steps_text": "Filters are a very handy tool to use when designing a system. They are extremely helpful for reducing noise or only allowing a certain frequency through. I hope these simple circuits will give you some insight into how to design your own filters and help you with your projects. If you have any questions feel free to ask or give me shout. I'd love to hear what people have used their filters for also! Anyway, thanks for reading. until next time.", "step_imgs": [], "step_title": "Step 4: In Conclusion"}], "channel": "Electronics"}, {"category": "technology", "description": "Pure Data is a free, open source, real-time graphical dataflow programming environment for audio, video, and graphics processing.\u00a0 It is especially great for writing interactive audio, video, and graphics applications because it can be easily hooked up to hardware (sensors, cameras, kinect, arduino...) and other software (processing, ableton...) to create some really amazing work. Programming in pd is not command line, instead it uses a graphical interface where data flows through objects via inlets and outlets.\u00a0 This interface makes it much easier for non-programmers to get their ideas down quickly and easily and makes designing a graphical user interface for your applications very straightforward.\u00a0 Pd runs in real-time which is helpful for debugging and understanding how objects are interacting with each other.", "title": "Beginner Pure Data Tutorial: Basic Synth", "url": "https://www.instructables.com/id/Beginner-Pure-Data-Tutorial-Basic-Synth/", "section": "technology", "steps": [{"step": 1, "steps_text": "The first step is to download Pure Data.\u00a0 There are many versions available, start with Pd extended. When you open pd a dialog box like the one pictured above will appear, ignore this for now.\u00a0 Programming in pd is done in files called \"patches,\" to open a new patch go to File>>New.\u00a0 Once you have a new file open go to Put>>Object or ctrl/command + 1 to start building your patch.\u00a0 A box will appear near your cursor; click somewhere within the space of your new patch.\u00a0 You can then type the name of the object into the box and click to create the object.\u00a0 Try out some simple objects like \"slider\" or \"+\", right click and select Help to learn more about how these objects are used.", "step_imgs": ["https://cdn.instructables.com/FY6/0HBZ/HGIEVF8Z/FY60HBZHGIEVF8Z.LARGE.jpg", "https://cdn.instructables.com/F5Y/2QAP/HGH6JE42/F5Y2QAPHGH6JE42.LARGE.jpg"], "step_title": "Step 1: Getting Started"}, {"step": 2, "steps_text": "This patch will introduce some objects that are useful for audio processing.\u00a0 All audio processing objects in pure data are denoted with a \"~\" at the end of their name.\u00a0 For example, a \"+\" object will add together two numbers, but a \"+~\" will add together two audio signals, or an audio signal and a number.\u00a0 If you try to connect a signal into the inlet of a regular \"+\", the connection will disappear. The most fundamental object in a synth patch is \"osc~\", this object generates a sine wave.\u00a0 You can specify the frequency of the sine wave by including an argument such as \"osc~ 440\"; this oscillator will generate a sine wave with a frequency of 440Hz.\u00a0 You can also send the frequency of the osc~ object through it's top left inlet.\u00a0 Remember if you want to find more info about any of the objects, right click on the object and select \"Help\". Next create a \"dac~\" object, dac stands for digital to audio converter.\u00a0 This object will route audio from pd to speakers or the audio output jack of your computer.\u00a0 The left inlet sends audio to the left channel and right inlet sends it to the right channel.\u00a0 Connect the outlet of the osc~ 440 to the inlets of the dac~ as shown in the first image. No sound is coming out of your speakers yet.\u00a0 This is because we have to tell pd to turn on its digital signal processing.\u00a0 Do this by selecting \"compute audio\" on the pd-extended main window (figure 2).\u00a0 You should hear a sine wave, if you want it to stop, uncheck compute audio. The sine wave output from osc~ has an amplitude of 1 by default; signals sent to the dac~ must be between -1 and 1 or they will be clipped and sound distorted.\u00a0\u00a0 If we want to change the overall gain/volume of the signal we need to add some more objects.\u00a0\u00a0 As shown in figure 4, create a \"slider\" and \"*~\" object and connect them so that the output from osc~ is multiplied by the slider value.\u00a0 Notice the \"/ 127\" object in the path between the slider and *~.\u00a0 The slider object outputs values between 0 and 127, but if we multiply our sine wave by anything larger than 1 it will be distorted in the dac~ (go ahead and try it).\u00a0 Dividing by 127 scales this number so that it is always between 0 and 1, now dragging the slider up and down should raise and lower the volume of the sine wave.\u00a0\u00a0 Use numberbox objects (\"nbx\") to double check that everything is working properly (figure 4). Next attach a numberbox (\"nbx\") to the left inlet of osc~ as shown in figure 5- this object will modulate the frequency of the osc~ object.\u00a0 Use control/command + e to switch out of edit mode\u00a0 (also Edit>>Edit Mode) and click and drag the numberbox to change its value.\u00a0 Once you get above about about 30Hz you will hear a low frequency sine (make sure compute audio is checked!). In figure 6 I have included some additional objects and connected them to the left inlet of osc.\u00a0 These objects will give our main sine wave some vibrato (wavering frequency).\u00a0 The osc~ 5 object outputs a sine wave of frequency 5Hz.\u00a0 Next and *~ gives the 5Hz sine wave an amplitude of 20.\u00a0 And finally, The sine wave is offset by 440 by the +~ object, this means that this signal coming out is a sine wave which oscillates between the numbers 420 and 460 at a frequency of 5Hz.\u00a0 When this signal is fed into the left inlet of another osc~, it sets the frequency of that osc~ to waiver between 420 and 460Hz at a frequency of 5Hz.\u00a0 This is called frequency modulation.\u00a0 Get out of Edit Mode and use the numberboxes to change the amplitude, rate, and center frequency of the frequency modulation to get a better understanding of how it works. I've attached this patch below.", "step_imgs": ["https://cdn.instructables.com/FRF/8RSE/HGH71N6J/FRF8RSEHGH71N6J.LARGE.jpg", "https://cdn.instructables.com/FRH/BJ8P/HGIEVF8Y/FRHBJ8PHGIEVF8Y.LARGE.jpg", "https://cdn.instructables.com/FO8/R3Q6/HGIEVF8X/FO8R3Q6HGIEVF8X.LARGE.jpg", "https://cdn.instructables.com/FV9/YR2D/HGHAP34X/FV9YR2DHGHAP34X.LARGE.jpg", "https://cdn.instructables.com/FZ3/NUKC/HGHAP34W/FZ3NUKCHGHAP34W.LARGE.jpg", "https://cdn.instructables.com/FKH/IEYY/HGH71N6H/FKHIEYYHGH71N6H.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 2: Basic Synth Patch"}], "channel": "Audio"}, {"category": "technology", "description": "This tutorial will show you how to visualize data from an HC-SR04 distance sensor on the WS2811 ledstrip. It consists of an Nodemcu Esp8266, An WS2811 Led-Strip, a HC-SR04 Distance sensor and some wires.Enjoy!", "title": "Display Sensor Data on WS2811", "url": "https://www.instructables.com/id/Arduino-Based-IoT-Hospitality-Fridge/", "section": "technology", "steps": [{"step": 1, "steps_text": "To make this project you will need the following: 1) 1x Node MCU2)  HC - SR04 Ultrasonic Distance Measuring Sensor*3) A PC or a Mac to connect the Arduino board4) Arduino Software5) Wires to connect the hardware", "step_imgs": [], "step_title": "Step 1: Supplies"}, {"step": 2, "steps_text": "First we need to make the WS2812B Ledstrip connectable. Grab the soldering machine and wait till it is warm enough to use. Strip the wires and solder them like the image above. I used black for Ground (GND), Red for +5v and white for the digital pin. Connect the wires to the NodeMCU like this:Pins & Wires WS2812B:Ground - Gnd+5V - 3V3Digital pin - Any (I Used D5)Finished? Allright, now it is time to connect the HC-SR04 Distance sensor. This sensor already has pins so it will take a little less time. Connect the wires to the NodeMCU like this:Pins & Wires HC-SR04:Ground - Gnd Vcc - VinEchopin - D0Trigpin - D1", "step_imgs": ["https://cdn.instructables.com/F6K/G5QQ/J9YJKB3J/F6KG5QQJ9YJKB3J.LARGE.jpg", "https://cdn.instructables.com/FGI/QXII/J9YJKBED/FGIQXIIJ9YJKBED.LARGE.jpg"], "step_title": "Step 2: Hardware Set-up"}, {"step": 3, "steps_text": "WS2812BTo program the Arduino we need to connect the NodeMCU to any pc or mac that has the Arduino software installed. To play with the WS2812B Led-Strip we need to download the Fastled Library. This Library will help creating animations and supports a wide range of popular leds.Installing the Library:1) Go to https://github.com/FastLED/FastLED/releases  and download the library (.zip file)2) Open Arduino Software > Sketch > Include Library > Add .zip library3) Navigate to the .zip file's location and open it. (As shown in the image above)4) Navigate to Sketch > Import Library menu. You should now see the library.Now we need to run some basic code to see whether the Led-Strip is working or not. This is also the start of our code./ defines pins numbers\n\n#include <FastLED.h>\n\n#define LED_PIN     5 // Connected Wire\n#define NUM_LEDS    10 // Number of Leds on strip\n#define BRIGHTNESS  64\n#define LED_TYPE    WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define UPDATES_PER_SECOND 100\n\nvoid setup() {\n  delay( 3000 ); // power-up safety delay\n    FastLED.addLeds(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );\n    FastLED.setBrightness(  BRIGHTNESS );\n  \nSerial.begin(115200); // Starts the serial communication\n}\n\nvoid loop() {\n      // Turn the first led red for 1 second\n      leds[0] = CRGB::Red; \n      FastLED.show();\n      delay(1000);\n      \n      // Set the first led back to black for 1 second\n      leds[0] = CRGB::Black;\n      FastLED.show();\n      delay(1000);\n    }This should make the first Led blink in red.HC-SR04To use the HC-SR04 Sensor we need to add some basic code. The following code will help us.const int trigPin = D1; // trigPin connected to D1\nconst int echoPin = D0; // echoPin connected to D0<br>// defines variables\nlong duration;\nint distance;\n\nvoid setup() {\npinMode(trigPin, OUTPUT); // Sets the trigPin as an Output\npinMode(echoPin, INPUT); // Sets the echoPin as an Input\nSerial.begin(115200); // Starts the serial communication\n}<br>void loop() {\n// Clears the trigPin\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(2);\n// Sets the trigPin on HIGH state for 10 micro seconds\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(10);\ndigitalWrite(trigPin, LOW);\n// Reads the echoPin, returns the sound wave travel time in microseconds\nduration = pulseIn(echoPin, HIGH);\n// Calculating the distance\ndistance= duration*0.034/2;\n// Prints the distance on the Serial Monitor\nSerial.print(\"Distance: \");\nSerial.println(distance)<br>}Now we have an variable called distance which is as it says the distance the HC-SR04 measures.", "step_imgs": ["https://cdn.instructables.com/FE5/N3RS/J9YJKC59/FE5N3RSJ9YJKC59.LARGE.jpg"], "step_title": "Step 3: Setting Up the Arduino"}, {"step": 4, "steps_text": "Now it is time to combine the sensor data from the HC-SR04 Sensor and show something on the WS2812b Led strip. If you combine the code from the previous step you get the following code. // defines pins numbers\n#include <FastLED.h>#define LED_PIN     5 // Connected Wire\n#define NUM_LEDS   10 // Number of Leds\n#define BRIGHTNESS  64\n#define LED_TYPE    WS2811 //Type\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];#define UPDATES_PER_SECOND 100<br>\nconst int trigPin = D1;\nconst int echoPin = D0;\n\n\n// defines variables\nlong duration;\nint distance;void setup() {\n  delay( 3000 ); // power-up safety delay\n    FastLED.addLeds(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );\n    FastLED.setBrightness(  BRIGHTNESS );\n  \npinMode(trigPin, OUTPUT); // Sets the trigPin as an Output\npinMode(echoPin, INPUT); // Sets the echoPin as an Input\nSerial.begin(115200); // Starts the serial communication\n}void loop() {\n// Clears the trigPin\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(2);\n// Sets the trigPin on HIGH state for 10 micro seconds\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(10);\ndigitalWrite(trigPin, LOW);\n// Reads the echoPin, returns the sound wave travel time in microseconds\nduration = pulseIn(echoPin, HIGH);\n// Calculating the distance\ndistance= duration*0.034/2;\n// Prints the distance on the Serial Monitor\nSerial.print(\"Distance: \");\nSerial.println(distance);// Add code here }This is the perfect template to mess around with. Do something when distance is somethingNow we want to make something happen at a certain distance. By adding the following code it is possible to run code when the distance is less than 20 centimeters from the sensor.if (distance  < 20) { \t\t\t\t// distance (from sensor) is < (less than) 20// Something happens\n   }It is also possible to do this with larger than, or even make combinations.", "step_imgs": [], "step_title": "Step 4: Combine the Code"}, {"step": 5, "steps_text": "Now it is time to use your knowledge to design and create something useful. I tried to show the amount of bottles in a fridge by displaying them on the Led-Strip. (See illustration).In this example the WS2812B is attached to the refrigerator and the HC-SR04 is placed in the inside of the fridge.The Led-strip changes every time a bottle is taken from the fridge. It turns orange when more than 50% is taken. And all the leds turn red when the fridge is empty.To realize this i made the following code:// defines pins numbers#include <FastLED.h>#define LED_PIN     5\n#define NUM_LEDS    33\n#define BRIGHTNESS  64\n#define LED_TYPE    WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];#define UPDATES_PER_SECOND 100const int trigPin = D1;\nconst int echoPin = D0;\n// defines variables\nlong duration;\nint distance;void setup() {\n  delay( 3000 ); // power-up safety delay\n    FastLED.addLeds(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );\n    FastLED.setBrightness(  BRIGHTNESS );\n  \npinMode(trigPin, OUTPUT); // Sets the trigPin as an Output\npinMode(echoPin, INPUT); // Sets the echoPin as an Input\nSerial.begin(115200); // Starts the serial communication\n}void loop() {\n// Clears the trigPin\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(2);\n// Sets the trigPin on HIGH state for 10 micro seconds\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(10);\ndigitalWrite(trigPin, LOW);\n// Reads the echoPin, returns the sound wave travel time in microseconds\nduration = pulseIn(echoPin, HIGH);\n// Calculating the distance\ndistance= duration*0.034/2;\n// Prints the distance on the Serial Monitor\nSerial.print(\"Distance: \");\nSerial.println(distance);  //in de buurt\n  if (distance < 5) {\n     leds[0] = CRGB::Green; \n        FastLED.show();    \n       leds[1] = CRGB::Green; \n        FastLED.show(); \n        leds[2] = CRGB::Green; \n        FastLED.show(); \n        leds[3] = CRGB::Green; \n        FastLED.show(); \n        leds[4] = CRGB::Green; \n        FastLED.show();\n         leds[5] = CRGB::Green; \n        FastLED.show(); \n        leds[6] = CRGB::Green; \n        FastLED.show(); \n        leds[7] = CRGB::Green; \n        FastLED.show(); \n        leds[8] = CRGB::Green; \n        FastLED.show();  \n        leds[9] = CRGB::Green; \n        FastLED.show();  \n  }    if (distance  > 5 && distance < 10) {\n        leds[0] = CRGB::Green; \n        FastLED.show(); \n          leds[1] = CRGB::Green; \n        FastLED.show(); \n        leds[2] = CRGB::Green; \n        FastLED.show(); \n        leds[3] = CRGB::Green; \n        FastLED.show(); \n        leds[4] = CRGB::Green; \n        FastLED.show();\n         leds[5] = CRGB::Green; \n        FastLED.show(); \n        leds[6] = CRGB::Green; \n        FastLED.show(); \n        leds[7] = CRGB::Green; \n        FastLED.show(); \n        leds[8] = CRGB::Green; \n        FastLED.show();   \n        leds[9] = CRGB::Black; \n        FastLED.show();  \n    }   if (distance  > 10 && distance < 15) {\n     leds[0] = CRGB::Green; \n        FastLED.show(); \n          leds[1] = CRGB::Green; \n        FastLED.show(); \n        leds[2] = CRGB::Green; \n        FastLED.show(); \n        leds[3] = CRGB::Green; \n        FastLED.show(); \n        leds[4] = CRGB::Green; \n        FastLED.show();\n         leds[5] = CRGB::Green; \n        FastLED.show(); \n        leds[6] = CRGB::Green; \n        FastLED.show(); \n        leds[7] = CRGB::Green; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }     if (distance  > 15 && distance < 20) {\n       leds[0] = CRGB::Green; \n        FastLED.show(); \n          leds[1] = CRGB::Green; \n        FastLED.show(); \n        leds[2] = CRGB::Green; \n        FastLED.show(); \n        leds[3] = CRGB::Green; \n        FastLED.show(); \n        leds[4] = CRGB::Green; \n        FastLED.show();\n         leds[5] = CRGB::Green; \n        FastLED.show(); \n        leds[6] = CRGB::Green; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n       \n    }       if (distance  > 20 && distance < 25) {\n          leds[0] = CRGB::Orange; \n        FastLED.show(); \n          leds[1] = CRGB::Orange; \n        FastLED.show(); \n        leds[2] = CRGB::Orange; \n        FastLED.show(); \n        leds[3] = CRGB::Orange; \n        FastLED.show(); \n        leds[4] = CRGB::Orange; \n        FastLED.show();\n         leds[5] = CRGB::Orange; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }        if (distance  > 25 && distance < 30) {\n            leds[0] = CRGB::Orange; \n        FastLED.show(); \n       leds[1] = CRGB::Orange; \n        FastLED.show(); \n        leds[2] = CRGB::Orange; \n        FastLED.show(); \n        leds[3] = CRGB::Orange; \n        FastLED.show(); \n        leds[4] = CRGB::Orange; \n        FastLED.show();\n         leds[5] = CRGB::Black; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }       if (distance  > 30 && distance < 35) {\n             leds[0] = CRGB::Orange; \n        FastLED.show(); \n       leds[1] = CRGB::Orange; \n        FastLED.show(); \n        leds[2] = CRGB::Orange; \n        FastLED.show(); \n        leds[3] = CRGB::Orange; \n        FastLED.show(); \n        leds[4] = CRGB::Black; \n        FastLED.show();\n         leds[5] = CRGB::Black; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }       if (distance  > 35 && distance < 40) {\n           leds[0] = CRGB::Orange; \n        FastLED.show(); \n       leds[1] = CRGB::Orange; \n        FastLED.show(); \n        leds[2] = CRGB::Orange; \n        FastLED.show(); \n        leds[3] = CRGB::Black; \n        FastLED.show(); \n        leds[4] = CRGB::Black; \n        FastLED.show();\n         leds[5] = CRGB::Black; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }\n     if (distance  > 40 && distance < 45) {\n       leds[0] = CRGB::Red; \n        FastLED.show(); \n       leds[1] = CRGB::Red; \n        FastLED.show(); \n        leds[2] = CRGB::Black; \n        FastLED.show(); \n        leds[3] = CRGB::Black; \n        FastLED.show(); \n        leds[4] = CRGB::Black; \n        FastLED.show();\n         leds[5] = CRGB::Black; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n    }      if (distance  > 40 && distance < 44) {\n           leds[0] = CRGB::Red; \n        FastLED.show(); \n       leds[1] = CRGB::Black; \n        FastLED.show(); \n        leds[2] = CRGB::Black; \n        FastLED.show(); \n        leds[3] = CRGB::Black; \n        FastLED.show(); \n        leds[4] = CRGB::Black; \n        FastLED.show();\n         leds[5] = CRGB::Black; \n        FastLED.show(); \n        leds[6] = CRGB::Black; \n        FastLED.show(); \n        leds[7] = CRGB::Black; \n        FastLED.show(); \n        leds[8] = CRGB::Black; \n        FastLED.show();  \n        leds[9] = CRGB::Black; \n        FastLED.show(); \n        leds[10] = CRGB::Black; \n        FastLED.show();  \n    }\n    \n      if (distance  > 45) {\n           leds[0] = CRGB::Red; \n        FastLED.show();\n       leds[1] = CRGB::Red; \n        FastLED.show(); \n        leds[2] = CRGB::Red; \n        FastLED.show(); \n        leds[3] = CRGB::Red; \n        FastLED.show(); \n        leds[4] = CRGB::Red; \n        FastLED.show();\n         leds[5] = CRGB::Red; \n        FastLED.show(); \n        leds[6] = CRGB::Red; \n        FastLED.show(); \n        leds[7] = CRGB::Red; \n        FastLED.show(); \n        leds[8] = CRGB::Red; \n        FastLED.show();  \n        leds[9] = CRGB::Red; \n        FastLED.show(); \n       \n    }\n  }That's all, Thank you for participating and I'd love to see any of your projects!", "step_imgs": ["https://cdn.instructables.com/F2S/0G6I/J9YJKLHJ/F2S0G6IJ9YJKLHJ.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 5: Create Something Usefull"}], "channel": "Arduino"}, {"category": "technology", "description": "Hello, I'm a student of Singapore Polytechnic. This project is called the Human Piano where Infra-red sensors are used to detect motion and each sensor plays a different tune using a Digital to Analog Converter (DAC). *Note* This project is done by students from Singapore Polytechnic. Tools and components were provided by our FYP supervisor Mr. Teo Shin Jen.", "title": "Human Piano", "url": "https://www.instructables.com/id/Human-Piano/", "section": "technology", "steps": [{"step": 1, "steps_text": "Items used in this project:\n1. \u00a0DAC0808 (https://www.national.com/ds/DA/DAC0808.pdf)\n2.\u00a0Sharp GP2Y0A02 (x7)\u00a0(http://sharp-world.com/products/device/lineup/data/pdf/datasheet/gp2y0a02_e.pdf)\n3. Regular speakers\n4. chipkit max32 (http://digilentinc.com/Data/Products/CHIPKIT-MAX32/chipKIT%20Max32_rm.pdf)", "step_imgs": [], "step_title": "Step 1: Getting Started"}, {"step": 2, "steps_text": "Firstly connect the DAC as shown in the picture.\nWith reference to the wave picture, inputing a binary pattern of decimal value 127 will cause the wave to be at the middle point at that particular time. Likewise, binary pattern of decimal value of 255 will cause the wave to be at the highest (peak) point and binary pattern of decimal value 0 will cause the wave to be at the lowest point.\nThe only way to manipulate the tone would be by changing the delay/time interval between each decimal value. For example, a tone with 1ms delay interval will sound different from a tone with 2ms delay interval.", "step_imgs": ["https://cdn.instructables.com/FVS/41US/H5ENPRTW/FVS41USH5ENPRTW.LARGE.jpg", "https://cdn.instructables.com/FR8/SUG1/H5ECMSHG/FR8SUG1H5ECMSHG.LARGE.jpg"], "step_title": "Step 2: How Does the DAC 0808 Work?"}, {"step": 3, "steps_text": "The Infra-red sensor measures distances between 20cm to 150cm.\nThere are only 3 pins to configure: 5V, Gnd and I/O pin\nIn this project, I have configured each IR to play a certain tone. (e.g. IR 1 will play with 1ms delay and IR 2 will play with 2ms delay)", "step_imgs": ["https://cdn.instructables.com/FHZ/ZQKG/H5EDU0N3/FHZZQKGH5EDU0N3.LARGE.jpg"], "step_title": "Step 3: Sharp GP2Y0A02"}, {"step": 4, "steps_text": "The link attached contains the code for this project\nhttp://snipt.org/vvga4", "step_imgs": [], "step_title": "Step 4: Code"}], "channel": "Arduino"}, {"category": "technology", "description": "Let me add this to the beginning of this... I made some very large safety mistakes in this... please if you do anything with this understand the electricity, how it should be used, and how to NOT do it like I did. There are some things are are fine... great even... and there are some things that should NOT be done. (the biggest ones I can think of are putting the relay on the neutral, instead of the hot, and using low voltage wire instead of 120v wire). That being said everything here works, and was very educational for me. With a few minor changes you can amke this functional AND safe. Thank you. I am very new to Arduino, but am having a lot of fun with it!!! After finishing the animatronics for my office Christmas float I decided to make some automated Christmas lights. I know this has been done many times online, but I think this shows the best, easiest, and cheapest of some of the different ways I have found. Most of this deals with the electrical box. I didn't take pictures of the cable build, so it is all in one step, but there is a lot there. Also the software and a MP3 is at the end. Let me know if you have any questions.I will also say that I got the hot/neutral backwards. You don't want to be switching the neutral on and off and constantly pushing electrons down the other lines (the hot). Any leak, insulation damage, or whatever else will results in leaking electrons... and this is never good. So make sure the lines that are being switched are the hot lines, not the neutral. I have keep this the same (wrong) way so as not to cause more confusion with the colors. If you are doing this I am going to assume you can make this switch without too much problem. Just make sure you are switching the hot, not the neutral.", "title": "Arduino Christmas Lights", "url": "https://www.instructables.com/id/Arduino-Christmas-lights-1/", "section": "technology", "steps": [{"step": 1, "steps_text": "Here is everything you will need for this project. From left to right: Arduino. I used the Arduino Mega 2560 and Ada Fruit Wave Shield. I went with the Mega because I wanted to be able to control more lights. With the mega I effectively can control as many as I want (not hundred, but dozens). If you want to go this way make sure you check out the differences in building the Wave Shield for the Mega as opposed for the Uno. Basically pins 10-13 need to be redirected to 50-53 (\"CCS\" to 53, 11 to 51, 12 to  50, 13 to 52). I'm not going to go into all of the changes for that, the AdaFruit forums are much better than I could do.  If you haven't used electrical scissors get them, I love them. Same with wire strippers. These are both things I have been reluctant to use for years, preferring to stick with a knife. Go for the succors and stripper.  In-sure wire connectors are not needed, but they sure make the connections easier.  Be sure to get jumper wires that are male on one end, and female on the other. There aren't many like that, so look for them, the ones from AdaFruit are good. cheap electrical outlets. Cheap plug from Home Depot 4-Gang Old Work Outlet Box. This makes a pretty good project box. I still need to get a 4 place faceplate to finish it off, and get another outlet box to house the arduino and relays. Currently it is functional, but not pretty.  Romex wire. It may be easer and better to just use some speaker wire or something like that, but I had the romex and so I used it. SainSmart 8-Channel Relay Module. This makes this easy, and is likely cheaper than any you would roll yourself. The only downside is you have to make sure you program them backwards from what I am used to... low is on, high is off. Strange, maybe that is how they do it in China.  Laptop for programing the Arduino. Make sure you switch the board from the Uno to the Mega... that one took me a while to figure out why it was not compiling right!!!", "step_imgs": ["https://cdn.instructables.com/FNR/J13P/HOUG1PBS/FNRJ13PHOUG1PBS.LARGE.jpg"], "step_title": "Step 1: Intro"}, {"step": 2, "steps_text": "The first thing you want to do is modify the outlets so that each outlet can control two channels. I will be passing the neutral through the relay. You can use hot, but it is not as safe, and not the standard. I would just stick with neutral. A few ways to know the difference is neutral has the wider outlet, the neutral is on the left of the receptacle (assuming ground is down), the neutral is often aluminum color and the hot is copper, the neutral line is ribbed, and usually the writing is on the hot line. A line tester will only light on hot side. These are only guidelines, so check and make sure you know which line you are working with. There is a little tab between the screws on the outlet that is the only thing that connects the top and bottom receptacle in an outlet. If you want to have two different circuits in a outlet you can easily break this off. In our project ONLY BREAK OFF THE HOT SIDE (the side with the large plug). (I have 4 extra receptacles with both the hot and neutral tabs broken off if you need them). You can do it with both tabs broken off, but is is much easier if you don't.  In these pictures you can see the tab, see it half broken off, and see if off.", "step_imgs": ["https://cdn.instructables.com/F4B/PEXZ/HOUG1PC5/F4BPEXZHOUG1PC5.LARGE.jpg", "https://cdn.instructables.com/FSC/6RK4/HOUG5AW8/FSC6RK4HOUG5AW8.LARGE.jpg", "https://cdn.instructables.com/FC3/REAU/HOUFZ9V5/FC3REAUHOUFZ9V5.LARGE.jpg"], "step_title": "Step 2: The Outlets"}, {"step": 3, "steps_text": "The hot side are all wired together. Use short 2-3\" jumpers to connect all 4 outlets. They are different colors because I made them from both wires from one length of romex. Measure them against the box. The end will be connected to the long wire from the outlet after everything is put together.  At this point go ahead and make the wall plug in. Cut a romex piece 2-3 foot long. Make sure the neutral is attached to the wide plug. Twisting the two lines together keep things much better organized.", "step_imgs": ["https://cdn.instructables.com/FWV/L7BP/HOUG7ZRG/FWVL7BPHOUG7ZRG.LARGE.jpg"], "step_title": "Step 3: Wire the Hot"}, {"step": 4, "steps_text": "You can see the 4 outlets ganged together by their hot sides.  Also you can see the plug put together, and the lines twisted. Also there are 8 pieces of romex cut about 10-12 inches long. I will take these apart, using the hot and neutral insulated wires, but keep the ground wire is not used, and kept for recycling. ", "step_imgs": ["https://cdn.instructables.com/FV6/A7PQ/HOUG7ZR8/FV6A7PQHOUG7ZR8.LARGE.jpg"], "step_title": "Step 4: "}, {"step": 5, "steps_text": "You can see after the romex is taken apart the ends are made ready. They are both stripped 1/2\" on one end, and 1/4\"- 1/8\" on the other. The hot lines (black) are kept strait, but the white (neutral) lines are curved on the 1/2\" end.  The short 1/4-1/8 inch end is for connecting to the relay. ", "step_imgs": ["https://cdn.instructables.com/F7N/F8H8/HOUG1PC6/F7NF8H8HOUG1PC6.LARGE.jpg"], "step_title": "Step 5: "}, {"step": 6, "steps_text": "The neutral lines are all ganged together. I used the In-sure connectors to connect all of the hot lines; this just makes it easier.", "step_imgs": ["https://cdn.instructables.com/FE5/TZ2Z/HOUG1PC7/FE5TZ2ZHOUG1PC7.LARGE.jpg"], "step_title": "Step 6: "}, {"step": 7, "steps_text": "Here you can see all of the leads connected to the neutral side of the plug. Note that you are going to have a wire connected to both screws on the neutral side, where as the hot side is all ganged together.", "step_imgs": ["https://cdn.instructables.com/FUQ/6V0B/HOUFQ7X6/FUQ6V0BHOUFQ7X6.LARGE.jpg"], "step_title": "Step 7: "}, {"step": 8, "steps_text": "Make sure you label the wires coming from the plugs. When you put them through the box it is easy to loose track of which one was for which outlet. I started to use a tape flag, but it didn't go through the junction box very well, so I used a sharpie instead.\u00a0 I used a line for 1, and a block for 5. In the picture you can clearly see a 7 and 8 in the middle, and a 1 is blurry on the right.", "step_imgs": ["https://cdn.instructables.com/F2S/3XZD/HOVU9LLK/F2S3XZDHOVU9LLK.LARGE.jpg"], "step_title": "Step 8: Label the Wires"}, {"step": 9, "steps_text": "Stick all of the wires through the holes in the outlet box. This includes sticking the outlet plug wires into the box.\u00a0 The hot wire goes directly to the hot screw on the closest outlet. The electricity will be spread to all of the plugs through the jumpers that gang all of the plugs together.\u00a0 All of the other wires you see down in the box (most of them) are neutral. It would have been better to have another color, but I didn't... so the dark color is the neutral that is all ganged together with the\u00a0In-sure connectors, and going out to the relays, and the white is the neutral coming back from the relay, and will only be neutral when the relay is closed.\u00a0", "step_imgs": ["https://cdn.instructables.com/FAQ/9QWU/HOW0HS30/FAQ9QWUHOW0HS30.LARGE.jpg"], "step_title": "Step 9: "}, {"step": 10, "steps_text": "Here you can see the outlets in place.\u00a0 The power is coming in from the top right. The hot is going to the first outlet, and a jumper wire is used to gang together all 4 outlets. The neutral line is then ganged tougher with the\u00a0In-sure connectors and going out of the box as the dark wires. The white wires will be coming back from the relay. If you look you can see the numbering system I put on the wires with brown sharpie.\u00a0", "step_imgs": ["https://cdn.instructables.com/F36/OBSQ/HOUFQ7YI/F36OBSQHOUFQ7YI.LARGE.jpg"], "step_title": "Step 10: "}, {"step": 11, "steps_text": "Here you can see I am holding the plug on the left, but it is going in on the top right.\u00a0 The 8 dark lines are all ganged together neutral, and are connected to the common (C) relay contact. The whites are attached to the normal open (NO) contact. You can see that I have now numbered the outlet, and the wire.\u00a0", "step_imgs": ["https://cdn.instructables.com/FC0/75H1/HOUFZ9VX/FC075H1HOUFZ9VX.LARGE.jpg"], "step_title": "Step 11: "}, {"step": 12, "steps_text": "I currently have my Arduino Mega, with the attached WaveShield, relay, and plug ins in a plastic tub. I next plan on getting a 4 gang plug cover the plugins, and may put the relay and Mega in another 4 gang junction box. The Arduno fits perfectly in the bottom, but the relay doesn't fit as well.\u00a0", "step_imgs": ["https://cdn.instructables.com/F5V/V1OX/HOW0HS35/F5VV1OXHOW0HS35.LARGE.jpg"], "step_title": "Step 12: "}, {"step": 13, "steps_text": "I am sorry I did not take pictures of how I made the extension cord for this. While you can simply use a bunch of extension cords, making your own is much easier to work with, and not so unsightly. First, two things. First I have made a few changes because of the education someone else took the time to help me with. The hot and neutral do matter. You don't want to be constantly sending elections down the wire unless you want to do something with them. Sure they will do nothing as long as there is no where to go, but just one little knick and you will have trouble. The common should be neutral for a reason. I think I have made all of theses changes, but if you find an area that does not agree with the rest sorry... I may have missed one. Second... use your brain. Just because someone did it one way... just because you can do something one way... does not mean you should. Using things differently than they were designed should always be cause for concern. Fuses, gauge size, insulation, GFCI outlets, and just good ole common sense all should come into play when doing anything like this, especially when working with 110v AC. What you need: 7 strand sprinkler cable 6 male and 6 female plugs two stranded wire (lamp cord) black electrical tape... quite a bit of it. I used 7 circuit sprinkler cable. It has 7 solid copper strands, each with their own color. You can see most of the colors where I have the male plug ends. The neutral is not seen in this version. I made two of them, and I liked the way I did this one better. Strip about 1-2 feet of the outer black sheath exposing the 7 wires. Pick which color you want to be neutral, I chose white.  Strip most of the insulation off the white (or whatever color you want to be neutral). Leave about 1\" near the base so you can make sure the insulation is totally covered. Take 3 strands of the two stranded wire about the same length as your stripped wire (about 1-1.5 feet). Split these two wires from each other so you have 6 wires. Strip 1/2\" from one end, and 1-2\" from the other. Twist all 6 of these around the base of the stripped (white) wire (this is where you will appreciate the 1-2 inches you stripped from the wire!!). Then take long bare copper wire and wrap it around the bundle of wire you now have. This will not only ensure you have a bullet proof connection, and will more importantly make sure you don't have one wire come loose from the rest. You then coat this with a generous covering of electrical tape.  You will then put the male plugs together using one wire from the sprinkler cable, and one from the neutral wire you have all ganged together with the white wire.  Now you decide how far down the line you want each connector. As I wanted my line to be fairly generic I spaced them all evenly apart.. about 18 foot (really 3 fully stretched arms, and the last two just split half way to the end, and then the end).  Very carefully split the black outer sheath only. You don't want to nick the insulation of any of the inner wires. You then pick which line you want to use first. I usually try and follow rainbow orders of colors, so I always know which one is next (Roy G Biv anyone?) So my first female plug was red, then yellow, green, blue, brown, and finally black. Make sure you label each female plug as you will not know what color they are once you are done. Once you have your hot wire (red for the first one) and neutral (white) isolated from the rest (they will always be at the bottom of the bundle, it is a rule of projects, one of Murphy's) you can take the insulation off. The hot (red) wire can be cut if you aren't going to be using it further down the line, but as I may want to put a line somewhere else down the line I kept all the lines intact. Make sure you keep the white (neutral) line intact, or if you cut it reconnect the ends together. You will for sure need it to be intact all the way to the end.  Use the two stranded wire to attach to the wires you have now exposed. A generous amount of electrical tape will keep everything in place, and hopefully watertight. I made the tail from the female plug about 1.5 feet long, but you can make it as long as you like.  Continue connecting each hot (colored) strand until all of the colors are used it. In my wire it was 6, as I had a 7 strand wire. There are also 5 strand wires.  I am still not sure if I should make the white (common) wire as the hot or the neutral, but as long as you are consistent it should be fine. I am sure there is some EE groaning right now... so please educate me.*********************** Someone did educate me!!! (Thank you very much). The HOT is the one what should be switched. This way you only have electrons being pushed down the line when the lights should be one. Otherwise electrons are always trying to be pushed down the line. Sure, it will work either way, but it is a fairly big safety thing).  I am also trying to decide if the electrical tape is good enough to be left outside. I have several layers, all wrapped very tight, but it still makes me a little nervous.", "step_imgs": ["https://cdn.instructables.com/FI5/LIEE/HOUG7ZRN/FI5LIEEHOUG7ZRN.LARGE.jpg"], "step_title": "Step 13: "}, {"step": 14, "steps_text": "I will say I got my start of this timing from some other webpage. I can't find where I got it, and had to make a lot of changes anyway, so I am loading it here. Once you have this it is very easy to create a program for any song.... but if you are like me you are better at the technical wiring and programing than you are matching dancing lights to music... so having a starting point is a great help.  So here is the code. Again it is the code for the Joy to the World file. The version I uploaded is MP3, but if you use the wave shield it will need to be converted to WAV. Also, I got tired of dealing with the very long code for the lights in the loop, so I made it a function, called \"joy()\". Here is the Arduino code:  // By: Tre' Landrum#include  #include  #include  #include \"WaveUtil.h\" #include \"WaveHC.h\" SdReader card;    // This object holds the information for the card FatVolume vol;    // This holds the information for the partition on the card FatReader root;   // This holds the information for the filesystem on the card FatReader f;      // This holds the information for the file we're play WaveHC wave;      // This is the only wave (audio) object, since we will only play one at a time #define DEBOUNCE 5  // button debouncer //This is for the dancing lights durring joy to the world // if you are using the Uno instead of the Mega you will need to change these pins. If you use the WaveShield you will only have a few pins avaialbe... 6-9 from the top of my head. int light1 = 22; int light2 = 24; int light3 = 26; int light4 = 28; int light5 = 30; int light6 = 32; int light7 = 34; int light8 = 36; int s = 150; int ds = 225; int e = 300; int de = 450; int q = 600; //600 int dq = 900; int h = 0; //1200 int dh = 1800; int start; int end; int time; int now; // Variables will change: // here is where we define the buttons that we'll use. button \"1\" is the first, button \"6\" is the 6th, etc byte buttons[] = {14, 15, 16, 17, 18, 19}; // This handy macro lets us determine how big the array up above is, by checking the size #define NUMBUTTONS sizeof(buttons) // we will track if a button is just pressed, just released, or 'pressed' (the current state volatile byte pressed[NUMBUTTONS], justpressed[NUMBUTTONS], justreleased[NUMBUTTONS]; // this handy function will return the number of bytes currently free in RAM, great for debugging!   int freeRam(void) {   extern int  __bss_end;   extern int  *__brkval;   int free_memory;   if((int)__brkval == 0) {     free_memory = ((int)&free_memory) - ((int)&__bss_end);   }   else {     free_memory = ((int)&free_memory) - ((int)__brkval);   }   return free_memory; } void sdErrorCheck(void) {   if (!card.errorCode()) return;   putstring(\"\\n\\rSD I/O error: \");   Serial.print(card.errorCode(), HEX);   putstring(\", \");   Serial.println(card.errorData(), HEX);   while(1); } void setup() {   byte i;   // set up serial port   Serial.begin(9600);   putstring_nl(\"WaveHC with \");   Serial.print(NUMBUTTONS, DEC);   putstring_nl(\"buttons\");   putstring(\"Free RAM: \");       // This can help with debugging, running out of RAM is bad   Serial.println(freeRam());      // if this is under 150 bytes it may spell trouble!   // Set the output pins for the DAC control. This pins are defined in the library   pinMode(2, OUTPUT);   pinMode(3, OUTPUT);   pinMode(4, OUTPUT);   pinMode(5, OUTPUT);   // pin13 LED   pinMode(13, OUTPUT);   // Make input & enable pull-up resistors on switch pins   for (i=0; i< NUMBUTTONS; i++) {     pinMode(buttons[i], INPUT);     digitalWrite(buttons[i], HIGH);   }   //  if (!card.init(true))  { //play with 4 MHz spi if 8MHz isn't working for you   if (!card.init()) {         //play with 8 MHz spi (default faster!)      putstring_nl(\"Card init. failed!\");  // Something went wrong, lets print out why     sdErrorCheck();     while(1);                            // then 'halt' - do nothing!   }   // enable optimize read - some cards may timeout. Disable if you're having problems   card.partialBlockRead(true); // Now we will look for a FAT partition!   uint8_t part;   for (part = 0; part < 5; part++) {     // we have up to 5 slots to look in     if (vol.init(card, part))       break;                             // we found one, lets bail   }   if (part == 5) {                       // if we ended up not finding one  :(     putstring_nl(\"No valid FAT partition!\");     sdErrorCheck();      // Something went wrong, lets print out why     while(1);                            // then 'halt' - do nothing!   }   // Lets tell the user about what we found   putstring(\"Using partition \");   Serial.print(part, DEC);   putstring(\", type is FAT\");   Serial.println(vol.fatType(),DEC);     // FAT16 or FAT32?   // Try to open the root directory   if (!root.openRoot(vol)) {     putstring_nl(\"Can't open root dir!\"); // Something went wrong,     while(1);                             // then 'halt' - do nothing!   }   // Whew! We got past the tough parts.   putstring_nl(\"Ready!\");   TCCR2A = 0;   TCCR2B = 1<    //Timer2 Overflow Interrupt Enable   TIMSK2 |= 1<    pinMode(light1, OUTPUT);   pinMode(light2, OUTPUT);   pinMode(light3, OUTPUT);   pinMode(light4, OUTPUT);   pinMode(light5, OUTPUT);   pinMode(light6, OUTPUT);   pinMode(light7, OUTPUT);   pinMode(light8, OUTPUT);   //the SainSmart Relay's are off high   digitalWrite(light1,HIGH);   digitalWrite(light2,HIGH);   digitalWrite(light3,HIGH);   digitalWrite(light4,HIGH);   digitalWrite(light5,HIGH);   digitalWrite(light6,HIGH);   digitalWrite(light7,HIGH);   digitalWrite(light8,HIGH);   Serial.begin(9600); } //void setup() SIGNAL(TIMER2_OVF_vect) {   check_switches(); } void check_switches() {   static byte previousstate[NUMBUTTONS];   static byte currentstate[NUMBUTTONS];   byte index;   for (index = 0; index < NUMBUTTONS; index++) {     currentstate[index] = digitalRead(buttons[index]);   // read the button     /*         Serial.print(index, DEC);     Serial.print(\": cstate=\");     Serial.print(currentstate[index], DEC);     Serial.print(\", pstate=\");     Serial.print(previousstate[index], DEC);     Serial.print(\", press=\");     */     if (currentstate[index] == previousstate[index]) {       if ((pressed[index] == LOW) && (currentstate[index] == LOW)) {           // just pressed           justpressed[index] = 1;       }       else if ((pressed[index] == HIGH) && (currentstate[index] == HIGH)) {           // just released           justreleased[index] = 1;       }       pressed[index] = !currentstate[index];  // remember, digital HIGH means NOT pressed     }     //Serial.println(pressed[index], DEC);     previousstate[index] = currentstate[index];   // keep a running tally of the buttons   } } //********************************************************************************************************** //********************************************************************************************************** void loop() {   byte i; //Make sure you change the name of the file to what you want playfile(\"JOY.WAV\"); joy();     // This is the function that plays joy to the world }//void loop() { //********************************************************************************************************** //********************************************************************************************************** // Plays a full file from beginning to end with no pause. void playcomplete(char *name) {   // call our helper to find and play this name   playfile(name);   while (wave.isplaying) {   // do nothing while its playing   }   // now its done playing } void playfile(char *name) {   // see if the wave object is currently doing something   if (wave.isplaying) {// already playing something, so stop it!     wave.stop(); // stop it   }   // look in the root directory and open the file   if (!f.open(root, name)) {     putstring(\"Couldn't open file \"); Serial.print(name); return;   }   // OK read the file and turn it into a wave object   if (!wave.create(f)) {     putstring_nl(\"Not a valid WAV\"); return;   }   // ok time to play! start playback   wave.play(); } // Function for making the diffrent strands light diffrent void joy() { putstring_nl(\"Start of Joy to the World\");   start = millis();   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(q);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(de);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(s);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(1050);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(s);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(q);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(q);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(dq);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   digitalWrite(light7, LOW);   delay(dq);   digitalWrite(light2, HIGH);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   digitalWrite(light6, LOW);   delay(dq);   digitalWrite(light3, HIGH);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light3, LOW);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   digitalWrite(light6, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(dq);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light3, HIGH);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);                                             //8100   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light8, HIGH);   digitalWrite(light1, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light7, LOW);   delay(e);   digitalWrite(light7, HIGH);     digitalWrite(light2, LOW);   delay(e);   digitalWrite(light2, HIGH);   digitalWrite(light6, LOW);   delay(e);   digitalWrite(light6, HIGH);   digitalWrite(light3, LOW);   delay(de);   digitalWrite(light3, HIGH);   digitalWrite(light5, LOW);   delay(s);   digitalWrite(light5, HIGH);   digitalWrite(light4, LOW);   delay(e);   digitalWrite(light4, HIGH);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light8, HIGH);   digitalWrite(light1, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light7, LOW);   delay(e);   digitalWrite(light7, HIGH);     digitalWrite(light2, LOW);   delay(e);   digitalWrite(light2, HIGH);   digitalWrite(light6, LOW);   delay(e);   digitalWrite(light6, HIGH);   digitalWrite(light3, LOW);   delay(de);   digitalWrite(light3, HIGH);   digitalWrite(light5, LOW);   delay(s);   digitalWrite(light5, HIGH);   digitalWrite(light4, LOW);   delay(e);   digitalWrite(light4, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(e);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(e);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);                                            //13806   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(75);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(75);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(dq);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(75);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);                                              //15235   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(75);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(e);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(e);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(e);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(75);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(75);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(dq);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(75);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);                                     //17339   digitalWrite(light2, LOW);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   digitalWrite(light7, LOW);   delay(75);   digitalWrite(light2, HIGH);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   digitalWrite(light6, LOW);   delay(e);   digitalWrite(light3, HIGH);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light3, LOW);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   digitalWrite(light6, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(q);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light3, HIGH);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);                                      //18315   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(e);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(de);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(s);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   delay(e);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light3, LOW);   digitalWrite(light6, LOW);   delay(e);   digitalWrite(light3, HIGH);   digitalWrite(light6, HIGH);   putstring_nl(\"      \");               //19817   digitalWrite(light2, LOW);   digitalWrite(light7, LOW);   delay(300);//delay(q);   digitalWrite(light2, HIGH);   digitalWrite(light7, HIGH);    now = millis();   time = now - start;   Serial.println(time);                //20117   digitalWrite(light1, LOW);   digitalWrite(light8, LOW);   delay(300);//delay(q);   digitalWrite(light1, HIGH);   digitalWrite(light8, HIGH);   putstring_nl(\"   last bit   \");                                     // 21018   digitalWrite(light1, LOW);   digitalWrite(light2, LOW);   digitalWrite(light3, LOW);   digitalWrite(light4, LOW);   digitalWrite(light5, LOW);   digitalWrite(light6, LOW);   digitalWrite(light7, LOW);   digitalWrite(light8, LOW);   delay(h);   digitalWrite(light1, HIGH);   digitalWrite(light2, HIGH);   digitalWrite(light3, HIGH);   digitalWrite(light4, HIGH);   digitalWrite(light5, HIGH);   digitalWrite(light6, HIGH);   digitalWrite(light7, HIGH);   digitalWrite(light8, HIGH);   delay(000);   putstring_nl(\"end of the song\");   end = millis();   time = end - start;   Serial.println(time);   Serial.println(start);   Serial.println(end); }", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 14: Software"}], "channel": "Arduino"}, {"category": "technology", "description": "In this lesson, let\u2019s try something interesting \u2013gradually changing the luminance of an LED through programming. Since the pulsing light looks like breathing, we give it a magical name - breathing LED. We\u2019ll accomplish this effect with pulse width modulation (PWM)", "title": "Breathing LED With Arduino Uno R3", "url": "https://www.instructables.com/id/Breathing-LED-With-Arduino-Uno-R3/", "section": "technology", "steps": [{"step": 1, "steps_text": "- Arduino Uno board * 1- USB cable * 1- Resistor (220\u03a9) * 1- LED * 1- Breadboard * 1- Jumper wires", "step_imgs": [], "step_title": "Step 1: Components"}, {"step": 2, "steps_text": "Pulse width modulation, or PWM, is a technique for getting analog results with digital means. Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between full on (5 Volts) and off (0 Volts) by changing the portion of the time the signal spends on versus the time that the signal spends off. The duration of \"on time\" is called pulse width. To get varying analog values, you change, or modulate, that width. If you repeat this on-off pattern fast enough with some device, an LED for example, it would be like this: the signal is a steady voltage between 0 and 5V controlling the brightness of the LED. (See the PWM description on the official website of Arduino).In the graphic below, the green lines represent a regular time period. This duration or period is the inverse of the PWM frequency. In other words, with Arduino PWM frequency at about 500Hz, the green lines would measure 2 milliseconds each.A call to analogWrite() is on a scale of 0 - 255, such that analogWrite(255) requests a 100% duty cycle (always on), and analogWrite(127) is a 50% duty cycle (on half the time) for example.You will find that the smaller the PWM value is, the smaller the value will be after being converted into voltage. Then the LED becomes dimmer accordingly. Therefore, we can control the brightness of the LED by controlling the PWM value.", "step_imgs": ["https://cdn.instructables.com/FQO/8QCK/JRGOOHON/FQO8QCKJRGOOHON.LARGE.jpg"], "step_title": "Step 2: \u200bPrinciple"}, {"step": 3, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F08/2GEW/JRGOOHOM/F082GEWJRGOOHOM.LARGE.jpg"], "step_title": "Step 3: The Schematic Diagram"}, {"step": 4, "steps_text": "By programming, we can use the analogWrite() function to write different values to pin 9. The luminance of the LED will change based on that. On the SunFounder Uno board, pin 3, 5, 6, 9, 10, and 11 are the pins of PWM (with \u201c~\u201c marked). You can connect any of these pins.Step 1:Build the circuit.Step 2:Download the code from https://github.com/primerobotics/ArduinoStep 3:Upload the sketch to the Arduino Uno boardClick the Upload icon to upload the code to the control board.If \"Done uploading\" appears at the bottom of the window, it means the sketch has been successfully uploaded.Here you should see the LED gets brighter and brighter, then slowly dimmer, and again brighter and dimmer repeatedly, just like breathing.", "step_imgs": ["https://cdn.instructables.com/FCA/Z2QZ/JRGOOHU4/FCAZ2QZJRGOOHU4.LARGE.jpg", "https://cdn.instructables.com/F9H/378Y/JRGOOHU7/F9H378YJRGOOHU7.LARGE.jpg"], "step_title": "Step 4: \u200bProcedures"}, {"step": 5, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FHS/2JBL/JRGOOHVG/FHS2JBLJRGOOHVG.LARGE.jpg"], "step_title": "Step 5: Code Analysis"}], "channel": "Arduino"}, {"category": "technology", "description": "This is a neat project I picked up about a month ago. It's a simple project allowing you to transfer sound across a space on light with little quality loss. The credit of this project goes here", "title": "Transfer Sound on a Laser", "url": "https://www.instructables.com/id/Transfer-Sound-on-a-Laser/", "section": "technology", "steps": [{"step": 1, "steps_text": "Things You Will Need:\rTwo Mono Jacks\r1 Audio Transformer\r1 Solar Resistor\r1 Laser\r1 Single AA Battery Clip (for reciever)\r1 Triple AAA Battery Clip (for laser)\rBatteries (1 AA, 3 AAA's)\rSome wires and tape\rA breadboard is optional, but I chose to use one to save time.", "step_imgs": ["https://cdn.instructables.com/F8J/TG9Q/1FIEP27YKI9/F8JTG9Q1FIEP27YKI9.LARGE.jpg"], "step_title": "Step 1: Gather Your Materials"}, {"step": 2, "steps_text": "Start by adding two wires to the leads of a mono jack. This will be the input of your transmitter.", "step_imgs": ["https://cdn.instructables.com/F5V/6G0Z/XHHEP27YKDZ/F5V6G0ZXHHEP27YKDZ.LARGE.jpg"], "step_title": "Step 2: Add a Mono Jack"}, {"step": 3, "steps_text": "Next we add the first two wires of our audio transformer. Connect the red and white leads of the transformer to the mono jack.", "step_imgs": ["https://cdn.instructables.com/FOT/1EQO/ID7EP27YKCW/FOT1EQOID7EP27YKCW.LARGE.jpg"], "step_title": "Step 3: Add the Transformer"}, {"step": 4, "steps_text": "The blue and green leads need to be connected to the breadboard and will later be connected to the laser. The middle black lead will not lead to anything, so it's best to wrap a piece of electrical tape around it, as I have done.", "step_imgs": ["https://cdn.instructables.com/FW5/9Q54/C5LEP27YKBT/FW59Q54C5LEP27YKBT.LARGE.jpg"], "step_title": "Step 4: Connect the Other Leads"}, {"step": 5, "steps_text": "Next we add the laser. The green lead of the transformer connects to the negative lead of the laser, and the positive lead of the laser leads to the positive lead of the battery. If everything is connected properly, you should be able to turn your laser on. This is the completed transmitter.", "step_imgs": ["https://cdn.instructables.com/FOR/6KD4/4EIEP27YKAQ/FOR6KD44EIEP27YKAQ.LARGE.jpg"], "step_title": "Step 5: Complete the Transmitter"}, {"step": 6, "steps_text": "Now that the transmitter is built, you can use it. Simply connect an audio source (such as a CD player) to the mono jack and turn on the laser. The modulations of current produced by the audio device causes the laser to modulate accordingly. It will get slightly dimmer and brighter, depending on the music. However, this is very difficult to detect by the human eye, and it isn't particularly useful. In order to make the circuit useful, we need build a reciever.", "step_imgs": [], "step_title": "Step 6: Using the Circuit"}, {"step": 7, "steps_text": "The reciever is the easiest part. Connect your second mono jack to the solar resistor and battery. You can even place it on the same breadboard, as I have. Just make sure you keep the circuits seperate.\rUse:\rAs stated before, connect an audio source to the first mono jack (the one connected to the laser) and turn the laser on. Connect the other jack to a reciever (such as an amp or the mic. port of your computer) and aim the laser at the solar resistor. The light modulation of the laser are reversed on the reciever and converted back into sound.", "step_imgs": ["https://cdn.instructables.com/F67/TB44/0E8EP27YK9N/F67TB440E8EP27YK9N.LARGE.jpg"], "step_title": "Step 7: Building the Reciever and Using the Device"}, {"step": 8, "steps_text": "Instead of using a battery and solar resistor, you could just use a small solar panel. However, these are more expensive and tend to break more easily.\rTheory: It may be possible to bounce the laser of glass behind which a conversation is occuring (such as a window) and pick up the sounds on the reciever, but I've yet to test it. Please let me know if anyone has tried this or has a better way to do this.", "step_imgs": [], "step_title": "Step 8: Alternate Construction and Theory"}], "channel": "Lasers"}, {"category": "technology", "description": "Have you ever wondered what sound waves would look like. Yes, we all know what a wave looks like. But if you asked me what a 400Hz looks like, I would probably draw a sine wave on a piece of paper and that would be it. I might calculate the length of the wave and tell you that it is 850mm. The velocity of the wave divided by the frequency. For sound waves of 400Hz in air that would be 343 meter/second divided by 400 = 0.85 meter.Time for some visuals. In the past I experimented a lot with slow shutter speed photography and arduino's. Those two could be the answer to my quest. Showing a sound wave with the correct length.This project was created during an Arduino-Jam at Timelab in Ghent (Belgium). I won the 9th edition of the jam with this project. Thanks to all the other contestants and the superb organization.Another similar project on Instructables: Imprint invisible sound and radio waves onto your retina: Augmented reality with perfect alignment by Steve Mann", "title": "SoundWave Printer", "url": "https://www.instructables.com/id/SoundWave-Printer/", "section": "technology", "steps": [{"step": 1, "steps_text": "I did some test with an arduino uno, M0. But finally settled on a teensy 3.x, because it gave me the fasted ADC sound wave sample speed.What you need to build the SoundWave Printer:Teensy 3.1 electret microphone rotary encoder 1K Ohm resistor 2x Neopixel stick (Adafruit) 1000 uF capacitor 330 Ohm resistor", "step_imgs": ["https://cdn.instructables.com/FZ7/T1FN/ILV88IWD/FZ7T1FNILV88IWD.LARGE.jpg"], "step_title": "Step 1: What Do We Need to Build a SoundWave Printer"}, {"step": 2, "steps_text": "I'll used an electret microphone without any amplification to keep things simple. And 1K Ohm resistor is placed between 3.3V and the positive side of the electret microphone.The Teensy has a 12bit ADC, which gave me enough room to capture my sound.To capture exact the length of one meter of sound wave, one would need to sample for 1 sec / 343 meter = 0.00291545189 sec or 2915 microseconds.With the Teensy I managed to have around 112 sample within 2915 microseconds. More then enough to show on one meter. I stored them in an arrayunsigned int startCounting = micros() + 2915;\n\nunsigned int counter = 0;\n\nwhile(micros() < startCounting ) {\n    soundSampleArray[counter] = analogRead(microphonePin);\n    delayMicroseconds(15); // Needed for the ADC to settle\n    counter++;\n\n}Because I'm not using any amplification the difference between my min and max reading is not that much. To maximally use the 16 pixel high display, I'll have to calibrate my data. void readSoundWaveSample () {  Serial.println(\"start reading\");\n  int maxR = 0;\n  int minR = 4096;\n  long totalCal = 0;\n  int calRead;\n  \n  unsigned int startCounting = micros() + 2915;\n  unsigned int counter = 0;  while(micros() < startCounting ){\n    calRead = analogRead(MICROPHONE_PIN);\n    soundSampleArray[counter] = calRead;    if (calRead > maxR) {\n      maxR = calRead;\n    }\n    if (calRead < minR) {\n      minR = calRead;\n    }\n    totalCal = totalCal + calRead;\n    \n    counter++;\n    delayMicroseconds(15);\n  }  calDif = ((maxR - minR)/2);\n  calMid = totalCal/counter;\n  \n  Serial.println(\"done reading\");\n  amountOfSamples = counter;\n}I'll use calMid and calDif to map my data.CalMid is the middle of my wave. CalMid minus calDif is the bottom of the wave, calMid plus calDif is the top of the wave.I'll use amountOfSamples later to map my data to the amount of steps I have per meter. In my case it happend to be 340 steps, with my 12 click rotary encoder.", "step_imgs": [], "step_title": "Step 2: Capture Sound Waves"}, {"step": 3, "steps_text": "I'm going to move a Neopixel led stick of 16 leds over a distance of one meter and map my recorded SoundWave on the 16 leds. I opted for making a little cart with one encoder wheel that returns the position of the cart.The encoder and the wheel gave me 340 steps for one meter. (I measured this with a different sketch).When I rol the cart I'll get a position from the rotary encoder. Then I would map this position to a sample in my soundSampleArray. Then I would map the data of that soundSample to one of the 16 led's.myEnc.write(0); // set encoderPosition to 0\n\noldPosition = 0; // oldPosition to 0\n\nstepsPerMeter = 340; // amount of steps for covering one meter\n\nwhile(oldPosition < stepsPerMeter) {\n\n   long newPosition = myEnc.read(); // read new encoder position\n\n   if (newPosition != oldPosition) {\n\n      oldPosition = newPosition; \n\n      int myArrayPos = map(newPosition, 0, stepsPerMeter ,0 ,soundSampleSize );\n\n      outputValue = map(soundSampleArray[myArrayPos] ,calMid-calDif ,calMid+calDif ,0 ,16 );\n\n      // print to led stick\n\n      for(uint16_t i=0; i < strip.numPixels(); i++) {\n\n         if (i == outputValue) {\n\n            strip.setPixelColor(i,255,0,0);\n\n         } else {\n\n            strip.setPixelColor(i,0,0,0);\n\n         }\n\n      }\n\n      strip.show();\n\n   }\n\n}", "step_imgs": ["https://cdn.instructables.com/FKK/97Q7/ILV8L0I8/FKK97Q7ILV8L0I8.LARGE.jpg", "https://cdn.instructables.com/FAW/CRS9/ILV8L0IE/FAWCRS9ILV8L0IE.LARGE.jpg"], "step_title": "Step 3: Print the SoundWave"}, {"step": 4, "steps_text": "I threw all of this together on a breadboard and mounted it on a piece of scrap acrylic.Neopixel has the 5V from usbV. And dataline on 6.Rotary encoder is connected to 7 & 8.The mircophone is connected to A0.I added some kind of user interface to it.SoundWave printer ready => all leds ON, pink Record sound by turning the wheel SoundWave is recorded => all leds ON, green SoundWave printer ready to print => all leds OFF Drag the SoundWave printer while taking a long exposure photograph Watch your SoundWave printed in the air.", "step_imgs": ["https://cdn.instructables.com/F3F/U4AL/ILV88TTM/F3FU4ALILV88TTM.LARGE.jpg", "https://cdn.instructables.com/FHK/8CLZ/ILV8L0IB/FHK8CLZILV8L0IB.LARGE.jpg", "https://cdn.instructables.com/F0V/5FGH/ILV8L0I9/F0V5FGHILV8L0I9.LARGE.jpg"], "step_title": "Step 4: The SoundWave Printer"}, {"step": 5, "steps_text": "Download the code from git.", "step_imgs": ["https://cdn.instructables.com/FQA/0UR9/ILV8L0IA/FQA0UR9ILV8L0IA.LARGE.jpg", "https://cdn.instructables.com/FSB/1902/ILV8L0J6/FSB1902ILV8L0J6.LARGE.jpg"], "step_title": "Step 5: The Code"}], "channel": "Art"}, {"category": "technology", "description": "In this project, fast fourier transform(fft) is used to convert analog data from time domain to frequency domain. We need to map the amplitude of each frequency bands (14 bands in total) and for all of the frequency bands into RGB. To further make the matter more complicated, Amplitude transition within each frequency band should be represented with the intensity/lumen of the RGB via the use of Pulse width modulation (PWM), follow by hue/fading when transition in-between frequency bands. In other words, the idea is to 1. Arrange the frequency bands into 3 \"groups\", low mid and high frequency and \"map\" into R, G then B. 2. Amplitude of each frequency band would translate into the brightness/intensity of each color using Pulse width modulation (PWM). 3. Cycling from one frequency band to another, the R<->G<->B would \"fade\" by changing the hue of each color.", "title": "Music to RGB Leds", "url": "https://www.instructables.com/id/Music-to-RGB-leds/", "section": "technology", "steps": [{"step": 1, "steps_text": "Firstly, an arduino shield was made using uln2003a darlington. It uses 3PWM on arduino to control brightness of RGB LEDs. The component side of stripboard is soldered on the connecting copper side instead.", "step_imgs": ["https://cdn.instructables.com/FK9/KK6P/H5E9JQ2Q/FK9KK6PH5E9JQ2Q.LARGE.jpg", "https://cdn.instructables.com/F73/5TYD/H5E9PTGH/F735TYDH5E9PTGH.LARGE.jpg"], "step_title": "Step 1: "}, {"step": 2, "steps_text": "This is how the RGB led strip looks like. We would need a LED driver circuit to power up long stretch of them. The shield can drive up to 6RGB LEDs with 12v 800mAH NiCad battery.", "step_imgs": ["https://cdn.instructables.com/FQO/4KT4/H5ECMSDW/FQO4KT4H5ECMSDW.LARGE.jpg"], "step_title": "Step 2: "}, {"step": 3, "steps_text": "Now, for the connection part Using a 3.5mm\" stereo jack to tap audio signal from computer/smart phone into A0 of arduino. PWN pin 9,10,11 are use for controlling the RGB. The arduino shield (it has a darlington IC) is used to \"switched\" 12v for the RGB LED strip with PWM.", "step_imgs": ["https://cdn.instructables.com/FUX/F3MP/H5E9PTGW/FUXF3MPH5E9PTGW.LARGE.jpg", "https://cdn.instructables.com/FD9/71UV/H5ECMSDZ/FD971UVH5ECMSDZ.LARGE.jpg"], "step_title": "Step 3: "}, {"step": 4, "steps_text": "The FFT\u00a0 library should be added to the arduino\\lib\\ folder to compile successfully. Fix_fft library: http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1286718155 Code :\u00a0 snipt.org/vvY4", "step_imgs": [], "step_title": "Step 4: Software"}, {"step": 5, "steps_text": "", "step_imgs": [], "step_title": "Step 5: Video"}], "channel": "Arduino"}, {"category": "technology", "description": "In this tutorial i will show you how to make a Music reactive or Sound activated LED strip lights. You can watch the video which is embedded in this step for construction, parts list, circuit diagram & testing or you can continue reading the post for further details.", "title": "Music Reactive or Sound Activated LED Strip Lights", "url": "https://www.instructables.com/id/Music-Reactive-or-Sound-Activated-LED-Strip-Lights/", "section": "technology", "steps": [{"step": 1, "steps_text": "1 * LM324 1 * BD139  2 * 1N4007  2 * 5.7k Ohm  2 * 10k Ohm  2 * 90k Ohm  1 * 5k Pot  1* 120 Ohm  1 * 2 way switch  1 * LED Strip light  1 * 12v LED Driver adapter  2 * 3.5mm Female Audio Jack  1 * Linear Pot Knob  1 * DC Socket  1 * 14 Pin IC socket  1 * 2 Pin Terminal Block***Affiliate Links***LM324 -  https://goo.gl/bbfd6Q 14 Pin IC Socket -  https://goo.gl/RnSWa4 BD139 -  https://goo.gl/9StC9e 2 way Switch -  https://goo.gl/1JaXhT LED Strip Light -  https://goo.gl/7Z9wpx 2 Pin Terminal Block -  https://goo.gl/DjPsduIf you wish to support my content, then you can do by using my affiliate links given below, this way i get small commission for your purchases.Bangood -  https://goo.gl/ZUhRmV AliExpress -  https://goo.gl/jioyhVAmazon USA -   http://amzn.to/2u7ztbP Amazon UK -  http://amzn.to/2wu4nYP Amazon India -  http://amzn.to/2hroLHz Flipkart -  http://fkrt.it/Pyiv9TuuuN", "step_imgs": ["https://cdn.instructables.com/FGT/2VLF/JAMU2WD9/FGT2VLFJAMU2WD9.LARGE.jpg", "https://cdn.instructables.com/F8U/08FA/JAMU2WDC/F8U08FAJAMU2WDC.LARGE.jpg", "https://cdn.instructables.com/F0N/OKPD/JAMU2WDE/F0NOKPDJAMU2WDE.LARGE.jpg"], "step_title": "Step 1: Parts List"}, {"step": 2, "steps_text": "Please Note: there is a little error in the circuit diagram shared. Please connect the Anode (+) of the LED to the 12 volt & Cathode (-) of the LED to the two way switch.For construction of this project we are using LM324 which is an Quadruple Operational Amplifier. In our case, out of 4 we are using only 2. The LM324 is arranged to be an comparator.The 2 way switch is used to select the modes. There are two modesLight Mode : this is the normal mode. directly connected      Audio Mode: in this mode the LED light reacts according to the music or soundThe pot is used to select the brightness of the LED Strip when it is in Audio Mode. The pot is optional.Note : in my circuit i have connected R1 with 90k & 10k in series to make it 100k ohm. For testing of the circuit please watch the video embedded in the initial step or CLICK HEREThank You for reading & watching For more such contents please visit & subscribe to my YouTube Channel by CLICKING HERE.", "step_imgs": ["https://cdn.instructables.com/FI4/8XDS/JAMU2WDF/FI48XDSJAMU2WDF.LARGE.jpg", "https://cdn.instructables.com/FK5/Q567/JAMU2WDG/FK5Q567JAMU2WDG.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram & Other Details"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          \u00a0\nA full featured driver board to control Red, Green, & Blue LEDs. When paired with the correct output board, it can control any arrangement of LEDs. Common Cathode, Common Anode, single color LEDs. From 1/8 watt LEDs to 3 watt LED arrangements.\n4 stand-alone modes. Fade & Flash with speed adjustment via\u00a0potentiometer. Manual color select via the same\u00a0potentiometer. Sound reactivity with sensitivity\u00a0adjustment\u00a0and secondary\u00a0adjustment.\nFull DMX-512 addressing. Connect to a DMX Controller or a DMX computer program. 5 channels for Red, Green, Blue, Function, Speed.\nEasy to control, a 3 position switch, a\u00a0potentiometer\u00a0for adjustment, and another\u00a0potentiometer\u00a0for sound sensitivity. 10 position DIP switch, 1-9 for DMX address, DIP 10 is for standalone controls.Datasheet Can Be Found Here, For More Files and Updates Visit My Main Website\nWith the supplied breakout boards, upwards of 40 watts per color channel can be\u00a0achieved.\nShown below is a 36 Watt\u00a0RGB LED Wash Light built using this driver.View My Other Projects on My Profile\n*Note some of the images show the V.1 PCB, and the diagrams show the V.2, the only difference is trace width and RHEO&MIC share a 3-pin header instead of two 2-pin headers.\nUPDATE: This kit is discontinued, Please View my new DMX-512 LED Controller with LED Display. All of the same features except sound\u00a0reaction, in a smaller, cheaper, easier to use form.\n\t\u00a0", "title": "DMX-512 RGB LED Wash Light Control Board", "url": "https://www.instructables.com/id/DMX-512-RGB-LED-Wash-Light-Control-Board/", "section": "technology", "steps": [{"step": 1, "steps_text": "Kits for this Entire Project can Purchased in My Store\u00a0\nKits including a 3 watt RGB LED Can Be Found Here\nIf not all the parts are required, ex. No DIP Switch, XLRs, sound control\nPlease Contact Me and I can put together a customized Kit.Parts:\n- PCB\n- PIC 16F688, programmed\n- PIC\u00a016F88, programmed\n- LM386\n- 20 mhz Series Oscillator\n- 8-pin socket\n- 14-pin socket\n- 18 pin socket\n- 10 position DIP Switch, DMX address selection\n- Triple Pole Triple Pole Switch, Stand-Alone Mode Selection\n- 15x 10k 1/4w Resistors\n- 1x 1k ohm 1/4w resistor, R2\n- 7805, TO-220 Voltage Regulator\n- 1x 1uF 100v Capacitor, C1\n- 1x 1uF 25v Capacitor, C2\n- 2x 10uF capacitor, C6 & C7\n- 2x 0.1uF disc Capacitor, C4 & C3\n- 1x Panel Mount Male XLR\n- 1x Panel Mount female XLR\n- 1x Electret Microphone\n- 1x 10k ohm\u00a0Logarithmic\u00a0Potentiometer\n- 1x Common Cathode RGB LED for Testing.\n- 1x 2-pin Header & Housing\n- 2x 3-pin Header & Housing\n- 1x 4-pin Header & Housing\n- 1x 6-pin header & Housing\n- 1x 12-pin Header & housing\n- Crimps\n- A Breakout board, chosen for the correct use. Just Ask\n\u00a0\u00a0 \u00a0Or a different form of current regulation that accepts TTL PWM, such as BuckPlus LinePart Images and Description\n.", "step_imgs": ["https://cdn.instructables.com/FSJ/2LBF/GDRPYNKV/FSJ2LBFGDRPYNKV.LARGE.jpg", "https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg"], "step_title": "Step 1: Layout the Parts"}, {"step": 2, "steps_text": "\nResistors first.\n\u2022 R1 is 10k ohm, Brown - Black - Orange - Gold\n\u2022 R2 is 1k ohm mounted vertically, Brown - Black - Red - Orange\n\u2022 R7 - R21 Are all 10k ohm 1/4w, Brown - Black - Orange - Gold\nThere is a 16 pin, 14 pin and 8 pin socket to place.\u00a0Align the notch on the socket to the notches on the top-side illustration.\n\u2022 Carefully align the pins with their holes, check all the pins will go in and press the socket in firmly.\u00a0", "step_imgs": ["https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg", "https://cdn.instructables.com/F0Z/G2QH/GDRPMSRM/F0ZG2QHGDRPMSRM.LARGE.jpg", "https://cdn.instructables.com/F40/Q3Q4/GDRPMSRO/F40Q3Q4GDRPMSRO.LARGE.jpg"], "step_title": "Step 2: Resistors and Sockets"}, {"step": 3, "steps_text": "\nOscillator:\n- Find the 20mhz oscillator and solder it into OSC. It has no polarity but Make sure its a good solder joint.\nCapacitors Next.The top-side illustration shows their polarity, the black solid stripe is the negative lead.\n\u00a0\n- Find the two 1uF caps that will be soldered into C1 & C2. They do have polarity, the side with the stripe is the negative lead.\n- Place the two 10uF capacitors next. C6 & C7. Again mind the polarity.\n- Finally place a 0.1uF disc capacitor in C3 & C4. They have no polarity and can go in either way.\nA mistake was made on the part naming and there is no C5.", "step_imgs": ["https://cdn.instructables.com/FB8/L6VU/GDRPMSTC/FB8L6VUGDRPMSTC.LARGE.jpg", "https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg"], "step_title": "Step 3: Oscillator and Capacitors"}, {"step": 4, "steps_text": "\nPolarized headers allows wires to be plugged and unplugged from the PCB easily. This project has a lot of switches,\u00a0potentiometers, mic, that aren't on the board and have wires running to them. The wires are connected to crimps and the crimps are slid into the housings, more details on Step 6\nDepending on kit variation some or all of these headers may be included. They are not\u00a0necessary\u00a0but make things easier. With out them the wires of the switches ect will need to soldered directly onto the board, making installation harder.\nI would recommend to try not to use a header and just solder the wires in directly to the PCB where possible.\nThere is an illustration of how the headers should be placed on the board. They have a polarized friction lock so a switch or voltage input cannot be plugged in backwards later.\nThere is a 12-pin, 6-pin, 3-pin, and 3x 2-pin headers to solder.\nPress them firmly in, flush with the PCB and start soldering. Careful not to bridge solder joints.\n- The 12-pin is for the 10-position DIP switch for DMX Address Selection and Mode Select.\n- The 6-pin header is for the Mode Switch and Speed\u00a0Potentiometer.\n- The 3-pin is for XLR hook-ups\n- A 2-pin header labled PWR is for voltage input, polarity marked on the PCB\n*UPDATE: The polarity markings are reversed on the PCB\n- The last two 2-pin headers are for sound input(rheostat and microphone), it is optimal to not install these headers and to wire the rheostat and mic directly PCB.", "step_imgs": ["https://cdn.instructables.com/F7H/858Z/GDRPHHTO/F7H858ZGDRPHHTO.LARGE.jpg"], "step_title": "Step 4: Interconnect Headers"}, {"step": 5, "steps_text": "\nNow that almost all the rest of the components are placed, its a good time to do all the jumpers. Which are used instead of dual-layer PCBs.\u00a0\nUse some solid-strand wire and carefully find a route for the jumpers to follow, the path shouldn't ever cross over another jumper wire.\nThe jumpers are as follows:\nJA1 goes to JA2\nJB1 goes to JB2\nJC1 goes to JC2\ncontinues to JF1&2\n*Note: JC4 is a misprint, ignore it.\nFinal Jumpers: if the output doesn't need the resistors to be used, jump the resistors R3, R4, and R5\u00a0\nFinally Place the 7805 as pictured. Solder it in well.", "step_imgs": ["https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg", "https://cdn.instructables.com/FOO/9JBN/GDRPHHUC/FOO9JBNGDRPHHUC.LARGE.jpg", "https://cdn.instructables.com/FN5/M0WJ/GDRPTR3A/FN5M0WJGDRPTR3A.LARGE.jpg"], "step_title": "Step 5: Jumpers & 7805 Regulator"}, {"step": 6, "steps_text": "\nIf board interconnects are being not being used skip this step. To continue the rest of the steps some interconnects will need to be wired. Part Pictures and Explaination\nTo start this step you will need to know how long you will want your wires for the various attachments. All of them are all made pretty much the same so I will only explain how to make the 6-wire interconnect with dual stranded wire. As pictured below.\n- Start with 3 equal lengths of dual stranded wire. \u00a0Total of 6 wires.\n- Strip a 1/8\" of insulation off the ends of the strands.\nCrimps will have to be attached to one end of the wires.\nI have an External Crimp Tutoral Page Covering the Process\nOnce you have 6 wires with one crimp on each wire. Get a housing that is the right size.\nEach crimp should slide into the housing and snap into it. They only fit in one way. Just press them in until they \"snap\"\nThe rest of the interconnects, power, mic, sound potetiometer, DIP Switch are all made the same but with a different size housing.", "step_imgs": ["https://cdn.instructables.com/F0C/VIRL/GDRPYNOP/F0CVIRLGDRPYNOP.LARGE.jpg", "https://cdn.instructables.com/F8I/6MB2/G4D5X56O/F8I6MB2G4D5X56O.LARGE.jpg"], "step_title": "Step 6: Prepare Interconnects"}, {"step": 7, "steps_text": "\nStart with the switch, the mode switch included in the kit is a double pole, triple throw and it needs to get jumped so it can act as a 3 position switch. It is used for stand-alone function selecting.\n- Just use a resistor clipping and solder in as pictured.\nNext the 6-pin interconnect for the previous step needs to be soldered to the switch. Reference the top-side illustration and the chart below to figure out what wires will need to go where on the mode switch or the speed pot.\n6 Pin Header Pinout for Mode Switch\n1. Control Pot. Center Tap\n2. DMX Select\n3. Auto Select\n4. Manual/Audio Select\n5. Negative, 0 volts\n6. Positive, +5 volts\n- DMX Select, Auto Select and Manual select are soldered to a position on the switch.\n- Negative gets soldered to the pins on the switch that were jumped, and another strand of wire is used to go from negative to a side lug on the control pot.\n- Control Pot is soldered to the center lug on the 2.5k ohm panel mount\u00a0potentiometer.\n- Positive is soldered to the remaining lug on the control pot.", "step_imgs": ["https://cdn.instructables.com/F8J/WXFP/GDRPMT3I/F8JWXFPGDRPMT3I.LARGE.jpg", "https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg", "https://cdn.instructables.com/FNI/8NR2/GDRPHHUM/FNI8NR2GDRPHHUM.LARGE.jpg", "https://cdn.instructables.com/F0M/APQE/GDRPMT3P/F0MAPQEGDRPMT3P.LARGE.jpg"], "step_title": "Step 7: Wire Mode Switch and Speed Pot"}, {"step": 8, "steps_text": "\nThe RHEO&MIC is used for Sound Input Controls, the left hole is for the Rheostat, center hole is shared between one lead of the rheo and one lead of the MIC, right hole is for the MIC.Sound\u00a0Potentiometer - Adjusts Sound Reactive Sensitivity\n- The potentiometer needs to be used as a Rheostat for this part.\n- One of the outer leads on the potentiometer should be soldered to the center lead. See Image\n- One lead goes to the Rheo Hole, the other connection goes to the shared center hole.Microphone - Listens for sound input.\n- The electret mic has 2 solder pads, One is soldered to the MIC hole and the other is soldered to the shared center hole.DIP Switch - 9 Positions are used for DMX Address and One is used for Stand-Alone Control. All the positions are pulled-up with the 10k resistors. And are \"ON\" when connected to GND.\nDIP1 on the PCB is Positive and not needed\nDIP2 is Ground, one side of the DIP switch will be wired to Ground\nDIP3 is Binary 1\nDIP4 is Binary 2\nDIP5 is Binary 4\nDIP6 is Binary 8\nDIP7 is Binary 16\nDIP8 is Binary 32\nDIP9 is Binary 64\nDIP10 is Binary 128\nDIP11 is Binary 256\nDIP12 is for Stand-Alone Mode Selection.\n- There are 2 rows of pins on the DIP Switch, one side/half of the pins are all connected together and attached to Ground(DIP2 on the PCB)\n- The other row of pins each needs to be connected to its proper place on the PCB.", "step_imgs": ["https://cdn.instructables.com/F4E/MTIC/GE39IF7A/F4EMTICGE39IF7A.LARGE.jpg", "https://cdn.instructables.com/FZR/YVEU/GE39IF9P/FZRYVEUGE39IF9P.LARGE.jpg", "https://cdn.instructables.com/F8B/2LI0/GE38R1VM/F8B2LI0GE38R1VM.LARGE.jpg", "https://cdn.instructables.com/FGK/YPV4/GE38T7DV/FGKYPV4GE38T7DV.LARGE.jpg"], "step_title": "Step 8: DIP Switch, Mic, Sound Pot"}, {"step": 9, "steps_text": "\nA Panel Mount Male and Female XLR Connectors are included with the kit.\nBefore doing this step, figure out how long the wires will need to be to connect the XLRs.\nThe pins on the connectors are\u00a0labeled\u00a01, 2 & 3. They are connected as follows.\nPCB PIn 1 connects to XLR 2\nPCB Pin 2 connects to XLR 3\nPCB Pin 3 connects to XLR 1\nBoth the male and female are connected the same.", "step_imgs": ["https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg", "https://cdn.instructables.com/FSO/IJOQ/GE4014ZV/FSOIJOQGE4014ZV.LARGE.jpg"], "step_title": "Step 9: XLR Connectors"}, {"step": 10, "steps_text": "\nThere are 4 ICs to plug into their sockets. Line up the dot near pin 1 on each of the ICs with the notch on the end of the IC sockets.\n- Align all the pins of each IC with their socket and press in firmly.\n- Plug in all the ICs ", "step_imgs": ["https://cdn.instructables.com/F09/KBFV/GDRPHHQ2/F09KBFVGDRPHHQ2.LARGE.jpg"], "step_title": "Step 10: Plug in the ICs"}, {"step": 11, "steps_text": "\nTo power anything more substantial than a single RGB LED, a breakout \u00a0board is used.\nA board is chosen depending on the LED setup to be used. They come in Resistor regulated Common-Anode, Resistor regulated Common Cathode Configuration and Constant-Current Regulated board.\nThe Supplied Resistor Regulated boards are meant for multiple small LEDs or a few high-wattage LEDs, R4, R5, & R6 are large enough for a 2 or 3 watt Resistors. MOSFETs included with the boards can handle up to 46 watts each.\nFor very large units, I have had good success with the BuckPlus Line of constant current regulators. See Here\nWhen ordering a kit, either decide what kind you will need or Contact Us for Help choosing.Testing:\nTo test if the PCB is working properly attach the included Common Cathode RGB LED to the\n\" - R G B\" Header.\n- First Attach a 100-500 ohm resistor in series with the common cathode( ground, its longest lead)\n- Then wire up the rest of the leads to the correct header pin. See Diagram.", "step_imgs": ["https://cdn.instructables.com/FG0/RQ1S/GE39IFGD/FG0RQ1SGE39IFGD.LARGE.jpg", "https://cdn.instructables.com/FHQ/1207/GE38R1WD/FHQ1207GE38R1WD.LARGE.jpg", "https://cdn.instructables.com/FND/ER4N/G9GQIMX7/FNDER4NG9GQIMX7.LARGE.jpg", "https://cdn.instructables.com/FSZ/D8QC/GE39IKMP/FSZD8QCGE39IKMP.LARGE.jpg"], "step_title": "Step 11: Breakout Board and Testing"}, {"step": 12, "steps_text": "\nI have built a 36 watt(12 watts per color) Wash Light and a few smaller 9 watt Wash Lights using 3 watt Single Color LEDs, and one of these drivers.\nThe 36 watt is pictured. Completely custom case, with all the user controls on one side. Some 07023-D-E-700 Buck-pucks from LuxDrive power the strings of 4x 3 watt LEDs per channel in series. A 24v @ 2.7A PSU is used to power it all. I really like the Buckpucks for simplicity and they are easy to adjust the colors for that perfect mixture. But they are on the expensive side.Information on my Main Site\n\u00a0I plan on building a new 9 watt can utilizing 3 watt LEDs 1 of each color, and a Constant-Current Breakout board. I will post it up on Instructables when it is complete.\nI have lots of other LED based Instructables to view on my\u00a0Projects in My Profile\nSubscribe to me or look out for Future Projects.\n.", "step_imgs": ["https://cdn.instructables.com/FQ6/PHL6/GE38T7EU/FQ6PHL6GE38T7EU.LARGE.jpg", "https://cdn.instructables.com/FMV/LAHE/GE39IFGS/FMVLAHEGE39IFGS.LARGE.jpg"], "step_title": "Step 12: Use It in a Wash Light"}], "channel": "LEDs"}, {"category": "technology", "description": "The main goal of the project is to achieve a system which codes sound signals using Radial Basis Function embedded on a Zybo FPGA board. After the coding process the RBF weights are to be transferred through a Pmod RF2 to a similar system, which ensures the decoding of the message, which then can be played back. The code is intended to be very secure and extremely hard to decipher. Another goal is to minimize the error and quality decrease between the originally recorded audio signal and played back audio signal.", "title": "Encoded Audio With Radial Basis Function", "url": "https://www.instructables.com/id/Encoded-Audio-With-Radial-Basis-Function/", "section": "technology", "steps": [{"step": 1, "steps_text": "1)  Xilinx Vivado Design Suite  2)   Matlab 2015b3)   Xilinx System Generator 2016.24)   1x Digilent Zybo Zynq-7000 ARM/FPGA SoC Trainer Board5)   2x Digilent Pmod RF2: IEEE 802.15 RF Transceiver6)   Microphone (or other recording device with 3.5 mm standard audio jack)7)   Audio output device with 3.5 mm standard audio jack (headphone, speaker)", "step_imgs": ["https://cdn.instructables.com/FZ5/42BP/J1CEIHUS/FZ542BPJ1CEIHUS.LARGE.jpg"], "step_title": "Step 1: Materials"}, {"step": 2, "steps_text": "As shown on the image all the system\u2019s modules are connected to the FPGA\u2019s embedded processor which ensures the synchronization of the modules. The processor also serves as a debugger so you can easily identify problems within a module. The plan was achieved using a pipeline architecture so the modules create a stream so that real time data processing could be achieved. We start with recording the audio signal using a microphone. I used the audio module for digital conversion. The digital data recorded through a Microphone Interface arrives to the Signal Coder module. Here the RBF neural network learns the signals in real time and outputs its weights and error signals for debugging purposes. If the code seems not to be secure enough then an additional coder is intended to be implemented for public channel transmission. The coded message is then forwarded through an RF Transceiver Interface to the RF module (Pmod RF2), which sends the data to another RF module. The sent data through a similar RF Transceiver Interface arrives to the decoder module which calculates the output of the RBF network using the same structure as the coder network. This output is considered the decoded signal which is forwarded to the Audio Output module through an Audio Output Interface. The audio output module was used for digital to analog conversion. This analog signal can be played back through a playback device plugged to the system.", "step_imgs": ["https://cdn.instructables.com/FPW/YXCZ/J16P5I9A/FPWYXCZJ16P5I9A.LARGE.jpg"], "step_title": "Step 2: System Schematic"}, {"step": 3, "steps_text": "The Radial Basis Function is a neural network, which is capable of learning signals by updating its basis function weights so that these functions match the reference signal. Like every other neural network this also needs to be trained. The Gaussian function was used for the basis functions of the system. By using this network the signals can be coded with an error which can be minimized by finding the best parameters for the network but can never reach 0, which means that the data can\u2019t be coded without loss.To be able to implement the algorithm on an FPGA, it needed a bit of refining. The Delta-algorithm was used for training the weights. But by optimizing the algorithm the number of calculations was reduced by a significant amount. Calculating the output:y[k] = w[l1[k]] * g(m1[k],s) + w[l2[k]] * g(m2[k],s), where y is the output vector, k is the current sample index, w is the weights vector, l1,l2 are the weight index vectors, m1,m2 are the distance vectors, s is the deviation and g is the Gaussian function output calculating function (e^(-(distance/s)^2)).Calculating the error:E[k] = d[k] \u2013 y[k], where E is the error vector, k is the current sample index, d is the reference sample vector and y is the output vectorUpdating the weights:w[l1[k]] = w[l1[k]] + nu * E[k] * g(m1[k],s)w[l2[k]] = w[l2[k]] + nu * E[k] * g(m2[k],s), where nu is the training coefficient", "step_imgs": ["https://cdn.instructables.com/FWS/3COY/J16P5IAT/FWS3COYJ16P5IAT.LARGE.jpg"], "step_title": "Step 3: Radial Basis Function"}, {"step": 4, "steps_text": "To code the samples in real time they mustn\u2019t be interrupted in their learning cycle, because otherwise it may hinder the output quality or a clearly audible break may be heard during playback. For this purpose a circular buffer was used, which enables a steady stream of input data for the neural training. At start the buffer is empty and the learning process won\u2019t start until the buffer gets full. The samples arrive in the buffer one by one. When the buffer is full the learning process begins, for all the samples in the buffer the network updates its weights throughout a given number of cycles to minimize the error. After that the first element of the buffer is replaced by a new sample. Then the network is retrained for these samples. This continues until all the samples which are related to a weight are replaced. Then that weight is sent to the output. This weight is now replaced with a new weight initialized with 0.", "step_imgs": ["https://cdn.instructables.com/FON/R1FK/J16P5ID1/FONR1FKJ16P5ID1.LARGE.jpg"], "step_title": "Step 4: Circular Buffer"}, {"step": 5, "steps_text": "For the neural network to learn the input sounds it is crucial to find its parameters including the number of samples between the middle of the basis functions, the basis function width parameter (sigma), the buffer size and the training coefficient. The tested parameters were chosen semi empirically. By looking at the plotted sound waves we can tell the width of and number of samples between basis functions. By utilizing the test parameters the power spectrum of the original sound (red colored wave) and the trained signal (blue colored wave) were compared. The network was tested for the following number of samples between basis functions (SN): 10, 20, 30, 40. For every number listed different width parameters were tested: SN/2, SN/4, SN/5, SN/6.The first image shows the overall best result where SN was 10 and the sigma was SN/5. The trained signal's power spectrum aligns close to the original signal's spectrum. The second image shows a poor result. The power spectrum of the trained signal differs significantly from the power spectrum of the original signal. Here the SN was 30 and the sigma was SN/2 .  In the third image an even poorer result appears. The network skips most of the input data\u2019s details. Instead of adding additional noise it removes important data sequences. The test parameters were SN: 40 and sigma: SN/2.", "step_imgs": ["https://cdn.instructables.com/FC6/7Q7Q/J16P5IN4/FC67Q7QJ16P5IN4.LARGE.jpg", "https://cdn.instructables.com/F7V/N7HL/J16P5IOI/F7VN7HLJ16P5IOI.LARGE.jpg", "https://cdn.instructables.com/F2E/V77L/J16P5IOP/F2EV77LJ16P5IOP.LARGE.jpg"], "step_title": "Step 5: Finding the Basis Function Parameter Based on Signals Power Spectrum Analysis"}, {"step": 6, "steps_text": "The different power spectrum comparisons were achieved by calculating the error between the original recorded sound power spectrum and the trained sound power spectrum. By getting the minimal error the best parameters could be picked for the neural network.The above first image is made of the best test result with the SN of 10 and sigma of SN/5 with a training coefficient of 0.1 and a buffer size of 160 samples.On the second image it is shown how the neural network is learning in every cycle. As it appears after the 10th cycle the error will not improve, which means that the network learned the signal as best as it could according to the given parameters mentioned above.", "step_imgs": ["https://cdn.instructables.com/FAB/LV1W/J16P5IVJ/FABLV1WJ16P5IVJ.LARGE.jpg", "https://cdn.instructables.com/FFK/H087/J1CEIYOD/FFKH087J1CEIYOD.LARGE.jpg"], "step_title": "Step 6: Choosing the Best Parameters"}, {"step": 7, "steps_text": "The coder module was built in System Generator. Look Up Tables were used (l1, l2, m1, m2) stored in Block-RAMs just as the weights of the network (W) and the sample which are to be learned. To synchronize the data the \u201clogic\u201d block written in MCode was used. This block controls which sample is currently coded in which cycle of the learning process also controls the write enable (we) of the weight storing Block-RAM and the sample storing Block-RAM. This \u201clogic\u201d block has 5 outputs. The first is \u201csel\u201d which controls the multiplexers to determine which set of LUTs are currently in use (l1, m1 or l2, m2). The second output is \u201caddr\u201d which controls the address from which we read from all the Block-RAMs (except the W Block RAM which gets its address from l1 or l2 depending on \u201csel\u201d). The third is \u201cwe\u201d which enables and disables the writing to the W Block-RAM. The forth is \u201cweData\u201d which enables and disables the writing to the Samples Block-RAM. The last one is \u201coutput\u201d which enables the writing to the output of the system.It is important to mention the used arithmetic that was the fixed point arithmetic. We are using numbers close to 1 so I used in total 20 bits from which 16 are binary bits. I used 16 binary bits because the accuracy of the calculations are in direct correlation with the quality of the outputted audio.", "step_imgs": ["https://cdn.instructables.com/FGP/XYC5/J16P5IXB/FGPXYC5J16P5IXB.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 7: Coder Module"}, {"step": 8, "steps_text": "This module is almost the same as the previous one, except is lacks the feedback loop in which the training of the weights was performed so only the output calculation is presented. The weights are inputted from the Radio Frequency Transceiver Interface module and stored in the W Block-RAM and are rotated according to the circular buffer.", "step_imgs": ["https://cdn.instructables.com/FSL/VZKJ/J16P5J8C/FSLVZKJJ16P5J8C.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Decoder Module"}, {"step": 9, "steps_text": "An audio interface was made through which the recorded data is sent to the coder module. It was made using System Generator. The primary module can be seen on the first image, which contains two subsystems connected with registers for the purpose of separating the data output and the data input from the clock handling. The input (reset, mute) and output (data_output_left, data_output,_right) are generated/displayed in the jtag_clock_domain seen on the second image. On the third image appears the sys_clock domain, which generates the necessary clock signals for the audio data to be received from the microphone.The fourth picture shows the 3 generated clock signals: Master clock, Bclock and PBLRC and the last signal is the on Mute signal. The master clock signal is set to the default 12.288 MHz (12.5) which gives a 48 kHz sampling rate.The fifth picture shows how the data is supposed to be received, but for some unknown reason when the system is tested online, it won\u2019t receive any input data. This still needs to be tested further and improved.", "step_imgs": ["https://cdn.instructables.com/FKD/SGBC/J1CEIZC5/FKDSGBCJ1CEIZC5.LARGE.jpg", "https://cdn.instructables.com/FTM/FPVD/J1CEIZC6/FTMFPVDJ1CEIZC6.LARGE.jpg", "https://cdn.instructables.com/FQO/DK8T/J1CEIZC8/FQODK8TJ1CEIZC8.LARGE.jpg", "https://cdn.instructables.com/F9J/9XRX/J1CEIZCA/F9J9XRXJ1CEIZCA.LARGE.jpg", "https://cdn.instructables.com/FWJ/5G3O/J1CEIZCP/FWJ5G3OJ1CEIZCP.LARGE.jpg"], "step_title": "Step 9: Audio Input"}, {"step": 10, "steps_text": "Work in progress** Here I will synchronize the input data with the coder module, then with the decoder module and last with the audio output module which is almost the same as the audio input module (the data is shifted in the other direction, but the sampling rates and the clock frequencies are the same). **", "step_imgs": [], "step_title": "Step 10: Putting It Together"}, {"step": 11, "steps_text": "Work in progress**Here I will design a radio frequency transmitter and receiver interface to send/ receive the coded signal.**", "step_imgs": [], "step_title": "Step 11: Step 12: RF Module"}], "channel": "Electronics"}, {"category": "technology", "description": "WARNING  !!!-***Sorry if it\"s totally unreadable it's my first inscrutable so be kind lol ***_Introduction:Over the past few years there has been a rapid growth in the utilization of the RF region of the electromagnetic spectrum. This is because of the huge growth in the number of mobile phones subscriptions in recent times. This has been causing a rapid reduction in free spectrum for future devices. Light-fidelity (Li-Fi) operates in the visible light spectrum of the electromagnetic spectrum i.e. it uses visible light as a medium of transmission rather than the traditional radio waves that are more eco-friendly compare to RF use more simple circuit and light the room which can in the same time save money and energy by Counterflix .Li-Fi stands for Light-Fidelity. Li-Fi is transmission of data using visible light by sending data through an LED light bulb that varies in intensity faster than the human eye can follow. If the LED is on, the photo detector registers a binary one; otherwise it\u2019s a binary zero. The idea of Li-Fi was introduced by a German physicist, Harald Hass, which he also referred to as \u201cData through Illumination\u201d. The term Li-Fi was first used by Haas in his TED Global talk on Visible Light Communication. According to Hass, the light, which he referred to as \u201eDLight\u201f, can be used to produce data rates higher than 1 Giga bits per second which is much faster than our average broadband connection.", "title": "Lifi ( Send Music Analog Signal Through Led )", "url": "https://www.instructables.com/id/Lifi-Send-Music-Analog-Signal-With-Led-/", "section": "technology", "steps": [{"step": 1, "steps_text": "The main advantage of Led over laser transmission is that led are more simple and they don't need much components .The Basic Components of the Circuits :Transmitter :- Power Supply (5V Supply) and (12V  Supply for the LED)- Capacitors (470uf , 2*10nf, 20nf )- Resistors (1k,10k variable )- NE555 IC-Transistor (tip122) ( or a mosfet )- Potentiometer (Change the frequency of the oscillator) - Light Source \u2013 1W LED (or Three led In series)Receiver :The basic Components of the Receiver Circuits are:\u00b7 Photo Detector \u2013 Solar cell\u00b7 TDA2822n\u00b7 Speaker  4 ohm 1 w\u00b7 Capacitor (100 uf, 2*1000 uf , 0.1 uf )\u00b7 Resistance (10k) \u00b7 Variable Resistance (50 k)\u00b7 9v battery or any other power supply (between 5v and 15v)Material :Soldring iron ,pcb ,hot glue gun.....etc", "step_imgs": [], "step_title": "Step 1: Grab Your COMPONENTS and Material "}, {"step": 2, "steps_text": "CIRCUIT WORKING  :In The Ne555 there in pin 5 a VCO a voltage Controlled Oscillator which basically Turn the amplitude of the sine wave into the width of the pulse as it\u2019s shown in the oscilloscope:The Capacitors C3, C4 are filters to reduce AC components spike in circuit.. The width of the pulse wave is controlled by The resistor RV1 by changing the value of the resistance we change the time charging and discharging the capacitor and btw changing  the time the pulse stay high and low  so it changes the time of on/off signal in the output pin 3,lower the resistance value the higher frequency will be modulated in the output .The Pulse signal is equivalent to the ON/OFF Signal in the Output pin 3 which control the intensity of the Light Source LED (D1)(D2)(D3). The Pulse wave is further Amplified and Modulated using Transistor TIP121 (T1)(it's a darling-tone transistor  but using mosfet is more efficient ) , which is an Amplifier Modulator having high current gain. The transistor will act as a Lamp Driver and drives the LED. LED emits light according to the pulse wave form and make lifi (Light-Fidelity )For the project we know that the human ear can only hear between 100 hz \u2013 20khz so we are using the carrier frequency wave above 20 khz or above and by the way only hear the Audio source input in receiver circuit .", "step_imgs": ["https://cdn.instructables.com/FCB/33SM/JIOU92E9/FCB33SMJIOU92E9.LARGE.jpg", "https://cdn.instructables.com/F5U/XPY4/JIOU92FP/F5UXPY4JIOU92FP.LARGE.jpg"], "step_title": "Step 2: TRANSMITTER CIRCUIT : "}, {"step": 3, "steps_text": " CIRCUIT WORKING :The Solar cell is used to detect the Light from the Transmitting LEDs. And reproducesan Analog output corresponding to the input signal. The frequency of the analog will be same as that of input signal, since the flickering of LED is controlled by the input signal and solar  cell detects only the fluctuation in the LED signal and produces the output. The output is then amplified using TDA22. It also helps in removing any phase changes occurs in the transmitted signal. And then filtered to remove any other light room about 60hz high pass filter The Amplified signal is fed to the speaker. The speaker converts the analog signal to the Audible Sound signal using the electromagnet present in the Speaker.", "step_imgs": ["https://cdn.instructables.com/FZ1/S9TJ/JIOU90QB/FZ1S9TJJIOU90QB.LARGE.jpg", "https://cdn.instructables.com/F79/DJ85/JIOU92H5/F79DJ85JIOU92H5.LARGE.jpg"], "step_title": "Step 3: RECEIVER CIRCUIT:"}, {"step": 4, "steps_text": "1 Transmitter Soldering :I Just wanted to make it look like a light- bulb   , so i cut  the pcb to fit in the light bulb shape , then implement all the component and start soldering  according to the schismatic 2 - Receiver soldering: .Did not do  anything special just solder . There you have it it's finish xd :)If you want more details you can read the word file ( .docx ) .Conclusion : By using Li-Fi we can have Energy saving Parallelism. With growing number of people and their many devices access wireless internet, on one way data transfer at high speed and at cheap cost. In future we can have LED array beside a motorway helping to light the road, displaying the latest traffic updates and transmitting internet information to wirelessly to passengers Laptops, Notebooks and Smart phones. This is the kind of extra ordinary, energy saving parallelism that is believed to deliver by this pioneering technology. ", "step_imgs": ["https://cdn.instructables.com/FCV/R9MZ/JIOU91KC/FCVR9MZJIOU91KC.LARGE.jpg", "https://cdn.instructables.com/FV7/UN1B/JIOU9232/FV7UN1BJIOU9232.LARGE.jpg", "https://cdn.instructables.com/FP5/3490/JIOU92AQ/FP53490JIOU92AQ.LARGE.jpg", "https://cdn.instructables.com/FVU/T6CK/JIOU927K/FVUT6CKJIOU927K.LARGE.jpg", "https://cdn.instructables.com/FE0/L10I/JIOU91Q8/FE0L10IJIOU91Q8.LARGE.jpg", "https://cdn.instructables.com/F4P/YYRE/JIOU90V2/F4PYYREJIOU90V2.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Soldering on Pcb :"}], "channel": "Electronics"}, {"category": "technology", "description": "Hello Guys, in this instructable I will give you a code for transtioning an LED. My group, Newton Labs, has spent quite a bit of time on this. Transitioning isn't as easy as it seems for a nice smooth transition.\nSubmitted by Newton Labs for the Instructables Sponsorship Program", "title": "RGB LED Transition (Arduino)", "url": "https://www.instructables.com/id/RGB-LED-transition-Arduino/", "section": "technology", "steps": [{"step": 1, "steps_text": "In this circuit, you will need to use 3 Pulse Width Modulation pins, PWM for short. Pins that are not specified as PWM pins are digital pins, which can only turn on and off. PWM pins can go from lets say 3.3 volts to five volts to 1.1 volts.\nIn my program\u00a0 Red = pin 3,\u00a0Blue = pin 5, and Green\u00a0= pin 6.", "step_imgs": ["https://cdn.instructables.com/FOL/JVVX/H5R9ECZ9/FOLJVVXH5R9ECZ9.LARGE.jpg"], "step_title": "Step 1: The Circuit"}, {"step": 2, "steps_text": "int prevR = 0, prevG = 0, prevB = 0; // all of the previous RGB values\nint const Red = 3; //pin 3\u00a0\nint const Blue = 5; // pin 4\nint const Green = 6; // pin 5\nvoid setup(){} // sets up the program\nvoid loop() { //main loop of the program\n\u00a0 RGB(255, 255, 255); // this calls the RGB function\n\u00a0 delay(1000); //stays on white for one second\n\u00a0 RGB(0, 0, 255);\u00a0\n\u00a0\u00a0 delay(1000);\n\u00a0\u00a0 RGB(0,120,255);\n\u00a0 delay(1000);\n\u00a0\u00a0\u00a0 RGB(0, 255, 0);\n\u00a0 delay(1000);\n\u00a0\u00a0\u00a0 RGB(255, 0, 255);\n\u00a0 delay(10);\n\u00a0\u00a0\u00a0 RGB(0,0,0);\n\u00a0 delay(1000);\n\u00a0\n}\nvoid RGB(int R, int G, int B) {\nfor (int i = 0; i <= 255; i++)\n{\nif (i >=\u00a0 prevR - R && prevR < R) {\n\u00a0\n\u00a0 analogWrite(Red, prevR + i);\n}\nif (i >= prevG - G && prevG < G) {\n\u00a0\n\u00a0 analogWrite(Green, prevG + i);\n\u00a0\n}\nif (i >= prevB - B && prevB < B) {\n\u00a0\n\u00a0 analogWrite(Blue, prevB + i);\n\u00a0\n}\n//delay(10);\n//}\n//for (int i = 0; i <= 255; i++)\n//{\nif (i >= R - prevR && prevR > R) {\n\u00a0\n\u00a0 analogWrite(Red, prevR - i);\n}\nif (i >= G - prevG && prevG > G) {\n\u00a0\n\u00a0 analogWrite(Green, prevG - i);\n\u00a0\n}\nif (i >= B - prevB && prevB > B) {\n\u00a0\n\u00a0 analogWrite(Blue, prevB - i);\n\u00a0\n}\ndelay(10);\n}\ndelay(10);\nanalogWrite(Red, R);\nanalogWrite(Green, G);\nanalogWrite(Blue, B);\nprevR = R;\nprevG = G;\nprevB = B;\n}", "step_imgs": ["https://cdn.instructables.com/FMP/GTWR/GVSUMP60/FMPGTWRGVSUMP60.LARGE.jpg"], "step_title": "Step 2: The Code"}, {"step": 3, "steps_text": "You are done and you should have Revision 3 of my RGB LED transitioning program!\u00a0", "step_imgs": ["https://cdn.instructables.com/FN1/F3MF/H1JUI9TM/FN1F3MFH1JUI9TM.LARGE.jpg"], "step_title": "Step 3: Hooray!"}], "channel": "Arduino"}, {"category": "technology", "description": "Do you have an amplifier hidden somewhere in the living room or basement (or home theater) that you want it to turn on when you start to play music?This circuit is the solution for you!\nIt\u00a0is pretty similar to another project I posted a while ago, but here it turns amplifier on and off. If source is playing then the unit will turn amplifier on by using the sending the remote infrared code to turn it on, and when idle for some time, the unit will send the power off remote infrared code to turn off the amplifier. The code here is set to work with a Kenwood 6030 amplifier. If you have a different gear, no fear. Changing the program to work with another set of codes is really simple. You will need to change one or two hex codes only in the KenwoodIdle.PDE file. The best place to learn the codes of your gear is by looking at\u00a0http://www.lirc.org/\u00a0\nThe PCB shown in the picture is part of a shield designed for similar idea that also includes Equalizer bar-graph of the music. The circuit here is a subset of it and for it no PCB is really necessary (but since I got 10 PCBs in a batch... I got some spare ones).", "title": "Turning Stereo Amplifer on and Off Automatically", "url": "https://www.instructables.com/id/Turning-Stereo-Amplifer-On-and-Off-automatically/", "section": "technology", "steps": [{"step": 1, "steps_text": "\n          1x Arduino, any type is good, Uno, Nano, Mini or other mutants.\n1x RGB LED (optional)1\n1x 330 Ohm Resistor (220 to 470 good as well)2\n1x 220 Ohm Resistor (100 Ohm is even better for the IR LED)3\n1x IR LED (most likely you need 940nm one)\n2x 3.5mm Stereo jacks\n4x 22KOhm Resistors (10K is minimum, 56K is maximum I believe)\nYou will need Arduino IDE 0022 as I did not see the IR Remote library ported to the Arduino 1.x IDE yet.\nPut the files in IRremote sub-directory into the Arduino libraries folder\nCompile and load the program to your Arduino.Notes:\n1) Status LED is optional, you don't really need it. but it is useful:\n\n\tIf showing Red, that means amplifier is off and no music is played by source.\n\tIf showing Green, that means amplifier is ON but no music is played by source\n\tIf showing Blue, that means amplifier is ON and music is played by source.\n2) Increasing the value of the resistor of the status LED will make it dimmed which might be desired. I use only one resistor and that means that you can only have one color at a time from this RGB LED. In this case it is by design. If you want to play around with different colors and stuff, you will need to move to three different resistors one for every color. Note that if you do that, the resistors should be slightly different between the Red, Green and Blue ones (for example 330 for Red, 300 for Green and \u00a0270 for Blue for the RGB LED that I have).\n3) Reducing the value of the resistor of the IR LED can increase the distance between the IR LED and the amplifier under control. Do not go below 100 ohm otherwise you might fry your Arduino. I used 220 Ohm as I placed the IR LED very close to the amplifier IR sensor.How to connect to your Stereo system:\nThe amplifier output should be connected to an output of the amplifier, connection to tape recorder is typically not used anymore these days and can very well be the best place to connect this unit to your amplifier (recording output of tape from Amplifier to the Amplifier jack of this unit).\nThe source input, marked as Sonos in the diagram below (this is almost always the source of music in my house these days) can be taken from RCA connection of the Sonos or using a split cable take one into this unit and the other to the amplifier.Enjoy the listening.", "step_imgs": ["https://cdn.instructables.com/FGI/PJE0/H6MF2PDK/FGIPJE0H6MF2PDK.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: Parts & Assembly"}], "channel": "Arduino"}, {"category": "technology", "description": "Do you have an amplifier hidden somewhere in the living room or basement (or home theater) that you want it to turn on when you start to play music?This circuit is the solution for you!\nIt\u00a0is pretty similar to another project I posted a while ago, but here it turns amplifier on and off. If source is playing then the unit will turn amplifier on by using the sending the remote infrared code to turn it on, and when idle for some time, the unit will send the power off remote infrared code to turn off the amplifier. The code here is set to work with a Kenwood 6030 amplifier. If you have a different gear, no fear. Changing the program to work with another set of codes is really simple. You will need to change one or two hex codes only in the KenwoodIdle.PDE file. The best place to learn the codes of your gear is by looking at\u00a0http://www.lirc.org/\u00a0\nThe PCB shown in the picture is part of a shield designed for similar idea that also includes Equalizer bar-graph of the music. The circuit here is a subset of it and for it no PCB is really necessary (but since I got 10 PCBs in a batch... I got some spare ones).", "title": "Turning Stereo Amplifer on and Off Automatically", "url": "https://www.instructables.com/id/Turning-Stereo-Amplifer-On-and-Off-automatically/", "section": "technology", "steps": [{"step": 1, "steps_text": "\n          1x Arduino, any type is good, Uno, Nano, Mini or other mutants.\n1x RGB LED (optional)1\n1x 330 Ohm Resistor (220 to 470 good as well)2\n1x 220 Ohm Resistor (100 Ohm is even better for the IR LED)3\n1x IR LED (most likely you need 940nm one)\n2x 3.5mm Stereo jacks\n4x 22KOhm Resistors (10K is minimum, 56K is maximum I believe)\nYou will need Arduino IDE 0022 as I did not see the IR Remote library ported to the Arduino 1.x IDE yet.\nPut the files in IRremote sub-directory into the Arduino libraries folder\nCompile and load the program to your Arduino.Notes:\n1) Status LED is optional, you don't really need it. but it is useful:\n\n\tIf showing Red, that means amplifier is off and no music is played by source.\n\tIf showing Green, that means amplifier is ON but no music is played by source\n\tIf showing Blue, that means amplifier is ON and music is played by source.\n2) Increasing the value of the resistor of the status LED will make it dimmed which might be desired. I use only one resistor and that means that you can only have one color at a time from this RGB LED. In this case it is by design. If you want to play around with different colors and stuff, you will need to move to three different resistors one for every color. Note that if you do that, the resistors should be slightly different between the Red, Green and Blue ones (for example 330 for Red, 300 for Green and \u00a0270 for Blue for the RGB LED that I have).\n3) Reducing the value of the resistor of the IR LED can increase the distance between the IR LED and the amplifier under control. Do not go below 100 ohm otherwise you might fry your Arduino. I used 220 Ohm as I placed the IR LED very close to the amplifier IR sensor.How to connect to your Stereo system:\nThe amplifier output should be connected to an output of the amplifier, connection to tape recorder is typically not used anymore these days and can very well be the best place to connect this unit to your amplifier (recording output of tape from Amplifier to the Amplifier jack of this unit).\nThe source input, marked as Sonos in the diagram below (this is almost always the source of music in my house these days) can be taken from RCA connection of the Sonos or using a split cable take one into this unit and the other to the amplifier.Enjoy the listening.", "step_imgs": ["https://cdn.instructables.com/FGI/PJE0/H6MF2PDK/FGIPJE0H6MF2PDK.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: Parts & Assembly"}], "channel": "Arduino"}, {"category": "technology", "description": "This is how you can use one of the BostonAndroid.com Xmega evaluation boards ($20) \u00a0to create a simple adjustable sine waveform generator with 12bit resolution and capable of producing frequencies from 125Hz - 20KHz using the integrated DAC. You can modify the code to produce any arbitrary waveform at up to 1MHz on 2 channels. You need only a PC, an eval board and a suitable Atmel programmer (AVRISP is under $30 new). There are a LOT\u00a0of features packed into the Xmega microcontrollers. This instructable is meant to demonstrate some of the really powerful ones like a 12bit DAC, 12bit ADC, DMA controller and open source compiler (avr-gcc).", "title": "Easy Atmel Xmega Sine Wave / Waveform Generator", "url": "https://www.instructables.com/id/Easy-Atmel-Xmega-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "You will need the following to complete this project:Boston Android Xmega EVAL-01 Development Board ($20) or build your ownMurata PV36W103C01B00 Trimpot 10Kohm, 25turn (or equiv from Mouser)PC with AVR Studio 4\u00a0(free)AVRISP mkII programmer\u00a0($30)\u00a0", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "To create an adjustable waveform generator we will use a simple resistor voltage divider to be read by the Xmega on board 12bit ADC. This value will then be used to\u00a0set the frequency of the DAC sine wave frequency but the following formula:reading = (Vin/1.6V) * 256freq = (reading * reading) + 1;By adding an adjustable 3pin\u00a0Potentiometer to PortA\u00a0on\u00a0the XMega-Eval01\u00a0we can create this simple voltage divider. You can also feed in your own voltage source between 0-1.6V to do the adjustment instead.The waveform is output from the DAC with 50 samples per cycle at 12bit resolution from PORTB pin2. Pin1 is setup as ground reference.", "step_imgs": ["https://cdn.instructables.com/FOC/ZE48/G145T03D/FOCZE48G145T03D.LARGE.gif"], "step_title": "Step 2: Theory of Operation"}, {"step": 3, "steps_text": "The instructions here are to simply buy the Boston Android EVAL-01 Xmega dev board. But you can also build your own by buying a TQFP-64 adapter board (check ebay ~$5) and buying an Xmega64a3 chip from Digikey or Mouser (~$8). Below is the schematic for the EVAL-01 board.", "step_imgs": ["https://cdn.instructables.com/FP9/1AJU/G1BBDO9J/FP91AJUG1BBDO9J.LARGE.jpg", "https://cdn.instructables.com/FO5/CEQ5/G1BBDOAE/FO5CEQ5G1BBDOAE.LARGE.jpg"], "step_title": "Step 3: Schematic for EVAL-01 Board or Build Your Own"}, {"step": 4, "steps_text": "Solder\u00a0the PV36W103C01B00 Trimpot to PortA pins 1-3 with the screw adjustment to the right.", "step_imgs": ["https://cdn.instructables.com/FV4/WRER/G145NUR9/FV4WRERG145NUR9.LARGE.jpg"], "step_title": "Step 4: Add Potentiometer"}, {"step": 5, "steps_text": "Solder two wires to PORTB pins 1 and 2.", "step_imgs": ["https://cdn.instructables.com/FMX/6C8P/G145NUR8/FMX6C8PG145NUR8.LARGE.jpg"], "step_title": "Step 5: Add Test Wire Leads"}, {"step": 6, "steps_text": "Using Atmel AVR Studio 4:1) Start Atmel AVR Studio 42)\u00a0Select \"New Project\"3) Select \"avr-gcc\" project4) Give your project a name5) Select \"AVR Simulator 2\" and target device: \"Atmel AVR ATXmega64A3\"6) Get C source code file xmega-waveform.c from BostonAndroid website and save to your project directory and add to your project (or copy source code into the default C file created by AVR studio)7) Go to \"Build\" menu and select \"Build\"", "step_imgs": [], "step_title": "Step 6: Compile Firmware"}, {"step": 7, "steps_text": "Connect 5VDC power supply to board. The easiest way is using a 5VDC wall adapter with center positive (you probably own one and don't know it; they are very common). If not, use an adjustable power supply or 3 AA batteries and connect to solder tabs at bottom of board. The contact close to the front of the connector is negative, the back one is positive.Next connect the Atmel AVRISP mkii programmer to your PC USB port.Next connect 6 pin ribbon cable between programmer and board as shown.Open the software project in AVRstudio that you compiled in the previous step and load the software on the device by clicking on the \"AVR\" button in the toolbar (or also in drop down menu \"program AVR device\")A dialog will appear which lists options like \"Device\" \"Flash\" & \"eeprom\". You want to program the flash memory on the target device. Select \"...\" under FLASH and locate a .hex file for your project, then click \"Program\". The .hex file name is .hex.In a small box at the bottom of this dialog you should see lots of successful looking messages. :-)", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 7: Program Device"}, {"step": 8, "steps_text": "Connect an Oscilloscope (or freq counter, or high impedance speaker like a headphone speaker) across PORTB pins 1 & 2. You should see a sine wave of 3.3V p-p amplitude. Adjust the potentiometer clockwise to increase frequency from 125-20KHz. Turn counter clockwise to decrease frequency.", "step_imgs": ["https://cdn.instructables.com/FHN/S7CK/G145NURB/FHNS7CKG145NURB.LARGE.gif", "https://cdn.instructables.com/FKF/J8WR/G145NUR3/FKFJ8WRG145NUR3.LARGE.gif"], "step_title": "Step 8: Use Device!"}, {"step": 9, "steps_text": "So, this is a simple example of how you can use the Atmel XMega microcontroller to generate sine waves. Here are some things you can do with minor changes to the firmware:1)\u00a0Go higher! The maximum frequency is limited by the 50 sample sine waveform and 1Msps DAC. You can modify the function LoadSineWave() and set the number of samples to be say 10: LoadSineWave(10). This will cause 5x more cycles. Now you can use SetWaveFreq() to go beyond 20KHz to 100KHz!2)\u00a0Arbitrary waveforms. LoadSineWave() loads a simple sine wave. But you can put any waveform you want into data12[] array. In C you can do this in the declaration:\u00a0\u00a0\u00a0 int data12[10] = {1,2,3,4,5,6,7,8,9,10};3) Vary amplitude. The output waveform is 0-3.3V but you can make this smaller by scaling the data loaded into data12[].4) Increase resolution of Freq adjustment potentiometer. The stock code uses the ADC in 8bit mode (256 discrete frequency settings). You can change this to 12bit and allow 2^12=4096 different frequencies", "step_imgs": [], "step_title": "Step 9: What Next? What Else Can This Thing Do?"}], "channel": "Electronics"}, {"category": "technology", "description": "This is how you can use one of the BostonAndroid.com Xmega evaluation boards ($20) \u00a0to create a simple adjustable sine waveform generator with 12bit resolution and capable of producing frequencies from 125Hz - 20KHz using the integrated DAC. You can modify the code to produce any arbitrary waveform at up to 1MHz on 2 channels. You need only a PC, an eval board and a suitable Atmel programmer (AVRISP is under $30 new). There are a LOT\u00a0of features packed into the Xmega microcontrollers. This instructable is meant to demonstrate some of the really powerful ones like a 12bit DAC, 12bit ADC, DMA controller and open source compiler (avr-gcc).", "title": "Easy Atmel Xmega Sine Wave / Waveform Generator", "url": "https://www.instructables.com/id/Easy-Atmel-Xmega-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "You will need the following to complete this project:Boston Android Xmega EVAL-01 Development Board ($20) or build your ownMurata PV36W103C01B00 Trimpot 10Kohm, 25turn (or equiv from Mouser)PC with AVR Studio 4\u00a0(free)AVRISP mkII programmer\u00a0($30)\u00a0", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "To create an adjustable waveform generator we will use a simple resistor voltage divider to be read by the Xmega on board 12bit ADC. This value will then be used to\u00a0set the frequency of the DAC sine wave frequency but the following formula:reading = (Vin/1.6V) * 256freq = (reading * reading) + 1;By adding an adjustable 3pin\u00a0Potentiometer to PortA\u00a0on\u00a0the XMega-Eval01\u00a0we can create this simple voltage divider. You can also feed in your own voltage source between 0-1.6V to do the adjustment instead.The waveform is output from the DAC with 50 samples per cycle at 12bit resolution from PORTB pin2. Pin1 is setup as ground reference.", "step_imgs": ["https://cdn.instructables.com/FOC/ZE48/G145T03D/FOCZE48G145T03D.LARGE.gif"], "step_title": "Step 2: Theory of Operation"}, {"step": 3, "steps_text": "The instructions here are to simply buy the Boston Android EVAL-01 Xmega dev board. But you can also build your own by buying a TQFP-64 adapter board (check ebay ~$5) and buying an Xmega64a3 chip from Digikey or Mouser (~$8). Below is the schematic for the EVAL-01 board.", "step_imgs": ["https://cdn.instructables.com/FP9/1AJU/G1BBDO9J/FP91AJUG1BBDO9J.LARGE.jpg", "https://cdn.instructables.com/FO5/CEQ5/G1BBDOAE/FO5CEQ5G1BBDOAE.LARGE.jpg"], "step_title": "Step 3: Schematic for EVAL-01 Board or Build Your Own"}, {"step": 4, "steps_text": "Solder\u00a0the PV36W103C01B00 Trimpot to PortA pins 1-3 with the screw adjustment to the right.", "step_imgs": ["https://cdn.instructables.com/FV4/WRER/G145NUR9/FV4WRERG145NUR9.LARGE.jpg"], "step_title": "Step 4: Add Potentiometer"}, {"step": 5, "steps_text": "Solder two wires to PORTB pins 1 and 2.", "step_imgs": ["https://cdn.instructables.com/FMX/6C8P/G145NUR8/FMX6C8PG145NUR8.LARGE.jpg"], "step_title": "Step 5: Add Test Wire Leads"}, {"step": 6, "steps_text": "Using Atmel AVR Studio 4:1) Start Atmel AVR Studio 42)\u00a0Select \"New Project\"3) Select \"avr-gcc\" project4) Give your project a name5) Select \"AVR Simulator 2\" and target device: \"Atmel AVR ATXmega64A3\"6) Get C source code file xmega-waveform.c from BostonAndroid website and save to your project directory and add to your project (or copy source code into the default C file created by AVR studio)7) Go to \"Build\" menu and select \"Build\"", "step_imgs": [], "step_title": "Step 6: Compile Firmware"}, {"step": 7, "steps_text": "Connect 5VDC power supply to board. The easiest way is using a 5VDC wall adapter with center positive (you probably own one and don't know it; they are very common). If not, use an adjustable power supply or 3 AA batteries and connect to solder tabs at bottom of board. The contact close to the front of the connector is negative, the back one is positive.Next connect the Atmel AVRISP mkii programmer to your PC USB port.Next connect 6 pin ribbon cable between programmer and board as shown.Open the software project in AVRstudio that you compiled in the previous step and load the software on the device by clicking on the \"AVR\" button in the toolbar (or also in drop down menu \"program AVR device\")A dialog will appear which lists options like \"Device\" \"Flash\" & \"eeprom\". You want to program the flash memory on the target device. Select \"...\" under FLASH and locate a .hex file for your project, then click \"Program\". The .hex file name is .hex.In a small box at the bottom of this dialog you should see lots of successful looking messages. :-)", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 7: Program Device"}, {"step": 8, "steps_text": "Connect an Oscilloscope (or freq counter, or high impedance speaker like a headphone speaker) across PORTB pins 1 & 2. You should see a sine wave of 3.3V p-p amplitude. Adjust the potentiometer clockwise to increase frequency from 125-20KHz. Turn counter clockwise to decrease frequency.", "step_imgs": ["https://cdn.instructables.com/FHN/S7CK/G145NURB/FHNS7CKG145NURB.LARGE.gif", "https://cdn.instructables.com/FKF/J8WR/G145NUR3/FKFJ8WRG145NUR3.LARGE.gif"], "step_title": "Step 8: Use Device!"}, {"step": 9, "steps_text": "So, this is a simple example of how you can use the Atmel XMega microcontroller to generate sine waves. Here are some things you can do with minor changes to the firmware:1)\u00a0Go higher! The maximum frequency is limited by the 50 sample sine waveform and 1Msps DAC. You can modify the function LoadSineWave() and set the number of samples to be say 10: LoadSineWave(10). This will cause 5x more cycles. Now you can use SetWaveFreq() to go beyond 20KHz to 100KHz!2)\u00a0Arbitrary waveforms. LoadSineWave() loads a simple sine wave. But you can put any waveform you want into data12[] array. In C you can do this in the declaration:\u00a0\u00a0\u00a0 int data12[10] = {1,2,3,4,5,6,7,8,9,10};3) Vary amplitude. The output waveform is 0-3.3V but you can make this smaller by scaling the data loaded into data12[].4) Increase resolution of Freq adjustment potentiometer. The stock code uses the ADC in 8bit mode (256 discrete frequency settings). You can change this to 12bit and allow 2^12=4096 different frequencies", "step_imgs": [], "step_title": "Step 9: What Next? What Else Can This Thing Do?"}], "channel": "Electronics"}, {"category": "technology", "description": "This project was designed to make a guitar tuner using Vivado and a 7-segment display. Once the tuner finds the frequency of the inputted sound, the tuner will compare that value to a list of hard-coded values for exact frequencies that are known as the standard frequency for the correct pitch of a note. Then the tuner will display how close or far your inputted sound is from your desired note. What is interesting is that a sound wave is a combination of multiple sinusoidal waveforms with real and imaginary components. While this may seem difficult to work with to those unfamiliar, there are a few ways that we can still analyze a wave with real and imaginary values.Demo:  ", "title": "Tuner", "url": "https://www.instructables.com/id/Tuner/", "section": "technology", "steps": [{"step": 1, "steps_text": "First we need a Basys 3 board and a computer that supports the following programs.Garageband/Audacity or another DAW - to record through a microphone and export wavfilesPython - able to use pylab and scipy for sampling and fftVivado - to connect to the Basys 3 board and visually see the results", "step_imgs": ["https://cdn.instructables.com/FYC/DSKT/JAMU2O64/FYCDSKTJAMU2O64.LARGE.jpg"], "step_title": "Step 1: Equipment List (take a Pic of the Board and Kevin's Comp)"}, {"step": 2, "steps_text": "A tuner is made up of few important components: microphone, sampler, FFT (Fast Fourier Transform), comparator, decoder, and display. The purpose of the microphone is to capture the input waveform. The sampler receives the microphone's output signal and uses the FFT to convert the signal into an output of magnitude in frequencies. Then using the output of the FFT and finding the max magnitude and the frequency associated with it divided by 2, the frequency associated with the pitch of the waveform can be found. That value can then go into the comparator.  It is then compared to a look-up table, which has already set frequency values for perfect pitches of all notes. The comparator is given an input for the desired note, which it can then match the desired note to it's correct frequency from the look-up table. Then the comparator will choose the note with the closest frequency to the maximum frequency. The comparator will compare the two values and see close the value of the frequency is to the desired one and then put that data into a signal. The comparator will send that signal to the decoder, where the decoder will choose the inputs for the anodes of the 7-segment display to show the accuracy of the note.", "step_imgs": ["https://cdn.instructables.com/FB9/0ZST/JAMTVQJA/FB90ZSTJAMTVQJA.LARGE.jpg"], "step_title": "Step 2: Overview"}, {"step": 3, "steps_text": "In this step, we will be taking a wav file of a pitch and try to output the frequency of that pitch.First you need a wav file of a note. In this example we will be using a 16 bit stereo wav file with a sampling rate of 44.1kHz. This can be either created in a DAW such as Garageband or downloaded. For this example, a A4 440Hz Sine wave generated by us on Garageband can be downloaded here. https://drive.google.com/file/d/16lprsKE2wFeKruB0u...", "step_imgs": ["https://cdn.instructables.com/FFL/URFU/JAMTVZXZ/FFLURFUJAMTVZXZ.LARGE.jpg"], "step_title": "Step 3: Wav File"}, {"step": 4, "steps_text": "We used Python library for doing \u201cFast Fourier transform\u201d. Online resource allowed us to imitate and see what is useful in pylab and scipy. 1.     If you haven\u2019t install pylab or scipy, you need to do so. Or, Pycharm has a very good feature, when tried importing pylab or scipy, there is a squiggly underline telling you that you haven\u2019t install the library yet. You can then install them directly by pressing the red light-bulb (it will appear when you put your cursor near the squiggly underline).2.     Using scipy.io.wavfile.read function, read and pull out data from sample wav file. Run through the data by pylab.fft, it will return you a list of magnitude for the power.3.     Then find the max of the power emitted from the list. Look for the list index where the max power occurs because the faster way to find what frequency associate with that power. Finally return the max frequency. Since we later need to input a binary frequency signal into VHDL code, we can convert frequency in float into binary, and return it.", "step_imgs": ["https://cdn.instructables.com/FYN/JCCH/JAMTSEJN/FYNJCCHJAMTSEJN.LARGE.jpg"], "step_title": "Step 4: Python- Uses of Pylab and Scipy"}, {"step": 5, "steps_text": "In this step, full credits go to this link below for the sampling and FFT.http://samcarcagno.altervista.org/blog/basic-sound...Our Code: https://drive.google.com/file/d/1S9jBfF44o72nBs0nd...After pylab and scipy have been installed, wav files are able to be imported and read. from pylab import*from scipy.io import wavfilesampFreq, snd = wavfile.read('440_sine.wav')Then snd.shape represents the sample points and the number of channels. In our case, the sample points depends on how long the wavfile is and the # of channels is 2 because it is stereo.Then snd = snd / (2.**15)...... xlabel('Time (ms)')organizes the time signal into an array.Then the FFT creates an array in frequency and magnitude (Power)Then through a while loop the max magnitude and the frequency associated with it is found.That frequency/2 represents the pitch of the wavfile.Then using our own code, the integer representing the frequency was converted into a 12 bit binary number and a text file was created with that number in it.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: Python-Sampling and FFT (Show Code and Its Results)"}, {"step": 6, "steps_text": "In this part of theprocess, we need a comparator to compare two input frequencies. 1.     Created a comparator to compare whether the input (receiver) frequency is higher, lower or within the 2 Hz margin range defined note. (typical guitar tuner ranges from e2 to g5, 82 Hz to 784 Hz).2.     When creating a margin of 2 Hz, we used a RCA to add \u201c000000000010\u201d to the receiver frequency, and check where it is still too low for user input. If that is the case, single bit signal \u201chigh\u201d <= \u20180\u2019, \u201clow\u201d <= \u20181\u2019. Then we add \u201c000000000010\u201d to the user input see if the receiver input is even higher than that. If that is the case, \u201chigh\u201d <= \u20181\u2019, \u201clow\u201d <= \u20180\u2019. Neither the case would both return \u20180\u2019.3.     Since the next part of the module need a specific 4-bits data to tell what the receiver note is, not only returning the 2 comparative outputs (low and high), we need to return the code associate to note, which associate with the frequency. Please refer to the chart below:       C                      |                  0011            C#                    |                  1011            D                      |                  0100            D#                    |                  1100            E                      |                   0101            F                      |                   0110            F#                    |                   1110            G                     |                    0111            G#                   |                    1111            A                      |                    0001            A#                    |                   1001            B                      |                    0010            Using several if statements to categorize them into note and encode them in to what is needed for the seven segment decoder.", "step_imgs": ["https://cdn.instructables.com/FKE/DQEH/JAMTSEFT/FKEDQEHJAMTSEFT.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 6: Vivado (Comparator)"}, {"step": 7, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FX0/K3D0/JAMTSIG5/FX0K3D0JAMTSIG5.LARGE.jpg"], "step_title": "Step 7: PICTURES OF BASYS 3 Board"}, {"step": 8, "steps_text": "Everything needs a display. It is an important factor that determines the value of a design. Therefore, we need to create a display using seven-segments decoder, which would allow us to demonstrate our ability to design a tuner on the B Board. Also, it would help us in testing and debugging.A seven-segments decoder contains inputs named Note, low, high, and CLK, while outputting SSEG, AN, and Fiz_Hz. There is a picture of block diagram above to help us understand the design.The purpose of having a two separate of low and high inputs is to provide the designer of the comparator the freedom to manipulate whether the sound (wave) frequency is higher or lower than the input frequency (Fix_Hz) the user wants to compare. In addition, the output SSEG represents the seven segments display and the dot next by while the AN represents the anodes for which set of the seven segments display to light up.In this seven-segments decoder, the clock (CLK) plays an important role in displaying two different values on two or more different anodes. As the Board doesn't allow us to display two different values at the same time, we have to use multiplexing to display a value one at a time, while switching into another value fast enough that our eyes can't capture it. This is where the CLK input comes into play.For more information, please refer to the source code.", "step_imgs": ["https://cdn.instructables.com/FJR/5G2T/JAMTSIGD/FJR5G2TJAMTSIGD.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Vivado (7 Segment Decoder With Multiplexing)"}, {"step": 9, "steps_text": "With every modules (python receiver, comparator, seven segment decoder, etc.) completed, we then put together using the a bigger module. Just like the picture under \"Over view\" section shown, we connect each signal accordingly. For reference, please check our source code \"SW_Hz.vhd\".Thank you. Hope you enjoy. ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 9: Vivado (Combining Components)"}], "channel": "Audio"}, {"category": "technology", "description": "This instructable will guide you through construction of the Endangered Audio Research Gristleizer from a kit or PCB.  Steps that are kit or PCB only will be marked (Kit) or (PCB) respectively.Although this version is intended for Eurorack, you can also install it in 5U, MOTM, Serge, or other systems as it runs on +/- 12-15V.The Gristleizer is a legendary VCA/VCF effect used extensively by industrial music pioneers Throbbing Gristle. Developed by a 15 year-old Roy Gwinn and published in a DIY electronics magazine in 1975, the original design found its way to Throbbing Gristle, who brought the Bias trimpot to the front panel and dubbed it The Gristleizer. Decades later, Endangered Audio Research released the first production Gristleizer tabletops, which faithfully recreated the circuit while solving many of the problems inherent in the original design.Now, after 8 years of continuous refinement, including a major overhaul of the filter circuit in version 3, expanded controls, and more CV options, Endangered Audio Research presents the Eurorack version of The Gristleizer. This is an extremely limited run, after which The Gristleizer name will be retired from the Endangered Audio Research product line permanently.Features:Knobs:BIAS - In VCA mode, the Bias effects the intensity and shape of the modulation, amount of distortion, and overall level of the modulated signal.  In VCF mode, the Bias sweeps the center frequency of the improved bandpass filter.GAIN - Controls the amount of signal drive in the first gain stage. FILTER MIX - Controls the amount of dry signal added to the filtered signal. FREQ - Controls the frequency of the internal LFO. DEPTH - Controls the amount of LFO modulation applied to the signal. LEVEL - Controls the output level of the module.Switches:MODE SWITCH - Selects VCA or VCF mode. IN/OUT SWITCH - True bypass switch.Light:LED - Indicates the rate of the internal LFO. A specially selected Fresnel lens and LED provides a convincing incandescent look.Jacks:IN - Signal to be Gristleized. OUT - Gristleized signal (when effect is switched in).BIAS IN - Allows for external control of the Bias voltage. Can be modulated by any signal of sufficient strength. This is a switching jack - when patched, it disconnects the BIAS knob on the front panel. BIAS MIX IN - Same as the BIAS IN, but does not disconnect the front panel BIAS control. Instead, the external input is mixed with and offset by the BIAS knob.FREQ IN - Allows for external control of the LFO frequency. This is a switching jack - when patched, it disconnects the FREQ knob on the front panel. FREQ MIX IN - Same as the FREQ IN, but does not disconnect the front panel FREQ control. Instead, the external input is mixed with and offset by the FREQ knob.MOD IN - This switching jack is normalled to the Triangle LFO, meaning you do not need to patch the module for it to function. Inserting a patch cable will break this connection and allow you to modulate The Gristleizer with any modulation source, including LFOs, envelopes, sequencers, sample & hold, and audio.TRIANGLE OUT - Triangle LFO SAWTOOTH OUT - Saw LFO SQUARE OUT - Square LFO - not a true square wave, but optimized with sloped rising and falling edges to prevent the clicking that plagues the original design.", "title": "Gristleizer Synthesizer Module Build Guide", "url": "https://www.instructables.com/id/Gristleizer-Synthesizer-Module-Build-Guide-Eurorac/", "section": "technology", "steps": [{"step": 1, "steps_text": "Unpack the kit and sort the components.  For small components like resistors and capacitors, group similar parts together and put them on a piece of paper.  Mark the value of each group of components on the paper next to them.  If you cannot read resistor codes (pictured above) or do not have a multimeter, you will not be able to complete your build.  ", "step_imgs": ["https://cdn.instructables.com/FCZ/H1ZP/IOYPYIUW/FCZH1ZPIOYPYIUW.LARGE.jpg"], "step_title": "Step 1: (Kit) Unpack and Sort Components"}, {"step": 2, "steps_text": "Control Panel Drill TemplateResistors (Metal Film):NOTE: R3 is 22k, not 47k (this was changed after boards were printed)Value - Quantity22 - 1   1k - 5   2.2k - 1   4.7k - 1   10k - 6   18k - 2   22k - 1   27k - 2   33k - 2   47k - 3   56k - 2   82k - 1   100k - 4   180k - 1   470k - 1   1m - 2Capacitors:Value - Quantity - Package Code.002uF (2nF) - 1 - 222   .01uF (10nF) - 2 - 103   .1uF (100nF) - 2 - 104   .47uF (470nF) - 1 - 474Electrolytic Capacitors:Value - Quantity1uF - 1  10uF -2  100uF - 2Diodes:Type - Quantity1N4148 - 2   1N4738 - 1   1N5817 - 2   LED - 1Transistors:Type - Quantity2N3906 - 2   BF256 - 1ICs:Type - QuantityRC4558 - 3Potentiometers:Value - Type - Quantity10k - Logarithmic (A) - 1   100k - Linear (B) - 5Switches:Type - QuantityDPDT - 2Jacks:Type - Quantity3.5mm Mono Switching - 10Wire:Gauge - Length24awg - 6 feet (2 meters)Knobs:Type - QuantitySmall - 4   Large - 2LED Lens:Type - QuantityFresnel Lens - 1Power Socket:Type - QuantityModular Keyed - 1", "step_imgs": ["https://cdn.instructables.com/FBE/BIT0/IP08W99J/FBEBIT0IP08W99J.LARGE.jpg", "https://cdn.instructables.com/FY9/X2PD/IP08W6TA/FY9X2PDIP08W6TA.LARGE.jpg", "https://cdn.instructables.com/FDA/K1GZ/IOVP7XO2/FDAK1GZIOVP7XO2.LARGE.jpg"], "step_title": "Step 2: (PCB) Purchase Components (Bill of Materials, Component Reference, & Schematic)"}, {"step": 3, "steps_text": "We source most parts from  www.mouser.com.  For international builders, we suggest using  www.farnell.com.All resistors are 1/4 watt metal film 1% tolerance.Electrolytic & film capacitors must be rated at 25 volts or more.  Be sure to check the lead spacing dimension of the part and make sure it will fit the component footprint on the PCB.For potentiometers, we use 16mm Alpha long pin right angle PCB mount pots.  These are available from Small Bear.  You can, of course, use your own potentiometers, especially if you do not plan to mount the PCB parallel to your panel.The 3.5mm jack we use is custom made, but you can use any 3.5mm jack (be aware: you may need to change the drill template to match your part).  We use switching jacks, but they are not necessary unless you would like to normal the connection between the triangle wave and Mod input.  A suitable jack can be found here on MCM Electronics.For the LED, you can use almost any standard one with or without a lens.The Power socket can be any brand that you like, so long as it has the standard .1\" (2.54mm) pin spacing.  You may also want to directly wire to the V+, V-, and GND connections, especially if you are not building a Eurorack Gristleizer.  We use a standard 16 pin socket that is available from Mouser.For the power supply, you can run this board at +/- 12V or +/-15V.", "step_imgs": [], "step_title": "Step 3: (PCB) Parts Sourcing Suggestions"}, {"step": 4, "steps_text": "Cut and strip the wires according to the length and the quantities listed below, and then set them aside.  Strip the end of each wire approximately 3/16ths of an inch (5mm).  We suggest you tin them by melting a little solder onto the tip of each wire \u2014 this prevents fraying as they are inserted into the switches and PCBs.2in (5cm): 13 wires    3in (7.5cm): 4 wires 4in (10cm): 3 wires", "step_imgs": [], "step_title": "Step 4: Cut, Strip, and Tin Wires"}, {"step": 5, "steps_text": "Populate and then solder all resistors.  Before soldering, double and then triple check that you are putting the correct value into the correct space.  Once they have been soldered, cut the resistors\u2019 leads and set them aside to be used as jumpers.  We recommend you use a multimeter to check resistor values - if you do not have a multimeter, use the color codes above.", "step_imgs": ["https://cdn.instructables.com/F22/X1AB/IOYPYJBM/F22X1ABIOYPYJBM.LARGE.jpg"], "step_title": "Step 5: Populate and Solder Resistors"}, {"step": 6, "steps_text": "Use one of the resistor leads you saved as a jumper from pads M to N on the back of the PCB.  The loop of the jumper should stick out on the back of the PCB \u2014 meaning when you solder it, you should solder it on the component side of the board.  You should do this because the jumper is a bare wire and you want to minimize the chance of it shorting to another component.  Clip the leads of the jumper on the component side of the board and discard them.", "step_imgs": [], "step_title": "Step 6: Connect the M and N Pads With a Jumper"}, {"step": 7, "steps_text": "Populate all diodes, making sure to observe correct orientation.  The stripe on the diode should match the stripe on the board.  Not orienting diodes correctly is the #1 mistake DIY builders make.  Once you have populated the diodes and checked their orientation, solder and then cut their leads.  The diodes with thick leads may be difficult to solder because their leads act like heat sinks.  To make them easier to solder, after inserting them into the board, bend their leads outward a little to keep them in place, and then cut most of the excess lead away before soldering.  After you have soldered them, cut the remaining excess.", "step_imgs": [], "step_title": "Step 7: Populate and Solder Diodes"}, {"step": 8, "steps_text": "Populate the three RC4558 op-amps.  Double and then triple check your orientation.  The Texas Instruments RC4558 has a dot next to pin 1. Pin 1 is on the left side of the keyhole on the PCB silkscreen.  This is another very common mistake that even experienced DIYers make, so slow down, focus, and put them in the correct way.  Once you are certain that you have them oriented correctly, solder them to the board.  ICs can be very heat sensitive, so when in doubt, wait 5-10 seconds between soldering each pin, or rotate between each IC to give the package time to cool off.", "step_imgs": [], "step_title": "Step 8: Populate and Solder ICs"}, {"step": 9, "steps_text": "Populate all transistors, again, making sure to observe correct orientation.  Incorrectly orienting transistors is another popular DIY mistake.  Look closely at each silkscreened outline: the long flat face of the outline should match the flat face of each transistor.  Transistors do not need to be mounted flush with the PCB - push them in as far as they\u2019ll go and then while the board is still component side up, bend the transistors\u2019 leads outward so that they will stay in place when you flip the board over to solder them.  After double and then triple checking your orientation, solder and then cut the transistors\u2019 leads.", "step_imgs": [], "step_title": "Step 9: Populate and Solder Transistors"}, {"step": 10, "steps_text": "Populate all the small, non-polarized capacitors. Double and triple check the values by reading the package code and checking it against the Bill of Materials.  Solder and cut their leads.", "step_imgs": [], "step_title": "Step 10: Populate and Solder Non-polarized Capacitors"}, {"step": 11, "steps_text": "Populate all the polarized electrolytic (barrel) capacitors.  The stripe with the minus (-) symbol is the negative lead.  Negative electrolytic leads are also often shorter than positive leads.  Double and then triple check each capacitor\u2019s orientation.  Once you are sure each capacitor is oriented correctly, solder and cut their leads.", "step_imgs": [], "step_title": "Step 11: Populate and Solder Electrolytic Capacitors"}, {"step": 12, "steps_text": "Place the power connector on the back (solder side) of the PCB with its locating notch facing towards the center of the PCB as seen in the photo.  You may find it helpful to use a clothespin to hold the connector in place as you solder.  You should only need to solder one or two pins to keep the power connector in place, after which you can remove the clothespin and finish soldering.  Be careful: applying heat too long to any one pin may melt its plastic casing.  If you think you are soldering too slowly, let the component cool off between each solder pin for 5-10 seconds.  Note: the power connector for this module is not \u201cRed stripe down.\u201d  Instead, the negative voltage enters at the top of the power connector.  If you orient the power connector correctly, this won\u2019t be a problem because the keyed slot will prevent backwards connection.  The power pads you see at the bottom of the connector are alternate pads for those who want to install this board into 5U or other non-Eurorack systems.  The power inputs are polarity protected by diodes.", "step_imgs": ["https://cdn.instructables.com/F3B/QNEX/IOVP7XUS/F3BQNEXIOVP7XUS.LARGE.jpg", "https://cdn.instructables.com/F4I/1LFO/IOVP7XYO/F4I1LFOIOVP7XYO.LARGE.jpg"], "step_title": "Step 12: Populate and Solder Power Connector"}, {"step": 13, "steps_text": "Break off the locking tabs on the potentiometers using wire cutters or pliers.  The metal is soft and should give easily and break cleanly.  Hold the body of the potentiometer with one hand (as shown) rather than holding the potentiometer by its pins.", "step_imgs": ["https://cdn.instructables.com/F97/X3K6/IOVP7XLL/F97X3K6IOVP7XLL.LARGE.jpg"], "step_title": "Step 13: Snap Off Locking Tabs From Pots"}, {"step": 14, "steps_text": "Note the orientation of the potentiometers in the photo before proceeding.  If the board is component side up, the \u201cEndangered Audio Research\u201d label should be at the top of the board.  Going from top to bottom, the first potentiometer is casing first; then pins, while all the rest on the board are pins first; then casing.", "step_imgs": ["https://cdn.instructables.com/FQK/YXWZ/IOVP7XKJ/FQKYXWZIOVP7XKJ.LARGE.jpg"], "step_title": "Step 14: Note Potentiometer Orientation"}, {"step": 15, "steps_text": "Populate the PCB-mounted potentiometers on the component side.  Double and then triple check each pot's value and orientation.  Turn the board over solder one leg of each pot.  After you apply the solder, check that each pot is flush with the component side of the board.  If not, reheat the solder and with your free hand, reposition the pot.  When you are confident that all pots are sitting flush on the PCB, solder the remaining pins.", "step_imgs": ["https://cdn.instructables.com/FLP/7DYG/IOVP7XLA/FLP7DYGIOVP7XLA.LARGE.jpg"], "step_title": "Step 15: Populate and Solder Pots"}, {"step": 16, "steps_text": "Insert the LED (D4), making sure to double and then triple check its polarity.  The flat edge of the LED lines up with the flat edge on the PCB silkscreen.  Like the electrolytic capacitors, the shorter lead of the LED is negative.  The LED should stand straight about a centimeter off the board.  If you want, you can cut a straw a desired length and feed one of the LED\u2019s leads through it so that it stands straight at the correct height.  The straw will also prevent accidental shorting from a rough hand during final assembly.  Just make sure it is not too tall that it won\u2019t fit properly into the panel lens.  Once you are certain of the LED\u2019s orientation and height, solder and cut the leads.", "step_imgs": [], "step_title": "Step 16: Populate and Solder the LED"}, {"step": 17, "steps_text": "Attached is a .zip file that includes a .pdf and .ai version of the Gristleizer drill template.There's no right way to design your panel; just make sure that the drill centers are accurate and that the labels you make for controls will not be covered by whatever type of knob you choose.Following the drill template and using PCB mounted pots will result in a very skiff-friendly module.If you are crafty, you can of course create a smaller, tighter layout with the PCB mounted at a right angle to the panel, but the result will not likely fit in shallow synth cases.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 17: (PCB) Design and Drill Your Panel"}, {"step": 18, "steps_text": "If you purchased a kit, carefully peel the protective plastic from the control panel.  Next, mount the indicator light lens.  The tolerance on the lens is very tight and you may need to push very hard to get it to pop through.  If you cannot seat the lens with your hands alone, lay a towel on a clean table and push the panel down onto the lens with both hands, taking care not to bend the panel.  Be aware of what the panel\u2019s face is touching to avoid scratches.", "step_imgs": [], "step_title": "Step 18: Mount Lens to Panel"}, {"step": 19, "steps_text": "Insert the potentiometer shafts through the front panel holes.  You may need to bend and straighten the pots a little.  The important thing here is to not jam them into place.  You also want to make sure that the LED is seating correctly in the lens.  Once all of the pots are seated and the LED is standing straight under the lens, fasten the potentiometers with their washer and nut.  Be careful not to over-torque them: they only need to be hand-tight.  Once you\u2019ve finished that, set the module aside for a moment.", "step_imgs": ["https://cdn.instructables.com/FQB/RU1Z/IOVP7XUJ/FQBRU1ZIOVP7XUJ.LARGE.jpg"], "step_title": "Step 19: Mount Board to Panel"}, {"step": 20, "steps_text": "Gather the two switches along with 10 of the 2in (5cm) wires that you made in step 3 and one jumper you collected from the resistors in step 4.  A vice or some way to hold the switch stable while you solder is highly recommended, but not required.", "step_imgs": [], "step_title": "Step 20: Gather Switches and Wire"}, {"step": 21, "steps_text": "Take all the hardware off the switch except for the bottom nut and set that aside in a place where you won\u2019t easily lose them.", "step_imgs": [], "step_title": "Step 21: Prepare Switches for Soldering"}, {"step": 22, "steps_text": "For the Mode switch (marked VCA/VCF on the panel), solder 6 of the 2in (5cm) wires, starting at the bottom of the switch and working your way up (see illustration below).  Take special care not to overheat the switch - using a broad-tipped soldering iron and pre-tinned wires will go a long way to quickly and cleanly soldering the switch without conducting too much heat into its plastic housing.  When in doubt, wait 5-10 seconds between each wire to allow the switch to cool down.", "step_imgs": ["https://cdn.instructables.com/FU4/YVD4/IOZ5184B/FU4YVD4IOZ5184B.LARGE.jpg"], "step_title": "Step 22: Solder Wires to the Mode Switch"}, {"step": 23, "steps_text": "For the Bypass switch, first solder the jumper between the bottom two pins, then solder the 4 remaining 2in (5cm) wires to the top four pins (see illustration below).  Cut the excess lead from the jumper.", "step_imgs": ["https://cdn.instructables.com/FJ1/9DAE/IOZ518CI/FJ19DAEIOZ518CI.LARGE.jpg"], "step_title": "Step 23: Solder Wires to the Bypass Switch"}, {"step": 24, "steps_text": "Replace the star washer on the switch bushing and make sure the teeth of the washer are facing towards the panel so that they will catch and dig into the panel.  Use the nut on the bottom of the switches\u2019 bushing to position them so that just enough threading (about 4-6 turns) is visible on the front panel.  Hold the switch in one hand while tightening the front panel nut with the other.  If you use a tool to tighten these switches, make sure you place a piece of paper between the tool and the panel so that you don\u2019t make any scratches.", "step_imgs": ["https://cdn.instructables.com/F8M/QWQ3/IOVP7XYX/F8MQWQ3IOVP7XYX.LARGE.jpg"], "step_title": "Step 24: Mount Switches to the Panel"}, {"step": 25, "steps_text": "Now that the switches have been mounted, connect each wire to the board as they are labelled in the illustrations.  Pay special attention to this so that the C pin of the Bypass switch goes to point C on the top of the board, and so on.  Double and then triple check your wiring before moving on to the next step.", "step_imgs": ["https://cdn.instructables.com/FV0/JBD9/IOVP7XZU/FV0JBD9IOVP7XZU.LARGE.jpg"], "step_title": "Step 25: Solder Switches to the PCB"}, {"step": 26, "steps_text": "If you have a vice, put the module in the vice with a cloth or paper towel around the panel and then into the vice to prevent scratching.  Tighten just enough to hold it steady.  If you do not have a vice, you can continue from here using the same steps, but use something to prop up and immobilize the panel while soldering.Insert the jacks into the jackboard.  Flip the board over so that the solder-side is facing up, reverse the board, and insert them into the panel.  Tighten their washers on the panel backwards and upside down as shown below.  This will allow you to solder each of the jack boards easily in a way that will also ensure that they will fit properly.", "step_imgs": ["https://cdn.instructables.com/FLB/KPQF/IOVP7XS2/FLBKPQFIOVP7XS2.LARGE.jpg", "https://cdn.instructables.com/FWQ/OVO1/IOVP7XSL/FWQOVO1IOVP7XSL.LARGE.jpg", "https://cdn.instructables.com/F36/I35Z/IOVP7XVZ/F36I35ZIOVP7XVZ.LARGE.jpg"], "step_title": "Step 26: (Kit) Prepare Jack Boards"}, {"step": 27, "steps_text": "Solder the jacks to the board.  When you finish soldering the first jack board, remove it, set it aside, and then insert the next set of jacks and repeat the process.  Do not solder the jacks to their jackboards without inserting them into the panel as described above \u2014 if you solder them outside the panel, they may not fit correctly, and you will have to resolder them to get them to fit.  Once you are finished with the second board, remove it and insert both jack boards in their correct orientation.  If you are using a vice, do not remove the module just yet.", "step_imgs": ["https://cdn.instructables.com/FKD/2YCR/IOVP7XSA/FKD2YCRIOVP7XSA.LARGE.jpg"], "step_title": "Step 27: (Kit) Solder Jack Boards"}, {"step": 28, "steps_text": "Grab 4 of the jumpers you set aside in step 4.  Start with the ground buss between the input and output jack (labeled GND).  Insert the jumper through both holes and bend the jumper at the top to hold it in place.  Solder the jumper to the bottom (Input) jack board first.  Now solder the GND pad on the top (Output) jack board.  Next, using the same technique, connect the Tip pads (labeled T) between the jack boards for the Bias and Bias Mix jacks.  After that, take the 3rd jumper and connect the T pads of the Freq and Freq Mix jacks together.  Finally, solder the last jumper between the triangle wave output and the Mod input through the Tip Switch pads (labeled TS).  The pictures clearly illustrate each of these connections.", "step_imgs": ["https://cdn.instructables.com/F9Q/3P7B/IOVP7XS0/F9Q3P7BIOVP7XS0.LARGE.jpg", "https://cdn.instructables.com/FBK/5LEH/IOVP7XRR/FBK5LEHIOVP7XRR.LARGE.jpg"], "step_title": "Step 28: (Kit) Insert and Solder Buss Wires to Jack Boards"}, {"step": 29, "steps_text": "Connect the remaining wires from the jack PCBs to the main PCB.  Start with the connections closest to the jack PCBs and work outwards.  Below are the specified wire lengths for each connection in the suggested soldering order:Square: 2in (5cm) - to Pad V  Triangle: 2in (5cm) - to Pad U  Mod: 2in (5cm) - to Pad Q  Input: 3in (7.5cm) - to Pad E  Output: 3in (7.5cm) - to Pad A  Bias: 3in (7.5cm) - to Pad O  Bias Mix: 3in (7.5cm) - to Pad P  Freq: 4in (10cm) - to Pad R  Freq Mix: 4in (10cm) - to Pad S  Saw: 4in (10cm) - to Pad T", "step_imgs": ["https://cdn.instructables.com/FV0/04U0/IOVP7XTA/FV004U0IOVP7XTA.LARGE.jpg"], "step_title": "Step 29: Solder the Jack Boards to the PCB"}, {"step": 30, "steps_text": "Connect your module to your rack\u2019s power source and turn it on.  Sweep the Freq pot and watch for the blinking LED.  If the LED does not turn on, quickly disconnect the module and start troubleshooting (check orientations!).  If the LED is flashing, then your module is likely assembled correctly.", "step_imgs": [], "step_title": "Step 30: Power Up Your Module"}, {"step": 31, "steps_text": "To assess your module\u2019s functionality, run it through our factory test routine:Feed a noise source or harmonically-rich oscillator waveform (like a Saw) to the module\u2019s input.   Switch the module to the \u201cOut\u201d (bypassed) position.    Feed the output of the module to an amplifier.  You should now hear the sound without any modulation.  If you hear modulation, check to make sure that your In/Out switch is wired correctly and is also not upside down.    Turn the Level knob all the way down.  This module can add a lot of gain to your signal, and suddenly switching it in with the Level knob turned all the way up may be an unpleasant surprise.    Switch the module into VCA mode, then switch in the effect.      Turn the Freq knob down to around 9 o\u2019clock so that it is flashing rapidly, but not so quickly that it looks persistently on.    Turn the Depth and Bias knobs all the way up and the Gain knob all the way down.    Slowly turn up the Level knob.    You should now be hearing a tremolo (amplitude modulating) effect.  If you are hearing a filtering effect, make sure the Mode switch is wired correctly and not turned upside down.  If you hear nothing, check the wiring on your In/Out switch.    Turn up the Gain knob - you should hear the signal begin to distort.    Turn down the Bias knob - you should hear the signal become less distorted.    Turn the Bias knob back up and then turn the Depth knob down - you should hear the modulation fade out, but the distortion will remain.    Switch into VCF mode.  The effect should now sound like an auto wah (sweeping bandpass filter).  Test all the controls in the same way you did for VCA mode.    Turn the Bias all the way down with the Depth all the way up.  Turn the Filter Mix knob all the way down.  You should now hear the filter sweeping in the high frequency ranges.  Slowly turn the Filter Mix knob up - you will begin to hear the low end starting to come back in.  If your input signal is very hot and the Gain is turned all the way up, as you turn the Filter Mix knob up, your signal may distort to the point where it sounds like it \u201cducks out,\u201d similar to a sidechained compressor.  This is normal and is caused by super-saturating the FET.    Turn the Bias knob all the way up, the Filter Mix all the way down, and the Freq knob back into the 9 o\u2019clock range if you have since changed it.    Take a patch cord and plug it into the Mod input.  You should hear the modulation stop suddenly.  This is because you are breaking the normalized connection between the Triangle LFO output jack and the Mod input jack.  With the patch cord still connected to the Mod input, insert the other end into the Triangle LFO output.  This should sound the same as the module when it is unpatched.  If it does not, check the buss wiring between the jack boards.    Remove the patch cable from the Triangle output and insert it into the Saw output.  You should notice a change both sonically and in the behavior of the LED.  If it is modulating but sounds like a square wave, you probably have the wiring reversed.    Remove the patch cable from the Saw output and insert it into the Square output.  Although the Square output is not a true square wave, it should have a more pronounced on/off modulation effect compared to the Triangle and Saw outputs.  If it sounds more like a saw wave, again, you may have reversed the wiring on the jack boards.    Switch the module back into VCA mode.  Remove the patch cable from the Mod input and place the Square wave LFO into the Freq Mix jack.  You should hear some self modulation happening \u2014 if you don\u2019t, try adjusting the Freq knob to offset the input voltage.  If you don\u2019t hear anything or the LFO suddenly stops, recheck your jacks\u2019 wiring.  If the Freq Mix input works, you can be certain that the Freq input works, as they are flowing to the same part of the circuit.  You should, however, plug into the Freq input to see that it switches out the Freq knob.  With a patch cable plugged into the Freq input, the Freq knob should be disabled.    Unplug the Square wave from the Freq Mix and plug it into the Bias Mix input.  With the Bias turned all the way up, you should hear some faint modulation in the distortion characteristics.  This is normal.  Because all of the LFO outputs are synced to one another, the effect of modulating the Bias or Frequency is less pronounced than it would be if modulate those parameters from a different source.  Like the Freq Mix input, you do not need to test the Bias input separately.  You should, however, plug into the Bias input to see that it switches out the Bias knob.  With a patch cable plugged into the Bias input, the Bias knob should be disabled.If your module has passed inspection, congratulations!  You are finished with construction.", "step_imgs": [], "step_title": "Step 31: Test Your Module"}, {"step": 32, "steps_text": "Troubleshooting: If it does not seem to work like it should, these are common reasons why it might not, ranked from most to least likely:Diodes are backwards  Electrolytic caps are backwards*  LED is backwards  Transistors are backwards*  ICs are backwards*  Wiring is incorrect*  Missing the M-N jumper  Components were overheated*  Power jack is backwards**** \u2014 if you find these problems when troubleshooting your build, you will likely need to desolder and replace some components, because they are probably destroyed.  Backwards or incorrect wiring can cause a host of problems \u2014 look for nearby damaged caps first then spread out from there.** \u2014 an easy rule to follow with soldering: if it looks terrible, it is terrible.  In other words, if you would be angry if you bought this module pre-made and it had the quality of solder work that you just gave it, your problem might be with your soldering.  The solution here is to step away from this project and go back to YouTube or down to simpler projects to practice good soldering techniques before returning to repair it.  Trying to repair your kit at this point might just do more harm than good.  Your solder should flow meaning you shouldn\u2019t have to cut off golf balls of solder from the bottom of the PCB.  If you are trimming a solder joint that is spherical, it means that the solder has not made a good connection.  If you have bad soldering technique, your problems may be myriad and intermittent.*** \u2014 if you soldered the power jack backwards and powered the unit up, you probably did no harm to your Gristleizer \u2014 that is, if you correctly oriented the polarity protection diodes.  If you didn\u2019t install the diodes correctly and fed the module power incorrectly, you probably caused a cascade of failures \u2014 at that point it might be worth it to start over with a fresh board.  If you did solder the power jack backwards but didn\u2019t harm your module, it might be worth your time just to cut out a new keyhole with a razor blade (carefully!) rather than trying to desolder it from the board.  You\u2019ll have to be mindful in the future about how you connect it though!", "step_imgs": [], "step_title": "Step 32: Troubleshooting Your Module"}], "channel": "Electronics"}, {"category": "No category to show", "description": "Lets start off by saying that I am a noob to micro controllers like Arduino. After looking through instructables for a while I saw the things that arduino could do. That is when I realized that I had to get one and learn the whole process of programming. So having said that I will now move onto my first instructable build. UPDATE!! \u00a0 IF YOU HAVE UPGRADED TO ARDUINO 1.0 THE WAVE LIBRARY WILL NOT WORK!!! I AM CURRENTLY LOOKING FOR A FIX TO THIS. IN THE\u00a0MEAN TIME PLEASE USE THE OLDER VERSION OF ARDUINO SOFTWARE OR IF YOU CAN HELP WITH THE FIX PLEASE POST!!\u00a0 I decided to create a singing pumpkin display for Halloween. I got the idea from https://www.instructables.com/id/Singing-PumpkinsParallel-Port-Relay-Box/ I did't have a parallel port but I had an arduino, sound shield and lots of patience. I used the song \"This is Halloween\" from Nightmare Before Christmas, wrote the code and built a relay board. I will go over how I did this later. Even though it took a lot of work the final result is well worth it! Video is posted in last step.CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! CAUTION!! THIS PROJECT DEALS WITH HIGH VOLTAGE. IF YOU ARE NOT CAREFUL YOU COULD GET SERIOUSLY INJURED. IF YOU ARE NOT COMFORTABLE WITH THAT PORTION OF THE PROJECT, PLEASE GET SOMEONE TO HELP. ", "title": "Singing Pumpkins/ Arduino", "url": "https://www.instructables.com/id/Singing-Pumpkins-Arduino/", "section": "home", "steps": [{"step": 1, "steps_text": "Things you will need: Tools: Drill Dremel Solder Iron Solder Screwdriver Utility Knife Supplies: Arduino ( I used the uno with smd chip) Wave shield 8 pumpkins with light socket and cord( the more styles the better ) flicker bulb set ( available at HD Christmas isle) 5 outlets relays wire ( low voltage, electrical cord ) Preff board 9 diodes- Vr/50v Io/1A T/R. Mfg P/N: 1N4001 9 10k OHM 5% 1/4W carbon film resistors 9 330 OHM 1/6W carbon film resistors 9 transistors- 600mA 75V NPN ON Semi Bipolar Small Signal Mfg P/N; P2N2222AG 9 leds 3v Plastic box ( for relay board and outlets ) Small plastic box ( protection for arduino and sound shield ) Masking Tape Electrical tape 9v wall wart (adapter) For the relay board set up I needed 9 relays that control 110v. That 's 8 for the pumpkins and 1 for the flicker bulbs that will run In standby mode. The relays I used are 5v input and 110v 12a output. The relays are wired to be controlled by the arduino but they are powered by a wall wart ( transistors are perfect for using a low voltage to control a higher voltage ). The circuit is simple( as you will see in upcoming steps). The arduino sends a signal to the 10k resistor which is connected to the center pin of the transistor. This will use the transistor as a switch to connect the negative from the wall wart to the relay pin by switching the ground.", "step_imgs": ["https://cdn.instructables.com/FG4/TT3O/GTYSUWKF/FG4TT3OGTYSUWKF.LARGE.jpg", "https://cdn.instructables.com/FAA/NJY2/GTO4P419/FAANJY2GTO4P419.LARGE.jpg", "https://cdn.instructables.com/F6I/UA63/GTN5PWNJ/F6IUA63GTN5PWNJ.LARGE.jpg"], "step_title": "Step 1: Things You Will Need"}, {"step": 2, "steps_text": "For this step I laid out my relays so I could get an Idea of how I wanted it to be. The relay I used had the load pin in the middle and it did not fit into the preff board so some drilling was needed ( see pic ). Now it's time to place relays and solder them. Once the relays are all soldered we can now move on to placing the other parts. I started with the diode. Even though relays have no polarity the diode will change that ( diodes let the juice flow one direction ) and that will keep the voltage from bouncing back where it shouldn't be.", "step_imgs": ["https://cdn.instructables.com/F8O/XG5Q/GTN5PWNM/F8OXG5QGTN5PWNM.LARGE.jpg", "https://cdn.instructables.com/FNN/P0LK/GTO4ORNI/FNNP0LKGTO4ORNI.LARGE.jpg", "https://cdn.instructables.com/F15/6JMN/GTN5PWNO/F156JMNGTN5PWNO.LARGE.jpg"], "step_title": "Step 2: Relay Board 1"}, {"step": 3, "steps_text": "At this point I added the transistor and first resistor (10k). Since the transistor switched a ground or negative I placed it so the output pin is connected to the diode negative or ground side. ( side without stripe ). The resistor is connected to the signal pin of the transistor this pin is used to control the internal switch. In the next picture I added the second resistor (330k). This is used to limit or resist the voltage to the led. In the picture it looks like it connects to the transistor but it is not. The side of the resistor that is facing away from the transistor will be soldered together. By now the solder connections are as follows. Solder relay to the board. solder diode so that each pin is soldered to the relay signal pins. Place transistor and solder one pin to the negative side of the diode and relay. Solder the 10k resistor to the middle pin of the transistor. Solder the 330ohm resistor so that both resistors are connected opposite of that transistor.", "step_imgs": ["https://cdn.instructables.com/FUL/3NY1/GTO4P41S/FUL3NY1GTO4P41S.LARGE.jpg", "https://cdn.instructables.com/FYN/2ZCC/GTO4ORNL/FYN2ZCCGTO4ORNL.LARGE.jpg"], "step_title": "Step 3: Relay Board 2"}, {"step": 4, "steps_text": "In this step add the led. Leds have a flat edge on one side this is the negative( - ) or cathode. This will be soldered to the last pin of the transistor. The other pin of the led the anode will be soldered to the 330k resistor. You may notice in the second picture the layout is slightly different then the first and that is because things got a bit tight for soldering. However the circuit remains the same. (See pic). The next pic show the jumper wires used to connect the positive( + ). This will feed power to all relays with a wall wart. The jumper wires are soldered to the stripe end of each diode. It's now a good time to add the signal wires. The wall wart negative (-) ground connects to the ground buss bar and arduino ground. Now to the bottom of the relay board for some major work ( see pic ). I know the solder isn't pretty but, hey, \u00a0it's my first major solder project. Solder a buss bar to all load pins on the relays. Solder either a buss bar or jumper wires to all negative ( - ) connections. The negative connections need to connect to the ground on the arduino and to the negative on the wall wart. The only thing left to solder is the line wire from a male plug and the output load wires to each relay that will connect to your outlets.", "step_imgs": ["https://cdn.instructables.com/FT7/MUZJ/GTGCR6L4/FT7MUZJGTGCR6L4.LARGE.jpg", "https://cdn.instructables.com/FRB/TK51/GTO4P432/FRBTK51GTO4P432.LARGE.jpg", "https://cdn.instructables.com/FZ6/Z6SH/GU45HCHU/FZ6Z6SHGU45HCHU.LARGE.jpg", "https://cdn.instructables.com/F1B/H1HH/GTGCR6LE/F1BH1HHGTGCR6LE.LARGE.jpg", "https://cdn.instructables.com/FRJ/O7SH/GTO4ORNR/FRJO7SHGTO4ORNR.LARGE.jpg", "https://cdn.instructables.com/FJW/6AI7/GTYSUWS4/FJW6AI7GTYSUWS4.LARGE.jpg"], "step_title": "Step 4: Relay Board 3"}, {"step": 5, "steps_text": "Housing: Select a plastic box that will suit your needs. I used a shoe box sized box with lid. It gave me room for the 5 outlets, relay board and small plastic box for the arduino and sound shield. Lay masking tape across the side you choose for the outlets. Use an outlet face plate and trace holes. Now use the dremel to cut holes. Outlets: I used 5 outlets for 8 pumpkins. This is accomplished by removing the metal tab on one side of the outlet ( copper screw side, See pics ) This will now change the 5 outlets to 10. The project uses 8 plugs for the pumpkins, 1 plug for the flicker bulb string. So the left over one I connected so it stays live for the use of an adapter. On the other side of the outlet will be silver screws this is the neutral side( White Wire ). Connect all neutral sides together. Now on the other side where the tab was removed attach one (black ) wire to the top screw and one (black ) wire to the bottom screw. The black wires will connected to the relays. ( See pic for details ) Now take a plug end from an extension cord. The white wire from the cord will connect to the white wires on the outlets. The black wire will connect to the relay board via buss bar.", "step_imgs": ["https://cdn.instructables.com/FHH/1L5I/GTY4RXGQ/FHH1L5IGTY4RXGQ.LARGE.jpg", "https://cdn.instructables.com/FC9/QU06/GTY4RXGV/FC9QU06GTY4RXGV.LARGE.jpg", "https://cdn.instructables.com/FU7/UIKG/GTXKH5L1/FU7UIKGGTXKH5L1.LARGE.jpg", "https://cdn.instructables.com/FBX/RN13/GTYSUWPO/FBXRN13GTYSUWPO.LARGE.jpg", "https://cdn.instructables.com/FTS/782Z/GTYSUXBZ/FTS782ZGTYSUXBZ.LARGE.jpg"], "step_title": "Step 5: Set Up the Housing"}, {"step": 6, "steps_text": "I used this wave shield http://www.ladyada.net/make/waveshield/ It comes as a kit simply \u00a0follow the assembly instructions on the link. The wave shield will use pins 1, 2 ,3 ,4 ,5 ,10 Our project uses pins 6, 7, 8, 9, A0, A1, A2, A3, A4, A5 Pins 6 ,7 ,8, 9, A0, A1, A2, A3 will be used for the pumpkins flashing lights, pin A4 will be used to control the flicker bulb set and pin A5 will be used to control a relay that will disconnect the background audio and connect the wave shield to one set of speakers. This is so that everyone will focus on the main event of the Halloween display. Upload the audio file to an sd card, and upload the sketch to the arduino.SKETCH\u00a0 // Created by Greg Spiridakos 2011// #include <AF_Wave.h> #include <avr/pgmspace.h> #include \"util.h\" #include \"wave.h\" AF_Wave card; File f; Wavefile wave;\u00a0\u00a0\u00a0\u00a0\u00a0 // only one! #define redled 9 uint16_t samplerate; void setup() { \u00a0 \u00a0 Serial.begin(9600);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // set up Serial library at 9600 bps \u00a0 Serial.println(\"Wave test!\"); \u00a0 pinMode(2, OUTPUT);\u00a0 // used by sound shield \u00a0 pinMode(3, OUTPUT);\u00a0 // used by sound shield \u00a0 pinMode(4, OUTPUT);\u00a0 // used by sound shield \u00a0 pinMode(5, OUTPUT);\u00a0 // used by sound shield \u00a0 pinMode(6, OUTPUT);\u00a0 // led light \u00a0 pinMode(7, OUTPUT);\u00a0 // led light \u00a0 pinMode(8, OUTPUT);\u00a0 // led light \u00a0 pinMode(9, OUTPUT);\u00a0 // led light \u00a0 pinMode(A0, OUTPUT); // led light \u00a0 pinMode(A1, OUTPUT); // led light \u00a0 pinMode(A2, OUTPUT); // led light \u00a0 pinMode(A3, OUTPUT); // led light \u00a0 pinMode(A4, OUTPUT); // flicker bulb set \u00a0 pinMode(A5, OUTPUT); // auido switch over relay \u00a0 \u00a0 pinMode(redled, OUTPUT); \u00a0 \u00a0 if (!card.init_card()) { \u00a0\u00a0\u00a0 putstring_nl(\"Card init. failed!\"); return; \u00a0 } \u00a0 if (!card.open_partition()) { \u00a0\u00a0\u00a0 putstring_nl(\"No partition!\"); return; \u00a0 } \u00a0 if (!card.open_filesys()) { \u00a0\u00a0\u00a0 putstring_nl(\"Couldn't open filesys\"); return; \u00a0 } if (!card.open_rootdir()) { \u00a0\u00a0\u00a0 putstring_nl(\"Couldn't open dir\"); return; \u00a0 } \u00a0 putstring_nl(\"Files found:\"); \u00a0 ls(); } void ls() { \u00a0 char name[13]; \u00a0 int ret; \u00a0 \u00a0 card.reset_dir(); \u00a0 putstring_nl(\"Files found:\"); \u00a0 while (1) { \u00a0\u00a0\u00a0 ret = card.get_next_name_in_dir(name); \u00a0\u00a0\u00a0 if (!ret) { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 card.reset_dir(); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return; \u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0 Serial.println(name); \u00a0 } } uint8_t tracknum = 0; void loop() { \u00a0\u00a0 uint8_t i, r; \u00a0\u00a0 char c, name[15]; \u00a0\u00a0 card.reset_dir(); \u00a0\u00a0 // scroll through the files in the directory \u00a0\u00a0 for (i=0; i<tracknum+1; i++) { \u00a0\u00a0\u00a0\u00a0 r = card.get_next_name_in_dir(name); \u00a0\u00a0\u00a0\u00a0 if (!r) { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // ran out of tracks! start over \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tracknum = 0; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return; \u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0 } \u00a0\u00a0 putstring(\"\\n\\rPlaying \"); Serial.print(name); \u00a0\u00a0 // reset the directory so we can find the file \u00a0\u00a0 card.reset_dir(); \u00a0\u00a0 playcomplete(name); \u00a0\u00a0 tracknum++; } void playcomplete(char *name) { \u00a0 uint16_t potval; \u00a0 uint32_t newsamplerate; \u00a0 \u00a0 playfile(name); \u00a0 samplerate = wave.dwSamplesPerSec; \u00a0 while (wave.isplaying) {\u00a0\u00a0\u00a0\u00a0 // you can do stuff here! delay(500); \u00a0\u00a0 } \u00a0 card.close_file(f); } void playfile(char *name) { \u00a0\u00a0 f = card.open_file(name); \u00a0\u00a0 if (!f) { \u00a0\u00a0\u00a0\u00a0\u00a0 putstring_nl(\" Couldn't open file\"); return; \u00a0\u00a0 } \u00a0\u00a0 if (!wave.create(f)) { \u00a0\u00a0\u00a0\u00a0 putstring_nl(\" Not a valid WAV\"); return; \u00a0\u00a0 } \u00a0\u00a0 // ok time to play! \u00a0\u00a0 wave.play(); \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // this group animates the leds \u00a0\u00a0 \u00a0\u00a0 digitalWrite(A5,HIGH);\u00a0\u00a0\u00a0 // this will turn audio relay on to switch background music to audio sheild sharing speakers \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0 delay(14500);\u00a0\u00a0\u00a0\u00a0 // this will delay the leds after the audio has started in miliseconds \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 1000 miliseconds = 1second \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 14.5sec delay from start \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0 cycle 1 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0\u00a0\u00a0\u00a0 all on \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(23000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //delay 23.0 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 2 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // all off \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(5100);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 5.1 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 3 \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 8 off \u00a0\u00a0 delay(5700);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 5.7 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 4 \u00a0\u00a0 digitalWrite(9, LOW);\u00a0\u00a0\u00a0\u00a0 // 9 off \u00a0\u00a0 digitalWrite(7, HIGH);\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(5000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 5 sec total delay from start \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 // cycle 5 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0 all on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(6300);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //delay 6.3 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 6 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(9,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // all off \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(1100);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1.1 sec\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 7 \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // 8 on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // 9 on \u00a0\u00a0 delay(6000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 6 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 8 \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 //8 off \u00a0\u00a0 digitalWrite(9,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 //9 off \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // A0 on \u00a0\u00a0 delay(5000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 5 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 9 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // A0 off \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7\u00a0\u00a0 on \u00a0\u00a0 delay(6000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 6 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 10 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 all on \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 1 sec delay \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 11 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // all but A0 off \u00a0\u00a0 digitalWrite(9,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(100);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // .1 sec delay \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 12 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 //\u00a0 A0 off \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 //\u00a0 A1 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 13 \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // A1 off \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 14 \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // A1 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 15 \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // A1 off \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // 8 on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // 9 on \u00a0\u00a0 delay(8000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 8 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 16 \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(3000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 // cycle 17 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // all but 7 on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(2000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 2 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 // cycle 18 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // all but 9 off \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(2000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 2 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 19 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // all but A2 off \u00a0\u00a0 digitalWrite(9,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // dealy 1 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 20 \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // A2 off \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // A3 on \u00a0\u00a0 delay(3000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 21 \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // A3 off \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // A0 on \u00a0\u00a0 delay(2500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 2.5 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 22 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // A0 off \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // A3 on \u00a0\u00a0 delay(3000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 23 \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // A3 off \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(5500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 5.5 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 24 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // all on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 //\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(6000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 6 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //\u00a0 cycle 25 \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // 8 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 26 \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 8 off \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // 9 on \u00a0\u00a0 delay(7500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 7.5 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 27 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // 6 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 28 \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // A1 on \u00a0\u00a0 delay(2000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 2 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 29 \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(3500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3.5 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 30 \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // A1 off \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 7 off \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // A0 on \u00a0\u00a0 delay(3000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 31 \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // A1 on \u00a0\u00a0 delay(3000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 32 \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // A0 off \u00a0\u00a0 delay(2500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 2.5 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 33 \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // 8 on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // 9 on \u00a0\u00a0 delay(3500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 3.5 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 34 \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // 7 on \u00a0\u00a0 delay(1000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 1 sec \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 35 \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 // A0 on \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // A1 on \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // A2 on \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // A3 on \u00a0\u00a0 delay(17500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 17.5 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 36 \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // 8 on \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // 9 on \u00a0\u00a0 delay(6500);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 6.5 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 37 \u00a0\u00a0 digitalWrite(6,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(7,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(8,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(9,HIGH);\u00a0\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A0,HIGH);\u00a0\u00a0\u00a0 //\u00a0\u00a0\u00a0 all on \u00a0\u00a0 digitalWrite(A1,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A2,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 digitalWrite(A3,HIGH);\u00a0\u00a0\u00a0 // \u00a0\u00a0 delay(10000);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // delay 10 sec \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 38 \u00a0\u00a0 digitalWrite(6,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 6 off \u00a0\u00a0 digitalWrite(7,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 7 off \u00a0\u00a0 digitalWrite(8,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 8 off \u00a0\u00a0 digitalWrite(9,LOW);\u00a0\u00a0\u00a0\u00a0\u00a0 // 9 off \u00a0\u00a0 digitalWrite(A0,LOW);\u00a0\u00a0\u00a0\u00a0 // A0 off\u00a0\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A1,LOW);\u00a0\u00a0\u00a0\u00a0 // A1 off \u00a0\u00a0 digitalWrite(A2,LOW);\u00a0\u00a0\u00a0\u00a0 // A2 off \u00a0\u00a0 digitalWrite(A3,LOW);\u00a0\u00a0\u00a0\u00a0 // A3 off \u00a0\u00a0 delay(100);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // .1 sec delay \u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // cycle 39 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // starts random flashing \u00a0\u00a0 digitalWrite(6,HIGH); \u00a0\u00a0 digitalWrite(A0,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,LOW); \u00a0\u00a0 digitalWrite(9,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(9,LOW); \u00a0\u00a0 digitalWrite(A0,LOW); \u00a0\u00a0 digitalWrite(7,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,HIGH); \u00a0\u00a0 digitalWrite(7,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,LOW); \u00a0\u00a0 digitalWrite(8,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(8,LOW); \u00a0\u00a0 digitalWrite(A2,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,LOW); \u00a0\u00a0 digitalWrite(A2,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,HIGH); \u00a0\u00a0 digitalWrite(A0,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,LOW); \u00a0\u00a0 digitalWrite(9,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(9,LOW); \u00a0\u00a0 digitalWrite(A0,LOW); \u00a0\u00a0 digitalWrite(7,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,HIGH); \u00a0\u00a0 digitalWrite(7,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,LOW); \u00a0\u00a0 digitalWrite(8,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(8,LOW); \u00a0\u00a0 digitalWrite(A2,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,LOW); \u00a0\u00a0 digitalWrite(A2,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,HIGH); \u00a0\u00a0 digitalWrite(A0,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,LOW); \u00a0\u00a0 digitalWrite(9,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(9,LOW); \u00a0\u00a0 digitalWrite(A0,LOW); \u00a0\u00a0 digitalWrite(7,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,HIGH); \u00a0\u00a0 digitalWrite(7,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,LOW); \u00a0\u00a0 digitalWrite(8,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(8,LOW); \u00a0\u00a0 digitalWrite(A2,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,LOW); \u00a0\u00a0 digitalWrite(A2,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,HIGH); \u00a0\u00a0 digitalWrite(A0,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,LOW); \u00a0\u00a0 digitalWrite(8,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A0,LOW); \u00a0\u00a0 digitalWrite(A2,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(8,LOW); \u00a0\u00a0 digitalWrite(A2,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(7,HIGH); \u00a0\u00a0 digitalWrite(A3,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(7,LOW); \u00a0\u00a0 digitalWrite(9,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A3,LOW); \u00a0\u00a0 digitalWrite(9,LOW); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,HIGH); \u00a0\u00a0 digitalWrite(A1,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(6,LOW); \u00a0\u00a0 digitalWrite(8,HIGH); \u00a0\u00a0 delay(150); \u00a0\u00a0 digitalWrite(A1,LOW); \u00a0\u00a0 digitalWrite(8,LOW); \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 delay(8000); //\u00a0 delay between song and flicker bulbs delay in ms \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // stand by mode which will turn on flicker bulbs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0 digitalWrite(A4, HIGH); // flicker bulbs on \u00a0\u00a0 delay(200); // delay till audio is switched from audio shield to background music \u00a0\u00a0 digitalWrite(A5, LOW); // disconnects relay from audio shield to background music \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 delay(600000); // delay till flicker bulbs turn off and starts song and light show (600000ms = 10min delay) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 1000ms = 1sec, 600000ms = 10min \u00a0\u00a0 \u00a0\u00a0 digitalWrite(A4, LOW); // Turns of flicker bulbs \u00a0\u00a0 }}", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: Arduino/Wave Shield Set Up and the Files"}, {"step": 7, "steps_text": "Each pumpkin has a bulb and wire attached to it. Each pumpkin will connected to an outlet and will be on it's own channel. On the bottom of the pumpkins, drill a hole large enough to hold the flicker bulbs. The flicker bulb string will plug into it's own line that connects to the A4 pin of the arduino.", "step_imgs": [], "step_title": "Step 7: Pumpkins"}, {"step": 8, "steps_text": "Build your stand. In the back of the stand will be the guts of the operation as seen in the pictures. As you can see, I used a black box for the arduino and wave shield. I placed a cover that has a seal on it as I didn't want any moisture to harm either board. Drill a hole and feed your signal wires, a plug for arduino, and audio plug through the hole. I used a 9v wall wart to power the relay board and the arduino. You will want to connect the arduino and relay board to the adapter. (Caution: do not use the power pins to to power the relay board. If you use the arduino to power the relay board it will suffer in power and the relays will not have a strong latch.) AUDIO RELAY: Optional. if you will not use background music for your display simply leave this step out. For the audio relay connect the common wire ( the one with no skin ) from two male plugs and speakers . On the male plug connect the red and white (left ch and right ch) together do this for both male plugs. On the relay find the n/o pin connect to one of the male plugs red and white wires. This plug will connect to the wave shield. Now on the n/c pin connect the other male plugs red and white wires to this the same way as the last one. This plug will connect to your background music either to a computer, Ipod, Stereo, or whatever you are using. Locate the line pin, now connect the speakers red and white wire to this. The relay needs to be built like the other ones in this project with diode, resistors, led and transistors. Connect the signal wire to the arduino's A5 pin. Connect relays coil wires (-) and (+) to the wall wart connection. This setup will allow background music to play while the pumpkins are in standby mode with flicker bulbs running. Once the arduino program starts the relay will disconnect the background music and connect the speakers to the wave shield during singing. Once singing is done and flicker bulbs turn on, the audio relay will switch back on the background music.", "step_imgs": ["https://cdn.instructables.com/F5W/KTCT/GTY4RY6W/F5WKTCTGTY4RY6W.LARGE.jpg", "https://cdn.instructables.com/FD1/IWQ6/GTXK89CN/FD1IWQ6GTXK89CN.LARGE.jpg", "https://cdn.instructables.com/F6I/UA63/GTN5PWNJ/F6IUA63GTN5PWNJ.LARGE.jpg"], "step_title": "Step 8: Final Assembly"}, {"step": 9, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FZY/YOB8/GU3UJ8R2/FZYYOB8GU3UJ8R2.LARGE.jpg"], "step_title": "Step 9: Enjoy the Video"}], "channel": "No channel to show"}, {"category": "technology", "description": "I wanted to have a two-channel function generator that goes above audio frequencies.I was inspired by this xmega-based waveform generator Instructable.  But instead of using an xmega development board, I used the handy little Brainlink.  That's a device with an atxmega 16a4, a Bluetooth adapter, a USB-rechargeable battery, various sensors, and a firmware designed for easy Bluetooth control, all in a cute package.  They are sadly discontinued, but can bought for $39 at SurplusShed which is the cost of the parts (and SurplusShed has occasional sales that go up to 50% off all stock).To get a two-channel function generator that I could control over Bluetooth from my phone, all I had to do was to extend the Brainlink's firmware to add a waveform generator function, and then to write a simple Android app that communicates over Bluetooth with the Brainlink.Now that this is done, all you need to do is to install the firmware with my Android-based firmware uploader which sends the new firmware (which is backwards compatible) via Bluetooth to the Brainlink, and then use my Android app that controls the function generator.  All source code is here.Ingredients:Brainlink Tether for Brainlink's 8-pin port (included with Brainlink, but I recommend buying extra 8-pin 1.25mm pin spacing JST cables on ebay) Android device (theoretically any Bluetooth-enabled device will work with your own software, and you can just control the Brainlink directly with Realterm) Optional: Capacitor(s) for bipolar mode (I used 0.1 microFarad)The Brainlink, of course, remains fully usable for other purposes (e.g., this or this) when you're not using it as a signal generator.Gratitude: While I have no affiliation with Birdbrain Technologies, the maker of the Brainlink, Tom Lauwers of Birdbrain was pleased to see my earlier firmware developments and very kindly gifted me three more Brainlinks.", "title": "Bluetooth 100kHz+ Two-channel Function Generator", "url": "https://www.instructables.com/id/Bluetooth-100kHz-two-channel-function-generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "The updated firmware for the Brainlink with waveform generator is backwards compatible, but also adds some new features (e.g., Roomba bridge support) and fixes a nasty buffer overflow bug. The easiest way to update the firmware over Bluetooth is from an Android phone or tablet. Just: make sure your Brainlink is fully chargeddownload my firmware update app from Google Playpair your Android device with Brainlink (PIN 1234)turn off the Brainlinkconnect pins 2 and 8 (numbered from right to left; see photo) on the Brainlink's 8-pin portturn on Brainlink while keeping pins connected (blue firmware update light should turn on)run Brainlink Firmware Uploader on your Android devicechoose your Brainlink device (typically shows up as RN42-xxxx) and whether you want firmware optimized for connecting to a Roomba 500+ or for one of the older Roomba 400 / Create robots tap on \"Program device\"Before the last step, you might also want to increase the Bluetooth connectivity setting in the Uploader. This sets the Brainlink's Bluetooth module to higher connectivity, making it easier to connect to it in the future (you do lose some battery life).", "step_imgs": ["https://cdn.instructables.com/FM7/I47W/I0A57ACU/FM7I47WI0A57ACU.LARGE.jpg", "https://cdn.instructables.com/F0F/E7A1/I0A5723S/F0FE7A1I0A5723S.LARGE.jpg"], "step_title": "Step 1: Upgrade Brainlink Firmware"}, {"step": 2, "steps_text": "Install Brainlink Wave Generator on your Android device.  If you're using a different Android device from the previous step, pair your Brainlink with it. Make sure Brainlink is turned on. Plug tether into the 8-pin port on the Brainlink, making sure no wires short together.  (If you use this configuration a lot, you might make a modified tether where the lines irrelevant to the function generator are cut off.) Use Ohm's Law to ensure that the current draw at the voltages you want to generate won't exceed 20mA, as the Brainlink's pins are rated only for 20mA.  For instance, if you're connecting to a 50 ohm load, make sure no voltage exceeds V=IR=(0.020)(50)=1v. If you're connecting to a 1 mega-ohm oscilloscope, no worries. Set the settings for channel 1 or channel 2 and press the right Play button.   The waveform generator output will come from the pins marked in the photo. (On the original 8-pin tether, the CH1 and CH2 pins are blue, and the GND pin is black.)The sine/square/triangle wave function requires an amplitude between 0 and 3.3v (with 254 steps in between). See step 5 for a warning. The square wave generator requires choosing duty cycle (percentage between 0 and 100).  The arbitrary wave generator function requires a sequence of voltages, which whole sequence is played at the indicated frequency.Limitations: The xmega is limited to 1.0 MS/s in single-channel mode and 0.67 MS/s in dual-channel mode. This means that the theoretical maximum for a single-channel square wave is 500 kHz.  In practice, about 320 kHz is the highest I'd go for a single-channel square wave, and \"square\" is a bit of an overstatement (see picture).  For sine waves, rather lower frequency is better.  Even at 100 kHz, a sine wave doesn't look great, given how few samples it has per period.  My experiments suggest that generally dual-channel operation is best at 100 kHz and below.", "step_imgs": ["https://cdn.instructables.com/FZK/RRRO/I0A5723T/FZKRRROI0A5723T.LARGE.jpg", "https://cdn.instructables.com/F08/IUXE/I0A573TR/F08IUXEI0A573TR.LARGE.jpg", "https://cdn.instructables.com/FAA/QUBR/I0A573MU/FAAQUBRI0A573MU.LARGE.jpg", "https://cdn.instructables.com/FR9/2FKE/I0A573LS/FR92FKEI0A573LS.LARGE.jpg", "https://cdn.instructables.com/FX0/KIHM/I0A573N3/FX0KIHMI0A573N3.LARGE.jpg", "https://cdn.instructables.com/FX8/9SPT/I0A573MX/FX89SPTI0A573MX.LARGE.jpg"], "step_title": "Step 2: Use Waveform Generator Via Android Device"}, {"step": 3, "steps_text": "The xmega in the Brainlink has a unipolar Digital to Analog Converter (DAC).  This means that it generates a voltage between 0 and 3.3v.  If you want to generate a bipolar wave, say between -0.5v and +0.5v (e.g., for audio use), you need to pass the output through a capacitor.  A 0.1 microfarad one worked perfectly for me.  Note that if you use the capacitor, then the voltage you specify in the app will become the peak-to-peak voltage.  Thus, if in the app you specify a symmetric wave of 1v amplitude, you'll get a bipolar wave ranging from -0.5v to +0.5v.", "step_imgs": ["https://cdn.instructables.com/FGQ/VMJC/I0A573MW/FGQVMJCI0A573MW.LARGE.jpg", "https://cdn.instructables.com/FND/AV84/I0A573MV/FNDAV84I0A573MV.LARGE.jpg"], "step_title": "Step 3: Optional: Bipolar Waveform Generator"}, {"step": 4, "steps_text": "The custom Brainlink firmware adds three new functions.  To access them, first enter Brainlink command mode by sending an ASCII '*' (outside of command mode, the Brainlink emits a repeating 'BL' sequence).To play a sine, triangle or square wave, use the 'w' function.  Just send a w followed by (with less than a second in between characters) seven bytes:byte 1: channel, either ASCII '0' or ASCII '1'byte 2: type, either ASCII 's' (sine), 't' (triangle) or 'q' (square)byte 3: duty, between 0x00 and 0x3F; only matters for square waves and is otherwise ignored; however, I recommend setting it to 0x20 for other waves in case I want to use it to describe sawtooth waves in the futurebyte 4: amplitude, between 0x00 (=0v) and 0xFF (=3.3v)bytes 5-7: frequency in Hz, 24-bit number, most significant byte firstTo play an arbitrary wave, use the 'W' function.  Just send a W followed by (with less than a second in between characters) 5+n bytes:byte 1: channel, either ASCII '0' or ASCII '1'bytes 2-4: frequency in Hz, 24-bit number, most significant byte firstbyte 5: number n of data points (between 1 and 0x40)bytes 6 through 6+n-1: amplitudes, between 0x00 (=0v) and 0xFF (=3.3v)To stop playback, send ASCII '@' followed by the channel (ASCII '0' or '1').Note that the first wave channel ('0') cannot be used simultaneously with the Brainlink buzzer (buzzer will turn the channel off, and vice versa) and the second wave channel ('1') cannot be used simultaneously with the Brainlink IR emitter (IR turns off the wave channel and vice versa).", "step_imgs": [], "step_title": "Step 4: Optional: Control From Other Devices"}], "channel": "Electronics"}, {"category": "technology", "description": "I wanted to have a two-channel function generator that goes above audio frequencies.I was inspired by this xmega-based waveform generator Instructable.  But instead of using an xmega development board, I used the handy little Brainlink.  That's a device with an atxmega 16a4, a Bluetooth adapter, a USB-rechargeable battery, various sensors, and a firmware designed for easy Bluetooth control, all in a cute package.  They are sadly discontinued, but can bought for $39 at SurplusShed which is the cost of the parts (and SurplusShed has occasional sales that go up to 50% off all stock).To get a two-channel function generator that I could control over Bluetooth from my phone, all I had to do was to extend the Brainlink's firmware to add a waveform generator function, and then to write a simple Android app that communicates over Bluetooth with the Brainlink.Now that this is done, all you need to do is to install the firmware with my Android-based firmware uploader which sends the new firmware (which is backwards compatible) via Bluetooth to the Brainlink, and then use my Android app that controls the function generator.  All source code is here.Ingredients:Brainlink Tether for Brainlink's 8-pin port (included with Brainlink, but I recommend buying extra 8-pin 1.25mm pin spacing JST cables on ebay) Android device (theoretically any Bluetooth-enabled device will work with your own software, and you can just control the Brainlink directly with Realterm) Optional: Capacitor(s) for bipolar mode (I used 0.1 microFarad)The Brainlink, of course, remains fully usable for other purposes (e.g., this or this) when you're not using it as a signal generator.Gratitude: While I have no affiliation with Birdbrain Technologies, the maker of the Brainlink, Tom Lauwers of Birdbrain was pleased to see my earlier firmware developments and very kindly gifted me three more Brainlinks.", "title": "Bluetooth 100kHz+ Two-channel Function Generator", "url": "https://www.instructables.com/id/Bluetooth-100kHz-two-channel-function-generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "The updated firmware for the Brainlink with waveform generator is backwards compatible, but also adds some new features (e.g., Roomba bridge support) and fixes a nasty buffer overflow bug. The easiest way to update the firmware over Bluetooth is from an Android phone or tablet. Just: make sure your Brainlink is fully chargeddownload my firmware update app from Google Playpair your Android device with Brainlink (PIN 1234)turn off the Brainlinkconnect pins 2 and 8 (numbered from right to left; see photo) on the Brainlink's 8-pin portturn on Brainlink while keeping pins connected (blue firmware update light should turn on)run Brainlink Firmware Uploader on your Android devicechoose your Brainlink device (typically shows up as RN42-xxxx) and whether you want firmware optimized for connecting to a Roomba 500+ or for one of the older Roomba 400 / Create robots tap on \"Program device\"Before the last step, you might also want to increase the Bluetooth connectivity setting in the Uploader. This sets the Brainlink's Bluetooth module to higher connectivity, making it easier to connect to it in the future (you do lose some battery life).", "step_imgs": ["https://cdn.instructables.com/FM7/I47W/I0A57ACU/FM7I47WI0A57ACU.LARGE.jpg", "https://cdn.instructables.com/F0F/E7A1/I0A5723S/F0FE7A1I0A5723S.LARGE.jpg"], "step_title": "Step 1: Upgrade Brainlink Firmware"}, {"step": 2, "steps_text": "Install Brainlink Wave Generator on your Android device.  If you're using a different Android device from the previous step, pair your Brainlink with it. Make sure Brainlink is turned on. Plug tether into the 8-pin port on the Brainlink, making sure no wires short together.  (If you use this configuration a lot, you might make a modified tether where the lines irrelevant to the function generator are cut off.) Use Ohm's Law to ensure that the current draw at the voltages you want to generate won't exceed 20mA, as the Brainlink's pins are rated only for 20mA.  For instance, if you're connecting to a 50 ohm load, make sure no voltage exceeds V=IR=(0.020)(50)=1v. If you're connecting to a 1 mega-ohm oscilloscope, no worries. Set the settings for channel 1 or channel 2 and press the right Play button.   The waveform generator output will come from the pins marked in the photo. (On the original 8-pin tether, the CH1 and CH2 pins are blue, and the GND pin is black.)The sine/square/triangle wave function requires an amplitude between 0 and 3.3v (with 254 steps in between). See step 5 for a warning. The square wave generator requires choosing duty cycle (percentage between 0 and 100).  The arbitrary wave generator function requires a sequence of voltages, which whole sequence is played at the indicated frequency.Limitations: The xmega is limited to 1.0 MS/s in single-channel mode and 0.67 MS/s in dual-channel mode. This means that the theoretical maximum for a single-channel square wave is 500 kHz.  In practice, about 320 kHz is the highest I'd go for a single-channel square wave, and \"square\" is a bit of an overstatement (see picture).  For sine waves, rather lower frequency is better.  Even at 100 kHz, a sine wave doesn't look great, given how few samples it has per period.  My experiments suggest that generally dual-channel operation is best at 100 kHz and below.", "step_imgs": ["https://cdn.instructables.com/FZK/RRRO/I0A5723T/FZKRRROI0A5723T.LARGE.jpg", "https://cdn.instructables.com/F08/IUXE/I0A573TR/F08IUXEI0A573TR.LARGE.jpg", "https://cdn.instructables.com/FAA/QUBR/I0A573MU/FAAQUBRI0A573MU.LARGE.jpg", "https://cdn.instructables.com/FR9/2FKE/I0A573LS/FR92FKEI0A573LS.LARGE.jpg", "https://cdn.instructables.com/FX0/KIHM/I0A573N3/FX0KIHMI0A573N3.LARGE.jpg", "https://cdn.instructables.com/FX8/9SPT/I0A573MX/FX89SPTI0A573MX.LARGE.jpg"], "step_title": "Step 2: Use Waveform Generator Via Android Device"}, {"step": 3, "steps_text": "The xmega in the Brainlink has a unipolar Digital to Analog Converter (DAC).  This means that it generates a voltage between 0 and 3.3v.  If you want to generate a bipolar wave, say between -0.5v and +0.5v (e.g., for audio use), you need to pass the output through a capacitor.  A 0.1 microfarad one worked perfectly for me.  Note that if you use the capacitor, then the voltage you specify in the app will become the peak-to-peak voltage.  Thus, if in the app you specify a symmetric wave of 1v amplitude, you'll get a bipolar wave ranging from -0.5v to +0.5v.", "step_imgs": ["https://cdn.instructables.com/FGQ/VMJC/I0A573MW/FGQVMJCI0A573MW.LARGE.jpg", "https://cdn.instructables.com/FND/AV84/I0A573MV/FNDAV84I0A573MV.LARGE.jpg"], "step_title": "Step 3: Optional: Bipolar Waveform Generator"}, {"step": 4, "steps_text": "The custom Brainlink firmware adds three new functions.  To access them, first enter Brainlink command mode by sending an ASCII '*' (outside of command mode, the Brainlink emits a repeating 'BL' sequence).To play a sine, triangle or square wave, use the 'w' function.  Just send a w followed by (with less than a second in between characters) seven bytes:byte 1: channel, either ASCII '0' or ASCII '1'byte 2: type, either ASCII 's' (sine), 't' (triangle) or 'q' (square)byte 3: duty, between 0x00 and 0x3F; only matters for square waves and is otherwise ignored; however, I recommend setting it to 0x20 for other waves in case I want to use it to describe sawtooth waves in the futurebyte 4: amplitude, between 0x00 (=0v) and 0xFF (=3.3v)bytes 5-7: frequency in Hz, 24-bit number, most significant byte firstTo play an arbitrary wave, use the 'W' function.  Just send a W followed by (with less than a second in between characters) 5+n bytes:byte 1: channel, either ASCII '0' or ASCII '1'bytes 2-4: frequency in Hz, 24-bit number, most significant byte firstbyte 5: number n of data points (between 1 and 0x40)bytes 6 through 6+n-1: amplitudes, between 0x00 (=0v) and 0xFF (=3.3v)To stop playback, send ASCII '@' followed by the channel (ASCII '0' or '1').Note that the first wave channel ('0') cannot be used simultaneously with the Brainlink buzzer (buzzer will turn the channel off, and vice versa) and the second wave channel ('1') cannot be used simultaneously with the Brainlink IR emitter (IR turns off the wave channel and vice versa).", "step_imgs": [], "step_title": "Step 4: Optional: Control From Other Devices"}], "channel": "Electronics"}, {"category": "technology", "description": "\n          Hey all! I struggled with making a loud piezo buzzer from 5volts. I figured it out. It is super simple and as loud as your fire alarm. If you have struggled with this problem... give yourself a break... there is zero good information on the internet. Many forum suggestions exist and I tried all these without success:astable multivibrator as suggested by some piezo MFG..     Arduino\u00a0charge pump to boost the voltage (cool idea though)  Arduino voltage booster (might be totally useful to another project though!)  I spent more hours than I will admit. Go to the dollar store and purchase their Intruder Alert noise maker and your'll find... an Auto Transformer and a 'black blob' of circuitry. The black blob is a pulsing square wave that the Arduino can produce. The tranformer works well. If anyone can explain the phyisics behind its operation, pleas chime in! thanks. The auto-transformer has three leads and you can measure the resistance across the leads to determine which is which. \u00a0Here is the transformer that I measured: Pin1-2 154ohm and Pin 2-3 8ohm Pins 1-3 is ~161ohm. \u00a0Also ozitronics posted some data (see picture) on his 'autotransformer' with similar resistance and 91mH/2.1mH inductance. If anyone can find similar transformers on Mouser I'd be interested in seeing it. thanks! Credits: I stole the pictures/knowledge/ and content from the following places: - How to harvest a piezo.(just a picture) - this fellow has a couple circuits using 555 timers to produce a square wave using an auto transformer. PDF version - Jack Lopez provided this nice schematic of the dollar store with 'black blob' circuit xxx\n        ", "title": "How to Drive a Piezo With an Arduino", "url": "https://www.instructables.com/id/How-to-make-an-Arduino-driven-Piezo-LOUD/", "section": "technology", "steps": [{"step": 1, "steps_text": "Look up the piezo buzzer's resonant frequency. \u00a0This one has a peak frequency of 2600 HZ shown on the cut sheet. It actually has two peak frequencies but I just chose one. The cut sheet selects the point in the middle of the two frequencies. Next calculate the square wave you need to make on the Arduino. 1 second / 2600 = 385us (micro seconds). The square wave is positive for half the time and neutral for half the time or 385/2 = 192us You may use other frequencies but this is one of the loudest frequencies based on the mfg literature. Arduino Code:\u00a0 int piezoPin = 5; void setup() {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pinMode(piezoPin, OUTPUT); } void loop() { analogWrite(piezoPin, 255);\u00a0 //positive square wave delayMicroseconds(192);\u00a0\u00a0\u00a0\u00a0\u00a0 //192uS analogWrite(piezoPin, 0); \u00a0 \u00a0 //neutral square wave delayMicroseconds(192);\u00a0\u00a0\u00a0\u00a0\u00a0 //192uS }", "step_imgs": ["https://cdn.instructables.com/FQT/E6F0/HNM44D6U/FQTE6F0HNM44D6U.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: How to Drive a Piezo With an Arduino"}], "channel": "Arduino"}, {"category": "technology", "description": "A fader is one of a basic component for mixing console. You can dynamically control your source with the movement of a fader. There are already several way to use push buttons in your projects (e.g. hacking mouse and keyboard, or Arduino, gainer, MCK). This probides alternative way to use faders with audio input and output. As side effects, it provides you with precious sampling resolution and frequency than the previous ways (i.e. 16bit to 8-10bit, 44.1KHz to 1KHz).We present an application of this instructable from a work The SINE WAVE ORCHESTRA stay amplified.All you need is just a fader, some soldering, and some software. Note: This is for variable resistor type faders only. This will not work on optical type.Note2: This is a series of \"How to coonect with Audio\". Please see others: Button, and  Sensor.", "title": "How to Connect a Fader With Audio Input and Output", "url": "https://www.instructables.com/id/How-to-Connect-a-Fader-with-Audio-Input-and-Output/", "section": "technology", "steps": [{"step": 1, "steps_text": "You need to have a fader before you start. It could be find from your broken mixing console, or from electronic components store (e.g. RSin UK, Digi-Key in USA, Marutsuin Japan) with its alternative name 'potentionmeter'. All of the other components can be found at your local electronics shop (e.g. maplin in UK, RadioShack in USA, Tokyu-Hands in Japan). 1 FaderThe fader should be a variable resistor type. It has three (or even more) connectors and change its resistance with the position of the fader. Some mixing console use optical fader (mostly for DJ cross fader) and it doesn't work with this instructable. In this time, we use 'PROFADER SVA-1100' from TOKYO KO-ON DENPA. It has a very smooth movement.2 3.5mm Mono PlugOne for audio input and another for audio output.1 Twin CableYou could use loudspeaker cable for this purpose. The length depends on how long you want.1 Heat Shrink TubeTo cover the connector of the fader.", "step_imgs": ["https://cdn.instructables.com/F42/T18Q/FN82TDG8/F42T18QFN82TDG8.LARGE.jpg"], "step_title": "Step 1: The Parts"}, {"step": 2, "steps_text": "These are standard tools for assembling this project. I borrow part of the list from greyhathacker45's great work, thanks!Soldering IronSolderMultimeterWire StrippersNippersSolder-suckerHelping HandsClipped Cables", "step_imgs": ["https://cdn.instructables.com/FQV/TTLJ/FN82WPGZ/FQVTTLJFN82WPGZ.LARGE.jpg"], "step_title": "Step 2: The Tools"}, {"step": 3, "steps_text": "Let's have two pair of cables and strip the ends. ", "step_imgs": ["https://cdn.instructables.com/FE0/MFG4/FN82TDG7/FE0MFG4FN82TDG7.LARGE.jpg"], "step_title": "Step 3: Cutting the Cable"}, {"step": 4, "steps_text": "Before soldering, you need to check the connector of the fader. Most fader has three connectors. Two behave as a resistor and one for ground. You could find proper connectors by the change of the resistance with multimeter. ", "step_imgs": ["https://cdn.instructables.com/FBT/M2MO/FN82TDG5/FBTM2MOFN82TDG5.LARGE.jpg"], "step_title": "Step 4: Check the Fader"}, {"step": 5, "steps_text": "Now you ready to solder the fader to the cables. Each one side of two cables to be solder to each resistor side of connector. If the cable has a marker for one side, it would be better to use same part for the resistor side. Before soldering, do not forget to put your heat shrink tube! The cutting side of the cable needs to be twisted to avoid expanses. After soldering, the connector need to be covered with heat shrink.", "step_imgs": ["https://cdn.instructables.com/FNB/26W5/FN82TDG3/FNB26W5FN82TDG3.LARGE.jpg"], "step_title": "Step 5: Soldering the Fader (1: Resistor Side)"}, {"step": 6, "steps_text": "Next, you ready to solder the ground side. Before soldering, each cutting side of the cables needs to be twisted to avoid expanses, and do not forget to put your heat shrink tube! ", "step_imgs": ["https://cdn.instructables.com/FGT/F8BN/FN82TDG1/FGTF8BNFN82TDG1.LARGE.jpg"], "step_title": "Step 6: Soldering the Fader (2: Ground Side)"}, {"step": 7, "steps_text": "Then you ready to solder the plugs to the each end of the cable. Before soldering, the plug cover needs to be installed in the cable . The cutting side of the cable needs to be twisted to avoid expanses. After soldering, just attach the cover for the plugs.", "step_imgs": ["https://cdn.instructables.com/F4W/22BD/FN49ZQU4/F4W22BDFN49ZQU4.LARGE.jpg"], "step_title": "Step 7: Soldering the Plugs"}, {"step": 8, "steps_text": "Now you have a set of a switch, two plugs, and a cable. Using multimeter on the resistance between the plugs. Tips (upper side) should be changing with the position of the fader and grounds (lower side) should be zero.", "step_imgs": ["https://cdn.instructables.com/FXW/M3I3/FN82TDFZ/FXWM3I3FN82TDFZ.LARGE.jpg"], "step_title": "Step 8: Quality Control"}, {"step": 9, "steps_text": "Now you have a working hardware, so lets connect each side of the plug to the audio input and output. ", "step_imgs": ["https://cdn.instructables.com/FJ0/P2CB/FN82TDG0/FJ0P2CBFN82TDG0.LARGE.jpg", "https://cdn.instructables.com/FET/M4FO/FN49ZR0Y/FETM4FOFN49ZR0Y.LARGE.jpg"], "step_title": "Step 9: Connect to the Audio Input and Output"}, {"step": 10, "steps_text": "Open your programming environment (e.g. MaxMSP, Pure Data, Flash, SuperCollider). If it could treat audio input and output, any environment is ok. In this time, we use MaxMSP.Assign an audio signal (e.g. 10000Hz sine wave) for audio output. Set volume calculator for audio input. In this time, we use 'peakamp~' object.Add a receiver for the calculator. In this time, we use 'multislider' object.Here is a basic example of MaxMSP patche.MaxMSP: fader-001.maxpat", "step_imgs": ["https://cdn.instructables.com/FGV/9OJW/FN82WPIO/FGV9OJWFN82WPIO.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 10: Some Software"}, {"step": 11, "steps_text": "\n          Start audio, move the fader, and get the connection! You're ready to use a fader with your projects. If it does not work, you just need to adjust the volume for audio output. ", "step_imgs": ["https://cdn.instructables.com/FXO/2A1T/FN82TDFY/FXO2A1TFN82TDFY.LARGE.jpg"], "step_title": "Step 11: Moment of the Connection"}, {"step": 12, "steps_text": "\n          There are many possible uses for the fader with Audio Input and Output. One of a feasible field is sound instrument. We made Sine Wave Oscilator with this instructable. It can make full use of its precious samping resolution.  Here is the setup. You will need split you audio output with stereo to dual mono cable. On one channel you connect the fader, and on another, you connect a speaker. Then you add a sine wave oscillator and a scale changer to fit the value frome fader to the frequency of the sine wave oscillator in your software. Now, you can finely control the sine wave oscilator in 16-bit resolution. Here is a MaxMSP patch.MaxMSP: fader-002.maxpat", "step_imgs": ["https://cdn.instructables.com/FDO/JDUK/FNGG8FYI/FDOJDUKFNGG8FYI.LARGE.jpg", "https://cdn.instructables.com/FTB/OB32/FNGG8FYH/FTBOB32FNGG8FYH.LARGE.jpg", "https://cdn.instructables.com/FXK/DVYE/FNZAF3CQ/FXKDVYEFNZAF3CQ.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 12: Uses? Sine Wave Oscilator"}, {"step": 13, "steps_text": "\n          The SINE WAVE ORCHESTRA stay amplified is a work of participatory sound performance project The SINE WAVE ORCHESTRA.We detect the resistance of a fader controller as the amplitude of audio signal.", "step_imgs": ["https://cdn.instructables.com/FX9/RDUO/FN84R07H/FX9RDUOFN84R07H.LARGE.jpg"], "step_title": "Step 13: Application: the SINE WAVE ORCHESTRA Stay Amplified"}, {"step": 14, "steps_text": "Though the sampling resolution of the movement is 16-bit or more (if you use external audio interfaces), you can use this instructable for controlling precious parameters (e.g frequency of oscillator). As the fader is one of a variable resistor, you can use other types of resistors instead (e.g. shaft, CDS)You can use two faders with 3.5mm stereo plugs and triple cable. If you need more faders, you can extend with external audio interfaces. In this time, you need to use proper plugs for the port of the audio interface.", "step_imgs": [], "step_title": "Step 14: Possible Improvements and Modifications"}], "channel": "Audio"}, {"category": "technology", "description": "  PC sound cards form a readily available Signal Generator for testing electronic circuits. The utility of these signal generators is limited because the outputs are AC coupled and limited to \u00b12V.  Taking advantage of the two channels provided by the sound card this Instructable shows a scheme which uses one channel to output the Sin/Square/Triangle waveform with a fixed gain, while setting up a 441 Hz PWM square wave on the second channel. This PWM waveform is converted to \u00b18V averaged and summed with the first channel to provide a DC offset controllable by the duty-cycle setting.  This PC sound-card interface implements a Signal-Generator with Sin/Square/Triangle output frequency variable from 50Hz to 10kHz, an amplitude variable from 0 to 5V and a variable DC offset of +/- 4V.  As a bonus the MAX232 , SMD/DIP, provides a 40kHz / 100kHz signal which can be used for step-response testing of analog circuits.  How I went about it:  1. Scribbled the Idea on to a piece of paper.  2. Selected the devices required and drew the prototype circuit.  3. Bread-Boarded the circuit and developed the PC GUI software.  4. Decided to do a professional job.  5. Obtained free samples from Texas Instruments. ( This is a great facility provided by TI)  6. Drew the Schematic and Designed the PCB using Eagle 5.10.0  7. Fabricated the double-sided SMD PCB using the toner-transfer method. ( It is possible to handle these fine pitch devices)  8. Populated the PCB and checked out the functioning.  9. Made minor changes in the GUI software to handle Channel-Interchange and Offset-Invert.  10. Put the circuit into a small-matchbox enclosure.  11. Wrote up the documentation for this system.  12. Archived all technical data in a .rar file  \u00a0", "title": "PC Sound-Card Signal-Generator-Interface", "url": "https://www.instructables.com/id/PC-Sound-Card-Signal-Generator-Interface/", "section": "technology", "steps": [{"step": 1, "steps_text": "The idea has three parts: 1. A MAX232 TTL-RS232 interface chip can be used to generate +/- 10V DC from +5V 2. One channel of the PC sound card can be programmed to output a fixed frequency PWM waveform which when converted to +/-10V using the MAX232 and averaged would provide a variable DC voltage depending on the PWM setting. 3. This can be suitably summed with the second PC sound-card output which is programmed to generate SIN/SQ/TRI outputs to form the final output. A GUI program on the PC can control the generation of the SIN/SQ/TRI amplitude and frequency and also the PWM to create a variable offset. --------------------------------------------------------------------------------------- The prototype was bread-boarded using the Max 232 and LF353 DIP components. This scheme can be implemented in case one does not want to work with the SMD components presented further on. The Oscilloscope display shows a 4V\u00a0Triangular\u00a0wave offset by +2V. --------------------------------------------------------------------------------------- The PC sound-card interface implements a Signal-Generator with Sin/Square/Triangle output frequency variable from 50Hz to 10kHz, an amplitude variable from \u00a00 to 5V and a DC offset of \u00a0+/- 4V. As a bonus the DIP MAX232 provides a 100kHz 5V/1V signal which can be used for step-response testing of analog circuits.", "step_imgs": ["https://cdn.instructables.com/F5Q/VM96/HRWNEB23/F5QVM96HRWNEB23.LARGE.jpg", "https://cdn.instructables.com/FIW/S7K1/HRWNEB2B/FIWS7K1HRWNEB2B.LARGE.jpg", "https://cdn.instructables.com/FDN/LQOY/HRWNEB2I/FDNLQOYHRWNEB2I.LARGE.jpg", "https://cdn.instructables.com/FUY/P7KR/HRWNEB2Z/FUYP7KRHRWNEB2Z.LARGE.jpg"], "step_title": "Step 1: The Idea"}, {"step": 2, "steps_text": "Referring to the simplified block schematic of the system. The USB +5V is fed to the MAX232 dual driver/receiver which carries out several functions: \u2022 Generation of generates +8V and -8V supply for the op-amp circuitry \u2022 Conversion of TTL level PWM to \u00b1 8V level \u2022 Generation of 40 kHz aux outputs The Left-Channel outputs a 441 Hz PWM signal which when converted to TTL and fed to the Max 232 provides a \u00b1 8V level PWM which is averaged to provide a DC offset signal. The Right Channel provides the Sin/Square/Triangle signal from the PC which is amplified by 5.5 and summed with the DC offset signal to form the Aj_SoundGen_SigGen output.", "step_imgs": ["https://cdn.instructables.com/FGS/165P/HRWNEBGF/FGS165PHRWNEBGF.LARGE.jpg"], "step_title": "Step 2: Block Schematic"}, {"step": 3, "steps_text": "A Microsoft Windows based GUI software has been developed \u00a0in VB.Net 2.0 which interfaces with the internal sound-card of the PC and provides the audio-outputs to the Aj_SoundGen_SigGen\u00a0 via the speaker port. The simple GUI is used to control the PC sound-card outputs and indirectly the Aj_SoundCard_SigGen. Once the Aj_SoundCard_SigGen USB and Audio connector are connected and the PC sound card enabled with maximum volume: \u2022 Three Radio-Buttons select the type of waveform \u2022 The first slider sets the signal generator frequency \u2022 The second slider sets the amplitude of the chosen waveform \u2022 The third slider controls the duty-cycle of the 441 Hz PWM which controls the DC offset. \u2022 The RUN ,STOP and EXIT buttons are self explanatory To ensure compatibility with different sound-cards: \u2022 The swap-output check-box swaps the L/R channels if required \u2022 And the Invert-Offset check-box inverts the polarity of the 441 Hz PWM.", "step_imgs": ["https://cdn.instructables.com/FCH/8ITJ/HRWNEBGY/FCH8ITJHRWNEBGY.LARGE.jpg", "https://cdn.instructables.com/FCZ/U3TU/HRWNEBH4/FCZU3TUHRWNEBH4.LARGE.jpg"], "step_title": "Step 3: Software on the PC Host:"}, {"step": 4, "steps_text": "PC sound cards form a readily available Signal Generator for testing electronic circuits. The utility of these signal generators is limited because the outputs are AC coupled and limited to \u00b12V. Taking advantage of the two channels provided by the sound card the circuit uses one channel to output the Sin/Square/Triangle waveform with a fixed gain, while setting up a 441 Hz PWM square wave on the second channel. This PWM waveform is converted to \u00b18V averaged and summed with the first channel to provide a DC offset controllable by the duty-cycle setting. The circuit in the schematic provides a variable offset of typically \u00b14V at the signal generator output. The circuit is powered from the PC USB +5V supply which is converted by the capacitive voltage generator within the MAX232 dual driver/receiver IC, U1 to typically \u00b18V to power the TL082 low power op-amp, U2. L1/C8 and L2/C7 filter out the ripple on the V+ and V- outputs of U1. The 441Hz PWM waveform output on the sound-card left-channel is clamped by C1/D1 and fed through R1 to the base of\u00a0 T1. This produces a TTL compatible square wave at the collector of T1 which is fed to theT2IN of U1. T2OUT is a \u00b18V PWM waveform which is averaged by R3/C6 and buffered by U2B to generate a DC voltage depending on the PWM duty-cycle. This voltage is summed along with the Sin/Square/Triangle waveform output on the sound-card right-channel by U2A and forms the signal generator output. C16/R5 forms a low-pass filter to smoothen the quantized signal generated by the sound-card. With the values of the components shown the right-channel is amplified by a fixed gain of 5.5 and the DC offset variation is typically \u00b15V. The waveforms captured on an oscilloscope illustrate the circuit operation. The 75% duty-cycle PWM input signal is converted to typically \u00b18V at T2OUT and when averaged produces ~ 4V DC at Pin7 of U2B. The 0.5V sin-wave is amplified and offset by the inverting summing amplifier U2A to form the signal generator output.", "step_imgs": ["https://cdn.instructables.com/FJS/SX9F/HRWNEBL5/FJSSX9FHRWNEBL5.LARGE.jpg", "https://cdn.instructables.com/FT3/2H1R/HRWNEBLF/FT32H1RHRWNEBLF.LARGE.jpg", "https://cdn.instructables.com/FTJ/Q3QM/HRWNEBM7/FTJQ3QMHRWNEBM7.LARGE.jpg"], "step_title": "Step 4: Schematic and Functional Description"}, {"step": 5, "steps_text": "The PCB is fabricated using the toner-transfer method and etched in a solution of Ferric Chloride. After drilling the PCB physical connections for the plated-through holes are made. SMD components and connectors are carefully soldered using a low-wattage soldering iron. The images show the component layout and populated PCB. The\u00a0finished\u00a0PCB is cleaned and the circuit operation tested. After a spray of conformal coating on both sides of the PCB it is enclosed in an empty matchbox container. The unit is now ready for use.", "step_imgs": ["https://cdn.instructables.com/F2O/CAZZ/HRWNEBML/F2OCAZZHRWNEBML.LARGE.jpg", "https://cdn.instructables.com/FEO/9XK0/HRWNEBMR/FEO9XK0HRWNEBMR.LARGE.jpg", "https://cdn.instructables.com/F7K/IZD5/HRWNEBMN/F7KIZD5HRWNEBMN.LARGE.jpg", "https://cdn.instructables.com/FGQ/MQ8S/HRWNEBMQ/FGQMQ8SHRWNEBMQ.LARGE.jpg"], "step_title": "Step 5: Fabrication"}, {"step": 6, "steps_text": "The technical documentation is provided as a pdf file:  Aj_SoundCard_Tech-Manual.pdf ----------------------------------------------------------------------------------------- The Windows GUI software is provided as a .rar archive: SoundCard_VB.rar *Note 1: after copying these files to the PC the folder any read-only permissions need to be removed. The executive creates an Ajoy.wav file which is played through the sound card. As this file is created and modified by the GUI software it will not work if the folder is read-only. *Note 2: The sound-output should be routed to the ext-speaker/ headphone socket and the volume control set to maximum. ------------------------------------------------------------------------------------------- PCB Gerber files are provided as a .rar archive: SoundCard_Gerber.rar ------------------------------------------------------------------------------------------- A complete .rar file can be downloaded from: http://sites.google.com/site/ramanajoy/home/my-zi... Please address any feedback / queries to:    ajoyraman@gmail.com My website is:    www.ajoyraman.in", "step_imgs": ["https://cdn.instructables.com/FH9/U66K/HRWNEBOZ/FH9U66KHRWNEBOZ.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: Documentation and Software"}], "channel": "Electronics"}, {"category": "technology", "description": "Hello Ladies and gentlemen :), I have a beginner tutorial Arduino project on the HC-SR04, this can actually be used as a security  measure. Like showing how close someone or something is standing close to your door.if the person is standing a fair distance away the LED is GREEN, else if closer BLUE else if too close RED. This is exactly the program software logic. So Let's go!", "title": "Ultrasonic Distance Sensor Arduino HC-SR04", "url": "https://www.instructables.com/id/Ultrasonic-Distance-Sensor-Arduino-HC-SR04/", "section": "technology", "steps": [{"step": 1, "steps_text": "Here is a list of electrical parts one needs to complete this project -Arduino board-jumpers -RGB led(I am using a common cathode but single LEDs can work as well)-3 resistors. -Breadboard-HC-SRO4.When you have all these, connect them ", "step_imgs": ["https://cdn.instructables.com/FZF/5S0B/IBW252XB/FZF5S0BIBW252XB.LARGE.jpg", "https://cdn.instructables.com/FLY/DBL8/IBW252XC/FLYDBL8IBW252XC.LARGE.jpg"], "step_title": "Step 1: Required Electrical Components"}, {"step": 2, "steps_text": "Supply +5v to the breadboard from the Arduino +5v and do the same for the ground. Mount the HC-SR04 on the breadboard. Remember from the digital electronics class the + rule vertical pins are linked together on the board rung and horizontal pins linked together in on he power rung.Connect the sensor to the GND and +5v.Connect the echo-pin of the HC-SR04 to pin 5 on the Arduino and trig-pin to pin 6 of the Arduino board.Mount the LED on the breadboard. Connect resistors to the RGB pins and connect them to pin 7,8 and 9 of the Arduino respectively and connect the Cathode to ground.", "step_imgs": ["https://cdn.instructables.com/F0X/7Q68/IBW252XF/F0X7Q68IBW252XF.LARGE.jpg", "https://cdn.instructables.com/F8C/S31G/IBW252XG/F8CS31GIBW252XG.LARGE.jpg", "https://cdn.instructables.com/F1C/CQI3/IBW252XS/F1CCQI3IBW252XS.LARGE.jpg", "https://cdn.instructables.com/FXS/5Y4G/IBW252YU/FXS5Y4GIBW252YU.LARGE.jpg", "https://cdn.instructables.com/F00/U8AU/IBW23HYG/F00U8AUIBW23HYG.LARGE.jpg", "https://cdn.instructables.com/F37/6VPM/IBW23HYH/F376VPMIBW23HYH.LARGE.jpg"], "step_title": "Step 2: Connection"}, {"step": 3, "steps_text": "After the connect write and upload the following code.*********************************************************************************************************************#define trigpin 6 #define echopin 5\n#define R 7#define G 8#define B 9void setup() { //serial monitor and pin setup.   Serial.begin(9600);\n  pinMode(trigpin,OUTPUT); //set trigpin as output\n   pinMode(echopin,INPUT);//set echopin as input\n   pinMode(R,OUTPUT);// set R,G and B as outputs\n   pinMode(G,OUTPUT);\n   pinMode(B,OUTPUT);\n   \n   \n  // put your setup code here, to run once:}void loop() {  \n  //the trigpin sends out a signal, which bounces off an obstacle and comes back, the \n  //echopin recieves this signal and gives out +5v setting the arduino pin on which it is connected to high.\n  //distance= time*speed, but this distnce is divided by 2 because signal sent out returns\n  //so distance= (the time it takes for the signal to leave and return)/2.\n  //i.e if the time is 6s the distance = (6s/2) = 3m or cm.\n  \n  int duration, distance;//declare distance and duration as integers\n  digitalWrite(trigpin,HIGH);// trigin send out signal\n  _delay_ms(1000);//coninously for 1000ms\n  digitalWrite(trigpin, LOW);// then goes low\n  \n  duration=pulseIn(echopin,HIGH); // duration is the pulseIn to the echopin\n  distance=(duration/2)/29.1; //  the 29.1 is used to convert the distnce to cm, the value varies for other units.\n  \n  if(distance > 0 && distance <= 20){//distcance is greater than 0 and less than 20cm\n    digitalWrite(G,LOW);//green led is off\n    digitalWrite(B,LOW);//blue led is off\n     _delay_ms(500);//delay\n    digitalWrite(R,HIGH);//red led is on\n  _delay_ms(500);\n  }\n  else if(distance > 20 && distance <= 80){//distcance is greater than 20 and less than 80cm\n        digitalWrite(R,LOW);//red led is off\n         digitalWrite(G,LOW);//green led is off\n         _delay_ms(500);\n    digitalWrite(B,HIGH);//blue led is on\n    \n      }\n      \n       else if(distance > 80 && distance <= 120 ){//distcance is greater than 80 and less than 120cm\n        digitalWrite(R,LOW);//red led is off\n        digitalWrite(B,LOW);//blue led is off\n         _delay_ms(500);\n    digitalWrite(G,HIGH);//green led is on\n      }\n   Serial.print(\"cm\");\n  Serial.println(distance);//print values on serial monitor\n  _delay_ms(100);\n}\n  \n  \n  // put your main code here, to run repeatedly:", "step_imgs": ["https://cdn.instructables.com/FA8/GQZ1/IBW23M25/FA8GQZ1IBW23M25.LARGE.jpg"], "step_title": "Step 3: Code"}, {"step": 4, "steps_text": "The floor in my apartment has tiles and you can see the distance from my cupboard and fridge. The LED is GREEN, and changed to BLUE when the distance was cut to half and finally RED when the sensor was really close. I hope you enjoyed this. I am planning to make something similar but I will be using the MQ-2 smoke sensor to change the color of the LEDs. if you have any questions about this project please put them as comments and i will reply. Thank you for your time. Arigato :)", "step_imgs": ["https://cdn.instructables.com/F2L/SQET/IBW23HYW/F2LSQETIBW23HYW.LARGE.jpg", "https://cdn.instructables.com/FGW/ZT1J/IBW252ZL/FGWZT1JIBW252ZL.LARGE.jpg", "https://cdn.instructables.com/FO2/Z0OY/IBW25308/FO2Z0OYIBW25308.LARGE.jpg"], "step_title": "Step 4: Test "}], "channel": "Arduino"}, {"category": "technology", "description": "Function Generators are very useful tool in electronics bench,but it can be quite expensive, but we have many options to build it cheaply. In this project we use ICl8038.", "title": "DIY Function Generator (ICL8038) 0 Hz - 400Khz", "url": "https://www.instructables.com/id/DIY-Function-Generator-ICL8038-0-Hz-400Khz/", "section": "technology", "steps": [{"step": 1, "steps_text": "You can also watch video for more Info. Or Visit Our Channel On Youtube Channel", "step_imgs": [], "step_title": "Step 1: Video"}, {"step": 2, "steps_text": "Lts look at our Build.", "step_imgs": ["https://cdn.instructables.com/FQA/VDXM/JIUK2K3T/FQAVDXMJIUK2K3T.LARGE.jpg", "https://cdn.instructables.com/FJW/ZH09/JIUK2K4K/FJWZH09JIUK2K4K.LARGE.jpg", "https://cdn.instructables.com/FT3/LRTW/JIUK2K1F/FT3LRTWJIUK2K1F.LARGE.jpg", "https://cdn.instructables.com/FZG/8X84/JIUK2JYA/FZG8X84JIUK2JYA.LARGE.jpg", "https://cdn.instructables.com/F3I/J0U4/JIUK2K0A/F3IJ0U4JIUK2K0A.LARGE.jpg"], "step_title": "Step 2: Over View"}, {"step": 3, "steps_text": "Use This schematic diagram to built your circuit. Circuit are divided into three sections.Power SectionFrequency Generator SectionAmplifier SectionPower Section- In this section we use two Positive Voltage regulator (7805,7812) 5v or 12v positive voltage regulator to stabilize positive voltage.    OR    We also have use negative side voltage regulator (7905,7912) -5v or -12v Voltage regulator to regulate Negative side Voltage to -5v ,-12v level.        We have used a 18-0-18 volt 2amp power transformer follow circuit diagram for more info.Frequency Generator Section- To generate a stable frequency We have used ICL8038 waveform generator is a monolithic integrated circuit capable of producing high accuracy sine, square, triangular waveform.Amplifier Section- This section is used to decrease Output impedance or used to Adjust DC Offset , Or Output Amplitude of Frequency. We have Utilized 2x Lm393 Duel Comparators (Comparators Can Handle Square Wave At High Frequency With Fast Edge Capability) and One Tl072 Low Noise Op-Amp to Produce Low Noise Signals at output.", "step_imgs": ["https://cdn.instructables.com/FNI/2CXU/JIUK2K4M/FNI2CXUJIUK2K4M.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Schematic Diagram"}, {"step": 4, "steps_text": "The ICL8038 waveform generator is a monolithic integratedcircuit capable of producing high accuracy sine, square, triangular, sawtooth and pulse waveforms with a minimum of external components. The frequency (or repetition rate) can be selected externally from 0.001Hz to more than 300kHz using either resistors or capacitors, and frequency modulation and sweeping can be accomplished with an external voltage. The ICL8038 is fabricated with advanced monolithic technology, using Schottky barrier diodes and thin film resistors, and the output is stable over a wide range of temperature and supply variations. These devices may be interfaced with phase locked loop circuitry to reduce temperature drift to less than 250ppm/oC.", "step_imgs": ["https://cdn.instructables.com/FB8/IR1X/JIUK2QLD/FB8IR1XJIUK2QLD.LARGE.jpg", "https://cdn.instructables.com/F3B/7AY5/JIUK2QL6/F3B7AY5JIUK2QL6.LARGE.jpg"], "step_title": "Step 4: ICL 8038 "}, {"step": 5, "steps_text": "Use Good quality Comparators and Op-Amps in this Project to obtain Good Quality Output waveforms. ", "step_imgs": ["https://cdn.instructables.com/FZW/ZCH0/JIOULOC0/FZWZCH0JIOULOC0.LARGE.jpg", "https://cdn.instructables.com/FVD/2XH0/JIUK2JWB/FVD2XH0JIUK2JWB.LARGE.jpg"], "step_title": "Step 5: Comparators and OP-Amps"}, {"step": 6, "steps_text": "Spent Too many time in making amplifier section, My old Amplifier section are made up of two opamps(TL072) This old amplifier section was handling shine wave and triangle wave easily but square wave get meshed up at higher frequencies above 100 Khz. So i decided to use comparator(LM393) instead of opamps because compatator can handle square wave easily because of there fast response time.  ", "step_imgs": ["https://cdn.instructables.com/F1L/E1OL/JIUK2K24/F1LE1OLJIUK2K24.LARGE.jpg", "https://cdn.instructables.com/FD9/F12T/JIUK2K4N/FD9F12TJIUK2K4N.LARGE.jpg"], "step_title": "Step 6: Amplifier Section (Old Discarded )"}, {"step": 7, "steps_text": "Use this dimension to make a proper housing for frequency generator project ", "step_imgs": ["https://cdn.instructables.com/FSJ/PLJA/JIUK2JTO/FSJPLJAJIUK2JTO.LARGE.jpg", "https://cdn.instructables.com/FMB/ZV8U/JIUK2KFJ/FMBZV8UJIUK2KFJ.LARGE.jpg"], "step_title": "Step 7: Dimension for Enclosure "}, {"step": 8, "steps_text": "Sine wave generated by this signal at different frequencies.", "step_imgs": ["https://cdn.instructables.com/FBR/FA1G/JIUK2QPW/FBRFA1GJIUK2QPW.LARGE.jpg", "https://cdn.instructables.com/FYN/MKTR/JIUK2QQL/FYNMKTRJIUK2QQL.LARGE.jpg", "https://cdn.instructables.com/FUL/AJQV/JIUK2QQN/FULAJQVJIUK2QQN.LARGE.jpg", "https://cdn.instructables.com/FTR/9SIG/JIUK2QUO/FTR9SIGJIUK2QUO.LARGE.jpg"], "step_title": "Step 8: Sinewave at Different Frequencies"}, {"step": 9, "steps_text": "Sine wave generated at different frequencies.", "step_imgs": ["https://cdn.instructables.com/FQR/HDI0/JIUK2QWW/FQRHDI0JIUK2QWW.LARGE.jpg", "https://cdn.instructables.com/FKJ/541Q/JIUK2QX1/FKJ541QJIUK2QX1.LARGE.jpg", "https://cdn.instructables.com/FHL/WTH5/JIUK2QX4/FHLWTH5JIUK2QX4.LARGE.jpg", "https://cdn.instructables.com/FGT/I4YH/JIUK2QY6/FGTI4YHJIUK2QY6.LARGE.jpg", "https://cdn.instructables.com/FNZ/GBHE/JIUK2QYB/FNZGBHEJIUK2QYB.LARGE.jpg", "https://cdn.instructables.com/FXO/DOFL/JIUK2R05/FXODOFLJIUK2R05.LARGE.jpg", "https://cdn.instructables.com/F90/B20Y/JIUK2R09/F90B20YJIUK2R09.LARGE.jpg", "https://cdn.instructables.com/F3F/R9IV/JIUK2R16/F3FR9IVJIUK2R16.LARGE.jpg", "https://cdn.instructables.com/FBY/C5KA/JIUK2R31/FBYC5KAJIUK2R31.LARGE.jpg"], "step_title": "Step 9: Square Wave at Different Frequencies."}, {"step": 10, "steps_text": "Triangular wave generated at different Frequencies.", "step_imgs": ["https://cdn.instructables.com/FVM/8C84/JIUK2R7C/FVM8C84JIUK2R7C.LARGE.jpg", "https://cdn.instructables.com/FLB/BIWN/JIUK2R89/FLBBIWNJIUK2R89.LARGE.jpg", "https://cdn.instructables.com/FIA/J2MR/JIUK2R8D/FIAJ2MRJIUK2R8D.LARGE.jpg", "https://cdn.instructables.com/FPG/8OHR/JIUK2RA5/FPG8OHRJIUK2RA5.LARGE.jpg", "https://cdn.instructables.com/FL2/TS8W/JIUK2RBB/FL2TS8WJIUK2RBB.LARGE.jpg"], "step_title": "Step 10: Triangle Wave at Different Frequencies."}, {"step": 11, "steps_text": "Now You can make your own function generator if you have any problem regarding this project leave a comment ,i will try to solve it, Make Your Own Let me notify .Visit my Channel for More Projects   ChannelTHANK YOU", "step_imgs": [], "step_title": "Step 11: All Done"}], "channel": "Electronics"}, {"category": "technology", "description": "Ever since I made the laser gun, I've been thinking about modulating the laser to send over audio, either for fun (a kids intercom), or maybe to transmit data for a more sophisticated laser gun, enabling a receiver to figure out by whom he was hit. In this instructable I will focus on the audio transmission.Many people have created analog modulated transmission systems by adding the analog audio signal to the power supply of the laser diode. This works, but it has a few serious drawbacks, mostly being the inability to amplify the signal at the receiving end without introducing a lot of noise. Also linearity is very poor.I wanted to modulate the laser digitally using a Pulse Width Modulation (PWM) system. The cheap laser diodes used in the laser gun project can be modulated even faster than a normal LED, way into the millions of pulses per second, so this should be very doable.", "title": "Simple and Cheap Laser Digital Audio Transmission", "url": "https://www.instructables.com/id/Simple-and-Cheap-Laser-Digital-Audio-Transmission/", "section": "technology", "steps": [{"step": 1, "steps_text": "It is entirely possible to build a somewhat decent transmitter using using a triangle or sawtooth generator and comparing it's output with the signal input with an op-amp. However, it is pretty hard to get good linearity and the number of components grows out of whack pretty fast, and the usable dynamic range is often limited. Besides, I decided it was allowed to be lazy.A bit of lateral thinking pointed me to an ultra cheap D-class audio amplifier called a PAM8403. I used it before as a real audio amplifier in the laser gun project. It does exactly what we want, pulse width modulating the audio input. Small boards with the required external components can be procured from eBay for under 1 Euro.The PAM8404 chip is a stereo amplifier with a full H-bridge output, which means it can drive both wires to the speaker to the Vcc (plus) rail or to ground, effectively quadrupling the output power compared to just driving one wire. For this project we can simply use one one of the two output wires, of one channel only. When in complete silence the output will be driven to a square wave of approximately 230 kHz. Modulation by the audio signal changes the pulse width of the output.Laser diodes are extremely sensitive to over-current. Even a 1 microsecond pulse can destroy it completely. The circuit shown prevents exactly that. It will drive the laser with 30 milliamp independent of VCC. However, it there is even the slightest disconnect of the diodes, normally clipping the transistor's basis voltage to 1.2 volt, the laser diode is immediately destroyed. I have blown two laser modules like this. I recommend to not build the laser driver on a breadboard, but solder it on  small piece of PCB or free-form in a piece of shrink tube at the back of the laser module.Back to the transmitter. Connect the output of the PAM8403 to the input of the laser driver circuit and the transmitter is done! When fired up, the laser is visually on and no modulation can be optically detected. This actually makes sense as the signal hovers around a 50/50 percent on/off state on a 230 kHz carrier frequency. Any visible modulation would not have been the volume of the signal, but the actual value of the signal. Only at very, very low frequencies the modulation will be noticeable.", "step_imgs": ["https://cdn.instructables.com/FV6/WWG5/ITW3434Z/FV6WWG5ITW3434Z.LARGE.jpg", "https://cdn.instructables.com/FCL/ABDV/INVZ43SW/FCLABDVINVZ43SW.LARGE.jpg"], "step_title": "Step 1: Proof of Principle (the Transmitter)"}, {"step": 2, "steps_text": "I investigated many principles for the receiver, such as negatively biased PIN photo diodes, non biased versions, etcetra. Different schematics had different advantages and disadvantages, such as speed versus sensitivity, but most of all things were complex.Now I had an old IKEA Solvinden solar powered light in the garden that was destroyed by rain ingress, so I salvaged the two small (4 x 5 cm) solar cells and tried how much signal would be produced by simply pointing the modulated red laser diode on one of them. This turned out to be a surprisingly good receiver. Modestly sensitive, and good dynamic range, as in, it works with even pretty bright illumination from stray sunlight.Of course you can search on i.e. eBay for small solar cells like this. They should retail for under 2 Euros.I hooked up another PAM8403 D class receiver board to it (which also got rid of the DC component), and connected a simple speaker attached to it. The result was impressive. Sound was reasonably loud and distortion-free.The downside from using a solar cell is that they are extremely slow. The digital carrier is completely wiped out and it is the actual demodulated audio frequency that is coming through as signal. The advantage is that no demodulator is needed at all: just hook up the amplifier and speaker and you're in business. The downside is that since the digital carrier is not present, and therefor cannot be restored, the performance of the receiver is completely dependent of the light intensity and audio will be distorted by all stray light sources modulated in the audio frequency range such as light bulbs, televisions and computer screens.", "step_imgs": ["https://cdn.instructables.com/F61/04UA/INVZ41IX/F6104UAINVZ41IX.LARGE.jpg", "https://cdn.instructables.com/FEP/4AI6/INVZ41JC/FEP4AI6INVZ41JC.LARGE.jpg"], "step_title": "Step 2: Proof of Principle (the Receiver, Solar Cell Version)"}, {"step": 3, "steps_text": "I took the transmitter and receiver out at night to easily see the beam and have maximum sensitivity of the solar cell, and there was immediate success. The signal was easily picked up 200 meters down range, where the width of the beam was no more than 20 cm. Not bad for a 60 cents laser module with a non-precision collimator lens, a scavenged solar cell and two amplifier modules.Minor disclaimer: I did not make this picture, just took it from a well known search site. As there was a little bit of moist in the air that night, the beam did indeed look like this when looking back towards the laser. Very cool, but that is beside the point.", "step_imgs": ["https://cdn.instructables.com/FQF/8E4P/INUV990Z/FQF8E4PINUV990Z.LARGE.jpg"], "step_title": "Step 3: Test!"}, {"step": 4, "steps_text": "Building a Digital Receiver, PIN Diode VersionAs said, without regenerating the high frequency PMW signal, stray signals are very audible. Also, without the PMW signal regenerated to a  fixed amplitude, the volume, and therefor the signal-to-noise ratio of the receiver is totally dependent on how  much laser light is captured by the receiver. If the PMW signal itself would be is sufficiently available at the light sensor's output, it should be very easy to filter out these stray light signals as basically  everything under the modulation frequency should be considered stray.  After that, simply amplifying the remaining signal should produce a  fixed amplitude, regenerated PWM signal.If have not yet build a digital receiver, but it might be very doable using a BWP34 PIN diode as detector. One would have to decide on a lens system to increase the capture area, as the BWP34 has a very small opening, about 4x4mm. Then make a sensitive detector, add a high pass filter, set to roughly 200 kHz. After filtering, the signal should be amplified, clipped to restore the original signal as good as possible. If that would all work, we have basically restored the signal as it was producted by the PAM chip and could be directly fed into a small speaker.Maybe for a later date!Different approach, the pro's!There are people doing light transmissions over vastly greater distances (several tens of kilometers) than presented here. They do not use lasers because monochromatic light actually fades quicker over distance in a non-vacuum than multichromatic light. They use LED clusters, huge fresnel lenses and of course travel great distances to find clean air and long lines of sight, read: mountains.And their receivers are of very special design. Fun stuff that can be found on the internet.", "step_imgs": ["https://cdn.instructables.com/FIE/B8A8/ITW34E5Q/FIEB8A8ITW34E5Q.LARGE.jpg"], "step_title": "Step 4: After Thoughts: Building a Digital Receiver"}], "channel": "Electronics"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "Transistors are arguably the most important electronic component in use today. They are the reason we have the technological advances we have today. Without them, there are no radios or computers, and in turn there are no modern TVs, phones (smart or dumb), or cars. Life would be drastically different. Over the years manufacturing techniques have been able to make smaller and smaller transistors to the point where you can only see them under magnification. Your phone alone has millions by itself. The Cortex A9 processor is widely used in smartphones and tablets and has 26,000,000 transistors (reference). The XBOX One processor has 5,000,000,000. That's 5 billion. In 363 mm2. That's just a bit smaller than a U.S. postage stamp (418 mm2)But what do they do? Why are they so important? More importantly, how do I use them in my own projects? My aim is to answer those questions in a clear and concise way so you can get back to your projects.Before we begin, I want to clarify. This Instructable is only going to cover the basics and is not intended to be a thorough text on all of the theory and math behind how transistors work. If you wish to learn more on that, check out the transistor pages at electronics-tutorials.ws and allaboutcircuits.com.There are also several types of transistor, with the two most common being the bi-polar junction transistor (BJT) and the Metal-Oxide Semiconducting Field Effect Transistor (MOSFET). They are both extremely useful and very similar in function, although there are many differences. I will begin here with BJTs. Click here for my MOSFET I'ble.", "title": "Transistor Basics - BJTs", "url": "https://www.instructables.com/id/Transistor-Basics-BJTs/", "section": "technology", "steps": [{"step": 1, "steps_text": "There are many, many types of BJTs out there, and most of them are interchangeable with each other for the vast majority of projects, as long as you match types properly. That means that the parts list is totally up for interpretation according to what you happen to have in your parts bin at home.You will need -+ NPN and PNP type transistors. For the sake of these demos I will be using 2N3904 (NPN) and 2N3906 (PNP) for nearly everything as these are extremely easy to get your hands on. Any differences will be noted. 2N2222 BJTs can be used for the 2N3904 and 2N2907 can be used for the 2N3906 if needed.+ various resistors - a range of values from 100-100k\u2126 will work nicely. Exact values will be given as needed.+ other bits - LEDs, motor, speaker, flex sensor, electret microphone, audio transformer, etc. Basically components that require some amplification to be useful, or require more power than the circuit can provide. Some of these will be used, others are suggestions for your own projects later on. Details will be given in the demos.+ breadboard - none of these demos is meant to permanent, so get a breadboard for ease of building+ jumper wires - for connecting bits together+ 9V batteries and battery connectors - for powerImages 1 and 2 are diagrams for both types of BJTs - NPN and PNP. The three pins are labeled as Base,  Collector, and Emitter (FYI - for FETs, these are labeled Gate, Drain, and Source and serve the same functions). Carefully note the orientation of the three pins in the image 3. Datasheets are your friend and will save lots of headaches. Always double check the datasheet for the BJT you are using since some use a different pin configuration. I'm always getting the pins crossed anyway, which for most projects won't be an issue if you catch it quickly enough, but it's best to avoid it. Here are the datasheets for the 2N3904 and for the 2N3906.As always there is a lot of information on the datasheets. Pay special attention to the maximum ratings. Don't operate near max ratings if you can avoid it, always giving yourself some room. Now look at image 1 again. In order for NPN BJTs to work, the base voltage (Vb) must be more positive than the emitter voltage (Ve). And the collector voltage (Vc) must be more positive than Vb. Going back to the max specs for the 2N3904 from the datasheet, we see that if Ve is 0, Vb can be no more than 6V more positive than that. And Vc can be no more than 40V more positive than Ve. Vb must be somewhere in between Ve and Vc for the BJT to work. The Vb threshold for many BJTs is about 0.7V, meaning that at that voltage they begin to open. Also, the nature of BJTs is that while you will need a minimum of about 0.7V to turn it on, the current through the base is the defining factor for performance. As the base current increases, so does the collector current. This is different for MOSFETs, which work more on gate voltage than current.For PNP BJTs to work, reverse all of that from above. Vb must be more NEGATIVE than Ve, and Vc more NEGATIVE than Vb. A little trick to help remember is to remember the type you are working with. NPN require Positive voltage and current, and PNP require Negative voltage and current.BJTs need to be protected from too much current, just like any other component. Don't ever connect the emitter and collector pins directly between the power supply and GND. Always put a component with resistance in series. Going back to the 2N3904 datasheet, we see a max collector current rating of 200mA, but in the bullets under features on the first page it says 100mA. That is an ideal figure and it's not a bad idea to use that as a self-imposed max value. Again, stay away from max limitations by using resistors. Obviously we will be operating at much lower than max for these demos.Image 4 shows a different type of packaging for BJTs. The smaller package, like in image 3, is known as the TO-92. The larger style is the TO-220. These packages are used in many applications besides BJTs and FETs, so don't assume that since it looks like one, it is one. Always check your part numbers. The difference is that the TO-220 can handle much, much higher current loads than the TO-92 if properly paired with an appropriate heat sink. I have some that are rated for 30A as opposed to 0.2A. There are still many more types of cases for transistors, if you're interested, and you can even get them as arrays in an IC package on one piece of silicone, like the LM3046.", "step_imgs": ["https://cdn.instructables.com/FX2/N06E/HY5Y4LKB/FX2N06EHY5Y4LKB.LARGE.jpg", "https://cdn.instructables.com/F3E/ELFQ/HY5Y4LJZ/F3EELFQHY5Y4LJZ.LARGE.jpg", "https://cdn.instructables.com/FT1/963L/HY5Y4MKM/FT1963LHY5Y4MKM.LARGE.jpg", "https://cdn.instructables.com/FYD/J2CC/HY7T1FY3/FYDJ2CCHY7T1FY3.LARGE.jpg"], "step_title": "Step 1: Some Parts and Then Some Theory."}, {"step": 2, "steps_text": "In their most basic function, BJTs are switches. By applying a small current at the base, we can get a much larger current to pass between the collector/emitter pins. Since transistors typically don't draw very much current, they make a great electronic switch instead of needing a mechanical one.Image 1 shows a simple LED driver schematic using the 2N3904 NPN BJT. In my testing, I measured a base current of 0.640mA, which would normally not be enough to turn on an LED. But the LED was nice and bright, with only 7.4mA passing through it.Build: Place the BJT on the breadboard with the flat side facing you. The left pin is the Emitter, the right pin is the Collector, and the middle pin is the Base. Connect the 10k\u2126 resistor between the switch and the base pin. Connect the 1k\u2126 resistor between the collector pin and +9V. Connect the LED between the emitter pin and GND, with the flat side of the LED, the cathode, connected to GND. Connect the other side of the switch to +9V. (Image 2)Push the switch, a positive voltage and current are available at the base pin, which closes the connection between the emitter and collector, allowing current to flow between them and turning on the LED.Now let's use a PNP transistor and see what we have to change (image 3). Try swapping it straight out and push the switch. Anything? Nope. Remember that the PNP BJTs need a relatively negative voltage at the base to work, so one change is that the switch has to be connected to GND instead of +9V. The other difference is that while the pin assignments are the same between NPN and PNP BJTs, the pins are NOT in the same orientation in the schematic. Look at image 1 and see that the emitter (the arrow pointing away from the base) is on the bottom near the LED. Now look at image 3 and see that the emitter (the arrow pointing toward the base) is now at the top near R2. Simply turn the flat side of the PNP BJT away from you and put it in the same three pins the NPN was in. (Image 4)Since a much higher current can be driven between the collector and emitter, we can use transistors to drive much larger loads than the circuit may be able to handle on it's own. Image 5 has a schematic for doing just that. R2 is not absolutely necessary since the relay has some resistance to protect the BJT.", "step_imgs": ["https://cdn.instructables.com/FW5/BQB5/HY7T1BJE/FW5BQB5HY7T1BJE.LARGE.jpg", "https://cdn.instructables.com/FNC/V6NH/HY7T1BJT/FNCV6NHHY7T1BJT.LARGE.jpg", "https://cdn.instructables.com/FA1/ZIXZ/HY7T1BK0/FA1ZIXZHY7T1BK0.LARGE.jpg", "https://cdn.instructables.com/FEQ/M3Z1/HY7T1BI6/FEQM3Z1HY7T1BI6.LARGE.jpg", "https://cdn.instructables.com/FTR/T0P4/HY7T1DE5/FTRT0P4HY7T1DE5.LARGE.jpg"], "step_title": "Step 2: Electronic Switches"}, {"step": 3, "steps_text": "Remember when I said that for BJTs to work, you need a small current at the base pin to allow a much larger current to flow across the collector and emitter pins? Small current in, large current out... that's an amplifier. The basic formula to determine the gain is to divide the output by the input. In our example earlier with the LED, a small current of 0.640mA allowed a larger current of 7.4mA to flow through the LED. In this specific example, the gain would be 7.4mA / 0.640mA = 11.56. In the datasheet, the built in gain of the BJT is labeled as hFE and is known as the DC current gain (pg 2 under \"ON characteristics\"). As you can see from the datasheet, the actual gain is determined by the base current, the collector current and the voltage across the collector and emitter. Some DMMs will have a function to allow you to test the open-loop gain of BJTs (image 1), though I have no idea what the test conditions are for each DMM.Image 2 shows a schematic for using an NPN BJT as a simple one-transistor amplifier. You will need an electret mic and an audio transformer with a 1k\u2126 primary and an 8\u2126 secondary. The circuit itself is not very powerful, and is better used as a simple demonstration.Build: Place the NPN BJT on the breadboard with the flat side facing you. Connect one end of the 100nF (104) ceramic capacitor to the base (middle) pin of the BJT. Connect the positive pin of the mic to the other side of the capacitor and connect the other pin of the mic to GND. Connect a 10k\u2126 resistor between the positive pin of the mic and +9V. Place the 10k\u2126 potentiometer on the board. Connect one side pin to +9V, the other side pin to GND, and the wiper (middle) pin to the base pin of the BJT. Connect the left pin (emitter) of the BJT to GND. Connect the right pin (collector) to one of the primary coil pins on the audio transformer. (If the primary winding is center-tapped, don't connect to the center tap. Use the full primary winding.) Connect the other side of the primary winding to +9V. Connect the speaker across the secondary winding pins. (Image 3)The potentiometer will allow you to tune the circuit so that it works. It is a rather small window where it works, so take your time. As you adjust the pot, tap or rub the mic. Put your ear near the speaker as you adjust so you can hear it when you find the sweet spot with the pot. The mic works by generating a very small voltage when sound waves hit it. This changing voltage allows the capacitor to charge/recharge very quickly according to the RC time constant established with the potentiometer. This translates into a current at the base pin of the BJT, which as we know will allow the current to flow between the emitter and collector. The transformer then steps the +9V down while increasing the current high enough to drive the diaphragm on the speaker.Image 4 shows the response of the mic when I blew on it. It peaks at about 5mV. Image 5 shows the voltage across the speaker at the same moment. The max now is about 20 mV, so a gain of about 4. It's not much, but it was enough to hear it. Next we'll add another amp stage and get even more out of it.This circuit can also be used with a small flex sensor. Just replace the mic with the flex sensor and remove the 10k\u2126 resistor as it won't be needed.", "step_imgs": ["https://cdn.instructables.com/FV2/8APZ/HYBDHEXN/FV28APZHYBDHEXN.LARGE.jpg", "https://cdn.instructables.com/F53/CEJ1/HYBDHEXQ/F53CEJ1HYBDHEXQ.LARGE.jpg", "https://cdn.instructables.com/F9K/GZJD/HYBDHEXS/F9KGZJDHYBDHEXS.LARGE.jpg", "https://cdn.instructables.com/FII/QP9D/HYBDHEXM/FIIQP9DHYBDHEXM.LARGE.jpg"], "step_title": "Step 3: One-stage Amplifiers"}, {"step": 4, "steps_text": "As is usually the case, if one is good, two is better. In this case, we can definitely improve performance of the amplifier if we add another BJT. Let's see how that would work. Image 1 is the schematic.Build: We're going to build off of the circuit from the last step. Disconnect the transformer and speaker from the circuit and set aside. Swap C1 with a 4.7uF electrolytic capacitor and the 10k\u2126 potentiometer with a 100k\u2126 potentiometer. Connect a 100\u2126 resistor and a 100uF capacitor between the emitter pin for the first BJT (Q1) and GND. Place a 10k\u2126 resistor between the collector pin of Q1 and +9V. Connect a second 4.7uF cap between the collector of Q1 and the base of Q2. Connect the two outer pins of the 1M\u2126 potentiometer between +9V and GND and connect the wiper pin (middle) to the base of Q2. Place a 100nF (104) capacitor between the collector of Q2 and +9V. Place a 100\u2126 resistor and a 100uF capacitor between the emitter of Q2 and GND. Connect one side of the primary winding for the audio transformer to the collector pin of Q2 and the other side of the primary to +9V. Place the speaker across the contacts for the secondary winding. (Image 2)The 100k\u2126 pot is for tuning the circuit. Again there is a small window where it will work, so take your time. You should here some squeals or pops as it gets close. Tap or rub the mic as you adjust so you can hear it. The 1M\u2126 pot is for volume, and it works very well. As you can see from the two scope images, the data from the mic looks like it did in the last step, with most of the data within about a 1-2mV swing, and peaking at about 4-5mV (image 3). The output across the speaker looks much different. Before we had a max of about 20mV for a gain of about 5. This time our peak values are about 400-500mV, with most of the data between 100-200mV. That shows a gain of 100 for the circuit and a 5X increase in gain from the last circuit (image 4).", "step_imgs": ["https://cdn.instructables.com/FPP/2D8H/HYBDIDIA/FPP2D8HHYBDIDIA.LARGE.jpg", "https://cdn.instructables.com/F2Y/C6P4/HYBDIDID/F2YC6P4HYBDIDID.LARGE.jpg", "https://cdn.instructables.com/F2O/1L06/HYBDIDKG/F2O1L06HYBDIDKG.LARGE.jpg", "https://cdn.instructables.com/FNN/ZPQ2/HYBDIDI9/FNNZPQ2HYBDIDI9.LARGE.jpg"], "step_title": "Step 4: Two-stage Amplifiers"}, {"step": 5, "steps_text": "Clearly BJTs are great at amplifying, but sometimes we just need more power. The last circuit is great, but what if we have a larger speaker? A small 8\u2126 speaker will work just fine for the last circuit, but what if we want some volume? Suppose we salvaged some 4 in. or 6 in. speakers from... whatever it was and we want to use those. Speakers that large could draw way too much power from our little circuit and could very well cause some damage to the components. So, what do we do? We build a class B amplifier, that's what we do!The class B amplifier is ridiculously simple (image 1). I used it before in this I'ble, and I'll keep coming back to it as it's just so elegantly simple. In it's basic form, it's just two high current BJTs in TO-220 packages, one NPN and one PNP. This circuit assumes that your input has both positive and negative voltage swings, like a true sine wave.You will need high current BJTs for this. I like the TIP31C (NPN) and the TIP32C (PNP), but that's mostly because I happen to have them in my parts bin. You will also need some form of sound generation (like a waveform generator), + and -  9V sources, and a speaker. Take a look at the datasheets for the TIP31C and the TIP32C to get the pin assignments as they are different than the smaller TO-92 packages. Looking at them with the tab toward the rear, the pins are base, collector, emitter from left to right. Again, double check the datasheets.Build: Put both BJTs on the bread board such that no pins are connected to each other. Connect the base pins together with a jumper wire. Tie the emitters together with a jumper wire. Connect the input from your circuit or wave generator to the base pins. Connect the two batteries in series, with the '+' from one connected to the '-' of the other. This junction is now GND. Connect the battery GND to the circuit GND so everything is in the same plane of reference. Take the unconnected '-' lead from the battery pair and connect it to the collector of the TIP32C. Connect the unconnected '+' lead from the battery pair and connect it to the collector of the TIP31C. (Image 2)I tested this circuit with a 1\" speaker and with a 5\" speaker and got nearly identical results. The test signal was a 4V0-p sine wave at 200 Hz. Images 3 and 4 show the distortion in the wave due to the characteristics of the speakers when there is no power amplifier connected (image 3 is the smaller speaker). When the power amp is connected, we see a much better output, as shown in images 5 and 6 (image 5 is the smaller speaker). But there is still some distortion and the 4V input has been dropped a bit by the threshold voltage of the BJT. How do we fix that?Image 7 shows the same circuit, but this time with an op-amp connected as a voltage follower. This will ensure that the voltage stays the same from input to output, while still allowing the BJTs to do their job of providing more current for the speaker to use. This is especially useful at higher frequencies. Between images 8 and 9 you can see the difference the voltage follower makes in removing distortion at high frequencies. The input here was a 2kHz sine wave with the same amplitude as before. The 5\" speaker was attached to the output. And yes, it was really loud.", "step_imgs": ["https://cdn.instructables.com/F7Q/SOMW/HYBDIDQL/F7QSOMWHYBDIDQL.LARGE.jpg", "https://cdn.instructables.com/FKH/MJ4T/HYBDIDQR/FKHMJ4THYBDIDQR.LARGE.jpg", "https://cdn.instructables.com/FLK/YXDS/HYBDIDRS/FLKYXDSHYBDIDRS.LARGE.jpg", "https://cdn.instructables.com/FZR/MOC4/HYBDIDRX/FZRMOC4HYBDIDRX.LARGE.jpg", "https://cdn.instructables.com/FUD/4P53/HYBDIDT0/FUD4P53HYBDIDT0.LARGE.jpg", "https://cdn.instructables.com/F3X/14EB/HYBDIDPC/F3X14EBHYBDIDPC.LARGE.jpg", "https://cdn.instructables.com/F4X/67NY/HYBDIDPD/F4X67NYHYBDIDPD.LARGE.jpg", "https://cdn.instructables.com/FSY/KOUK/HYBDIDPF/FSYKOUKHYBDIDPF.LARGE.jpg", "https://cdn.instructables.com/FG0/B6ET/HYBDIDQI/FG0B6ETHYBDIDQI.LARGE.jpg"], "step_title": "Step 5: Power Amplifier"}, {"step": 6, "steps_text": "BJTs are wonderful for oscillating circuits because of their ability to turn on and off based on the voltage/current at the base pin. There are numerous applications for this, but we'll look at a couple here.The first is an LED flasher (image 1). This can be used for either one or two LEDs and the flash rate is fully adjustable for your own application.Build: Place two PNP BJTs on the bread board with the flat side facing you and no pins connected to each other. Put a 10uF capacitor between the base pin of one BJT and the collector pin of the other, with the cathode of the capacitor connected to the base pin. Place a second 10uF capacitor between the other base/collector pin pair in a similar manner. Connect a 100k\u2126 resistor between each base pin and GND. Connect a 470\u2126 resistor to each collector pin and then an LED between each 470\u2126 resistor and GND. (Image 2)As shown the LEDs will flash at about 1Hz. Changing either capacitor or either of the 100k\u2126 resistors will change the flash rate of one or both LEDs, so you may want to use variable capacitors and/or potentiometers to play around with this circuit. The thing about this circuit is that if one LED is on the other is off, but one will always be on. You get no period of time where both are on/off at the same time. If you only want to use one LED, remove one and tie the associated 470\u2126 resistor directly to GND. If you want to stack several LEDs in series, this circuit can handle it, limited by the voltage rating on the capacitors and BJTs, the collector current rating on the BJTs, and the amount of voltage you can provide. I built a 4 LED flasher, set in a rectangular shape with alternating corners flashing for a reader board for my work.Another application for oscillators is in radio circuits, both for transmitting and receiving. A simple 2-transistor, AM frequency transmitter circuit is shown in image 3. (Disclaimer - If you decide to build a transmitter, be aware of any local laws that govern transmission of the resulting waves. The circuits I provide shouldn't transmit beyond the other side of the room, but that doesn't mean that they can't be modified by the savvy hobbyist, so know the laws and whatever happens as result is on you.)Build: Place both BJTs on the board such that no pins are connected. Connect the collector of the PNP BJT (Q1) to the base of the NPN BJT (Q2). Put the 10nF (103) ceramic capacitor between the collector of Q2 and the base of Q1. Tie the emitter of Q1 to +9V and tie the emitter of Q2 to GND. Attach one end of a 100\u2126 resistor to the collector of Q2 and then connect a length of coiled wire and an LED between +9V and the other end of the 100\u2126 resistor. Connect the base of Q1 to one side of a 1M\u2126 potentiometer. Attach the wiper of the potentiometer to one end of a 100k\u2126 resistor and the other end of the 100k\u2126 resistor to GND.The LED is there to let you know you have found the sweet spot on the potentiometer for getting the thing tuned right. Place a small transistor radio in the AM band nearby to pick up the signal. The circuit should work without the wire antenna, but it helps.FM transmitters are pretty easy to build as well, though I will refer you to a search of Instructables and Google and let you filter the results as you see fit. A couple that really got my interest were from Make: and from I'bler ASCAS.", "step_imgs": ["https://cdn.instructables.com/F19/AY1X/HYE5YQS2/F19AY1XHYE5YQS2.LARGE.jpg", "https://cdn.instructables.com/FOZ/YXMM/HYE5YQS4/FOZYXMMHYE5YQS4.LARGE.jpg", "https://cdn.instructables.com/FO5/Q2HD/HYE5YQS8/FO5Q2HDHYE5YQS8.LARGE.jpg", "https://cdn.instructables.com/FHW/L0DX/HYE5YQPJ/FHWL0DXHYE5YQPJ.LARGE.jpg"], "step_title": "Step 6: Oscillators"}, {"step": 7, "steps_text": "But not from me though. I've gone over several simple uses for BJTs, and there are still more. You can even build your own op-amps and 555 timers if you wanted to.Thanks for reading. Please don't hesitate to ask questions in the comments below. You never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 7: But Wait, There's More..."}], "channel": "Electronics"}, {"category": "technology", "description": "With this synthesizer you can make Arduino reproduce totally customized waveforms. Due to the MIDI interface, it can be connected to any instrument which such feature and play it with the sound you want.", "title": "How to Make an Arduino Sound Synthesizer With MIDI Interface", "url": "https://www.instructables.com/id/How-to-make-an-Arduino-sound-synthesizer-with-MIDI/", "section": "technology", "steps": [{"step": 1, "steps_text": "Arduino (in this case Arduino UNO) Instrument with MIDI interface Wire for connections Capacitors: 220\u00b5F, 10nF, 0.56\u00b5F -Resistors: 10 \u03a9 8 \u03a9 speaker Breadboard LM386Pins strips (male and female)For soldering (optional):Solder Soldering iron Sponge Strip board", "step_imgs": [], "step_title": "Step 1: Materials "}, {"step": 2, "steps_text": "This amplifier is made for low voltage, it can afford until 18V at supply voltage.First of all, we should put all parts together in the breadboard and check that everything works properly, just like at images. A breadboard is not a good option for sound circuits due to the parasitic capacitances, what introduce noise in our sound signal. Therefore, after test that everything work as expected, it is a good idea to solder it to remove noise effect.", "step_imgs": ["https://cdn.instructables.com/F7E/3T2D/I66CZICH/F7E3T2DI66CZICH.LARGE.jpg", "https://cdn.instructables.com/FDW/PP7J/I66CZKFS/FDWPP7JI66CZKFS.LARGE.jpg"], "step_title": "Step 2: The Amplifier"}, {"step": 3, "steps_text": "If you never tried soldering before, read this Instructable first:https://www.instructables.com/id/Electrical-Soldering/For the soldering we will use a strip board for prototyping. We need to place the components where it is indicated in the design and solder them. Then, some parts of the circuit need to be isolated from others. For this we just need to cut some strips on the reverse part of the board: the strips behind the chip, and the strips at pins that are not used (they are included to attach it to Arduino shield).Also in this case we included two extra connections that were not used in the breadboard design, they are marked with red wire. This connections are made for gain control. At the moment the gain of the amplifier is 20, if we add a capacitor (around 10uF) between this pins, the gain increase until 200.", "step_imgs": ["https://cdn.instructables.com/FAK/KKJK/I66CZHTB/FAKKKJKI66CZHTB.LARGE.jpg", "https://cdn.instructables.com/F9Q/KZWS/I66CZI0A/F9QKZWSI66CZI0A.LARGE.jpg"], "step_title": "Step 3: Soldering the Amplifier (optional)"}, {"step": 4, "steps_text": "As we said at the beginning, we need an instrument with MIDI interface to generate the notes. The MIDI connector has 5 pins, but only 3 are used: GND, VCC and DATA. VCC is not needed, so we just need to connect GND and DATA to the Arduino board.Then, with a MIDI cable, we can make the connection with the instrument we are using.", "step_imgs": ["https://cdn.instructables.com/FLL/ADGF/I66CZI2U/FLLADGFI66CZI2U.LARGE.jpg", "https://cdn.instructables.com/FHC/5LT6/I66CZI68/FHC5LT6I66CZI68.LARGE.jpg", "https://cdn.instructables.com/F6Z/45SH/I66CZIC5/F6Z45SHI66CZIC5.LARGE.jpg", "https://cdn.instructables.com/FK1/E4BW/I66CZL43/FK1E4BWI66CZL43.LARGE.jpg"], "step_title": "Step 4: The MIDI Conection"}, {"step": 5, "steps_text": "Now we just needto load the code into the Arduino. The code uses MIDI library and Mozzi libraries, that should be installed. This libraries can be found here: http://sensorium.github.io/Mozzi/https://github.com/FortySevenEffects/arduino_midi_library/If you don't know how to install a library for Arduino, follow this link: http://arduino.cc/en/Guide/Libraries", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: The Code"}, {"step": 6, "steps_text": "Now you just need to play! Connect everything properly and start testing your creation. The audio input of the amplifier came from pin 9 of Arduino (in Arduino UNO).If something went wrong: In case you cannot hear anything, check the led indicator on Arduino Board. It should be ON when a note is pressed, and OFF when released. If this does not happen, maybe something is wrong with the MIDI connector. If you can hear it, but does not sound good: This project uses PWM based sound, what does not deal good with low frequency sounds. Increase the scale of the instrument if possible. If not, change the parameter INCREMENT_NOTE at the beginning of the code. Try different values until the sound improves (it should be a positive value, maybe several tens).", "step_imgs": [], "step_title": "Step 6: Test It!"}, {"step": 7, "steps_text": "In this case, the sound is obtained from the addition of two sinusoidal waves. You can experiment with different sounds changing the wave table. Mozzi includes more already-made tables which can be used. For this, you can follow the instructions in the code and comment the section of \u201cSINE WAVE\u201d and uncomment another section.You can even create your own tables and try them with your personalised wave form.", "step_imgs": [], "step_title": "Step 7: The Wave Tables"}, {"step": 8, "steps_text": "The duration of the notes are divided in 4: attack, delay, sustain, release. This times change the way the sound. Instead of manipulate this times in the code, we can add an external hardware control, and change the durations at anytime.Also, an external control can be added to switch between different wave tables. This way the sound can be changed faster, at the same time the instrument is being played. If we want to improve the sound quality, we should use a Digital Analog Converter. This way, we can use the digital exits of the Arduino shield to indicate the analogical value of the wave at the moment, then the converter will turn it into analogical value. The sound will be softer and we will be able to hear lower frequencies.", "step_imgs": [], "step_title": "Step 8: Further Ideas"}], "channel": "Arduino"}, {"category": "technology", "description": "Note:Any one can ask me for help.Don't comment me on my spelling and grammar.......Because my mother language isn't english.OK LETS GO                                  and also plz plz rate my instructable well                   Hi every one.Today i'll show you how to make a PWM(pulse width modulation) out of a very famous chip 555(lm,ne any one will do) with some other parts offcourse.This is really simple and it is very handy if you want to control your leds,light bulb,servo motor or dc motor(brushless also works). My pwm can only change the duty cyle from 10% to 90% it cant do nothing more!", "title": "Very Simple PWM With 555...Modulate Every Thing", "url": "https://www.instructables.com/id/Very-simple-PWM-with-555Modulate-every-thing/", "section": "technology", "steps": [{"step": 1, "steps_text": "Pulse-width modulation (PWM) of a signal or power source involves the modulation of its duty cycle, to either convey information over a communications channel or control the amount of power sent to a load.The simplest way to generate a PWM signal is the intersective method, which requires only a sawtooth or a triangle waveform (easily generated using a simple oscillator) and a comparator. When the value of the reference signal (the green sine wave in figure 2) is more than the modulation waveform (blue), the PWM signal (magenta) is in the high state, otherwise it is in the low state.But in my pwm I will not use comparator.", "step_imgs": [], "step_title": "Step 1: What Is PWM"}, {"step": 2, "steps_text": "Three types of pulse-width modulation (PWM) are possible:   1. The pulse center may be fixed in the center of the time window and both edges of the pulse moved to compress or expand the width.   2. The lead edge can be held at the lead edge of the window and the tail edge modulated.   3. The tail edge can be fixed and the lead edge modulated.Three types of PWM signals (blue): leading edge modulation (top), trailing edge modulation (middle) and centered pulses (both edges are modulated, bottom). The green lines are the sawtooth signals used to generate the PWM waveforms using the intersective method.", "step_imgs": ["https://cdn.instructables.com/FHU/XL0Y/FOHTTUXB/FHUXL0YFOHTTUXB.LARGE.jpg"], "step_title": "Step 2: Types of Pwm"}, {"step": 3, "steps_text": "Power delivery:PWM can be used to reduce the total amount of power delivered to a load without losses normally incurred when a power source is limited by resistive means. This is because the average power delivered is proportional to the modulation duty cycle. With a sufficiently high modulation rate, passive electronic filters can be used to smooth the pulse train and recover an average analog waveform.High frequency PWM power control systems are easily realisable with semiconductor switches. The discrete on/off states of the modulation are used to control the state of the switch(es) which correspondingly control the voltage across or current through the load. The major advantage of this system is the switches are either off and not conducting any current, or on and have (ideally) no voltage drop across them. The product of the current and the voltage at any given time defines the power dissipated by the switch, thus (ideally) no power is dissipated by the switch. Realistically, semiconductor switches such as MOSFETs or BJTs are non-ideal switches, but high efficiency controllers can still be built.PWM is also often used to control the supply of electrical power to another device such as in speed control of electric motors, volume control of Class D audio amplifiers or brightness control of light sources and many other power electronics applications. For example, light dimmers for home use employ a specific type of PWM control. Home use light dimmers typically include electronic circuitry which suppresses current flow during defined portions of each cycle of the AC line voltage. Adjusting the brightness of light emitted by a light source is then merely a matter of setting at what voltage (or phase) in the AC cycle the dimmer begins to provide electrical current to the light source (e.g. by using an electronic switch such as a triac). In this case the PWM duty cycle is defined by the frequency of the AC line voltage (50 Hz or 60 Hz depending on the country). These rather simple types of dimmers can be effectively used with inert (or relatively slow reacting) light sources such as incandescent lamps, for example, for which the additional modulation in supplied electrical energy which is caused by the dimmer causes only negligible additional fluctuations in the emitted light. Some other types of light sources such as light-emitting diodes (LEDs), however, turn on and off extremely rapidly and would perceivably flicker if supplied with low frequency drive voltages. Perceivable flicker effects from such rapid response light sources can be reduced by increasing the PWM frequency. If the light fluctuations are sufficiently rapid, the human visual system can no longer resolve them and the eye perceives the time average intensity without flicker (see flicker fusion threshold).Voltage regulation:PWM is also used in efficient voltage regulators. By switching voltage to the load with the appropriate duty cycle, the output will approximate a voltage at the desired level. The switching noise is usually filtered with an inductor and a capacitor.One method measures the output voltage. When it is lower than the desired voltage, it turns on the switch. When the output voltage is above the desired voltage, it turns off the switch.Variable-speed fan controllers for computers usually use PWM, as it is far more efficient when compared to a potentiometer.Audio effects and amplification:PWM is sometimes used in sound synthesis, in particular subtractive synthesis, as it gives a sound effect similar to chorus or slightly detuned oscillators played together. (In fact, PWM is equivalent to the difference of two sawtooth waves. [1]) The ratio between the high and low level is typically modulated with a low frequency oscillator, or LFO.A new class of audio amplifiers based on the PWM principle is becoming popular. Called \"Class-D amplifiers\", these amplifiers produce a PWM equivalent of the analog input signal which is fed to the loudspeaker via a suitable filter network to block the carrier and recover the original audio. These amplifiers are characterized by very good efficiency figures (e 90%) and compact size/light weight for large power outputs.Historically, a crude form of PWM has been used to play back PCM digital sound on the PC speaker, which is only capable of outputting two sound levels. By carefully timing the duration of the pulses, and by relying on the speaker's physical filtering properties (limited frequency response, self-inductance, etc.) it was possible to obtain an approximate playback of mono PCM samples, although at a very low quality, and with greatly varying results between implementations.In more recent times, the Direct Stream Digital sound encoding method was introduced, which uses a generalized form of pulse-width modulation called pulse density modulation, at a high enough sampling rate (typically in the order of MHz) to cover the whole acoustic frequencies range with sufficient fidelity. This method is used in the SACD format, and reproduction of the encoded audio signal is essentially similar to the method used in class-D amplifiers.Speaker:Using pwm it is possible to modulate arc(plasma) and if it is in the hearing range,it can be used as a speaker.Such speaker are used in Hi-Fi sound system as tweeterCOOLLLL right?", "step_imgs": [], "step_title": "Step 3: How Can PWM Help Us???"}, {"step": 4, "steps_text": "because it's a simple one chip circuit you won't need lots of part1.NE555,LM555 or 7555(cmos)2.two diodes 1n4148 is recomended but you can also use 1n40xx series diodes3.100k pot(volume control pots are good for this circuit)4.100nf green cap 5.220pf ceramic cap6.breadbord7.power transistor Easy right?", "step_imgs": ["https://cdn.instructables.com/F08/6F30/FOHTTXTF/F086F30FOHTTXTF.LARGE.jpg", "https://cdn.instructables.com/FDP/8BXK/FOHTTXTU/FDP8BXKFOHTTXTU.LARGE.jpg", "https://cdn.instructables.com/FQH/BSKC/FOHTTXU0/FQHBSKCFOHTTXU0.LARGE.jpg"], "step_title": "Step 4: Thing You Will Need"}, {"step": 5, "steps_text": "Just follow the diagram and put all parts on the breadboard.Recheck every thing twice before you power it up.if you want to drive efficiently and control the brightness of a light source or a motor you can only put a power transistor on it out put but if you only want drive a light source or a motor efficiently then put a higer rating cap 2200uf is recomended.If put this cap and drive a motor on 40% duty cyle then your motor will be 60% efficient at almost same speed and same torque.Go build it nowthere is two video.you can watch how pwm works.and my pwm really works with out any op amp1. u can see the fan starts to spin 1/2 sec then is starts to spin on 90 % duty cycle2.u can see the leds blinks like the blinker of cars the it is on 80% duty cycleP.S:plz plz rate this instructable with higher rating.I'm only 15 years old.Good-byemy next instructable will be a arc speaker with pwm", "step_imgs": ["https://cdn.instructables.com/F27/G3TA/FOHTTUY8/F27G3TAFOHTTUY8.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 5: Building It $$$$"}], "channel": "Electronics"}, {"category": "technology", "description": "Do you have an amplifier hidden somewhere in the living room or basement (or home theater) that you want it to turn on when you start to play music?This circuit is the solution for you!\nIt\u00a0is pretty similar to another project I posted a while ago, but here it turns amplifier on and off. If source is playing then the unit will turn amplifier on by using the sending the remote infrared code to turn it on, and when idle for some time, the unit will send the power off remote infrared code to turn off the amplifier. The code here is set to work with a Kenwood 6030 amplifier. If you have a different gear, no fear. Changing the program to work with another set of codes is really simple. You will need to change one or two hex codes only in the KenwoodIdle.PDE file. The best place to learn the codes of your gear is by looking at\u00a0http://www.lirc.org/\u00a0\nThe PCB shown in the picture is part of a shield designed for similar idea that also includes Equalizer bar-graph of the music. The circuit here is a subset of it and for it no PCB is really necessary (but since I got 10 PCBs in a batch... I got some spare ones).", "title": "Turning Stereo Amplifer on and Off Automatically", "url": "https://www.instructables.com/id/Turning-Stereo-Amplifer-On-and-Off-automatically/", "section": "technology", "steps": [{"step": 1, "steps_text": "\n          1x Arduino, any type is good, Uno, Nano, Mini or other mutants.\n1x RGB LED (optional)1\n1x 330 Ohm Resistor (220 to 470 good as well)2\n1x 220 Ohm Resistor (100 Ohm is even better for the IR LED)3\n1x IR LED (most likely you need 940nm one)\n2x 3.5mm Stereo jacks\n4x 22KOhm Resistors (10K is minimum, 56K is maximum I believe)\nYou will need Arduino IDE 0022 as I did not see the IR Remote library ported to the Arduino 1.x IDE yet.\nPut the files in IRremote sub-directory into the Arduino libraries folder\nCompile and load the program to your Arduino.Notes:\n1) Status LED is optional, you don't really need it. but it is useful:\n\n\tIf showing Red, that means amplifier is off and no music is played by source.\n\tIf showing Green, that means amplifier is ON but no music is played by source\n\tIf showing Blue, that means amplifier is ON and music is played by source.\n2) Increasing the value of the resistor of the status LED will make it dimmed which might be desired. I use only one resistor and that means that you can only have one color at a time from this RGB LED. In this case it is by design. If you want to play around with different colors and stuff, you will need to move to three different resistors one for every color. Note that if you do that, the resistors should be slightly different between the Red, Green and Blue ones (for example 330 for Red, 300 for Green and \u00a0270 for Blue for the RGB LED that I have).\n3) Reducing the value of the resistor of the IR LED can increase the distance between the IR LED and the amplifier under control. Do not go below 100 ohm otherwise you might fry your Arduino. I used 220 Ohm as I placed the IR LED very close to the amplifier IR sensor.How to connect to your Stereo system:\nThe amplifier output should be connected to an output of the amplifier, connection to tape recorder is typically not used anymore these days and can very well be the best place to connect this unit to your amplifier (recording output of tape from Amplifier to the Amplifier jack of this unit).\nThe source input, marked as Sonos in the diagram below (this is almost always the source of music in my house these days) can be taken from RCA connection of the Sonos or using a split cable take one into this unit and the other to the amplifier.Enjoy the listening.", "step_imgs": ["https://cdn.instructables.com/FGI/PJE0/H6MF2PDK/FGIPJE0H6MF2PDK.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: Parts & Assembly"}], "channel": "Arduino"}, {"category": "technology", "description": "Do you have an amplifier hidden somewhere in the living room or basement (or home theater) that you want it to turn on when you start to play music?This circuit is the solution for you!\nIt\u00a0is pretty similar to another project I posted a while ago, but here it turns amplifier on and off. If source is playing then the unit will turn amplifier on by using the sending the remote infrared code to turn it on, and when idle for some time, the unit will send the power off remote infrared code to turn off the amplifier. The code here is set to work with a Kenwood 6030 amplifier. If you have a different gear, no fear. Changing the program to work with another set of codes is really simple. You will need to change one or two hex codes only in the KenwoodIdle.PDE file. The best place to learn the codes of your gear is by looking at\u00a0http://www.lirc.org/\u00a0\nThe PCB shown in the picture is part of a shield designed for similar idea that also includes Equalizer bar-graph of the music. The circuit here is a subset of it and for it no PCB is really necessary (but since I got 10 PCBs in a batch... I got some spare ones).", "title": "Turning Stereo Amplifer on and Off Automatically", "url": "https://www.instructables.com/id/Turning-Stereo-Amplifer-On-and-Off-automatically/", "section": "technology", "steps": [{"step": 1, "steps_text": "\n          1x Arduino, any type is good, Uno, Nano, Mini or other mutants.\n1x RGB LED (optional)1\n1x 330 Ohm Resistor (220 to 470 good as well)2\n1x 220 Ohm Resistor (100 Ohm is even better for the IR LED)3\n1x IR LED (most likely you need 940nm one)\n2x 3.5mm Stereo jacks\n4x 22KOhm Resistors (10K is minimum, 56K is maximum I believe)\nYou will need Arduino IDE 0022 as I did not see the IR Remote library ported to the Arduino 1.x IDE yet.\nPut the files in IRremote sub-directory into the Arduino libraries folder\nCompile and load the program to your Arduino.Notes:\n1) Status LED is optional, you don't really need it. but it is useful:\n\n\tIf showing Red, that means amplifier is off and no music is played by source.\n\tIf showing Green, that means amplifier is ON but no music is played by source\n\tIf showing Blue, that means amplifier is ON and music is played by source.\n2) Increasing the value of the resistor of the status LED will make it dimmed which might be desired. I use only one resistor and that means that you can only have one color at a time from this RGB LED. In this case it is by design. If you want to play around with different colors and stuff, you will need to move to three different resistors one for every color. Note that if you do that, the resistors should be slightly different between the Red, Green and Blue ones (for example 330 for Red, 300 for Green and \u00a0270 for Blue for the RGB LED that I have).\n3) Reducing the value of the resistor of the IR LED can increase the distance between the IR LED and the amplifier under control. Do not go below 100 ohm otherwise you might fry your Arduino. I used 220 Ohm as I placed the IR LED very close to the amplifier IR sensor.How to connect to your Stereo system:\nThe amplifier output should be connected to an output of the amplifier, connection to tape recorder is typically not used anymore these days and can very well be the best place to connect this unit to your amplifier (recording output of tape from Amplifier to the Amplifier jack of this unit).\nThe source input, marked as Sonos in the diagram below (this is almost always the source of music in my house these days) can be taken from RCA connection of the Sonos or using a split cable take one into this unit and the other to the amplifier.Enjoy the listening.", "step_imgs": ["https://cdn.instructables.com/FGI/PJE0/H6MF2PDK/FGIPJE0H6MF2PDK.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: Parts & Assembly"}], "channel": "Arduino"}, {"category": "technology", "description": "This is how you can use one of the BostonAndroid.com Xmega evaluation boards ($20) \u00a0to create a simple adjustable sine waveform generator with 12bit resolution and capable of producing frequencies from 125Hz - 20KHz using the integrated DAC. You can modify the code to produce any arbitrary waveform at up to 1MHz on 2 channels. You need only a PC, an eval board and a suitable Atmel programmer (AVRISP is under $30 new). There are a LOT\u00a0of features packed into the Xmega microcontrollers. This instructable is meant to demonstrate some of the really powerful ones like a 12bit DAC, 12bit ADC, DMA controller and open source compiler (avr-gcc).", "title": "Easy Atmel Xmega Sine Wave / Waveform Generator", "url": "https://www.instructables.com/id/Easy-Atmel-Xmega-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "You will need the following to complete this project:Boston Android Xmega EVAL-01 Development Board ($20) or build your ownMurata PV36W103C01B00 Trimpot 10Kohm, 25turn (or equiv from Mouser)PC with AVR Studio 4\u00a0(free)AVRISP mkII programmer\u00a0($30)\u00a0", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "To create an adjustable waveform generator we will use a simple resistor voltage divider to be read by the Xmega on board 12bit ADC. This value will then be used to\u00a0set the frequency of the DAC sine wave frequency but the following formula:reading = (Vin/1.6V) * 256freq = (reading * reading) + 1;By adding an adjustable 3pin\u00a0Potentiometer to PortA\u00a0on\u00a0the XMega-Eval01\u00a0we can create this simple voltage divider. You can also feed in your own voltage source between 0-1.6V to do the adjustment instead.The waveform is output from the DAC with 50 samples per cycle at 12bit resolution from PORTB pin2. Pin1 is setup as ground reference.", "step_imgs": ["https://cdn.instructables.com/FOC/ZE48/G145T03D/FOCZE48G145T03D.LARGE.gif"], "step_title": "Step 2: Theory of Operation"}, {"step": 3, "steps_text": "The instructions here are to simply buy the Boston Android EVAL-01 Xmega dev board. But you can also build your own by buying a TQFP-64 adapter board (check ebay ~$5) and buying an Xmega64a3 chip from Digikey or Mouser (~$8). Below is the schematic for the EVAL-01 board.", "step_imgs": ["https://cdn.instructables.com/FP9/1AJU/G1BBDO9J/FP91AJUG1BBDO9J.LARGE.jpg", "https://cdn.instructables.com/FO5/CEQ5/G1BBDOAE/FO5CEQ5G1BBDOAE.LARGE.jpg"], "step_title": "Step 3: Schematic for EVAL-01 Board or Build Your Own"}, {"step": 4, "steps_text": "Solder\u00a0the PV36W103C01B00 Trimpot to PortA pins 1-3 with the screw adjustment to the right.", "step_imgs": ["https://cdn.instructables.com/FV4/WRER/G145NUR9/FV4WRERG145NUR9.LARGE.jpg"], "step_title": "Step 4: Add Potentiometer"}, {"step": 5, "steps_text": "Solder two wires to PORTB pins 1 and 2.", "step_imgs": ["https://cdn.instructables.com/FMX/6C8P/G145NUR8/FMX6C8PG145NUR8.LARGE.jpg"], "step_title": "Step 5: Add Test Wire Leads"}, {"step": 6, "steps_text": "Using Atmel AVR Studio 4:1) Start Atmel AVR Studio 42)\u00a0Select \"New Project\"3) Select \"avr-gcc\" project4) Give your project a name5) Select \"AVR Simulator 2\" and target device: \"Atmel AVR ATXmega64A3\"6) Get C source code file xmega-waveform.c from BostonAndroid website and save to your project directory and add to your project (or copy source code into the default C file created by AVR studio)7) Go to \"Build\" menu and select \"Build\"", "step_imgs": [], "step_title": "Step 6: Compile Firmware"}, {"step": 7, "steps_text": "Connect 5VDC power supply to board. The easiest way is using a 5VDC wall adapter with center positive (you probably own one and don't know it; they are very common). If not, use an adjustable power supply or 3 AA batteries and connect to solder tabs at bottom of board. The contact close to the front of the connector is negative, the back one is positive.Next connect the Atmel AVRISP mkii programmer to your PC USB port.Next connect 6 pin ribbon cable between programmer and board as shown.Open the software project in AVRstudio that you compiled in the previous step and load the software on the device by clicking on the \"AVR\" button in the toolbar (or also in drop down menu \"program AVR device\")A dialog will appear which lists options like \"Device\" \"Flash\" & \"eeprom\". You want to program the flash memory on the target device. Select \"...\" under FLASH and locate a .hex file for your project, then click \"Program\". The .hex file name is .hex.In a small box at the bottom of this dialog you should see lots of successful looking messages. :-)", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 7: Program Device"}, {"step": 8, "steps_text": "Connect an Oscilloscope (or freq counter, or high impedance speaker like a headphone speaker) across PORTB pins 1 & 2. You should see a sine wave of 3.3V p-p amplitude. Adjust the potentiometer clockwise to increase frequency from 125-20KHz. Turn counter clockwise to decrease frequency.", "step_imgs": ["https://cdn.instructables.com/FHN/S7CK/G145NURB/FHNS7CKG145NURB.LARGE.gif", "https://cdn.instructables.com/FKF/J8WR/G145NUR3/FKFJ8WRG145NUR3.LARGE.gif"], "step_title": "Step 8: Use Device!"}, {"step": 9, "steps_text": "So, this is a simple example of how you can use the Atmel XMega microcontroller to generate sine waves. Here are some things you can do with minor changes to the firmware:1)\u00a0Go higher! The maximum frequency is limited by the 50 sample sine waveform and 1Msps DAC. You can modify the function LoadSineWave() and set the number of samples to be say 10: LoadSineWave(10). This will cause 5x more cycles. Now you can use SetWaveFreq() to go beyond 20KHz to 100KHz!2)\u00a0Arbitrary waveforms. LoadSineWave() loads a simple sine wave. But you can put any waveform you want into data12[] array. In C you can do this in the declaration:\u00a0\u00a0\u00a0 int data12[10] = {1,2,3,4,5,6,7,8,9,10};3) Vary amplitude. The output waveform is 0-3.3V but you can make this smaller by scaling the data loaded into data12[].4) Increase resolution of Freq adjustment potentiometer. The stock code uses the ADC in 8bit mode (256 discrete frequency settings). You can change this to 12bit and allow 2^12=4096 different frequencies", "step_imgs": [], "step_title": "Step 9: What Next? What Else Can This Thing Do?"}], "channel": "Electronics"}, {"category": "technology", "description": "This is how you can use one of the BostonAndroid.com Xmega evaluation boards ($20) \u00a0to create a simple adjustable sine waveform generator with 12bit resolution and capable of producing frequencies from 125Hz - 20KHz using the integrated DAC. You can modify the code to produce any arbitrary waveform at up to 1MHz on 2 channels. You need only a PC, an eval board and a suitable Atmel programmer (AVRISP is under $30 new). There are a LOT\u00a0of features packed into the Xmega microcontrollers. This instructable is meant to demonstrate some of the really powerful ones like a 12bit DAC, 12bit ADC, DMA controller and open source compiler (avr-gcc).", "title": "Easy Atmel Xmega Sine Wave / Waveform Generator", "url": "https://www.instructables.com/id/Easy-Atmel-Xmega-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "You will need the following to complete this project:Boston Android Xmega EVAL-01 Development Board ($20) or build your ownMurata PV36W103C01B00 Trimpot 10Kohm, 25turn (or equiv from Mouser)PC with AVR Studio 4\u00a0(free)AVRISP mkII programmer\u00a0($30)\u00a0", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "To create an adjustable waveform generator we will use a simple resistor voltage divider to be read by the Xmega on board 12bit ADC. This value will then be used to\u00a0set the frequency of the DAC sine wave frequency but the following formula:reading = (Vin/1.6V) * 256freq = (reading * reading) + 1;By adding an adjustable 3pin\u00a0Potentiometer to PortA\u00a0on\u00a0the XMega-Eval01\u00a0we can create this simple voltage divider. You can also feed in your own voltage source between 0-1.6V to do the adjustment instead.The waveform is output from the DAC with 50 samples per cycle at 12bit resolution from PORTB pin2. Pin1 is setup as ground reference.", "step_imgs": ["https://cdn.instructables.com/FOC/ZE48/G145T03D/FOCZE48G145T03D.LARGE.gif"], "step_title": "Step 2: Theory of Operation"}, {"step": 3, "steps_text": "The instructions here are to simply buy the Boston Android EVAL-01 Xmega dev board. But you can also build your own by buying a TQFP-64 adapter board (check ebay ~$5) and buying an Xmega64a3 chip from Digikey or Mouser (~$8). Below is the schematic for the EVAL-01 board.", "step_imgs": ["https://cdn.instructables.com/FP9/1AJU/G1BBDO9J/FP91AJUG1BBDO9J.LARGE.jpg", "https://cdn.instructables.com/FO5/CEQ5/G1BBDOAE/FO5CEQ5G1BBDOAE.LARGE.jpg"], "step_title": "Step 3: Schematic for EVAL-01 Board or Build Your Own"}, {"step": 4, "steps_text": "Solder\u00a0the PV36W103C01B00 Trimpot to PortA pins 1-3 with the screw adjustment to the right.", "step_imgs": ["https://cdn.instructables.com/FV4/WRER/G145NUR9/FV4WRERG145NUR9.LARGE.jpg"], "step_title": "Step 4: Add Potentiometer"}, {"step": 5, "steps_text": "Solder two wires to PORTB pins 1 and 2.", "step_imgs": ["https://cdn.instructables.com/FMX/6C8P/G145NUR8/FMX6C8PG145NUR8.LARGE.jpg"], "step_title": "Step 5: Add Test Wire Leads"}, {"step": 6, "steps_text": "Using Atmel AVR Studio 4:1) Start Atmel AVR Studio 42)\u00a0Select \"New Project\"3) Select \"avr-gcc\" project4) Give your project a name5) Select \"AVR Simulator 2\" and target device: \"Atmel AVR ATXmega64A3\"6) Get C source code file xmega-waveform.c from BostonAndroid website and save to your project directory and add to your project (or copy source code into the default C file created by AVR studio)7) Go to \"Build\" menu and select \"Build\"", "step_imgs": [], "step_title": "Step 6: Compile Firmware"}, {"step": 7, "steps_text": "Connect 5VDC power supply to board. The easiest way is using a 5VDC wall adapter with center positive (you probably own one and don't know it; they are very common). If not, use an adjustable power supply or 3 AA batteries and connect to solder tabs at bottom of board. The contact close to the front of the connector is negative, the back one is positive.Next connect the Atmel AVRISP mkii programmer to your PC USB port.Next connect 6 pin ribbon cable between programmer and board as shown.Open the software project in AVRstudio that you compiled in the previous step and load the software on the device by clicking on the \"AVR\" button in the toolbar (or also in drop down menu \"program AVR device\")A dialog will appear which lists options like \"Device\" \"Flash\" & \"eeprom\". You want to program the flash memory on the target device. Select \"...\" under FLASH and locate a .hex file for your project, then click \"Program\". The .hex file name is .hex.In a small box at the bottom of this dialog you should see lots of successful looking messages. :-)", "step_imgs": ["https://cdn.instructables.com/FUA/KHK2/G145NURA/FUAKHK2G145NURA.LARGE.jpg"], "step_title": "Step 7: Program Device"}, {"step": 8, "steps_text": "Connect an Oscilloscope (or freq counter, or high impedance speaker like a headphone speaker) across PORTB pins 1 & 2. You should see a sine wave of 3.3V p-p amplitude. Adjust the potentiometer clockwise to increase frequency from 125-20KHz. Turn counter clockwise to decrease frequency.", "step_imgs": ["https://cdn.instructables.com/FHN/S7CK/G145NURB/FHNS7CKG145NURB.LARGE.gif", "https://cdn.instructables.com/FKF/J8WR/G145NUR3/FKFJ8WRG145NUR3.LARGE.gif"], "step_title": "Step 8: Use Device!"}, {"step": 9, "steps_text": "So, this is a simple example of how you can use the Atmel XMega microcontroller to generate sine waves. Here are some things you can do with minor changes to the firmware:1)\u00a0Go higher! The maximum frequency is limited by the 50 sample sine waveform and 1Msps DAC. You can modify the function LoadSineWave() and set the number of samples to be say 10: LoadSineWave(10). This will cause 5x more cycles. Now you can use SetWaveFreq() to go beyond 20KHz to 100KHz!2)\u00a0Arbitrary waveforms. LoadSineWave() loads a simple sine wave. But you can put any waveform you want into data12[] array. In C you can do this in the declaration:\u00a0\u00a0\u00a0 int data12[10] = {1,2,3,4,5,6,7,8,9,10};3) Vary amplitude. The output waveform is 0-3.3V but you can make this smaller by scaling the data loaded into data12[].4) Increase resolution of Freq adjustment potentiometer. The stock code uses the ADC in 8bit mode (256 discrete frequency settings). You can change this to 12bit and allow 2^12=4096 different frequencies", "step_imgs": [], "step_title": "Step 9: What Next? What Else Can This Thing Do?"}], "channel": "Electronics"}, {"category": "technology", "description": "It is a simple time pass project.. All of you can make on your ceiling fan. the led lights are attached on the leaves of the fan. the lights will glow with respect to the audio source attached to it.", "title": "Equalizer Light on FAN ", "url": "https://www.instructables.com/id/Equalizer-Light-On-FAN/", "section": "technology", "steps": [{"step": 1, "steps_text": "to feed the external power and audio input. use/make slip rings on the fans neck.", "step_imgs": ["https://cdn.instructables.com/FAM/GWKT/IBW27IW9/FAMGWKTIBW27IW9.LARGE.jpg", "https://cdn.instructables.com/FZR/426R/IBW27IW6/FZR426RIBW27IW6.LARGE.jpg"], "step_title": "Step 1: Slip Rings on Fan"}, {"step": 2, "steps_text": "LM 3914 equalizer I.C is used here to made the circuit.", "step_imgs": ["https://cdn.instructables.com/FXC/8S4Q/IBW27IW0/FXC8S4QIBW27IW0.LARGE.jpg", "https://cdn.instructables.com/F3D/HY9X/IBW27IW4/F3DHY9XIBW27IW4.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram"}, {"step": 3, "steps_text": "these are the pics showing lighting variations at different audio intensities.", "step_imgs": ["https://cdn.instructables.com/FQW/1HKP/IBW27IVQ/FQW1HKPIBW27IVQ.LARGE.jpg", "https://cdn.instructables.com/F6Q/M1RK/IBW27IVZ/F6QM1RKIBW27IVZ.LARGE.jpg", "https://cdn.instructables.com/FS2/GL8K/IBW27IVW/FS2GL8KIBW27IVW.LARGE.jpg", "https://cdn.instructables.com/FQX/ZGDQ/IBW27IW2/FQXZGDQIBW27IW2.LARGE.jpg", "https://cdn.instructables.com/F6E/DFPS/IBW27IVU/F6EDFPSIBW27IVU.LARGE.jpg", "https://cdn.instructables.com/FVP/81NB/IBW27IVS/FVP81NBIBW27IVS.LARGE.jpg", "https://cdn.instructables.com/FVQ/EGX6/IBW27IW3/FVQEGX6IBW27IW3.LARGE.jpg"], "step_title": "Step 3: Photos "}, {"step": 4, "steps_text": "", "step_imgs": [], "step_title": "Step 4: "}], "channel": "LEDs"}, {"category": "technology", "description": "It is a simple time pass project.. All of you can make on your ceiling fan. the led lights are attached on the leaves of the fan. the lights will glow with respect to the audio source attached to it.", "title": "Equalizer Light on FAN ", "url": "https://www.instructables.com/id/Equalizer-Light-On-FAN/", "section": "technology", "steps": [{"step": 1, "steps_text": "to feed the external power and audio input. use/make slip rings on the fans neck.", "step_imgs": ["https://cdn.instructables.com/FAM/GWKT/IBW27IW9/FAMGWKTIBW27IW9.LARGE.jpg", "https://cdn.instructables.com/FZR/426R/IBW27IW6/FZR426RIBW27IW6.LARGE.jpg"], "step_title": "Step 1: Slip Rings on Fan"}, {"step": 2, "steps_text": "LM 3914 equalizer I.C is used here to made the circuit.", "step_imgs": ["https://cdn.instructables.com/FXC/8S4Q/IBW27IW0/FXC8S4QIBW27IW0.LARGE.jpg", "https://cdn.instructables.com/F3D/HY9X/IBW27IW4/F3DHY9XIBW27IW4.LARGE.jpg"], "step_title": "Step 2: Circuit Diagram"}, {"step": 3, "steps_text": "these are the pics showing lighting variations at different audio intensities.", "step_imgs": ["https://cdn.instructables.com/FQW/1HKP/IBW27IVQ/FQW1HKPIBW27IVQ.LARGE.jpg", "https://cdn.instructables.com/F6Q/M1RK/IBW27IVZ/F6QM1RKIBW27IVZ.LARGE.jpg", "https://cdn.instructables.com/FS2/GL8K/IBW27IVW/FS2GL8KIBW27IVW.LARGE.jpg", "https://cdn.instructables.com/FQX/ZGDQ/IBW27IW2/FQXZGDQIBW27IW2.LARGE.jpg", "https://cdn.instructables.com/F6E/DFPS/IBW27IVU/F6EDFPSIBW27IVU.LARGE.jpg", "https://cdn.instructables.com/FVP/81NB/IBW27IVS/FVP81NBIBW27IVS.LARGE.jpg", "https://cdn.instructables.com/FVQ/EGX6/IBW27IW3/FVQEGX6IBW27IW3.LARGE.jpg"], "step_title": "Step 3: Photos "}, {"step": 4, "steps_text": "", "step_imgs": [], "step_title": "Step 4: "}], "channel": "LEDs"}, {"category": "technology", "description": "WARNING: this project involves the use and modification of laser devices. While the lasers I suggest using (store-bought red pointers) are relatively safe to handle, NEVER LOOK DIRECTLY INTO A LASER BEAM, BEWARE OF REFLECTIONS, and be EXTREMELY CAREFUL when MODIFYING a laser product. Also, I am not liable for anything stupid you do.Here is yet another thing to do with those promotional laser pointers: send music (or data) from point A to point B over the laser beam using amplitude modulation. All it takes is pointing the moded laser at a detector, and music can be heard from an attached amplifier. The range and quality (or data speed) can vary, but I have gotten a HALF MILE of range with excellent audio quality and around 300bps of throughput.The image shown here is the transmitter and receiver working across my desk during a test.TO SEE HOW TO USE TWO LASERS TO TRANSMIT TWO MUSIC CHANNELS AND MIX THEM WITH A PAIR OF SUNGLASSES, check out the blog post here.A video of the system working can be found here: http://video.google.com/videoplay?docid=6895048767032879458&hl=enMuch inspiration for this project came from http://sci-toys.com/scitoys/scitoys/light/light.html#laser_communicator", "title": "Send Music Over a Laser Beam", "url": "https://www.instructables.com/id/Send-Music-over-a-Laser-Beam/", "section": "technology", "steps": [{"step": 1, "steps_text": "To send music over a laser beam you will need the following parts, most of which can be gotten for less than 5 dollars at radioshack total (besides the pointer, which probably costs $15). If you are on a tight budget, try replacing the laser with a red LED and a 100ohm resistor attached in series.\rfor the transmitter:\r a laser pointer\r batteries (D-cell work best)\r potentiometer (variable resistor) 50k ohm or less\r audio source (iPod, cd player, mic preamp, PC line-out, etc.)\r some wire (cat5 aka ethernet cabling works best)\r toggle switch (a turbo switch from an old PC works well)\r audio transformer (can be pulled from audio equipment)\r 1/8\" audio jack (can be gotten from the end of a headphones cable)\rfor the reciever:\r phototransitor (photodiodes or IR detectors also work)\r 1/8\" audio jack\r some more wire\r high-gain amplifier (laptop with mic input, or mic preamp plus amplifier)\r magnifying glass (helps at great distances)\rtools:\r wire cutter/stripper\r soldering iron and electronics solder\r tape (clear and/or electrical)\r digital multimeter (can be useful... not realy required)\r tripod (helps for aiming laser at a distance)\r empty pizza boxes with white backs (for finding beam and for adjustments)\r some assistants", "step_imgs": ["https://cdn.instructables.com/F8A/9T9A/VLNEPLK0DMU/F8A9T9AVLNEPLK0DMU.LARGE.jpg"], "step_title": "Step 1: Gather Materials"}, {"step": 2, "steps_text": "First the laser pointer needs to be modified. Remove all bateries and total up the voltage of the batteries to find the voltage required by the laser. For instance, mine takes two AAA batteries, so that is 2 x 1.5 or 3 volts. Now solder wires on to the positive and negative terminals inside the laser. This might require cutting open the case a bit (a dremmel is sometimes nessisary).\rNext, figure out how to hold down the button on the pointer that makes it light. A shaved-down pencil eraser and a ruberband works for me.\rNow test the modified laser by connecting batteries of appropriate voltage to the newly attached wires. If it does't work, try connecting them in the opposite direction. Laser pointers use laser diodes which only take current in one direction.\rThis mod will allow us to control the brightness of the laser by varying the voltage and current supplied to it.\rIn the photo below you can see my pointer, with two D-cell batteries attached.", "step_imgs": ["https://cdn.instructables.com/F58/581S/FW2EPLK0DT7/F58581SFW2EPLK0DT7.LARGE.jpg"], "step_title": "Step 2: Hack the Laser"}, {"step": 3, "steps_text": "Use the schematic below as a guide in soldering togeather the transmitter circuit. Everything to the left of the laser is the transmitter circuit.\rTape or glue the compents down to a piece of cardboard, or use a breadboard.\rCheck out the photo of my finished board. I used an 1/8th inch female jack to make connections easier.\rTo test the circuit, turn up the iPod volume to MAX, play some music with alot of bass, and turn the potentiometer all the way down. The laser dot should appear to pulsate with the music, since this is an amplitude modulated (AM) circuit.", "step_imgs": ["https://cdn.instructables.com/F7H/VVQG/FJNEHRO1/F7HVVQGFJNEHRO1.LARGE.jpg", "https://cdn.instructables.com/FSR/CBOV/NM5EPLK0DVW/FSRCBOVNM5EPLK0DVW.LARGE.jpg", "https://cdn.instructables.com/FKK/623X/6YKEPLK0DZH/FKK623X6YKEPLK0DZH.LARGE.jpg", "https://cdn.instructables.com/FRC/S207/ILXEPLK0DXS/FRCS207ILXEPLK0DXS.LARGE.jpg", "https://cdn.instructables.com/FJJ/UQZ9/7W4EPLK0DQU/FJJUQZ97W4EPLK0DQU.LARGE.jpg"], "step_title": "Step 3: Create Transmitter Circuitry"}, {"step": 4, "steps_text": "Solder long leads onto the phototransistor (or photodiode). Attach these to an 1/8th inch audio jack (a headphones cable is perfect). Plug this into the MIC port on a laptop or PC or other MIC preamp/amp and turn up the gain and volume to a moderate level. Try to mount the whole setup (with room for a magnifying glass) on a sturdy but portable material (like a wooden board).\rFor this project the GAIN of the amplifier is critical. It must be very high to pick-up slight variations in input signal (light) to pull out the music. Therefore I build a breadboard preamp from RadioShack's 50-in-1 Sensor Lab breadboard kit, which I highly recommend. Check out the photos and schematics from the included book.", "step_imgs": ["https://cdn.instructables.com/F06/LJ6D/HL0EPH67K4F/F06LJ6DHL0EPH67K4F.LARGE.jpg", "https://cdn.instructables.com/FGF/8QNB/I8VEPLK0E8A/FGF8QNBI8VEPLK0E8A.LARGE.jpg", "https://cdn.instructables.com/FMA/ED1V/LL6EPLK0EAU/FMAED1VLL6EPLK0EAU.LARGE.jpg"], "step_title": "Step 4: Setup the Receiver"}, {"step": 5, "steps_text": "Point the laser beam at the photodiode, hit play on the iPod, and listen to any and all noises comming from the amp. Play with the iPod volume and potentiometer positions until music can be heard clearly and without distortion on the recieving side. Then turn up the reciever gain as nessisary.\r Try mounting the laser on a tripod and sending music a longer distance. I recently was able to hear Starway to Heaven clearly at a beam distance of a half mile. This was done over a small lake, with an assistant in a canue with a pizza box to help with the aiming.", "step_imgs": ["https://cdn.instructables.com/FDB/2DR7/N75EPLK0EEG/FDB2DR7N75EPLK0EEG.LARGE.jpg", "https://cdn.instructables.com/FJZ/UAL2/HNNEPLK0ED9/FJZUAL2HNNEPLK0ED9.LARGE.jpg"], "step_title": "Step 5: Give It a Try"}, {"step": 6, "steps_text": "This circuit works using amplitude modulation, exactly like AM radio, except using a visible light wavelength instead of a radio frequency. The audio signal leaves the iPod as a varying voltage which forces a varying current through the laser. Then the laser's varying brightness conveys the musical information. Finaly, the phototransistor varies in resistance as the brightness on it changes. The mic amp applies a small voltage to the phototransistor and amplifies the resulting current.\rA problem with this system is that at each step there is a non-linear transfer function, that is, there is distortion that occurs because the brightness changes are not always proportional to the change in voltage applied. See the screenshot below for an example, and listen to the attached audio sample.\rThe next step in this project would be to use pulses (like fast, computer operated morse code)  to convey digital information like text, crystal-clear audio, or even video. One could even network computers with laser beams in a manner similar to fiberoptics but in open air. I will post C code for my transmitting and recieving programs.", "step_imgs": ["https://cdn.instructables.com/F0L/JDDP/S61EPLK0EIH/F0LJDDPS61EPLK0EIH.LARGE.jpg", "https://cdn.instructables.com/F0C/TYPL/AUIEPLK0EHE/F0CTYPLAUIEPLK0EHE.LARGE.jpg", "https://cdn.instructables.com/FME/HXS2/XC9EPLK0EGB/FMEHXS2XC9EPLK0EGB.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: How Does That Work? and Where Do I Go From Here?"}], "channel": "Lasers"}, {"category": "outside", "description": "Backyard games like Cornhole are a lot of fun. But you can make them even better by adding lights and sounds. By hooking up some simple electronics, you can make the board light up and play a victory fanfare whenever someone scores. Here is how to make it. ", "title": "Add Light Up Effects to Backyard Games Like Cornhole", "url": "https://www.instructables.com/id/Add-Light-Up-Effects-to-Backyard-Games-Like-Cornho/", "section": "outside", "steps": [{"step": 1, "steps_text": "Here is a video walkthrough of the project. ", "step_imgs": [], "step_title": "Step 1: Watch the Video"}, {"step": 2, "steps_text": "Here are the materials and tools that you will need to complete this project:Materials:Arduino UnoArduino Wave Shield 2 x IRF510 POWER MOSFETBattery Powered Christmas LightsJumper Wires Laser PointerPhotoresistor 10 kohm ResistorAlligator ClipsTools:Soldering Iron and SolderWire CuttersWire StrippersScrewdriver Hot Glue Gun and Glue Sticks", "step_imgs": ["https://cdn.instructables.com/FAM/I4HX/IB7BB6YE/FAMI4HXIB7BB6YE.LARGE.jpg", "https://cdn.instructables.com/FBE/8AKN/IB7BB6YB/FBE8AKNIB7BB6YB.LARGE.jpg", "https://cdn.instructables.com/FH2/XTFX/IB7BC4SN/FH2XTFXIB7BC4SN.LARGE.jpg", "https://cdn.instructables.com/FAL/R3FB/IB7BB6YF/FALR3FBIB7BB6YF.LARGE.jpg", "https://cdn.instructables.com/FJE/JXK2/IB7BC4HV/FJEJXK2IB7BC4HV.LARGE.jpg", "https://cdn.instructables.com/FF9/5CKV/IB7BC6Z5/FF95CKVIB7BC6Z5.LARGE.jpg", "https://cdn.instructables.com/F07/U3DP/IB8IIV6P/F07U3DPIB8IIV6P.LARGE.jpg", "https://cdn.instructables.com/FJG/CC2V/IB8IIVFM/FJGCC2VIB8IIVFM.LARGE.jpg", "https://cdn.instructables.com/FRW/BOZW/IB8IFQ8L/FRWBOZWIB8IFQ8L.LARGE.jpg"], "step_title": "Step 2: Materials"}, {"step": 3, "steps_text": "To detect when someone scores, I am using a basic light sensing circuit. A laser pointer is set up on one side of the hole. On the other side of the hole, a light detector is positioned in line with the laser pointer. The light detector that I am using is a photoresistor that is wired in series with a 10 kohm fixed resistor. The 10 kohm resistor is connected to 5V and the photoresistor is connected to GND. The center pin between them is connected to an analog input pin on the arduino. When the light beam of the laser pointer is interrupted by the bag going through the hole, the voltage at the center pin goes up. This change in voltage is detected by the Arduino and the Arduino activates lights and sounds.", "step_imgs": ["https://cdn.instructables.com/FGW/EE6P/IB8IMINN/FGWEE6PIB8IMINN.LARGE.jpg", "https://cdn.instructables.com/FO9/T8Y4/IB8IMR4O/FO9T8Y4IB8IMR4O.LARGE.jpg"], "step_title": "Step 3: How the Sensor Works"}, {"step": 4, "steps_text": "I am powering the laser pointer from the Arduino. To do this, I took a pair of jumper wires and I attached alligator clips on the ends. The negative wire was attached to the spring inside the laser pointer. Then this wire was connected to GND. The positive wire was connected to the barrel of the laser pointer. This wire was then connected to 5V from the Arduino. To keep the laser pointer on, you can just wrap some tape around the barrel over the switch.", "step_imgs": ["https://cdn.instructables.com/FGS/AK53/IB8I8AGB/FGSAK53IB8I8AGB.LARGE.jpg", "https://cdn.instructables.com/FIT/VP67/IB8I8AGA/FITVP67IB8I8AGA.LARGE.jpg", "https://cdn.instructables.com/FRQ/Y639/IB8I8AGC/FRQY639IB8I8AGC.LARGE.jpg", "https://cdn.instructables.com/FXU/DR69/IB8I8AGD/FXUDR69IB8I8AGD.LARGE.jpg", "https://cdn.instructables.com/F1K/LESJ/IB8I8AGE/F1KLESJIB8I8AGE.LARGE.jpg", "https://cdn.instructables.com/FEH/8PJ3/IB8I8AIT/FEH8PJ3IB8I8AIT.LARGE.jpg", "https://cdn.instructables.com/F07/RHAB/IB8I9KOJ/F07RHABIB8I9KOJ.LARGE.jpg"], "step_title": "Step 4: Connect the Arduino to the Laser Pointer"}, {"step": 5, "steps_text": "The center pin of the sensor needs to be connected to one of the analog input pins. In this project, I am using the Adafruit wave shield to add sound effects. So I first attached the wave shield to the Arduino. Then I used a jumper wire with a female header pin connector to connect to the top of the wave shield.", "step_imgs": ["https://cdn.instructables.com/F20/OH0K/IB8IMXG6/F20OH0KIB8IMXG6.LARGE.jpg", "https://cdn.instructables.com/FA9/CN4B/IB8IMOJ8/FA9CN4BIB8IMOJ8.LARGE.jpg", "https://cdn.instructables.com/FXW/QCQJ/IB8IMOJ5/FXWQCQJIB8IMOJ5.LARGE.jpg"], "step_title": "Step 5: Connecting the Sensor to the Arduino"}, {"step": 6, "steps_text": "The lights require more power than Arduino can output. So we need to use an external power source. I decided to use two strings of battery powered LED lights. To turn the lights on and off, I am using a pair of IRF510 power MOSFETs. The gate of the MOSFET is connected to digital pin 6 on the wave shield. The source pin of the MOSFET is connected to the GND pin on the wave shield. The source pin of the MOSFET is also connected to the negative terminal of the light's battery pack. The Drain pin of the MOSFET is connected to the spring of the battery holder. These are separated  and insulated from each other by inserting a piece of card stock between them. With this card in place, the light circuit can only be completed through the transistor. When a HIGH signal is sent from the Arduino to the Gate pin, the transistor connects the battery to the LEDs and the lights turn on. ", "step_imgs": ["https://cdn.instructables.com/F54/9OIL/IB8I8QSO/F549OILIB8I8QSO.LARGE.jpg", "https://cdn.instructables.com/FTF/LTW9/IB8I8VO1/FTFLTW9IB8I8VO1.LARGE.jpg", "https://cdn.instructables.com/F9E/REHZ/IB8I8A4L/F9EREHZIB8I8A4L.LARGE.jpg", "https://cdn.instructables.com/FG6/V4KO/IB8I8A4N/FG6V4KOIB8I8A4N.LARGE.jpg"], "step_title": "Step 6: Connect the Arduino to the Lights"}, {"step": 7, "steps_text": "// Here is a copy of the code that I used for this project. You can copy and paste it into a new sketch or download the code file. #include #include \n#include \n#include \"WaveUtil.h\"\n#include \"WaveHC.h\"SdReader card;    // This object holds the information for the card\nFatVolume vol;    // This holds the information for the partition on the card\nFatReader root;   // This holds the information for the filesystem on the card\nFatReader f;      // This holds the information for the file we're playWaveHC wave;      // This is the only wave (audio) object, since we will only play one at a time#define DEBOUNCE 100  // button debouncerint ledPin = 6; // this handy function will return the number of bytes currently free in RAM, great for debugging!   \nint freeRam(void)\n{\n  extern int  __bss_end; \n  extern int  *__brkval; \n  int free_memory; \n  if((int)__brkval == 0) {\n    free_memory = ((int)&free_memory) - ((int)&__bss_end); \n  }\n  else {\n    free_memory = ((int)&free_memory) - ((int)__brkval); \n  }\n  return free_memory; \n} void sdErrorCheck(void)\n{\n  if (!card.errorCode()) return;\n  putstring(\"\\n\\rSD I/O error: \");\n  Serial.print(card.errorCode(), HEX);\n  putstring(\", \");\n  Serial.println(card.errorData(), HEX);\n  while(1);\n}//<------------------------------------------------------------------------------ Void Setup\nvoid setup() {\n  // set up serial port\n  Serial.begin(9600);\n  putstring_nl(\"WaveHC with 6 buttons\");\n  \n   putstring(\"Free RAM: \");       // This can help with debugging, running out of RAM is bad\n  Serial.println(freeRam());      // if this is under 150 bytes it may spell trouble!\n  \n  // Set the output pins for the DAC control. This pins are defined in the library\n  pinMode(13, OUTPUT); \n  //  if (!card.init(true)) { //play with 4 MHz spi if 8MHz isn't working for you\n  if (!card.init()) {         //play with 8 MHz spi (default faster!)  \n    putstring_nl(\"Card init. failed!\");  // Something went wrong, lets print out why\n    sdErrorCheck();\n    while(1);                            // then 'halt' - do nothing!\n  }\n  \n  // enable optimize read - some cards may timeout. Disable if you're having problems\n  card.partialBlockRead(true);\n \n// Now we will look for a FAT partition!\n  uint8_t part;\n  for (part = 0; part < 5; part++) {     // we have up to 5 slots to look in\n    if (vol.init(card, part)) \n      break;                             // we found one, lets bail\n  }\n  if (part == 5) {                       // if we ended up not finding one  :(\n    putstring_nl(\"No valid FAT partition!\");\n    sdErrorCheck();      // Something went wrong, lets print out why\n    while(1);                            // then 'halt' - do nothing!\n  }\n  \n  // Lets tell the user about what we found\n  putstring(\"Using partition \");\n  Serial.print(part, DEC);\n  putstring(\", type is FAT\");\n  Serial.println(vol.fatType(),DEC);     // FAT16 or FAT32?\n  \n  // Try to open the root directory\n  if (!root.openRoot(vol)) {\n    putstring_nl(\"Can't open root dir!\"); // Something went wrong,\n    while(1);                             // then 'halt' - do nothing!\n  }\n  \n  // Whew! We got past the tough parts.\n  putstring_nl(\"Ready!\");pinMode(ledPin, OUTPUT); \n}//<------------------------------------------------------------------------------------- Void Loopvoid loop() {\n//putstring(\".\");    // uncomment this to see if the loop isnt runningint sensorValue = 0;       \nint sensorPin = 5;\nint sensorThreshold = 200;sensorValue = analogRead(sensorPin);    // read the input pinSerial.println(sensorValue);             // debug valueif(sensorValue > sensorThreshold)\n{\n  Serial.println(\"Play Sounds and Lights\");\n  \n  digitalWrite(ledPin, HIGH);   // sets the LED on\n  playcomplete(\"1.WAV\");\n  digitalWrite(ledPin, LOW);    // sets the LED off\n  delay(500);}\n}// Plays a full file from beginning to end with no pause.\nvoid playcomplete(char *name) {\n  // call our helper to find and play this name\n  playfile(name);\n  while (wave.isplaying) {\n  // do nothing while its playing\n  }\n  // now its done playing\n}void playfile(char *name) {\n  // see if the wave object is currently doing something\n  if (wave.isplaying) {// already playing something, so stop it!\n    wave.stop(); // stop it\n  }\n  // look in the root directory and open the file\n  if (!f.open(root, name)) {\n    putstring(\"Couldn't open file \"); Serial.print(name); return;\n  }\n  // OK read the file and turn it into a wave object\n  if (!wave.create(f)) {\n    putstring_nl(\"Not a valid WAV\"); return;\n  }\n  \n  // ok time to play! start playback\n  wave.play();\n}", "step_imgs": ["https://cdn.instructables.com/FZW/SUUU/IBAA9L8Q/FZWSUUUIBAA9L8Q.LARGE.jpg"], "step_title": "Step 7: The Arduino Code"}, {"step": 8, "steps_text": "It is always a good idea to prototype a new circuit on a breadboard before soldering it together. This give you a chance to make any necessary changes before everything is soldered in place. ", "step_imgs": ["https://cdn.instructables.com/F9X/MR5H/IB8IIVPM/F9XMR5HIB8IIVPM.LARGE.jpg", "https://cdn.instructables.com/FIQ/SJQ1/IB8IIVPP/FIQSJQ1IB8IIVPP.LARGE.jpg", "https://cdn.instructables.com/F4C/6QYR/IB8IIVPS/F4C6QYRIB8IIVPS.LARGE.jpg", "https://cdn.instructables.com/FYU/HVI0/IB8IIVPT/FYUHVI0IB8IIVPT.LARGE.jpg", "https://cdn.instructables.com/FCN/Y3B4/IB8IIVPW/FCNY3B4IB8IIVPW.LARGE.jpg"], "step_title": "Step 8: Prototype the Circuit on a Breadboard"}, {"step": 9, "steps_text": "Once everything is working properly, you can solder all the parts onto a printed circuit board or a piece of perf board. ", "step_imgs": ["https://cdn.instructables.com/FRC/BJUC/IB8IIVQ4/FRCBJUCIB8IIVQ4.LARGE.jpg", "https://cdn.instructables.com/FDH/F1B6/IB8IIVQ2/FDHF1B6IB8IIVQ2.LARGE.jpg", "https://cdn.instructables.com/F8Z/WL8G/IB8IIVV8/F8ZWL8GIB8IIVV8.LARGE.jpg", "https://cdn.instructables.com/FEA/I2OK/IB8IIVVU/FEAI2OKIB8IIVVU.LARGE.jpg", "https://cdn.instructables.com/F6L/D8SJ/IB8IIVX2/F6LD8SJIB8IIVX2.LARGE.jpg", "https://cdn.instructables.com/FZ7/ZH5V/IB8IIVPZ/FZ7ZH5VIB8IIVPZ.LARGE.jpg"], "step_title": "Step 9: Solder the Circuit Onto a Perf Board"}, {"step": 10, "steps_text": "If you want your game to play sounds, you can add a Wave Shield to your Arduino. This will let it play audio files. This shield may be purchased as a kit from Adafruit or fully assembled from the MakerShed. If you choose to assemble it from the kit, you can get detailed instructions from the Adafruit website. For this project, one additional wire needs to be soldered to digital pin 6 to allow it to activate the lights.Once you have an assembled wave shield, you need to download the WaveHC library. You can download a copy from the author's website here or you can just download the zip file attached to this step. Download the zip file. Then unzip/extract the files. Copy the WaveHC folder into the libraries directory of your Arduino program folder. You can find a detailed tutorial on the library and how to use it here.", "step_imgs": ["https://cdn.instructables.com/F07/ALI7/IB7BC3OQ/F07ALI7IB7BC3OQ.LARGE.jpg", "https://cdn.instructables.com/FR1/HGIN/IB7BC40O/FR1HGINIB7BC40O.LARGE.jpg", "https://cdn.instructables.com/FU8/MY1D/IB7BC40P/FU8MY1DIB7BC40P.LARGE.jpg", "https://cdn.instructables.com/FVZ/CEF0/IB7BC3V4/FVZCEF0IB7BC3V4.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 10: Set Up the Wave Shield "}, {"step": 11, "steps_text": "The Wave shield can only play audio files in the .WAV format. So if your sound recorder saves the files in a different format, you will need to convert them to .WAV.If you have itunes you can use this tutorial to convert them: https://learn.adafruit.com/adafruit-wave-shield-audio-shield-for-arduino/convert-files. You can also use online file converters such as this one: http://audio.online-convert.com/convert-to-wav. Regardless of which program you use, you need to convert the file to the .wav type. The bit resolution should be set to \"16 bit\". The sampling rate should be set to 22050 Hz (or 22.050 kHz). The audio channels should be set to \"Mono.\"For simplicity, I changed my audio file to 1.wav. If you use this file name you will not need to modify the code. Then just load the files onto an SD card and insert it into the wave shield. ", "step_imgs": ["https://cdn.instructables.com/FQB/2R2G/IB8I9XZY/FQB2R2GIB8I9XZY.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 11: Convert the Audio Files to the .WAV Format "}, {"step": 12, "steps_text": "Now you need to attach the laser pointer and the light sensor to the game board. To do this, I just used hot glue to stick the parts to the under side of the board. Just make sure that the light sensor is perfectly lined up with the beam of the laser pointer.", "step_imgs": ["https://cdn.instructables.com/FA8/2MYV/IB8IDXNO/FA82MYVIB8IDXNO.LARGE.jpg", "https://cdn.instructables.com/FSK/CG3W/IB8IDXQB/FSKCG3WIB8IDXQB.LARGE.jpg", "https://cdn.instructables.com/FI8/E5VA/IB8IDXQC/FI8E5VAIB8IDXQC.LARGE.jpg", "https://cdn.instructables.com/F4W/6N6N/IB8IDXQ4/F4W6N6NIB8IDXQ4.LARGE.jpg", "https://cdn.instructables.com/F2R/B4XY/IB8IDXQ8/F2RB4XYIB8IDXQ8.LARGE.jpg"], "step_title": "Step 12: Attach the Light Sensor Circuit to the Game Board"}, {"step": 13, "steps_text": "To secure the rest of the parts just hot glue them to the underside of the board. To help protect the Arduino, I put that inside a plastic project enclosure. ", "step_imgs": ["https://cdn.instructables.com/F7R/WZV3/IBAA9MLY/F7RWZV3IBAA9MLY.LARGE.jpg", "https://cdn.instructables.com/FEV/5LU7/IB8IC1WN/FEV5LU7IB8IC1WN.LARGE.jpg", "https://cdn.instructables.com/FSL/RTX7/IB8IC2SH/FSLRTX7IB8IC2SH.LARGE.jpg"], "step_title": "Step 13: Attach the Rest of the Parts to the Inside of the Game Board"}, {"step": 14, "steps_text": "The last thing to do is to glue all the LEDs in place. I used hot glue to mount one string of LEDs around the inside of the hole. Then I mounted the second string of lights around that inside the box. ", "step_imgs": ["https://cdn.instructables.com/F2Y/2TQL/IB8IF84Z/F2Y2TQLIB8IF84Z.LARGE.jpg", "https://cdn.instructables.com/FGE/JAAU/IBAA9MS1/FGEJAAUIBAA9MS1.LARGE.jpg", "https://cdn.instructables.com/FFQ/5FVY/IB8IF86T/FFQ5FVYIB8IF86T.LARGE.jpg", "https://cdn.instructables.com/FWA/DDYG/IBAA9MSH/FWADDYGIBAA9MSH.LARGE.jpg"], "step_title": "Step 14: Glue the LEDs in Place"}, {"step": 15, "steps_text": "Now all you have to do is turn on the power and try it out. Wave your hand in front of the beam. The lights should turn on and the sounds should play. ", "step_imgs": ["https://cdn.instructables.com/FRY/HG6B/IB8IF888/FRYHG6BIB8IF888.LARGE.jpg", "https://cdn.instructables.com/FEW/QDFN/IB8IF885/FEWQDFNIB8IF885.LARGE.jpg"], "step_title": "Step 15: Test It"}, {"step": 16, "steps_text": "Now you are ready to play a game. Whenever you toss a bag into the hole, it will interrupt the beam from the laser pointer. Then the lights and sounds will play. I did this with a basic cornhole board. But you can make this work with lots of different games. For instance you could make this same setup with a basketball goal. Try it out and have fun.", "step_imgs": ["https://cdn.instructables.com/FEZ/JW8V/IBAA9OY8/FEZJW8VIBAA9OY8.LARGE.jpg", "https://cdn.instructables.com/FMB/3IKK/IBAA9OYQ/FMB3IKKIBAA9OYQ.LARGE.jpg", "https://cdn.instructables.com/F6U/MKOO/IBAA9OYB/F6UMKOOIBAA9OYB.LARGE.jpg", "https://cdn.instructables.com/FD1/I6DX/IBAA9OWU/FD1I6DXIBAA9OWU.LARGE.jpg"], "step_title": "Step 16: Use Your Light Up Game Board"}], "channel": "Backyard"}, {"category": "technology", "description": "A little backgroundAcoustic beam forming is the process used to concentrate or cancel out sound at certain points by changing the phase and amplitude of sound waves being emitted from multiple sources. In simple terms, that means that we can play sounds from two speakers and control those speakers electronically so that the sound cancels out at a certain point in a room. Not only that, we can move the point of cancellation around without ever physically moving our speakers! If that sounds cool to you, read on to see how to this works, or skip to step 5 to jump to the instructions right away and find out how to build your own acoustic beam forming circuit.  If you want the really nitty gritty details of the math, click here to find out more!", "title": "Acoustic Beam Forming Circuit", "url": "https://www.instructables.com/id/Acoustic-Beam-Forming-Circuit/", "section": "technology", "steps": [{"step": 1, "steps_text": "Feel free to skip to ahead to section 5 if you want to get building. Here we'll get into the principles behind acoustic beam forming. What's going on in the diagram above? There are two speakers that we placed in the same room, speaker 1 and speaker 2. Speaker 1 and speaker 2 are playing the same periodic sound with the same frequency. (Periodic just means that the sound being played is repeated, and the frequency is the number of times that the repeated section is played, per second.) In this case, both speakers are playing a sine wave with the same wavelength, denoted as lambda. (If the speakers are playing a sound with the same frequency, the sound has the same wavelength as well. Frequency and wavelength are inversely proportional to each other.)    The circles in this diagram indicate how far away locations are from either speaker. If you stand along the red circle that is labeled .5 lambda, or .5 wavelengths away from speaker 1, sounds from speaker 1 will have to travel .5 lambda meters to get to you. I could have drawn infinitely many of these circles to represent 2 lambda, 2.5 lambda, and so on, but only drew a few in here. You'll have to imagine the rest! Now something really interesting happens where blue and red circles intersect. I marked those intersections in green, with green dots showing the places where constructive interference happens, and green X's showing the places where destructive interference occurs. Fancy sounding terms, but all I'm really saying is that if somebody stood at one of the spots marked by the green dots, they would hear the sound waves from the two speakers combining to form a really loud sound, and if somebody stood at one of the spots marked by the green X's, they would hear the sound waves from the two speakers combining to cancel out. Let's take a closer look and see what's happening at point A and point B.  ", "step_imgs": ["https://cdn.instructables.com/FK4/W6QH/I92LTFWU/FK4W6QHI92LTFWU.LARGE.jpg"], "step_title": "Step 1: How Does It Work? (Part 1)"}, {"step": 2, "steps_text": "At point A in the previous diagram, there's a green dot, so according to me, constructive interference is happening and things get real loud for anybody standing there. Why is that? Well, let's see. Point A is 1 wavelength away from speaker 1, and 1 wavelength away from speaker 2. Imagine that our heroine, Angela, is standing at point A. She's just as far from speaker 1 as she is from speaker 2, so sounds from either speaker take the same amount of time to travel to her ear. Since that's the case, there is zero phase offset between the two sound waves when they arrive at Angela's ear. You can think of phase offset as how much one sound signal is shifted off of the other sound signal in time. By the way, phase offset is measured in degrees or radians, since it's a circular measurement. Why is that? Remember that we're working with periodic signals, so if you shift a signal like a sine wave far enough in one direction (by 2 pi radians, to be exact), you end up with the same signal again!Since there's no phase offset between the two sound signals, Angela hears them adding up together to make one big fat sine wave with a large amplitude. You can see that in the diagram above.      ", "step_imgs": ["https://cdn.instructables.com/F6E/3PP8/I92LTFRF/F6E3PP8I92LTFRF.LARGE.jpg"], "step_title": "Step 2: How Does It Work? (Part 2)"}, {"step": 3, "steps_text": "Not too surprising or impressive so far- so two speakers add up together to be loud. What's more interesting is what goes on at point B, where our hero Bobby is standing. Point B is 1 wave length away from speaker 1 and 1.5 wavelengths away from speaker 2, so the signal from speaker 1 gets to Bobby's ear before the signal from speaker 2. Since Bobby hears speaker 2 just a tiny bit later, there is a phase offset between the two signals that are combining to make the one sound that Bobby is perceiving. The phase offset that corresponds to the sound wave having to travel an additional .5 lambda meters to get to his ear is 1 pi radians. This means that the sine wave from speaker 2 is offset from the sine wave from speaker 1 by half a period, and the two waves add destructively to make it so that Bobby hears nothing! Well, almost nothing. In practice, sound waves will be redirected and bounced off a whole bunch of things before getting to your ear, and the sound waves from speakers 1 and 2 almost certainly wouldn't be the same amplitude when they got to you, so perfect cancellation doesn't happen in the real world. Plus, people have two ears, not one! But even in real life, Angela would probably yell to Bobby that she couldn't hear anything over the awful noise, and Bobby would be confused since he was barely hearing anything from the two speakers.  ", "step_imgs": ["https://cdn.instructables.com/F6P/7BM3/I92LTFWW/F6P7BM3I92LTFWW.LARGE.jpg"], "step_title": "Step 3: How Does It Work? (Part 3)"}, {"step": 4, "steps_text": "Everything I just described happens naturally without you having to do anything. Set up two large speakers playing the same periodic sound, wander around, and if you listen carefully, you can probably find the points of constructive and destructive interference.  But let's say we want to play an elaborate prank on Bobby, where no matter where he wanders in the room, he hears almost nothing coming out of the two speakers, while everybody else in the room complains about how loud it is. If we always knew where Bobby was standing, we could add a phase offset between the two signals before they're played in order to make them interfere destructively when they do reach Bobby's ears! Now one speaker plays a sin wave with frequency w, [sin(wt)], and the other speaker plays a sin wave with the same frequency w and a dynamically changing offset, [sin(wt+phi(t))]. To find out what phase offset is needed at any time, we plant a little microphone on Bobby that tells us how we should adjust the phase offset based on the volume of the sound received.That's the basic idea behind beam formation- tweak the phase offset between the signals being played on multiple speakers, and we can cause sound waves to constructively or destructively interfere at points of our choosing. Constantly tweak that phase offset, and we can confuse Bobby as he walks around the room. In the rest of this Instructable, we'll show you how to build a small circuit that demonstrates beam formation.", "step_imgs": [], "step_title": "Step 4: How Does It Work? (Part 4)"}, {"step": 5, "steps_text": "The oscillators 1x breadboard2x speakers2x OPA551 operational amplifiers6x 10K potentiometers (adjustable resistors)2x 1uF capacitors1x 4.99K resistorThe controller1x breadboard1x speaker (backdriven to act as a microphone)2x TLO81 operational amplifiers2x 200K resistors2x 1K resistors2x 1nF cpacitorsToolsOscilloscopeWire strippers, wires", "step_imgs": [], "step_title": "Step 5: What You'll Need"}, {"step": 6, "steps_text": "We will drive our two speakers with square waves generated by two hysteretic oscillators. The signals are not sine waves like in the previous examples explaining beam formation, but they are periodic signals, so constructive and destructive interference will work just fine.Build the circuit following the diagram above, you can disregard the 4.99 K resistor in the bottom circuit for now. Make sure to use the OPA551s or an op amp with similar current sourcing capabilities and operating voltages, otherwise you won't have enough power to drive the speakers. Supply the op amps with -12V and 12V.Once you've built the circuit, adjusting the potentiometers connected to the inverting and non inverting inputs of an op amp will adjust the frequency of the square wave generated. Adjusting the potentiometer connected to the speaker will change the volume of the speaker. Make sure to build the two oscillator circuits on the same board! Parasitic capacitance will cause the oscillators to sync up with each other and lock together, making it easier for you to tune the two oscillators to generate the same frequency signals. The second image above shows the measurement of the outputs of the oscillators (the oscilliscope is measuring voltage at the output of the two op amps). In the image, the square waves are the same frequency and are locked together out of phase. You will be able to clearly hear this locking occur once you've tuned the two oscillators to be the same frequency. Try to do so to test your oscillators.", "step_imgs": ["https://cdn.instructables.com/FEB/AOM3/I92LX18G/FEBAOM3I92LX18G.LARGE.jpg", "https://cdn.instructables.com/F1U/9OEU/I92LU62R/F1U9OEUI92LU62R.LARGE.jpg"], "step_title": "Step 6: Building the Oscillators"}, {"step": 7, "steps_text": "To build the controller, grab another breadboard and follow the circuit diagram above. The controller simplify amplifies the received microphone signal with two stages, each with a gain of 200. The capacitors act as high pass filters that center voltages, so that our measurements remain centered at zero.For the backdriven speaker in this circuit, try to use a speaker that is of similar shape and size as compared to the two speakers that will be playing the sound. Power the TLOs between -12V and 12V. To test if it's working, scope at the output of the second capacitor, you should see an amplified microphone (the backdriven speaker acts as the microphone) signal. It should be very sensitive, and will pick up conversation and sounds from a few feet away.", "step_imgs": ["https://cdn.instructables.com/FI6/LQKF/I92LUHZ4/FI6LQKFI92LUHZ4.LARGE.jpg"], "step_title": "Step 7: Building a Controller"}, {"step": 8, "steps_text": "Hook up the oscillators and controllers with the control wire in the diagram shown above, and you should start seeing destructive interference wherever the microphone (backdriven speaker) is! For our demonstration, we tuned the oscillators to generate 2KHz square waves, and the control worked as long as the controller was kept within the range of a foot or two. You should see that moving the controller will slowly shift the phase offset between the generated square waves if you scope at the outputs of the oscillators. Take a look at the demo video to see it all in action! It may be hard for your ears to distinguish the destructive interference near the microphone, but oscilloscopes don't lie! You should see that the amplitude of the received microphone signal is real small once you hook up the control wire, due to destructive interference. If you scaled up this system and used larger speakers, a more sensitive microphone, and a lower frequency signal with a longer wavelength, you could make much larger areas of a room noticeably quieter using the same techniques! We'll leave that as something for you to explore because we wanted this Instructable to be cheap and relatively easy.   ", "step_imgs": ["https://cdn.instructables.com/FGN/YT29/I92LX185/FGNYT29I92LX185.LARGE.jpg"], "step_title": "Step 8: Hooking It All Together"}, {"step": 9, "steps_text": "Wait a second! You told me that we were controlling phase to achieve beam formation, but aren't you tuning frequency with your controller?Yep! That's exactly right! Ideally, we'd have a oscillator whose phase is directly controlled by a voltage since it'd make this system easier to analyze, but those aren't as common or as easy to build as the oscillator we used, where frequency is directly controlled by an input voltage. Since phase is the integral of frequency, we are indirectly tuning the phase by tuning the frequency. You're tuning phase, but wouldn't you really need to tune amplitude as well to achieve sound cancellation?Yes! Beam formation systems that are far more sophisticated than the one we built will tune the amplitude of the waves as well to ensure destructive or constructive interference at a point. By only tuning phase, we are assuming that the amplitude of the sound waves will be the same or close at most points. In reality, if you're close to one speaker and far away from another, by the time the sound gets to you from the far away speaker, it will have a smaller amplitude, and the circuit that we built does not compensate for that.  How does the controller work? It seems like you're just amplifying the received signal, shoving that back into the system, and magically getting destructive interference at the microphone.Controls is pretty magical, but we've done our best to analyze parts of our system here:http://nbviewer.ipython.org/github/mbocamazo/ThinkDSP/blob/master/code/SigSys_CntrlAcstcIntfr.pdfWho wrote this Instructable?Never thought you'd ask! We're Dennis Chen & Michael Bocamazo, students from Olin College who created this as a final project for our Spring 2015 Signals and Systems Class.", "step_imgs": [], "step_title": "Step 9: FAQ + More Info"}], "channel": "Electronics"}, {"category": "technology", "description": "In this tutorial I will show you how to do a PWM (Pulse Width Modulation) on an LED using the Linkit One Board.", "title": "Linkit One: PWM LED", "url": "https://www.instructables.com/id/Linkit-One-PWM-LED/", "section": "technology", "steps": [{"step": 1, "steps_text": "For this tutorial we will simply use one LED, any color is OK. Put the Long feet of the LED to Pin 9 on Linkit ONE and the Short one to GND Pin.Plug the board to computer and open Arduino IDE, then open the Fading examples code just like in the picture", "step_imgs": ["https://cdn.instructables.com/FPY/ORXK/IG6RTV2T/FPYORXKIG6RTV2T.LARGE.jpg"], "step_title": "Step 1: Setup"}, {"step": 2, "steps_text": "Once the fading code is open, upload the code to the linkit one board.when its done you will see the LED start to fade and then turn back on again on a loop.This PWM tutorial is a basic example for PWM. PWM also could be use to control a servo. I will show it you in the next tutorial.", "step_imgs": ["https://cdn.instructables.com/F9S/ZAJX/IG6RTV02/F9SZAJXIG6RTV02.LARGE.jpg"], "step_title": "Step 2: Upload the Code and Profit"}], "channel": "Arduino"}, {"category": "technology", "description": "This digital sine wave keyboard synthesizer will take user inputs via a series of momentary switches laid out like a keyboard and output an audio wave through a speaker. Based on user inputs, the device will generate sine waves of various frequencies from C4 to C6. The user can input notes from C4 up to C6 (25 notes total), and up to four keys at the same time -- if more than four keys are pressed, the four lowest tones will be played.This project was done by Ryan Morris and Mavis Tsoi for our Cal Poly CPE 133 Digital Design class :)", "title": "Basys3 FPGA Digital Audio Synthesizer", "url": "https://www.instructables.com/id/Basys3-FPGA-Digital-Audio-Synthesizer/", "section": "technology", "steps": [{"step": 1, "steps_text": "An FPGA board can only output digital signals. In other words, it can only produce a high (3.3V) voltage or a low (0V) voltage. However, audio signals are analog and can have infinitely many increments in voltage. To get around this, we will use a PWM (pulse width modulation) signal to emulate an analog wave. If you don\u2019t know what PWM is, check this out: https://learn.sparkfun.com/tutorials/pulse-width-modulation.", "step_imgs": [], "step_title": "Step 1: Theory"}, {"step": 2, "steps_text": "Computer with Vivado installed  We will be using Vivado version 2017.2   Basys3 FPGA Board   25 SPDT Limit Switches (we used these)30 jumper wires (one end male, other end doesn\u2019t matter), 12 inchWire cutters Wire strippers Spare wire for soldering   Resin-core Solder   Soldering iron\u00bc\u201d female audio jack   Amplifier/speaker   Something to mount the switches on (we used protoboard + wooden box)", "step_imgs": [], "step_title": "Step 2: Ingredients & Tools"}, {"step": 3, "steps_text": "System ArchitectureSee Figure 1: 25 available inputs \u2192 Basys3 Board \u2192 amplifier & speaker.OutputSee Figure 2: Basys3 Board \u2192 1/2\" Female Audio Jack \u2192 Speaker (with Amplifier)InputThe pmod connections on the Basys3 board must be connected to ground in order to see a low input and will not function properly if left as an open circuit. Because of this, we have to use SPDT switches for all of our note keys. An SPDT switch basically allows the user to switch between circuits when pressed, so we will use them as our \u201cbuttons\u201d to input low (0V) or high (3.3V) signals to the Basys3 board. Each switch will have the NO (normally opened) terminal connected to 3.3V, NC (normally closed) terminal connected to GND, and COM (common) terminal connected to the FPGA input. See Figure 3.Because we have 25 limit switches, they will all share a common 3.3V line and a common GND line. Then, the signal line from each limit switch will be bundled up in groups of 8 and hooked up to the pmod connections on the Basys3 board using zippable jumper wires to minimize the monumental mess we\u2019ll make. See Figure 4 or an example of the first eight keys.", "step_imgs": ["https://cdn.instructables.com/F9I/1BS9/JAMTQKO0/F9I1BS9JAMTQKO0.LARGE.jpg", "https://cdn.instructables.com/FL8/GH72/JAMTQKO1/FL8GH72JAMTQKO1.LARGE.jpg", "https://cdn.instructables.com/F2F/94Q1/JAMTQKNZ/F2F94Q1JAMTQKNZ.LARGE.jpg", "https://cdn.instructables.com/FFH/1EX3/JAMTQKP8/FFH1EX3JAMTQKP8.LARGE.jpg", "https://cdn.instructables.com/FFD/2HJF/JAMTQLDI/FFD2HJFJAMTQLDI.LARGE.jpg", "https://cdn.instructables.com/F68/WYUJ/JAMTQLDH/F68WYUJJAMTQLDH.LARGE.jpg", "https://cdn.instructables.com/FRN/UNDK/JAMTQLDD/FRNUNDKJAMTQLDD.LARGE.jpg", "https://cdn.instructables.com/F1G/2NIU/JAMTWIZY/F1G2NIUJAMTWIZY.LARGE.jpg"], "step_title": "Step 3: Wiring & Hardware Setup"}, {"step": 4, "steps_text": "The sine wave generator and PWM generator were first tested to make sure our concept worked, then the input limiter and amplitude adder/shifter were integrated. Details of the function and I/O of each process block is as shown in the Figure. The code is shown below, but also attached as VHD and txt files. If there are discrepancies, go with the VHD files.BTW: we probably should've made our lines shorter but code embedding on Instructables also turned out to be quite annoying to deal with, so the spacing isn't the greatest and there's no syntax highlighting. If you have Vivado and would like to follow along the code, we highly recommend you to just download the file.First, let's look at the Sine Wave Generator module. library IEEE;<br>use IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.NUMERIC_STD.ALL;\nentity Wave_Generator is\n    Port ( Trigger : in STD_LOGIC;                       -- Key press\n          Freq_Cnt : in STD_LOGIC_VECTOR(15 downto 0);   -- Counter value = 100MHz / (Note Frequency*64 Divisions of Sine Wave) (round to nearest num)\n                                                            -- renamed from Freq\n        wavegenCLK : in STD_LOGIC;                       -- Basys3 100MHz CLK\n           WaveOut : out STD_LOGIC_VECTOR(9 downto 0));  -- Signed amplitude of wave\nend Wave_Generator;\narchitecture Behavioral of Wave_Generator is\n    signal i : integer range 0 to 64 := 0;                           -- index of amplitude memory bank\n    type memory_type is array (0 to 63) of integer range -64 to 63;  -- create memory bank (ROM) to hold amplitude values\n                                                                      -- is this RAM or ROM just wondering...\n    signal amplitude : memory_type := ( 0,  7, 13, 19, 25, 30, 35, 40, 45, 49, 52, 55, 58, 60, 62, 63, \n                                       63, 63, 62, 60, 58, 55, 52, 49, 45, 40, 35, 30, 25, 19, 13,  7, \n                                        0, -7,-13,-19,-25,-30,-35,-40,-45,-49,-52,-55,-58,-60,-62,-63,  \n                                      -63,-63,-62,-60,-58,-55,-52,-49,-45,-40,-35,-30,-25,-19,-13, -7); -- amplitude memory bank for sine wave\nbegin\n    process (wavegenCLK, Trigger)\n        variable counter : unsigned (15 downto 0) := to_unsigned(0, 16); -- clock divider counter, renamed from count1\n    begin\n        if (rising_edge(wavegenCLK)) then\n            if (Trigger = '1') then -- key is pressed\n                counter := counter + 1;\n                if (counter = unsigned(Freq_Cnt)) then  -- Freq_Cnt = 100Mhz / (note freq * 64 divisions of the sine wave)   \n                    -- reset counter and assign amplitude data to output\n                    counter := to_unsigned(0, 16);\n                    WaveOut <= STD_LOGIC_VECTOR (to_signed(amplitude(i), 10));\n                    -- increment i for next reading\n                    i <= i + 1;\n                    -- reset i if one sine wave has been completed\n                    if(i = 63) then\n                        i <= 0;\n                    end if;\n                end if; -- (counter = unsigned(Freq_Cnt))\n            else -- key is not pressed\n                -- reset output, amplitude index, and counter\n                WaveOut <= \"0000000000\";\n                i <= 0;\n                counter := to_unsigned(0, 16); --output Amplitude = -64 when no note is played\n            end if; -- (Trigger = '1')\n        end if; -- (rising_edge(CLK))\n    end process;\nend Behavioral;\nWe will generate a digital sine wave in the Basys3 by using the internal clock and a ROM. This ROM will store 64 values that represent 64 amplitudes on a sine wave. See Figure 1. The 64 values we use emulate a sine wave with pretty good resolution.Using the internal clock, we count to a value that represents the clock speed divided by the frequency of the wave we want and 64: Clk div = 100MHz / (Freq * 64) Every time our counter reaches that value, we call a number from the ROM and send that out of our wave generator module. The frequency of our wave will depend on how fast we call these amplitudes.We will have 25 sub-modules, each associated with one frequency/note.Here's the remaining of the code that calls the Sine Wave Generator modules:library IEEE;<br>use IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.NUMERIC_STD.ALL;\n\n\nentity Two_Octave_Synth is\n    Port ( CLK : in STD_LOGIC; \n           O4 : in STD_LOGIC_VECTOR(11 downto 0);\n           O5 : in STD_LOGIC_VECTOR(12 downto 0);\n           output : out STD_LOGIC);\nend Two_Octave_Synth;\n\n\narchitecture Behavioral of Two_Octave_Synth is\n    component Wave_Generator is\n        Port ( Trigger : in STD_LOGIC;\n           Freq_Cnt : in STD_LOGIC_VECTOR(15 downto 0);\n           wavegenCLK : in STD_LOGIC;\n           WaveOut : out STD_LOGIC_VECTOR(9 downto 0));\n    end component;\n\n\n---------------------------output signals from wave generator-----------------------\n    signal WaveC4, WaveCs4, WaveD4, WaveDs4, WaveE4, WaveF4, WaveFs4, WaveG4, WaveGs4, WaveA4, WaveAs4, WaveB4, \n           WaveC5, WaveCs5, WaveD5, WaveDs5, WaveE5, WaveF5, WaveFs5, WaveG5, WaveGs5, WaveA5, WaveAs5, WaveB5, WaveC6  : signed(9 downto 0);\n\n\n--------------------------------for note selection logic--------------------\n    signal C4, Cs4, D4, Ds4, E4, F4, Fs4, G4, Gs4, A4, As4, B4, C5, Cs5, D5, Ds5, E5, F5, Fs5, G5, Gs5, A5, As5, B5, C6 : unsigned(4 downto 0);\n    signal cntC4, cntCs4, cntD4, cntDs4, cntE4, cntF4, cntFs4, cntG4, cntGs4, cntA4, cntAs4, cntB4, cntC5, cntCs5, cntD5, \n           cntDs5, cntE5, cntF5, cntFs5, cntG5, cntGs5, cntA5, cntAs5, cntB5, cntC6 : unsigned(4 downto 0);\n    signal error : STD_LOGIC;\n\n\n-----------------------------------for adding sine waves--------------------------\n    signal Wave0, Wave1, Wave2, Wave3 : signed(9 downto 0); --signals from Wave Generator module output\n    signal WaveSum : STD_LOGIC_VECTOR(9 downto 0); --signal for summed sine waves (2's compliment -512 to 511)\n    signal positiveWaveSum : STD_LOGIC_VECTOR(9 downto 0); --unsigned 0 to 1023, for use in PWM generator\n\n\n-----------------------------------for generating PWM-------------------------------\n    signal ping_length : unsigned (9 downto 0) := unsigned(positiveWaveSum);\n    --signal off_length : unsigned (6 downto 0) := to_unsigned(127, 7) - unsigned(WAVE);\n    signal PWM : unsigned (9 downto 0) := to_unsigned(0, 10);\n\n\nbegin\n    Note_C4  : Wave_Generator port map (Trigger => O4(0), Freq_Cnt => X\"1755\", wavegenCLK => CLK, signed(WaveOut) => WaveC4); --5973, 261.63 Hz\n    Note_Cs4 : Wave_Generator port map (Trigger => O4(1), Freq_Cnt => X\"1606\", wavegenCLK => CLK, signed(WaveOut) => WaveCs4);--5638, 277.18 Hz\n    Note_D4  : Wave_Generator port map (Trigger => O4(2), Freq_Cnt => X\"14C9\", wavegenCLK => CLK, signed(WaveOut) => WaveD4); --5321, 293.66 Hz\n    Note_Ds4 : Wave_Generator port map (Trigger => O4(3), Freq_Cnt => X\"139F\", wavegenCLK => CLK, signed(WaveOut) => WaveDs4);--5023, 311.13 Hz\n    Note_E4  : Wave_Generator port map (Trigger => O4(4), Freq_Cnt => X\"1285\", wavegenCLK => CLK, signed(WaveOut) => WaveE4); --4741, 329.63 Hz\n    Note_F4  : Wave_Generator port map (Trigger => O4(5), Freq_Cnt => X\"117B\", wavegenCLK => CLK, signed(WaveOut) => WaveF4); --4475, 349.23 Hz\n    Note_Fs4 : Wave_Generator port map (Trigger => O4(6), Freq_Cnt => X\"1080\", wavegenCLK => CLK, signed(WaveOut) => WaveFs4);--4224, 369.99 Hz\n    Note_G4  : Wave_Generator port map (Trigger => O4(7), Freq_Cnt => X\"0F92\", wavegenCLK => CLK, signed(WaveOut) => WaveG4); --3986, 392.00 Hz\n    Note_Gs4 : Wave_Generator port map (Trigger => O4(8), Freq_Cnt => X\"0EB3\", wavegenCLK => CLK, signed(WaveOut) => WaveGs4);--3763, 415.30 Hz\n    Note_A4  : Wave_Generator port map (Trigger => O4(9), Freq_Cnt => X\"0DE0\", wavegenCLK => CLK, signed(WaveOut) => WaveA4); --3552, 440.00 Hz\n    Note_As4 : Wave_Generator port map (Trigger => O4(10),Freq_Cnt => X\"0D18\", wavegenCLK => CLK, signed(WaveOut) => WaveAs4);--3352, 466.16 Hz\n    Note_B4  : Wave_Generator port map (Trigger => O4(11),Freq_Cnt => X\"0C5C\", wavegenCLK => CLK, signed(WaveOut) => WaveB4); --3164, 493.88 Hz\n-------------------------------------------------------------------------------------------------------------------------                                                                  \n    Note_C5  : Wave_Generator port map (Trigger => O5(0), Freq_Cnt => X\"0BAB\", wavegenCLK => CLK, signed(WaveOut) => WaveC5); --2987, 523.25 Hz\n    Note_Cs5 : Wave_Generator port map (Trigger => O5(1), Freq_Cnt => X\"0B03\", wavegenCLK => CLK, signed(WaveOut) => WaveCs5);--2819, 554.37 Hz\n    Note_D5  : Wave_Generator port map (Trigger => O5(2), Freq_Cnt => X\"0A65\", wavegenCLK => CLK, signed(WaveOut) => WaveD5); --2661, 587.33 Hz\n    Note_Ds5 : Wave_Generator port map (Trigger => O5(3), Freq_Cnt => X\"09D0\", wavegenCLK => CLK, signed(WaveOut) => WaveDs5);--2512, 622.25 Hz\n    Note_E5  : Wave_Generator port map (Trigger => O5(4), Freq_Cnt => X\"0943\", wavegenCLK => CLK, signed(WaveOut) => WaveE5); --2371, 659.25 Hz\n    Note_F5  : Wave_Generator port map (Trigger => O5(5), Freq_Cnt => X\"08Be\", wavegenCLK => CLK, signed(WaveOut) => WaveF5); --2238, 698.46 Hz\n    Note_Fs5 : Wave_Generator port map (Trigger => O5(6), Freq_Cnt => X\"0840\", wavegenCLK => CLK, signed(WaveOut) => WaveFs5);--2112, 739.99 Hz\n    Note_G5  : Wave_Generator port map (Trigger => O5(7), Freq_Cnt => X\"07CA\", wavegenCLK => CLK, signed(WaveOut) => WaveG5); --1994, 783.99 Hz\n    Note_Gs5 : Wave_Generator port map (Trigger => O5(8), Freq_Cnt => X\"075A\", wavegenCLK => CLK, signed(WaveOut) => WaveGs5);--1882, 830.61 Hz\n    Note_A5  : Wave_Generator port map (Trigger => O5(9), Freq_Cnt => X\"06F0\", wavegenCLK => CLK, signed(WaveOut) => WaveA5); --1776, 880.00 Hz\n    Note_As5 : Wave_Generator port map (Trigger => O5(10),Freq_Cnt => X\"068C\", wavegenCLK => CLK, signed(WaveOut) => WaveAs5);--1676, 932.33 Hz\n    Note_B5  : Wave_Generator port map (Trigger => O5(11),Freq_Cnt => X\"062E\", wavegenCLK => CLK, signed(WaveOut) => WaveB5); --1582, 987.77 Hz\n    Note_C6  : Wave_Generator port map (Trigger => O5(12),Freq_Cnt => X\"05D6\", wavegenCLK => CLK, signed(WaveOut) => WaveC6); --1494, 1046.5 Hz\n\n\n------------note selection logic------------\n    C4  <= \"0000\" & O4(0);\n    Cs4 <= \"0000\" & O4(1);\n    D4  <= \"0000\" & O4(2);\n    Ds4 <= \"0000\" & O4(3);\n    E4  <= \"0000\" & O4(4);\n    F4  <= \"0000\" & O4(5);\n    Fs4 <= \"0000\" & O4(6);\n    G4  <= \"0000\" & O4(7);\n    Gs4 <= \"0000\" & O4(8);\n    A4  <= \"0000\" & O4(9);\n    As4 <= \"0000\" & O4(10);\n    B4  <= \"0000\" & O4(11);\n    C5  <= \"0000\" & O5(0);\n    Cs5 <= \"0000\" & O5(1);\n    D5  <= \"0000\" & O5(2);\n    Ds5 <= \"0000\" & O5(3);\n    E5  <= \"0000\" & O5(4);\n    F5  <= \"0000\" & O5(5);\n    Fs5 <= \"0000\" & O5(6);\n    G5  <= \"0000\" & O5(7);\n    Gs5 <= \"0000\" & O5(8);\n    A5  <= \"0000\" & O5(9);\n    As5 <= \"0000\" & O5(10);\n    B5  <= \"0000\" & O5(11);\n    C6  <= \"0000\" & O5(12);  \n    cntC4 <= C4;\n    cntCs4 <= C4 + Cs4;\n    cntD4  <= C4 + Cs4 + D4;\n    cntDs4 <= C4 + Cs4 + D4 + Ds4;\n    cntE4  <= C4 + Cs4 + D4 + Ds4 + E4;\n    cntF4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4;\n    cntFs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4;\n    cntG4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4;\n    cntGs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4;\n    cntA4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4;\n    cntAs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4;\n    cntB4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4;\n    cntC5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5;\n    cntCs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5;\n    cntD5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5;\n    cntDs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5;\n    cntE5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5;\n    cntF5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5;\n    cntFs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5;\n    cntG5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5;\n    cntGs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5;\n    cntA5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5;\n    cntAs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5;\n    cntB5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5 + B5;\n    cntC6  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5 + B5 + C6;\n\n\n    Selection : process (WaveC4, WaveCs4, WaveD4, WaveDs4, WaveE4, WaveF4, WaveFs4, WaveG4, WaveGs4, WaveA4, WaveAs4, WaveB4, \n                         WaveC5, WaveCs5, WaveD5, WaveDs5, WaveE5, WaveF5, WaveFs5, WaveG5, WaveGs5, WaveA5, WaveAs5, WaveB5, WaveC6)\n\n\n    begin  \n        if (cntC6 = \"00000\") then ---------------if no signals being generated\n            Wave0 <= \"0000000000\";\n            Wave1 <= \"0000000000\";\n            Wave2 <= \"0000000000\";\n            Wave3 <= \"0000000000\";\n        else\n            if (O4(0) = '1') then -------------------note C4 played\n                Wave0 <= WaveC4;\n            end if;\n            if (O4(1) = '1') then -------------------note Cs5 played\n                case(cntCs4) is\n                    when \"00001\" => Wave0 <= WaveCs4;\n                    when \"00010\" => Wave1 <= WaveCs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(2) = '1') then--------------------note D4 played\n                case(cntD4) is\n                    when \"00001\" => Wave0 <= WaveD4;\n                    when \"00010\" => Wave1 <= WaveD4;\n                    when \"00011\" => Wave2 <= WaveD4;\n                    when others => error <= '1';\n                end case;\n            end if;\n-------------------------------------------------------------------------------------------------------------------------\n            if (O4(3) = '1') then--------------------note Ds4 played\n                case(cntDs4) is\n                    when \"00001\" => Wave0 <= WaveDs4;\n                    when \"00010\" => Wave1 <= WaveDs4;\n                    when \"00011\" => Wave2 <= WaveDs4;\n                    when \"00100\" => Wave3 <= WaveDs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(4) = '1') then--------------------note E4 played\n                case(cntE4) is\n                    when \"00001\" => Wave0 <= WaveE4;\n                    when \"00010\" => Wave1 <= WaveE4;\n                    when \"00011\" => Wave2 <= WaveE4;\n                    when \"00100\" => Wave3 <= WaveE4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(5) = '1') then--------------------note F4 played\n                case(cntF4) is\n                    when \"00001\" => Wave0 <= WaveF4;\n                    when \"00010\" => Wave1 <= WaveF4;\n                    when \"00011\" => Wave2 <= WaveF4;\n                    when \"00100\" => Wave3 <= WaveF4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(6) = '1') then--------------------note Fs4 played\n                case(cntFs4) is\n                    when \"00001\" => Wave0 <= WaveFs4;\n                    when \"00010\" => Wave1 <= WaveFs4;\n                    when \"00011\" => Wave2 <= WaveFs4;\n                    when \"00100\" => Wave3 <= WaveFs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(7) = '1') then--------------------note G4 played\n                case(cntG4) is\n                    when \"00001\" => Wave0 <= WaveG4;\n                    when \"00010\" => Wave1 <= WaveG4;\n                    when \"00011\" => Wave2 <= WaveG4;\n                    when \"00100\" => Wave3 <= WaveG4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(8) = '1') then--------------------note Gs4 played\n                case(cntGs4) is\n                    when \"00001\" => Wave0 <= WaveGs4;\n                    when \"00010\" => Wave1 <= WaveGs4;\n                    when \"00011\" => Wave2 <= WaveGs4;\n                    when \"00100\" => Wave3 <= WaveGs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(9) = '1') then--------------------note A4 played\n                case(cntA4) is\n                    when \"00001\" => Wave0 <= WaveA4;\n                    when \"00010\" => Wave1 <= WaveA4;\n                    when \"00011\" => Wave2 <= WaveA4;\n                    when \"00100\" => Wave3 <= WaveA4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(10) = '1') then--------------------note As4 played\n                case(cntAs4) is\n                    when \"00001\" => Wave0 <= WaveAs4;\n                    when \"00010\" => Wave1 <= WaveAs4;\n                    when \"00011\" => Wave2 <= WaveAs4;\n                    when \"00100\" => Wave3 <= WaveAs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(11) = '1') then--------------------note B4 played\n                case(cntB4) is\n                    when \"00001\" => Wave0 <= WaveB4;\n                    when \"00010\" => Wave1 <= WaveB4;\n                    when \"00011\" => Wave2 <= WaveB4;\n                    when \"00100\" => Wave3 <= WaveB4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(0) = '1') then--------------------note C5 played\n                case(cntC5) is\n                    when \"00001\" => Wave0 <= WaveC5;\n                    when \"00010\" => Wave1 <= WaveC5;\n                    when \"00011\" => Wave2 <= WaveC5;\n                    when \"00100\" => Wave3 <= WaveC5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(1) = '1') then--------------------note Cs5 played\n                case(cntCs5) is\n                    when \"00001\" => Wave0 <= WaveCs5;\n                    when \"00010\" => Wave1 <= WaveCs5;\n                    when \"00011\" => Wave2 <= WaveCs5;\n                    when \"00100\" => Wave3 <= WaveCs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(2) = '1') then--------------------note D5 played\n                case(cntD5) is\n                    when \"00001\" => Wave0 <= WaveD5;\n                    when \"00010\" => Wave1 <= WaveD5;\n                    when \"00011\" => Wave2 <= WaveD5;\n                    when \"00100\" => Wave3 <= WaveD5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(3) = '1') then--------------------note Ds5 played\n                case(cntDs5) is\n                    when \"00001\" => Wave0 <= WaveDs5;\n                    when \"00010\" => Wave1 <= WaveDs5;\n                    when \"00011\" => Wave2 <= WaveDs5;\n                    when \"00100\" => Wave3 <= WaveDs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(4) = '1') then--------------------note E5 played\n                case(cntE5) is\n                    when \"00001\" => Wave0 <= WaveE5;\n                    when \"00010\" => Wave1 <= WaveE5;\n                    when \"00011\" => Wave2 <= WaveE5;\n                    when \"00100\" => Wave3 <= WaveE5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(5) = '1') then--------------------note F5 played\n                case(cntF5) is\n                    when \"00001\" => Wave0 <= WaveF5;\n                    when \"00010\" => Wave1 <= WaveF5;\n                    when \"00011\" => Wave2 <= WaveF5;\n                    when \"00100\" => Wave3 <= WaveF5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(6) = '1') then--------------------note Fs5 played\n                case(cntFs5) is\n                    when \"00001\" => Wave0 <= WaveFs5;\n                    when \"00010\" => Wave1 <= WaveFs5;\n                    when \"00011\" => Wave2 <= WaveFs5;\n                    when \"00100\" => Wave3 <= WaveFs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(7) = '1') then--------------------note G5 played\n                case(cntG5) is\n                    when \"00001\" => Wave0 <= WaveG5;\n                    when \"00010\" => Wave1 <= WaveG5;\n                    when \"00011\" => Wave2 <= WaveG5;\n                    when \"00100\" => Wave3 <= WaveG5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(8) = '1') then--------------------note Gs5 played\n                case(cntGs5) is\n                    when \"00001\" => Wave0 <= WaveGs5;\n                    when \"00010\" => Wave1 <= WaveGs5;\n                    when \"00011\" => Wave2 <= WaveGs5;\n                    when \"00100\" => Wave3 <= WaveGs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(9) = '1') then--------------------note A5 played\n                case(cntA5) is\n                    when \"00001\" => Wave0 <= WaveA5;\n                    when \"00010\" => Wave1 <= WaveA5;\n                    when \"00011\" => Wave2 <= WaveA5;\n                    when \"00100\" => Wave3 <= WaveA5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(10) = '1') then--------------------note As5 played\n                case(cntAs5) is\n                    when \"00001\" => Wave0 <= WaveAs5;\n                    when \"00010\" => Wave1 <= WaveAs5;\n                    when \"00011\" => Wave2 <= WaveAs5;\n                    when \"00100\" => Wave3 <= WaveAs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(11) = '1') then--------------------note B5 played\n                case(cntB5) is\n                    when \"00001\" => Wave0 <= WaveB5;\n                    when \"00010\" => Wave1 <= WaveB5;\n                    when \"00011\" => Wave2 <= WaveB5;\n                    when \"00100\" => Wave3 <= WaveB5;\n                    when others => error <= '1';\n                end case;\n            end if;\n---------------------------------------------------------------------------------------------------------------------------------    \n            if(O5(12) = '1') then--------------------note C6 played\n                case(cntC6) is\n                    when \"00001\" => \n                        Wave0 <= WaveC6;\n                        Wave1 <= \"0000000000\";\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00010\" => \n                        Wave1 <= WaveC6;\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00011\" => \n                        Wave2 <= WaveC6;\n                        Wave3 <= \"0000000000\";\n                    when \"00100\" => Wave3 <= WaveC6;\n                    when others => error <= '1';\n                end case;   \n            else\n                case(cntC6) is--------------------------fill in extra waves\n                    when \"00001\" => \n                        Wave1 <= \"0000000000\";\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00010\" => \n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00011\" => \n                        Wave3 <= \"0000000000\";\n                    when others => error <= '1';\n                end case;   \n            end if;    \n        end if;     \n    end process;\n\n\n-------------sine wave adder--------------------\n    WaveSum <= STD_LOGIC_VECTOR(Wave0 + Wave1 + Wave2 + Wave3);\n\n\n---------make sine wave positive for pwm---------------------\n    positiveWaveSum <= not WaveSum(9) & WaveSum(8 downto 0);\n\n\n-------------PWM generator---------------------\n    process(CLK) \n            --variable count : unsigned (1 downto 0) := to_unsigned(0, 2);\n        begin\n            if (rising_edge(CLK)) then\n                --count := count + 1;\n                --if (count = to_unsigned(4, 2)) then\n                    --count := to_unsigned(0, 2);\n                    --if (PWM = to_\n                    if (PWM < ping_length) then\n                        output <= '1';\n                    else\n                        output <= '0';\n                    end if;\n                    PWM <= PWM + 1;\n                    ping_length <= unsigned(positiveWaveSum);\n                --end if;\n            end if;\n        end process;\nend Behavioral; 4 Note SelectorThe trickiest part of this project is selecting just four frequencies. We did it with a whole lotta IF statements, and we used signals instead of variables so that the process can be simulated and debugged. We tried other methods using variables and FOR loops, but ran into run-time errors. So, in the end, we decided that if it works, we\u2019ll leave it alone. Don\u2019t fix what ain\u2019t broken amirite?The four output waves are labeled Wave0, Wave1, Wave2, Wave3 -- these are what will be added together to form the final output.Looking at the code, you\u2019ll see a bunch of signals labeled C4, Cs4, D4, Ds4, etc. These are 5-bit signals that take the corresponding trigger from O4 (octave 4) or O5 (octave 5) and make them 5-bit for adding. Next the cntC4, cntCs4, etc variables represent how many notes lower than the target note have been played, including the target note. For example, if C4, E4, G4, A#4, and D5 are played (C9 chord) cntC4 will be 1, cntE4 will be 2, cntG4 will be 3, etc. Then, whenever a note is played, the count for the target note will be examined to see where to hook the note signal up to. For example, if D5 note is played (which means O5(2) is high) and cntD5 is 3, then there are currently 3 notes being played, with 2 notes lower than D5, so we will hook waveD5 to Wave2 (the third wave signal counting from Wave0). Alternatively, if cntD5 is 5, then there are currently 5 notes being played, with 4 notes lower than D5, so we will just leave waveD5 hanging and not do anything with it.The IF statements are then repeated to cover the cases for all 25 notes.Amplitude Adder After the lowest 4 waves are selected we have to add them together. The reason we will only add four notes together is because the PWM idea we are using for our output can only have a certain resolution until the PWM is running too slow and the speaker will start picking up the PWM square wave. For example, if we were to use a resolution of 8192 (13 bit), each of those 8192 points has to correspond to a rising edge of the onboard clock. So, 100MHz / 8192 = 12.2kHz, which is well within the range of human hearing.The actual addition of the amplitudes is super simple, you just have to make sure it can run really fast.PWM Output The PWM\u2019s duty cycle will represent the amplitude of our output wave at that instant. For example, if we have an amplitude range of 0 to 128, 0 would be a 0% duty cycle, 64 would be 50%, 128 would be 100%, etc.  This PWM will run extremely fast (ours is 97.6 kHz),  so fast that the speaker will not recognize the individual square waves and instead look at the average voltage, creating our \u201canalog\u201d signal.Constraints FileYou may have hooked up your hardware differently, so just make sure the constraints file matches up.", "step_imgs": ["https://cdn.instructables.com/FVK/OOU2/JAMTQLIK/FVKOOU2JAMTQLIK.LARGE.jpg", "https://cdn.instructables.com/F54/9HYJ/JAIJOPH9/F549HYJJAIJOPH9.LARGE.jpg"], "step_title": "Step 4: VHDL Setup (Vivado)"}, {"step": 5, "steps_text": "Below is the code, both in .txt format and .vhd for Vivado. Wave_Generator is the wave generator sub-module, and Two_Octave_Synth is the top module with everything else.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 5: Code Downloads"}], "channel": "Gadgets"}, {"category": "technology", "description": "This is a pretty cool project that I created with my daughter. The final product is fun and gives you something cool to take to school for a show-and-tell or show your relatives when they come to visit! It's a combination of three other small Arduino projects: - a light sensor using a photocell- using a piezo buzzer to create a beeper with variable tone and speed and- blinking a sequence of LEDs with variable speedThe final product is a light sensor with a series of LEDs that (a) blink faster with more light (and slower with less) and (b) beeps faster and at a higher pitch with more light (and slower and lower pitch with less. When I created the breadboard diagram using Fritzing I made some adjustments from the original breadboard so that it's clear to visualize the wires etc. What you will need:- breadboard- Arduino Uno- 5x LEDs- photovoltaic cell- piezo speaker- 5x 220 ohm resistor (for LEDs)- 500 ohm resistor (for photovoltaic cell) - 100 ohm resistor (for piezo buzzer)To be completely honest, I've selected those resistors based on the work done by other people and other projects I've found online. I'm sure there is science and formulas behind it but you will not find it in this Instructable, sorry. ", "title": "Arduino Light Sensor With Buzzer and Blinking LEDs", "url": "https://www.instructables.com/id/Arduino-Light-Sensor-With-Buzzer-and-Blinking-LEDs/", "section": "technology", "steps": [{"step": 1, "steps_text": "Start with the basics: connect the board to GND and the 5V pins and make sure you have jumpers connecting the positive and negative rails to the other side of the breadboard, making them \"active\" and helping you build your circuits without crossing over the breadboard too much. We want to create a sequence of LEDs to be operated independently. Let's connect the first LED. The positive side of the LED connects to pin 13. The negative side of the LED you will connect with a 220 ohm resistor, that is then connected to GND. ", "step_imgs": ["https://cdn.instructables.com/FHF/0XLV/JF34H125/FHF0XLVJF34H125.LARGE.jpg"], "step_title": "Step 1: Step 1 - Wire the First LED"}, {"step": 2, "steps_text": "Now wire the other four LEDs following the same plan: positive sides each to pins 12, 11, 10 and 9 respectively, and negative sides to ground, using each a 220 ohm resistor. The LEDs are ready: you will be able to control them independently, each one through a separate PIN. ", "step_imgs": ["https://cdn.instructables.com/F4M/AC5S/JF34H128/F4MAC5SJF34H128.LARGE.jpg"], "step_title": "Step 2: Step 2 - Wire the Other 4 LEDs "}, {"step": 3, "steps_text": "We want our sensor to beep. For that we'll use a Piezo buzzer, so let's wire it. The negative wire connects to GND and the positive wire connects first to a 100 ohm resistor, than to pin 7. As I said before, the 100 ohm resistor is suggested in other projects that I found online. ", "step_imgs": ["https://cdn.instructables.com/F3G/YTIC/JF34H15H/F3GYTICJF34H15H.LARGE.jpg"], "step_title": "Step 3: Step 3 - Wire the Piezo"}, {"step": 4, "steps_text": "The photovoltaic cell is a simple resistor that becomes more conductive when exposed to light. So, with zero light it blocks 100% of current, and with full light it allows current to flow through. The way Arduino \"reads\" this is that zero light returns a value of 0 and full light returns a value of 1024. The photovoltaic cell doesn't have a negative and positive side. So you will wire one side to the positive rail of the board. The wiring of the negative side is slightly complicated: you will connect it both (a) to the negative rail using a 500 ohm resistor and (b) directly to pin A0 . The circuit is ready. Let's look at the code. ", "step_imgs": ["https://cdn.instructables.com/FTM/6VFR/JF34H0F8/FTM6VFRJF34H0F8.LARGE.jpg"], "step_title": "Step 4: Step 4 - Wire the Photovoltaic Cell"}, {"step": 5, "steps_text": "You will find the full code below to cut and paste. It has //comments so that you can understand what is going on where. This is what the code is doing: 1 - The sensor reads the light level, measuring it from 0 to 10242 - We \"translate\" this reading into an instruction for the buzzer to beep and the LEDs to blink.3 - For the LEDs, we translate the reading of the light into milliseconds of blinking. The less light, the slow it blinks. Doing some tests, even when the light is strong, it doesn't read more than 700 or 800 (hard to get to 1024) so I used 700 as my \"top\" light level. Because of the way the MAP function works, if light reaches above 700, it would turn the blinking time into a negative number - and the whole thing crashes. So I created a rule that Blink_Time cannot be shorter than 20 milliseconds.  4 - The LEDs light in sequence (that is, the first one turns on, then when it turns off the next one turns on etc)5 - For the buzzer, we translate the reading of the light (0 - 1024) to hertz (120 to 1500), so the more light, the higher the pitch. 6 - The buzzer beeps at the same time as the first, third and fifth LED, (and for the sale length of time) then pauses as the LEDs pause. This creates a pulsating effect, light and sound in the same rhythm. This is it. Enjoy it! Code: // Light sensors with beeps and sequence of leds like an airport// ints for blinking   int Blink_Time = 20; // creates this variable to be used for the length of the blinks and intervals   int Light_Level = 0; //creates this variable to be used for the level of light   int Light_Pin = A0; // pin 0 will be used for the photocell// ints for buzzer     int Buzz_Tone = 300; // creates this variable for the tone of the buzzer   int Buzz_Tone_Max = 1500; // max herz for buzz tone   int Buzz_Tone_Min = 120; // min herz for buzz tonevoid setup() {   pinMode(9, OUTPUT);   // initialize pint 9 - 13 as as outputs for the ledspinMode(10, OUTPUT);   pinMode(11, OUTPUT);   pinMode(12, OUTPUT);   pinMode(13, OUTPUT);   pinMode(7, OUTPUT); // Set buzzer - pin 7 as an output for the buzzer   Serial.begin(9600);   Serial.println(\"Ready\"); // Open the serial port at 9600 baud to monitor the behavior of the variables}void loop() {    Light_Level = analogRead(Light_Pin); // reads light levelBlink_Time = map (Light_Level, 0, 700, 300, 1); // sets blink time according to light level (more light, more speed)if (Blink_Time <= 20) {Blink_Time = 20;} // sets a minimum limit for the blink time. Because the light level can go above 700, the mapping function can cause blink time to become negative, in which case the program freezes. // sets buzz tone according to light level (more light, more herz, higher pitch) Buzz_Tone = map (Light_Level, 0, 700, Buzz_Tone_Min, Buzz_Tone_Max);           // prints all variables in the serial monitor for you to see what is happeningSerial.print(\"Light level = \");     Serial.print(Light_Level);     Serial.print(\"    Blink time = \");     Serial.print(Blink_Time);       Serial.print(\"    Buzz_Tone = \");     Serial.print(Buzz_Tone);Serial.println(\" \");       // first LEDtone(7, Buzz_Tone);   // starts the beep at the same time that the first led turns ondigitalWrite(9, HIGH);   // turn the LED on (HIGH is the voltage level)   delay(Blink_Time);                       // wait for [blink time]   digitalWrite(9, LOW);    // turn the LED off by making the voltage LOW noTone(7);      // stops the beep// second LED// no beep here, I want only three beeps so I put them on the first, third and fifth LEDsdigitalWrite(10, HIGH);   // turn the LED on (HIGH is the voltage level)   delay(Blink_Time);                       // wait for [blink time]   digitalWrite(10, LOW);    // turn the LED off by making the voltage LOW// third LEDtone(7, Buzz_Tone);  //beepdigitalWrite(11, HIGH);   // turn the LED on (HIGH is the voltage level)   delay(Blink_Time);                       // wait for [blink time]   digitalWrite(11, LOW);    // turn the LED off by making the voltage LOWnoTone(7); // fourth LEDdigitalWrite(12, HIGH);   // turn the LED on (HIGH is the voltage level)   delay(Blink_Time);                       // wait for [blink time]   digitalWrite(12, LOW);    // turn the LED off by making the voltage LOW// fifth LEDtone(7, Buzz_Tone);         digitalWrite(13, HIGH);   // turn the LED on (HIGH is the voltage level)   delay(Blink_Time);                       // wait for [blink time]   digitalWrite(13, LOW);    // turn the LED off by making the voltage LOWnoTone(7);delay (5*Blink_Time); // pause between series of blinking LEDs + Beeps}", "step_imgs": [], "step_title": "Step 5: Step 5 - the Code"}], "channel": "Arduino"}, {"category": "technology", "description": "This oscilloscope (here after referred to as \"o-scope\") is an excellent beginning o-scope which provides most of the basic functions needed for analyzing/trouble shooting circuits. This guide will document how to properly set up the o-scope, and safely use many of its features. To begin with, here is a summary of the operating requirements and capabilities of the o-scope and the probes:Power supply required: 90-264 VACRMS, 45-66 Hz. North American wall power is 120V, 60 Hz.Channels: 2Bandwidth: 40MHzInput capacitance: 20 pFSample rate: 500 MS/s ( 500 Megasamples/second, or 500X106 samples/second)Here are the specifications from the manual about the probes for this o-scope. It works well with the Textronix TPP0101 and the TPP0201. Both are passive probes with an attenuation factor of 10X. The only difference between the probes is the bandwidth. The TPP0101 has a maximum bandwidth of 100 MHz, while the TPP0201 can measure up to 200 MHz. Electrical and Mechanical SpecificationsCharacteristicTPP0101TPP0201BandwidthDC to 100MHzDC to 200MHzSystem attenuation accuracy10:1 \u00b1 3.2%10:1 \u00b1 3.2%Compensation Range15 pF - 25 pF15 pF - 25 pFSystem Input Resistance10 \u03a9M \u00b1 1.5%10 \u03a9M \u00b1 1.5%System Input Capacitance<12 pF<12 pFSystem Rise Time (typical)<3.5 ns<3.5 nsPropagation Delay~6.1 ns~6.1 nsMaximum Input Voltage<300 VRMS CAT II<300 VRMS CAT IICable Length<1.3 m<1.3 mProbe Connection InterfaceBNCBNCEnvironmental SpecificationsCharacteristicDescriptionOperating Temperature -10 \u00b0 C to +55 \u00b0 C (+14 \u00b0 F to +131 \u00b0 F)Storage Temperature -55 \u00b0 C to +71 \u00b0 C (-60 \u00b0 F to +160 \u00b0 F)Operating Alitude3.0 km (10,000 ft) maximumStorage Altitude12.2 km (40,000 ft) maximum ", "title": "Guide to the Tektronix TBS 1042 Oscilloscope", "url": "https://www.instructables.com/id/Guide-to-the-Tektronix-TBS-1042-Oscilloscope/", "section": "technology", "steps": [{"step": 1, "steps_text": "Some preliminary terms to get us startedSoft key: any of the keys to the right of the screen without permanent labels. The screen will display an appropriate label for the keys depending on the context.CH1 button: the yellow button labeled with a 1CH 2 button: the blue button labeled with a 2Step / Step: The slash indicates a series of steps that build on one another", "step_imgs": ["https://cdn.instructables.com/F4M/GY63/I12KIH5D/F4MGY63I12KIH5D.LARGE.jpg"], "step_title": "Step 1: Guide Terminology"}, {"step": 2, "steps_text": "Turn the o-scope on. Wait for it to pass the self-check, then press any button to continue. Connect the probe to the BNC port of Channel 1 on the o-scope. Align the slots on the probe with the small posts on the o-scope port. Twist the probe connector to the right to lock it in place. (Picture 1)Probe compensation involves turning a small screw attached to  variable capacitor inside the probe. By turning the screw, you change the frequency response of the probe. It helps ensure the probe measures accurately. On the TPP0101 and TPP0201 probes, the screw is located on the BNC connector.Connect the probe tip to the upper terminal that says Probe comp. Connect the alligator clip of the probe to the bottom terminal with the ground symbol next to it. See the second picture for clarificationNow we need to make sure the o-scope knows the attenuation of the probe. The attenuation factor helps limit the load on the circuit under test, but it also divides your signal by some factor. The standard for general probes is 10X or an attenuation factor of 10. To set the o-scope, press the CH 1 button / press the Probe 10X Attenuation soft key / press Voltage Attenuation soft key until 10x appears. Press Back  soft key / Press the button labeled AutoSet (see the third picture)You will see a square wave on the screen with a period of 1 kHz at about 5 V peak-to-peak at 1ms/division (1ms/Div) (see the fourth picture)Now we can compensate! If the output from the probe looks like the fourth picture with flat topped square waves, the probe is properly attenuated. If the leading edge of the square wave is curved like the fifth picture, the probe needs to be compensated more. Turn the compensations screw until the square wave is flat. If the leading edge of the wave is peaked, the probe is over compensated. Turn the screw until the wave is flat. Usually it will not take much turning to properly compensate the probe.", "step_imgs": ["https://cdn.instructables.com/F54/KUIU/I0R18KXB/F54KUIUI0R18KXB.LARGE.jpg", "https://cdn.instructables.com/FOY/OQZS/I12KHURI/FOYOQZSI12KHURI.LARGE.jpg", "https://cdn.instructables.com/FF1/HBP4/I12KI7TZ/FF1HBP4I12KI7TZ.LARGE.jpg", "https://cdn.instructables.com/FZC/3FU6/I0R18KW6/FZC3FU6I0R18KW6.LARGE.jpg", "https://cdn.instructables.com/FY7/BE16/I0R18KW8/FY7BE16I0R18KW8.LARGE.jpg", "https://cdn.instructables.com/FD5/BMN3/I0R18KWA/FD5BMN3I0R18KWA.LARGE.jpg"], "step_title": "Step 2: Probe Setup"}, {"step": 3, "steps_text": "Self CalibrationThe Self Calibration feature ensures your o-scope is measuring accurately. The routine should be performed after the scope has been turned on for about 20 minutes to ensure it has equalized to ambient temperature. The check should be performed if the ambient temperature changes by 5 \u00b0C (9 \u00b0F) or more.Disconnect any probes from the inputs ports. Then, press Utility / Do Self Cal and follow the directions on the screen.NOTE: You can skip the following section if you are using a regular probe.From the manual:Current probes provide a voltage signal proportional to the current. The o-scope needs to be set so it matches the scale of the probe. The default scale is 10 A/V (10 amps/volt)For a probe connected to CH 1, push the yellow 1 button / Probe (to the right of the screen) / Current / Scale and select the appropriate value", "step_imgs": [], "step_title": "Step 3: Self Calibration and Current Probe Setup"}, {"step": 4, "steps_text": "The controls on the left control CH 1, and the controls on the right control CH 2.The Position knob moves the respective signal up or downThe Scale knob increases or decreases the vertical scale factor of the window. It ranges from 20 mV to 50 V (0.02 V - 50 V). By pressing the Volts/Div soft key (shown in the third picture) you can select to have the Scale knob provide course or fine adjustments of the vertical scale (AKA the vertical Volts/Division). A division is one of the white dotted lines displayed on the screen. 5 Volts/Div means each horizontal line indicates a change of 5 V from the previous horizontal line. The horizontal line in the middle of the screen represents 0 V.The CH 1 and CH 2 buttons toggle their respective channels on or off.The Math button toggles the Math waveform. Once the Math button is pressed, you will be able to select mathematical operations to perform using the two waveforms such as addition, subtraction, and multiplication. These options can be selected using the soft key labeled Operation.", "step_imgs": ["https://cdn.instructables.com/FAQ/D625/I12KIFFW/FAQD625I12KIFFW.LARGE.jpg", "https://cdn.instructables.com/FXM/00J9/I12KIH3C/FXM00J9I12KIH3C.LARGE.jpg", "https://cdn.instructables.com/F4M/GY63/I12KIH5D/F4MGY63I12KIH5D.LARGE.jpg"], "step_title": "Step 4: Vertical Controls"}, {"step": 5, "steps_text": "The Position knob controls the horizontal location of all waveforms: CH 1, CH 2, and MathThe Horiz Menu button displays the Horizontal MenuThe Set to Zero button returns the horizontal axis to 0The Scale knob controls the horizontal time/division factor of the window. It can range from 5 ns to 50 s.", "step_imgs": ["https://cdn.instructables.com/FSF/7Y3K/I12KIJCY/FSF7Y3KI12KIJCY.LARGE.jpg"], "step_title": "Step 5: Horizontal Controls"}, {"step": 6, "steps_text": "The trigger controls are used to change where the o-scope thinks a waveform begins or ends. These controls are useful for helping the o-scope understand what it should look for to display a clear and informative picture.Generally the o-scope will look for the rising or falling edge of a waveform to define the start or end of a wave. The rising and falling edges are labeled in the second picture.The Level knob controls what voltage the o-scope will trigger at. The knob moves the trigger level up or down, raising or lowering the trigger voltage level. The level is indicated on the screen with a line, called the Cursor.The Set to 50% button sets the trigger level to halfway between the minimum and maximum amplitudes of the waveform.The Force Trig button forces the o-scope to finish acquiring a signal and determine a trigger point. It does not function if the o-scope has already acquired a signal.While holding the Trig View button, you can view the trigger waveform in place of the CH 1 or CH 2 waveform. This is useful for determining how the trigger settings affect where the o-scope thinks the trigger point is. It's good for trouble shooting.There is also a trigger input on the bottom next to the CH 1 and CH 2 inputs. The trigger input can be used to tell the o-scope when to look for the start of a new waveform.", "step_imgs": ["https://cdn.instructables.com/FCD/YNUL/I1563C6I/FCDYNULI1563C6I.LARGE.jpg", "https://cdn.instructables.com/FYR/YXDQ/I1563CVV/FYRYXDQI1563CVV.LARGE.jpg"], "step_title": "Step 6: Trigger Controls"}, {"step": 7, "steps_text": "The last group of buttons perform most of the information gathering functions of the o-scope.The Multipurpose knob is used to navigate through menus displayed on the screen. When the green LED next to the knob is illuminated, the knob can be used to select various options.The AutoRange button attempts to scale the window view to fit the waveform from the CH 1 or CH 2 probes. Be careful, you may get strange results if the o-scope cannot determine how to properly scale the display window. AutoRange continues to scale the window to fit the waveform if the waveform changes drastically.The Save/Recall button access the Save/Recall menuThe Measurements button displays the Measurements menu. This is useful if you wish to measure certain aspects of the waveform, such as amplitude, period, frequency, or phase shift between two signals.The Acquire button displays the Acquire menu. In the menu you will find settings to change how the o-scope interprets the waveform being measured. More information can be found in the manual.The Ref. button allows you access stored reference waveforms.The Utility button accesses the Utility menuThe Cursor button accesses the Cursor menu. Cursors are vertical and horizontal lines that can only be moved when the Cursor menu is activated. They are moved using the knobs on the o-scope. There are Time cursors (vertical lines) and Amplitude cursors (horizontal lines) that are used to measure time and amplitude characteristics of the waveform.The Display button accesses the Display menu. The Help button accesses the Help menu, which is quite useful for learning about various functions.The Default Setup button returns the o-scope to the factory setup. This is useful if you make a big mess of things.The AutoSet button attempts to make an intelligent choice to best display the input waveform. It seems to take more liberties than AutoRange, which one can interpret as more chances of making a mess  displaying the signal. It can be useful for finding evasive waveforms.The Single button acquires a single waveform and stops.The Run/Stop button toggles between acquiring and pausing acquisition of the input waveform.The Save and Save/Print buttons are used to save data to a USB drive inserted in the front panel.", "step_imgs": ["https://cdn.instructables.com/FTV/XC99/I1563EYW/FTVXC99I1563EYW.LARGE.jpg"], "step_title": "Step 7: General and Menu Control Buttons"}, {"step": 8, "steps_text": "This step provides an easy way to learn how the o-scope probe is used to measure circuit components. I used an Arduino as the signal source.The code was very rudimentary, just enough to get a PWM signal from the board. I attached a jumper cable to Pin 11, and another to ground. Then I attached the probe as shown in the first picture. The code was:const int SignalOut = 11;void setup() {pinMode(SignalOut, OUTPUT);}void loop() {analogWrite(SignalOut, 200);}Any pin with PWM capabilities can be used (it has a ~ next to the pin number) and any ground on the Arduino should work. As for the number, it can range from 0-255. Try different values to see what they look like on the o-scope! The result from my Arduino is in the second picture.", "step_imgs": ["https://cdn.instructables.com/F71/4DHV/I1WHFR7Z/F714DHVI1WHFR7Z.LARGE.jpg", "https://cdn.instructables.com/FE1/J2NM/I1WHFR7X/FE1J2NMI1WHFR7X.LARGE.jpg"], "step_title": "Step 8: Simple Measurement Excercise"}, {"step": 9, "steps_text": "Once the probes are compensated, it is fairly straight forward to use the o-scope to acquire data. The the probe tip attaches to the point you are trying to measure. The attachment point for the ground clip can vary depending on the circuit, but it generally attaches to the ground of the circuit.This o-scope as a lot to offer, and it will serve you well.A great resource for advanced usage is the online manual, found here: http://www.giakova.com/siti/GIAKOVA/img/upload/Pro...It covers many more topics in greater depth.", "step_imgs": [], "step_title": "Step 9: Go Measure Things!"}], "channel": "Electronics"}, {"category": "technology", "description": "This instructable will guide you through creating a simple circuit that taps into the ultrasonic spectrum. There are tons of applications of the design, from playing the song of a dog whistle to an 'on/off' verification of ultrasound probes in medical applications. This is an entirely analog project that can be built with readily-available components: resistors, capacitors, op-amps, a multiplier, an ultrasonic receiver, and stand-alone speakers.  This is a great project for practicing analog electronic knowledge, as well as for gaining experience with frequency shifts and bandwidth limitations.This project was created by Matisse Milovich and Steven Shepard as part of Stanford's EE122A, taught by Professor Greg Kovacs and Laurent Giovangrandi. We\u2019d like to thank Professor Kovacs and TA Bill Esposito for valuable feedback and help along the way.", "title": "Ultrasound Listener. Electronics That Expand Your Auditory Perception", "url": "https://www.instructables.com/id/Ultrasound-Listener-Electronics-that-expand-your-a/", "section": "technology", "steps": [{"step": 1, "steps_text": "Tools:Oscilloscope (recommended)  Solder iron & solder (handy but not required)  Bread boardParts List:Power supply (+/-9V if using the AD633 Multiplier)Op Amps (x4) similar to the LT1056Analog Multiplier IC (x1) with same capability as the AD633Ultrasound Transmitter/Receiver  (1 each)Computer SpeakersVarious ResistorsVarious CapacitorsWiresSpecific Parts We Used:Op Amps: LT1056 (4 x $4.09)Multiplier: AD633. Be aware of its power requirements, it needs at least +/- 8V. (1x $9.39).Ultrasound Receiver and Transmitter: Murata MA40S4R and MA40S4S. ($5 each). We were disappointed in the 600Hz bandwidth (measured at -3db) of the receiver. We'd suggest trying other receivers, though this one certainly works at 40kHz +/- 0.3kHz. These specific parts total about $45.", "step_imgs": [], "step_title": "Step 1: What You'll Need"}, {"step": 2, "steps_text": "Before getting our hands dirty, it is essential to understand the physics and signal processing theories behind the function of this circuit.Audible Sound Versus Ultrasound SoundsThe human ear can hear occur at frequencies between 20Hz and 20kHz. Ultrasound is an acoustic (pressure) wave at anything in the region above 20kHz. A sound wave can be represented by: A*sin (w*t+phi), with A = amplitude, w= 2*pi*frequency, phi = phase. Going higher in the spectrum of sound corresponds to increasing w, and increasing the loudness corresponds to increasing A.  Sound waves can be relatively constant for a period of time, with no decay of amplitude, or they can change over time with rising and falling envelopes. OscillatorsOscillators provide a steady continuous swing between two voltages. The swing can be abrupt, like the square wave, or the swing can been a clean sinusoidal wave, a specialty of the Wein bridge.", "step_imgs": [], "step_title": "Step 2: Background"}, {"step": 3, "steps_text": "The block diagram above shows the high-level view of our circuit. An introduction to the theory is given here, and more detail for each part of the circuit is provided in later steps.Multiplying Two Sinusoidal WavesTo achieve a frequency shift of our incoming ultrasonic signal we took advantage of the following trig identity:cos(A)*cos(B) = \u00bd[cos(A-B)+cos(A+B)], i.e. the product of two signals at different frequencies produces the sum of two signals: one at the sum of the incoming frequencies, and one at the difference of the incoming frequencies. Do not worry that we are now using cosine instead of sine, cosine is just a sine wave shifted 90 degrees, sin(wt) = cos(wt +90). Our ears cannot distinguish a 90 degree phase shift of sound wave.Think of cos(A) be our incoming signal from the ultrasonic receiver, and think of cos(B) be a local oscillation we create. We can measure A, and we can choose B in order to place cos(A-B) in the audio range.In reality, our incoming ultrasonic signal will be the composition of several frequencies, but the principle outlined above still holds. The only difference is that we will also see the harmonics A and B in our output as well. For more information, see the technique of heterodyning.Choosing Shift AmountWe planned for an incoming ultrasonic signal centered around 40kHz, since that is by far the most common center frequency of affordable ultrasonic receivers. We assumed a receiver bandwidth of 10kHz maximum, which meant that our incoming frequencies would be between 35kHz and 45kHz. Consequently, our shifting signal needed to be 35kHz to shift the lower bound of the incoming signal to 0Hz, and the upper bound to 10kHz (still within the audible range). The center frequency would land at 5kHz, which was a pleasant-enough audible sound. Upon building the entire circuit and realizing the bandwidth of the receiver was far narrower than expected, we made the shifting frequency higher to produce a lower, more pleasant center frequency of the audio output.", "step_imgs": ["https://cdn.instructables.com/F1R/RN2F/I3AKCCI3/F1RRN2FI3AKCCI3.LARGE.jpg"], "step_title": "Step 3: Theory "}, {"step": 4, "steps_text": "The schematic above shows our full design on two pages. The output of the multiplier on the first page feeds in to the input of the LPF on the second page. The critical portion is the ultrasonic receiver circuit, which takes in an ultrasonic signal and outputs an audio signal. Optional elements include the ultrasonic transmitter (boxed in the bottom left), and a potential power supply (boxed in the top right) to help those of you who want to make the circuit portable.", "step_imgs": ["https://cdn.instructables.com/FLY/97OI/I3BH735F/FLY97OII3BH735F.LARGE.jpg", "https://cdn.instructables.com/FZX/ROZY/I3BH735G/FZXROZYI3BH735G.LARGE.jpg"], "step_title": "Step 4: Full Schematic"}, {"step": 5, "steps_text": "**Optional but recommended for testing your receiver**In case there are no ultrasound sources in the vicinity of your prototyping bench, you can test the ultrasound listener circuit with a complementary transmitter circuit. The transmitter can be driven by a function generator or by a Wein bridge oscillator (shown above). The oscillating frequency of this oscillator should be within the bandwidth of the ultrasound transmitter and receiver. Refer to the Wein Bridge steps below for more info", "step_imgs": ["https://cdn.instructables.com/FFX/664Q/I3BH6Y09/FFX664QI3BH6Y09.LARGE.jpg", "https://cdn.instructables.com/F63/PXKO/I3BH95M5/F63PXKOI3BH95M5.LARGE.jpg"], "step_title": "Step 5: Transmitter"}, {"step": 6, "steps_text": "Several stages are needed between the ultrasonic receiver and the multiplier: a voltage buffer, a band-pass filter, and a gain stage. Voltage Buffer after ReceiverSupplies current. Otherwise current must come from the sound itself via the ultrasound receiver, and that current is insufficient. Simply connect one end of the transducer inducer to the non-inverting input of the op-amp. Set a feedback loop with no resistance from the output to the inverting input of the op-amp.Bandpass FilterThe bandpass filter does two things: it attenuates noise outside of our expected frequency band, and its high-pass portion prevents negative frequencies from occurring. See the following section if you're interested in more detail.Gain StageThe gain stage should be designed last out of these three steps. Simply measure the voltage of the signal without the gain stage, and set the gain accordingly to provide a signal with the strength of a few volts. The gain for the configuration above is set by (R1+R2)/R2. Check the max input voltage your multiplier can handle, and make sure that won't be exceeded when the receiver is at its minimum distance from the ultrasonic source.", "step_imgs": ["https://cdn.instructables.com/FCZ/L90M/I3BH7HXM/FCZL90MI3BH7HXM.LARGE.jpg"], "step_title": "Step 6: \u200bProcessing the Received Ultrasound Signal"}, {"step": 7, "steps_text": "We added a band-pass filter (BPF) after the receiver in case the received signal landed outside the assumed range of 35kHz to 45kHz. This turned out to be redundant with our particular receiver\u2019s transfer function (which was far narrower), but we kept it as a preventative measure in case we found a receiver a larger bandwidth, one extending beyond our passband. The main concern is the folding of negative frequencies back into the (positive) audible range. For instance, if the incoming signal was a mix of 34kHz and 36kHz, and the shift frequency was 35kHz, we wouldn\u2019t want to produce double the amplitude of a 1kHz audio output. We would rather band-limit the incoming ultrasonic signal to fall within the window we designed for. A second consideration is wanting to band-limit the signal before it goes through the op-amp gain stage, since op-amps have a fixed gain-bandwidth product. Too large of a signal bandwidth would impede the op-amp's performance.You won't need to worry about frequency folding if you make your shift frequency lie outside the bandwidth of your received signal, i.e. lower than the lower bound or higher than the higher bound. ", "step_imgs": [], "step_title": "Step 7: Reasoning Behind Bandpass Stage"}, {"step": 8, "steps_text": "We needed to generate two signals: one for the transmitting frequency used to test our circuit, and one to act as the shifting signal, cos(B) in the block diagram. Several oscillator designs exist, including the Twin-T design, Phase-Shift Oscillators, and the Wein Bridge design. We elected to use a Wein Bridge oscillator because it produces the cleanest sinusoid output. The frequency of oscillation can be easily adjusted by tuning two pairs of RC values, or by hooking up a dual potentiometer with sufficient granularity in your desired range. The frequency of oscillation is 1/(2*pi*R*C), where R and C are specifically called \"R\" and \"C\" in the schematic above. R2, R3 and R4  are chosen such that R3 is slightly less than 2*R2, and R3+R4 is slightly more than 2*R2. The diodes act as a stabilizing measure, ensuring oscillation.Our values were for the oscillator that serves as the frequency shifter were R=4.3kOhms and C = .001uF, corresponding to a frequency of oscillation at 37kHz. The measured frequency was quite close to the expected (calculated) frequency. For the oscillator involved in the transmitting circuit we wanted an oscillation frequency that fell within our receiver's bandwidth. The center frequency of our receiver was 40kHz, so we chose R = 3.9kOhms and C=0.001uF for a nominal oscillation frequency of 40.8 kHz.", "step_imgs": ["https://cdn.instructables.com/FRV/R824/I3BH76WN/FRVR824I3BH76WN.LARGE.jpg"], "step_title": "Step 8: Wein Bridge Oscillator Design"}, {"step": 9, "steps_text": "Check the output of your oscillator to make sure it produces the clean sine wave that Wein Bridge oscillators are known for. We want to have as pure of a harmonic as possible so that we shift the ultrasound signal by one amount rather than by several, which would create a distorted signal at the output of the multiplier.The first image above shows a desirable sine wave output, whereas the second image is an example an oscillation that is far too jagged (in other words, it has higher frequencies present that should not be there). Another common problem when building a Wein Bridge Oscillator is clipping. If you notice clipping on your output check your power supply rails and the values of R2, R3 and R4. Once the signal looks good you can make your oscillator frequency more precise by picking resistors and capacitors that most closely match your desired values (since all component values are slightly off of their nominal value).We noticed it was critical to have R values in the kOhm range rather than the Ohm range, since the lower value was drawing too much current and throwing the oscillator out of balance. When R was 43 Ohms (accidentally), we produced the signal in the second image above. Changing R to 4.3 kOhms did the trick to get a clean sinusoid.It's not as critical to have a clean sinusoid fed in to the ultrasonic transmitter (if you build that testing portion of the circuit). In reality, sounds in our environment are composed of numerous frequencies, so you will merely be transmitting a more realistic ultrasound signal. The composition of your transmitted signal is something you can play with, just make sure you keep an eye on its bandwidth so that all the frequencies you want to hear aren't blocked out by the bandwidths of the transmitter, receiver, of BPF down the road.", "step_imgs": ["https://cdn.instructables.com/FWA/WYJC/I3BH79N8/FWAWYJCI3BH79N8.LARGE.jpg", "https://cdn.instructables.com/FYR/6AE9/I3BH79NS/FYR6AE9I3BH79NS.LARGE.jpg"], "step_title": "Step 9: Wein Bridge Oscillator Tips"}, {"step": 10, "steps_text": "Remember, the product of two sinusoidal signals is a signal with a frequency at the sum and difference of the inputs, according to cos(A)*cos(B)=1/2[cos(A+B) + cos(A-B)].InputsTwo signals: one from the receiver after the gain stage, another from the Wein Bridge oscillator. These signals are shown in the third image above, as as Ch2 and Ch3 respectively. Ch1 is the input from the receiver before the gain stage.OutputIdeally a waveform at the sum and difference of the two input frequencies is produced, but oftentimes the mixer does not completely get rid of the signals that enter it. Thus we implement a LPF following the output of the mixer to look at the window of frequencies that we are interested in. Mixing an approximately 38kHz signal with an approximate 40kHz ultrasound signal, we get out a 2kHz and 78kHz signal plus other noise, namely at 40kHz and 38kHz.  You can see the output in the fourth image above. The fourth image above shows the output from the multiplier after it has gone through the LPF. We can still see the noise at 78kHz, 38kHz and 40kHz, though it has been attenuated by more than 20db.Tip: Be sure to ground the impedance pin (pin 6 for AD633).  The second image shows the input and output ports labeled with notes.", "step_imgs": ["https://cdn.instructables.com/FUX/T5EB/I3BH97NO/FUXT5EBI3BH97NO.LARGE.jpg", "https://cdn.instructables.com/FDK/DC9A/I3BH97NQ/FDKDC9AI3BH97NQ.LARGE.jpg", "https://cdn.instructables.com/FQB/YM5H/I3BH5JI3/FQBYM5HI3BH5JI3.LARGE.jpg", "https://cdn.instructables.com/F83/3R83/I3BH9ASQ/F833R83I3BH9ASQ.LARGE.jpg"], "step_title": "Step 10: Multiplier"}, {"step": 11, "steps_text": "LPFSelects the desired signal, which falls in the audio range. Not a necessary step if your speakers can handle high-frequency noise, but a good precautionary measure. We chose to use a passive RC filter because it was sufficient. There was more than a decade of frequency between the competing noise (at ~75kHz) and the signal (at ~5kHz), so the noise would be attenuated by about 20db.  Let there be Sound (that we can hear)The signal is now ready to go directly to computer speakers using an audio jack and audio cable. You can use smaller speakers or headphones, but you may need to build an amplifier stage. We designed an AB amplifier stage to go with an 8Ohm Speaker, but elected to use computer speakers for their better sound quality.Safety NoteFor the protection of your hearing, always turn your speaker volume down and then increase it gradually. Long-term exposure to loud high-frequency sounds can damage your ears. The sound will be quite loud if you use our component values and put the transmitter inches away from the receiver. We set the knob of our computer speakers to be quite low.", "step_imgs": ["https://cdn.instructables.com/FB9/ZWSC/I3BH93U5/FB9ZWSCI3BH93U5.LARGE.jpg"], "step_title": "Step 11: Audio Output"}, {"step": 12, "steps_text": "Ultrasound Receiver Bandwidth LimitationsThe performance of our ultrasound transducers was the largest limiting factor in what ultrasonic sources we could hear. This is because the receivers have a bandwidth of just 600Hz. This means that we can only receive signals at our center frequency of ~40kKHz plus or minus 300Hz without much attenuation. The first two graphs above show the measured the frequency response of our transducer, done using a Network Analyzer.  'Spoiling' the bandwidth can be done by putting a capacitor in parallel with the transducer receiver. Doing this only added about 100Hz for us. An ideal transducer (or set of transducers) would have a bandwidth of about 20KHz, so that we could make an analog mapping from the ultrasound range to the entire human hearing range.Circuit works as expected for wider range of frequenciesFor testing, we used the AWG input to send in an ultrasonic signal in place of a received one. The circuit behaved properly for the input frequency range we designed for (35kHz to 45kHz), and beyond. Plots showing these results are above. Ch 4 is the output given to the speaker, Ch1 is from the receiver, Ch2 is the amplified received ultrasonic source, Ch3 is the fixed oscillator signal. In all of these plots Ch4 is at the difference of the frequencies of Ch2 and Ch 3, and the noise spectrum is as expected as well. By showing that the circuit behaves as we expect, we can be confident that the limiting factor of what ultrasonic signals we can hear is the bandwidth of the ultrasonic receiver.", "step_imgs": ["https://cdn.instructables.com/FO5/I8QL/I3BH64C0/FO5I8QLI3BH64C0.LARGE.jpg", "https://cdn.instructables.com/FMY/01AJ/I3BH64E2/FMY01AJI3BH64E2.LARGE.jpg", "https://cdn.instructables.com/FQY/NTGU/I3BH9G3I/FQYNTGUI3BH9G3I.LARGE.jpg", "https://cdn.instructables.com/FSK/2NDM/I3BH9G3L/FSK2NDMI3BH9G3L.LARGE.jpg", "https://cdn.instructables.com/FZ9/2H55/I3BH9G3M/FZ92H55I3BH9G3M.LARGE.jpg"], "step_title": "Step 12: Transducer Limitations and Possibilities"}, {"step": 13, "steps_text": "Now that this fundamental circuitry works, the ultrasound spectrum is yours to explore! Below are some extension ideas, many more exist.Extras- Transducer array- Send different tones through transmitter- Vary oscillator frequency. Simply replace the two identical resistors in the oscillator with the leads from a dual potentiometer to adjust the two resistor values at the same time.- Reduce the power rails by using a low-power multiplier. Our power rails were determined by the AD633 IC chip. Using a low-power multiplier would be a large step towards making this circuit portable, since smaller power supplies would enable using fewer batteries, and more common voltage regulators. We noticed -5V voltage regulators were easier to find than -9V regulators.", "step_imgs": [], "step_title": "Step 13: Be Creative With Your Ultrasound Listener!"}], "channel": "Electronics"}, {"category": "technology", "description": "The goal of this project is to teach you how to control the analog discovery with LabVIEW. In particular this project will demonstrate how to control the analog discoveries wave form generator. You can control the frequency and amplitude using a 2d box. Depending on where you click inside the 2d box, a different frequency and amplitude will be played. The intention was to make an audible tone generator similar to this one. To hear the tones being played you can plug headphones or speakers into the Analog Discovery\u2019s 3.5mm jack.Waveform Generator DetailsThe LabVIEW project lets you generateSine wave Square wave  Triangle wave Ramp Up Wave   Ramp Down WaveThe project allows you to control the following aspects of the waveformsWaveform type Frequency Amplitude/Volume  Phase shift  DC offset NOTE: For this project DC offset is set to a constant of 0. DC offsets can potentially damage speakers/headphones. If you do not intend to use the project for generating audible tones with speakers connected, feel free to replace the DC offset constant with a control.Click here to see a preview of the project. ", "title": "Controlling the Analog Discovery\u2122 Waveform Generator in LabVIEW", "url": "https://www.instructables.com/id/Controlling-the-Analog-Discovery-Waveform-Generato/", "section": "technology", "steps": [{"step": 1, "steps_text": "Perquisites: You must have completed step 2 in the previous project. Following Option 2.1 (i.e Install LabVIEW) from the previous project is required. HardwareAnalog Discovery: LinkSoftwareWaveForms version 2.6.2 or later LabVIEW (versions 2013 and 2014 have been tested to work so far) ", "step_imgs": [], "step_title": "Step 1: Materials"}, {"step": 2, "steps_text": "To properly understand how this project functions, it is important to understand the Waveforms SDK. Normally the analog discovery is controlled through the free software package Waveforms. WaveForms also comes with an open source development kit. This SDK gives you access to a C/C++ API library allowing anyone to write their own software interface for the Analog Discovery. An overview of all the functions available in the API can be found in the WaveForms Reference Manual.At its core this LabVIEW project is simply calling the C/C++ API functions. Special VIs usedto call each individual Waveforms API function in LabVIEW. You can see list of the available API functions by clicking the digilent.lvllib in the project window. Every VI in this list has a corresponding C/C++ API function. For more info about how each function works refer to the WaveForms Reference Manual, as illustrated in the image above. If you want to learn more about how to call C functions in LabVIEW check out the following links.https://decibel.ni.com/content/docs/DOC-9076https://decibel.ni.com/content/docs/DOC-9079", "step_imgs": ["https://cdn.instructables.com/FY1/VN68/I6W2TZRA/FY1VN68I6W2TZRA.LARGE.jpg"], "step_title": "Step 2: Preface"}, {"step": 3, "steps_text": "In GUI Main, the code is a simplified derivative of GUI Main from the previous LabForms Project. For neatness a lot of the Waveforms API calls have been grouped together into subVIs. In the new GUI Main there are two primary sections to focus on, the Device Selection Loop and the Run Device Functions section.   Device Selection Loop The Device Selection Loop has a couple primary functions. First it searches for compatible devices to connect to using the \"Find Connected Devices.vi\". A refresh button option has been added so you can connect a device after starting the GUI Main.vi.  The \"Find Connected Devices.vi\" checks to make sure no other applications are already using the device you want to open. If the device is already in use, the front panel controls are configured so the \"OK\" button is grayed out. This prevents you from opening a device that is already in use. If the device isn't in use you can hit 'OK' to move on to the opening process. Once the opening process beings the Device Selection Loop terminates, and the Run Device Functions section is initiated.Run Device FunctionsThe first portion of this section opens the selected device. The process is rather self explanatory and does not need to be explained in detail. Refer to the numbered comments in the code for more info. Once the device is opened, any custom VI you designed will begin to run. In this project the \" GUI Custom Waveform  Gen.vi\"  is run. If you want to scope your custom signal output, you can click the Enable Scope button before selecting the device. This will open the standard oscilloscope window from LabForms.", "step_imgs": ["https://cdn.instructables.com/F8B/ZO2W/I6W2TZUL/F8BZO2WI6W2TZUL.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Main GUI Code Overview"}, {"step": 4, "steps_text": "The custom waveform generator does a couple of things. The first time it is called, both waveform Channels W1 and W2 are enabled (see the code in the top left of the loop).   Next some calculations are done to convert cursor position with in a 2d box, into amplitude and frequency of a waveform. Refer the the comments in the code for details. Generate Wavefrom/Event StructureThe core of this project is generating analog signals. This is done in event structure, using \"Generate Waveform.vi\". This sub VI simply calls a handful of WaveForms API functions that control the Analog discovery. A picture of the Generate Waveform.vi code is included above. It depicts which API functions are used to control the Analog Discovery's signal generator.  For more info on how these API functions work refer to the WaveForms SDK reference manual. For the waveform generation to work well it is important to note the context in which the Generate Waveform.vi is called. This VI should be called in a Event Structure so it is only activated when some event occurs. Calling Generate Waveform.vi every loop iteration causes performance issues, and discontinuities in the output waveform. This event structure contains two different cases. Event Structure Case[0]:The fist is a timeout case. It is important that a timeout duration is supplied by wiring a value to the small hourglass in the top left of the event structure. Failing to do so can cause the whole project to freeze running. Event Structure Case[1]:This event case is the one that calls the Generate Waveform.vi it is set to be triggered when the mouse is clicked within the picture boundaries, moves with in the picture boundaries, or exits the picture boundaries. If you want, you can edit the events handled by the case by right click on the event structure and clicking the corresponding tab. Drawing a Cursor on the 2d PictureIf you are curious about how to draw a cursor on the 2d picture check out the subVI code above. The comments in the code explain how the cursor is drawn. ", "step_imgs": ["https://cdn.instructables.com/FVH/8AT1/I6W2TZXI/FVH8AT1I6W2TZXI.LARGE.jpg", "https://cdn.instructables.com/F8T/JBA8/I735XZDN/F8TJBA8I735XZDN.LARGE.jpg", "https://cdn.instructables.com/FYF/01R1/I735XZDP/FYF01R1I735XZDP.LARGE.jpg"], "step_title": "Step 4: Custom Wavefrom Generation Code Overview"}, {"step": 5, "steps_text": "To get things running open the LabVIEW project. Once the project window has opened double click the \"GUI Main.vi\". Once the the front panel has open for this VI do what is depicted in this gif to get the waveform generator running. Physical Wiring for WaveGen/ScopeIf you want to view the waveform being generated in the scope panel, you must wire the waveform an analog output and analog input pins (see image above). For pin details refer to the Analog Discovery pinout.Properly Stopping the ProjectTo get the entire project to stop, you must hit the stop buttons on all the windows that popped up. The GUI main window does not have a stop button, and will automatically stop once you have properly closed the other windows.", "step_imgs": ["https://cdn.instructables.com/FNP/FSMM/I735Y1X5/FNPFSMMI735Y1X5.LARGE.jpg"], "step_title": "Step 5: Running the Project"}], "channel": "Electronics"}, {"category": "technology", "description": "I have, for some unknown reason, always been interested in ancient technology, mainly electronics and mechanical things and I have always wanted to make a true old fashioned style crystal radio. A crystal radio, or crystal set as it is sometimes called, is a radio that only uses the power of the radio waves picked up by the antenna to generate the sound heard in the head phones. The reason it is called a crystal set is because they use a mineral crystal as a diode for the detector in the circuit.\rQuite a few years ago I found a book in the library called \"Radios That Work for Free\" by K E Edwards and found a set of plans for a radio that I just had to make, unfortunately I did not have the resources to build it at the time so I made a photo copy of the pages from the book for future reference. Well I was poking around on the net the other day and found a site that sells copies of that old book, along with various other electronics books and parts related to crystal radios and decided to order a copy for myself along with two 365 pf variable capacitors needed for the circuit I copied from the book. \rThe radio that I am going to build is the second one shown in the book but I am going to make some changes to the original set. The three changes I am going to make to the set are that I am going to build the set into a box instead of just having the control panel attached to a base board. I am also going to make an antique style \"Cats Whisker\" style detector instead of using a Germanium diode and use a matching transformer so I can use a set of modern headphones instead of trying to find an antique high impedance set or a crappy little crystal earplug. \rI have written this instructable assuming the reader has basic wood working and electronics skills like making boxes and soldering, explaining the more involved and specific tasks in detail, as in winding the coil.", "title": "Build an Antique Style Crystal Radio", "url": "https://www.instructables.com/id/Build-an-antique-style-crystal-radio/", "section": "technology", "steps": [{"step": 1, "steps_text": "Here is a scan of the circuit from the book. The circuit is actually pretty simple, just two variable capacitors(C1 & C2), a coil(L) with 8 taps and a tap switch(S), a detector(D) and a set of phones(P). \rWithout getting into the rather intensive math involved, I have taken classes on this stuff, here is in a nutshell how it all works. \rCrystal radios mainly work on AM or Amplitude Modulation radio waves, there are some that well work on FM as well. AM radio waves are actually composed of two waves combined together, one is a high frequency wave called the carrier wave and the other is the lower frequency sound waves being transmitted. The carrier wave is on the order of 750 to 1500 kHz. and is used to transmit the sound wave. The way it works is that the two waves are added together, or modulated, producing a signal that is of the same frequency as the carrier wave but its amplitude is determined by the sound wave(see second picture).\rThe way a crystal radio actually works is pretty ingenious, it uses the coil L and variable tuning capacitor C1 as a low pass filter to only allow frequencies at the desired frequency of the carrier wave to be passed to the detector D. The detector then demodulates the signal by only letting the low frequency part of the signal to pass, ie the sound wave, to the headphones where they are then turned back into sound. There are no batteries, no transistors or amplifiers of any kind, the sound is produced solely by the energy of the filtered radio wave.  ", "step_imgs": ["https://cdn.instructables.com/F45/4JCN/F5VMX97Z/F454JCNF5VMX97Z.LARGE.jpg", "https://cdn.instructables.com/FB5/C61U/F5VMX99W/FB5C61UF5VMX99W.LARGE.gif"], "step_title": "Step 1: Circuit and Theory"}, {"step": 2, "steps_text": "-Hardware:3 x 6-32 2\" long screws11 x 6-32 3/8\" long screws2 x 6-32 3/4\" long screws6 x 6-32 1/4\" long screws4 x #6 1/2\" long wood screws22 x 6-32 hex nuts2 x 6-32 thumb nuts8 x #6 washers- sheet of 1/8\" thick Plexiglas for panel1 x 1/2\"x6\"x4' board, I used poplar as it is cheaper and looks nice you could also use pine or oak or what ever you like.1 x 3/8\"x6\"x2' board, again I used poplar-some thin copper sheet, or brass (Scrap metal dealer or hobby shop) $4 for a large piece 1 x 3/8\" dowel (All above items are from the hardware store. I used brass but steel would be a significantly cheaper) $91 x 2\" diameter 5\" long cardboard tube, you could also use pvc (mailing tube or hardware store)-Electronic Bits:1 x binding post (AES S-H226B or RS, AES has single binding posts instead of multi packs) $214 x solder lugs (AES S-H112) Package of 10 from AES $12 x 3/4\" Fahnstock (AES)1 x 1N34 Germanium diode1 x 1/4 lb roll of 20 awg enameled copper wire (AES S-WL3-610 has 21 gauge wire which should be close enough)1 x short piece of 12 gauge bare copper wire (got mine from a scrap if Romex)2 x 365 pf air gap variable capacitors (AES C-V365) $12 each1 x chunk of iron pyrite (Rock shop or sometimes gift shops have things of different minerals)1 x 1K to 8 ohm matching transformer (RS# 273-1380) $31 x 1/4\" stereo phone jack (RS# 274-249) $3 2 x large knobs (RS)  $2- 22 gauge hookup wire (RS or AES has the old fashioned style fabric covered wire which would look real good but it is expensive) $6 for three 25 foot rolls from radio shack  -Optional:- Stain for staining the box- Lacquer or other clear coat to protect the box- Black paint for the panel and tap switch knobSuppliers:AES: Antique Electronic Supply, has all kinds of antique style parts, vacuum tubes and stuff you generally can not get any where else. Antique Electronic SupplyRS: Radio Shack, they still have one or two things in stock that are useful.Substitutes: The copper, iron pyrite, 10 3/8\" screws, one of the 2\" long screws and 12 of the nuts are used to make a tap switch and detector for the set and can be substituted with commercially made parts if you do not wish to make them by hand. The tap switch can be replaced with a 10 position rotary switch and the detector can be replaced with a 1N34 Germanium diode, both of which are available from Radio Shack. I made them on mine because I wanted to make the set as authentic looking as possible, mind you the modern substitutes would be more reliable and quicker.-Tools:- Hobby Knife or utility knife- Drill and bits 1/16\" and 5/32\"- Pliers, needle and regular- Ruler- Pencil- Marker- Tin Snips- Metal File- Wood Saw - Hammer and 1\" long finish nails- Nail set- Wood putty- Wood glue- Super Glue - Soldering iron and solder- Wire cutter and striper", "step_imgs": [], "step_title": "Step 2: Materials"}, {"step": 3, "steps_text": "To wind the coil you well need:\r- 2\" diameter tube\r- 1/4 lb of 20 gauge enameled copper wire\r- ruler\r- pencil\r- small drill\r- pliers\r- wire cutters\r1) Mark and cut the tube to length:\r     -With a ruler mark the tube at 5 inches from on end and wrap tape around the tube at that mark.\r     -With a sharp knife cut along the edge of the tape to make a nice even cut.\r2) Using a ruler draw a strait line across the length of the tube.\r3) Using the ruler make a mark on the line 1/2 inch from one end of the tube, this is were the coil well start.\r4) Using a small drill, make a hole on the previously made mark, also make another hole about 1/4 down from that hole, the two holes well be used to secure the end of the wire.\r5) Unwrap a few inches of wire from the end of your spool of wire and feed the end through the first hole drilled in the tube.\r6) Pull the end of the wire through the first hole a couple of inches and then feed it back out through the other hole, this well lock the end of the wire onto the tube.\r7) Start carefully wrapping the wire around the tube away from the starting hole. The hardest part is to keep the windings tight and even.\r8) At the fifth winding use the pliers to make a loop in the wire by holding the wire in the pliers and folding the two ends down the twisting the wire around once. \r9) Continue to wind the coil and make another loop at wraps 10, 16, 24, 32, 40, 52 and 65 after the loop at wrap 65 there are no more loops but you have to continue to wind the coil until you have 80 wraps. These loops well become the taps in the coil in the finished circuit.\r10) Once you have made 80 wraps drill two more holes, one on the line and one about 1/4\" above it, right next to the previous wrap.\r11) Cut the wire from the spool leaving a few extra inches of wire to feed through the holes.\r12) Feed the wire through the first hole and back through the second, just like at the start and pull the wire tight to insure the windings are tight.\r13) Measure the tube 1/2 inch from the end of the windings and cut off the excess tube so that the tube is even.  ", "step_imgs": ["https://cdn.instructables.com/FI6/P384/F5LD3T3H/FI6P384F5LD3T3H.LARGE.jpg", "https://cdn.instructables.com/F4P/I96V/F5LD3T3J/F4PI96VF5LD3T3J.LARGE.jpg", "https://cdn.instructables.com/FB4/Z4BX/F5LD3T3L/FB4Z4BXF5LD3T3L.LARGE.jpg", "https://cdn.instructables.com/FUK/NQA7/F5LD3T3R/FUKNQA7F5LD3T3R.LARGE.jpg", "https://cdn.instructables.com/F22/A7EF/F5LD3T3U/F22A7EFF5LD3T3U.LARGE.jpg", "https://cdn.instructables.com/FA7/4ZSP/F5LD3T3T/FA74ZSPF5LD3T3T.LARGE.jpg", "https://cdn.instructables.com/FSD/QM9Q/F5LD3T3P/FSDQM9QF5LD3T3P.LARGE.jpg", "https://cdn.instructables.com/F26/NT7J/F5LD3T3O/F26NT7JF5LD3T3O.LARGE.jpg", "https://cdn.instructables.com/FV5/6WHO/F5LD3T3Q/FV56WHOF5LD3T3Q.LARGE.jpg", "https://cdn.instructables.com/FJI/BSFY/F5LD3T3N/FJIBSFYF5LD3T3N.LARGE.jpg", "https://cdn.instructables.com/FLI/I19H/F5LD3T3F/FLII19HF5LD3T3F.LARGE.jpg", "https://cdn.instructables.com/FME/OTVZ/F5LD3T3K/FMEOTVZF5LD3T3K.LARGE.jpg", "https://cdn.instructables.com/FI8/WCB2/F5LD3T3D/FI8WCB2F5LD3T3D.LARGE.jpg", "https://cdn.instructables.com/F7Q/0INL/F5LD3T3E/F7Q0INLF5LD3T3E.LARGE.jpg"], "step_title": "Step 3: Winding the Coil"}, {"step": 4, "steps_text": "In this step we well make the pieces for the tap switch. The tap switch is used to select from the different sections of the coil using the loops/ taps made when we wound the coil. If you decide you do not want to make the tap switch from scratch you can use a rotary switch instead. Also in the next step I am going to show how to make the cats whisker detector, this was one of the first types of detectors invented for use in radios, it uses a piece of mineral, like galena or in my case iron pyrite, and a fine wire to act as a simple diode. If you do not want to make the detector by hand you can use a common 1N34 germanium diode available from Radio Shack instead.\rTo make the tap switch you well need:\r- strip of thin copper or brass 3/8\" wide\r- one 2\" long screw \r- one 1\" long piece of dowel\r- one hex nut\r- one washer\r- super glue\r- paint or stain and lacquer\rTools:\r- tin snips\r- drill\r- metal file\r- pliers\r- paint brush\r1) Using a ruler and utility knife score a line 3/8\" of an inch from one end of you sheet of copper.\r2) Using tin snips cut the strip out along the line and re-flatten the strip with a hammer on a hard surface.\r3) Cut the strip to 1-9/16\" long.\r4) Mark the strip 3/8\" from one end all the way across. At the other end of the strip opposite the end you just marked measure in from each side 1/16\" along the top. scribe a line from the marks on the top to the line 3/8\" from the bottom and cut along the line with tin snips, this tappers the pointer down to 1/4\" at the top. See forth picture.\r5) Use a file to clean up the edges and round the ends of the pointer.\r6) Cut a piece of dowel 1/2\" long and drill a hole 5/32\" down the center.\r7) Holding a the dowel in position on the pointer use a nail in the center hole of the dowel to make a mark and drill a 5/32\" hole through the pointer at that mark.\r8) Slide a washer over the 2\" long screw and then slip the dowel and pointer on after. Using a small drop of super glue, glue the pointer to the dowel and thread the nut onto the screw and tighten the nut.\r9) You can either paint the knob, stain it like I am doing or just clear coat it and keep it the natural color of the wood.", "step_imgs": ["https://cdn.instructables.com/F3N/ZVOZ/F5QTFYI6/F3NZVOZF5QTFYI6.LARGE.jpg", "https://cdn.instructables.com/FY6/NE5P/F5QTFYI4/FY6NE5PF5QTFYI4.LARGE.jpg", "https://cdn.instructables.com/FY3/S1XF/F5QTFYI1/FY3S1XFF5QTFYI1.LARGE.jpg", "https://cdn.instructables.com/FYZ/ER68/F5QTFYHW/FYZER68F5QTFYHW.LARGE.jpg", "https://cdn.instructables.com/FWY/PC7C/F5QTFYHU/FWYPC7CF5QTFYHU.LARGE.jpg", "https://cdn.instructables.com/FC3/B3UY/F5QTFYI2/FC3B3UYF5QTFYI2.LARGE.jpg", "https://cdn.instructables.com/F7S/3RUE/F5QTFYI5/F7S3RUEF5QTFYI5.LARGE.jpg", "https://cdn.instructables.com/F9D/IPB5/F5QTFYHV/F9DIPB5F5QTFYHV.LARGE.jpg", "https://cdn.instructables.com/FCU/QONH/F5QTFYHZ/FCUQONHF5QTFYHZ.LARGE.jpg", "https://cdn.instructables.com/FFB/CNX7/F5QTFYHY/FFBCNX7F5QTFYHY.LARGE.jpg", "https://cdn.instructables.com/FVG/FWB1/F5QTFYI3/FVGFWB1F5QTFYI3.LARGE.jpg", "https://cdn.instructables.com/FP8/7DHK/F5QTFYHX/FP87DHKF5QTFYHX.LARGE.jpg", "https://cdn.instructables.com/F9A/QCYM/F5QTFYI0/F9AQCYMF5QTFYI0.LARGE.jpg"], "step_title": "Step 4: Making the Tapswitch"}, {"step": 5, "steps_text": "As mentioned you can omit this step in favor of a modern Germanium Diode instead, I have decided to make the detector from scratch to make the set more authentic. I well probably install a set of terminals so that I can use a diode as well if I do not want to fiddle with the Whisker.I actually got the plans for this detector from the book, \"The Boys first book of radio and electronics\" by Alfred P. Morgan. This is a really great old book with loads of information on this kind of stuff with numerous plans for crystal radios, a tube radio and tube amplifiers, I would highly recommend this and any other book by this author if you can find them. To make the detector you well need:1 - 3/8\" wide strip of copper 1-7/8\" long1 - piece of heavy gauge copper wire about 2-1/2\" long1 - spring from a worn out ball point pen1 - binding postTools:- pliers- tin snips- strait edge and utility knife- drill and 5/32\" drill bit- file- soldering iron and solder1) Start by cutting a strip of 3/8\" wide copper 1-7/8\" long to make the crystal holder.2) Mark and drill a 5/32\" hole in the middle of the strip of copper.3) Using a file on edge cut teeth into the ends of the strip of copper.4) Using a large pair of pliers with jaws that are about 1/2\" wide, hold the hold the strip of copper in the middle so that the strip is perpendicular to the jaws. Fold the two ends up.5) Bend the serrated ends over to make a set of jaws to hold the raw iron pyrite.(see photos)6) Take the spring from the pen and straiten out one end so that it is about 3/4\" long and then solder the spring to the end of the piece of bare copper wire. ", "step_imgs": ["https://cdn.instructables.com/FYF/HLRA/F5VMX9SP/FYFHLRAF5VMX9SP.LARGE.jpg", "https://cdn.instructables.com/FKR/ZCVW/F5VMX9SO/FKRZCVWF5VMX9SO.LARGE.jpg", "https://cdn.instructables.com/FPD/5BF7/F5VMX9SQ/FPD5BF7F5VMX9SQ.LARGE.jpg", "https://cdn.instructables.com/F9M/FODP/F5VMX9SL/F9MFODPF5VMX9SL.LARGE.jpg", "https://cdn.instructables.com/FKN/16AK/F5VMX9SK/FKN16AKF5VMX9SK.LARGE.jpg", "https://cdn.instructables.com/FS4/KMVT/F5VMX9SM/FS4KMVTF5VMX9SM.LARGE.jpg", "https://cdn.instructables.com/FRQ/2MH4/F5VMX9SJ/FRQ2MH4F5VMX9SJ.LARGE.jpg", "https://cdn.instructables.com/FHS/COUG/F5VMX9SH/FHSCOUGF5VMX9SH.LARGE.jpg"], "step_title": "Step 5: Making the Cats Whisker Detector"}, {"step": 6, "steps_text": "The case is made of 1/2\" think by 6\" wide boards, I am using Poplar on mine as it is cheap and accepts stain well.To make the case you well need:1 x 1/2\"x6\"x4' long board1 x 3/8\"x6\"x2' long board- glue- nails- finishing supplies, paint, stain, whateverTools:- Saw, I am using a power miter box because I am lazy- Hammer, again I am lazy so I am using a pneumatic brad nailer with 1\" long brads- Sanding block and sand paper, I use 220 because it well wear down to finer and finer grades as you use it so it leaves a nice surface for finishing. 1) The first thing that has to be done is to cut the boards to length to make the sides and front and back. You well need to cut 2 1/2\"x6\"x9\" long boards for the front and back and 2  1/2\"x6\"x7\" long boards for the two sides, also cut 2 3/8\"x6\"x7\" long boards to be glued together for the bottom.2) Next you need to glue the two sides and front and back together to make a box, the two side pieces go between the front and back not on the ends of the front and back.3) Now would be a good time to use some wood putty to fill in the holes left by the nail set, or in my case the hammer of the pneumatic brad nailer.4) To make the bottom you well need to glue the two 3/8\" pieces that are cut to 7\" long along the sides that are 7\" long. Start by sticking a wide piece of masking tape, 1\" is probably good enough, along the 7\" long edge of one of the boards leaving it sticking out half way, see photo.5) Butt the other piece of wood up to the first one and align the ends so that they are flush and stick the tape down to the other board while holding the two firmly together.6) Once the tape is stuck to the other board flip the two over and fold them together so you can apply glue to the edges that well be stuck together.7) Spread some glue to the edge of one of the boards where the seam well be and lay the two boards out flat again of a flat hard surface.8)  Push down along the seam to ensure that the two boards and even and all the excess glue squeezes out and wipe up the excess.9) Put another piece of tape alone the seam on this side making sure that the seam is flat and even then place another board on top of the two being glued together and place a heavy weight on top of that to hold it down while it is drying.10) After the glued has dried on the bottom, pull the tape off and trim it to length so that it fits inside of the bottom of the box and glue it in.11) I also decided to make a lid for my prototype, I glued two boards together the same way as I did on the bottom and cut it to size so that it sets over the top of the box.12) Next add some slats to the inside of the box to screw the panel to, if you are making a lid set the slats down 1\" from the top, it not set them 1/8\" from the top so that the panel well be flush with the top of the box.13) Finish the box with what ever finish you desire, I chose to staining mine and then coating it with two coats if polyurethane, you could paint it instead which would be simpler.14) Once the finish has had adequate time to dry, tape the top down to the top of the box in the orientation that is well be in when finished on the three sides that well not be hinged.15) Using pieces of tape to hold the hinges in place, drill pilot holes for the hinge screws and install the lower screws. After the bottom half of the hinge is mounted pull the tape off and attach the upper half.16) Remove the tape holding the top on and make sure the hinges do not bind.", "step_imgs": ["https://cdn.instructables.com/FEJ/WRUA/F5R8MPXY/FEJWRUAF5R8MPXY.LARGE.jpg", "https://cdn.instructables.com/FOW/8C81/F5R8MPY0/FOW8C81F5R8MPY0.LARGE.jpg", "https://cdn.instructables.com/FWQ/XV3X/F5R8MPY2/FWQXV3XF5R8MPY2.LARGE.jpg", "https://cdn.instructables.com/FYV/EBK7/F5R8MPY9/FYVEBK7F5R8MPY9.LARGE.jpg", "https://cdn.instructables.com/F4L/0RFM/F5R8MPY8/F4L0RFMF5R8MPY8.LARGE.jpg", "https://cdn.instructables.com/F0A/3NLH/F5R8MPYB/F0A3NLHF5R8MPYB.LARGE.jpg", "https://cdn.instructables.com/FJ9/11BP/F5R8MPYA/FJ911BPF5R8MPYA.LARGE.jpg", "https://cdn.instructables.com/FGW/0C9X/F5R8MPY6/FGW0C9XF5R8MPY6.LARGE.jpg", "https://cdn.instructables.com/FE5/DB0M/F5R8MPY5/FE5DB0MF5R8MPY5.LARGE.jpg", "https://cdn.instructables.com/FHR/IMS0/F5R8MPY7/FHRIMS0F5R8MPY7.LARGE.jpg", "https://cdn.instructables.com/FR9/M60V/F5R8MPY3/FR9M60VF5R8MPY3.LARGE.jpg", "https://cdn.instructables.com/FIZ/2G1N/F5R8MPY4/FIZ2G1NF5R8MPY4.LARGE.jpg", "https://cdn.instructables.com/FSI/VAXQ/F5R8MPXW/FSIVAXQF5R8MPXW.LARGE.jpg", "https://cdn.instructables.com/FNV/GZPJ/F5R8MPXX/FNVGZPJF5R8MPXX.LARGE.jpg", "https://cdn.instructables.com/FOU/4ZU3/F5R8MPXZ/FOU4ZU3F5R8MPXZ.LARGE.jpg", "https://cdn.instructables.com/FFZ/KVNP/F5R8MPY1/FFZKVNPF5R8MPY1.LARGE.jpg", "https://cdn.instructables.com/FHC/6GWM/F5VMX9AJ/FHC6GWMF5VMX9AJ.LARGE.jpg", "https://cdn.instructables.com/FST/V80D/F5VMX92V/FSTV80DF5VMX92V.LARGE.jpg", "https://cdn.instructables.com/FMB/8K3F/F5VMX9AL/FMB8K3FF5VMX9AL.LARGE.jpg", "https://cdn.instructables.com/FMW/FQ37/F5VMX9AK/FMWFQ37F5VMX9AK.LARGE.jpg", "https://cdn.instructables.com/FAH/9TBN/F5VMX9AI/FAH9TBNF5VMX9AI.LARGE.jpg", "https://cdn.instructables.com/FQD/UAA4/F5VMX9UG/FQDUAA4F5VMX9UG.LARGE.jpg", "https://cdn.instructables.com/F8R/X2KB/F5VMX9UF/F8RX2KBF5VMX9UF.LARGE.jpg"], "step_title": "Step 6: Making the Case"}, {"step": 7, "steps_text": "To make the front panel you well need- some 1/8\" Plexiglas- graph paper- pencil and ruler- tape- drill and 5/32\" drill- metal strait edge- utility knife 1) Start by cutting the Plexiglas to size, the easiest way to do this it to use a strait edge and knife to score the Plexiglas and then to break it by firmly holding it over a sharp edge and snapping off the excess. If you are mounting the panel on top of the box make the panel 8\" by 9\", if you are mounting it inside of the box like I am cut the panel to 7\" by 8\".2) Next you well need to figure out who you well want to have the panel laid out. To do this you well need to collect all of your parts so that you know who big things are and how they well have to be in relationship to everything else. 3) Next take your graph paper and draw a full size representation of the panel on the graph paper and use your parts as a guide to figure out where all of the holes well need to be drilled to accommodate everything. The only two measurements that are already determined are that the holes for mounting the coil have to be 3-1/2\" apart and that for the tap switch you well need 9 evenly spaced holes around a center hole with a radius of 1-1/4\". It also helps to have the coil and tap switch close together making it easier to wire the two together and keep the wires short.4) Now make a photocopy of your plan and tape it to the front of the panel and use it as a guide to drill the holes in the panel. Note: Plexiglas can be tricky to drill, don't run your drill at too high of speed as it well melt the plastic to much and also don't use too much downward force when drilling as that well cause cracking. It is also a good idea to practice on a small scrap before hand so you can get an idea of what works the best.5) After all the holes have been drilled you can paint the panel if you want, you can also leave it clear if you want to see the insides of the radio which is cool. Start by taking some fine sandpaper or a Scotchbrite pad and scuffing up the surface to be painted. Once the surface is evenly scuffed up clean it with dish soap and dry it thoroughly.6) Paint the panel, I am using black spray enamel.", "step_imgs": ["https://cdn.instructables.com/FL3/FYCB/F5VMX930/FL3FYCBF5VMX930.LARGE.jpg", "https://cdn.instructables.com/FOC/KKMJ/F5VMX92W/FOCKKMJF5VMX92W.LARGE.jpg", "https://cdn.instructables.com/FDJ/F2DY/F5VMX92X/FDJF2DYF5VMX92X.LARGE.jpg", "https://cdn.instructables.com/FD1/NRIJ/F5VMX92Y/FD1NRIJF5VMX92Y.LARGE.jpg", "https://cdn.instructables.com/FIV/50N7/F5VMX92T/FIV50N7F5VMX92T.LARGE.jpg", "https://cdn.instructables.com/FBP/T535/F5VMX92S/FBPT535F5VMX92S.LARGE.jpg", "https://cdn.instructables.com/FBH/5JJR/F5VMX92U/FBH5JJRF5VMX92U.LARGE.jpg", "https://cdn.instructables.com/FRS/L0DZ/F5VMX92P/FRSL0DZF5VMX92P.LARGE.jpg", "https://cdn.instructables.com/FM4/0G3M/F5VMX92O/FM40G3MF5VMX92O.LARGE.jpg", "https://cdn.instructables.com/FGG/Z78W/F5VMX92Z/FGGZ78WF5VMX92Z.LARGE.jpg"], "step_title": "Step 7: Making the Front Panel "}, {"step": 8, "steps_text": "Right now that all the pieces have been made it is time to put it all together.Materials:- all the screws, washers, nuts, solder lugs and other miscellaneous hardware- the case, detector parts, panel, tap switch wiper ectTools:- flat head screwdriver - pliers- 5/16\" open ended wrench- soldering iron and solder- wire cutters and strippers1) First we well start by assembling the tap switch.   a) Start by adding the screws for the tap switch, place a screw in the hole and add a solder lug to the back side and tighten it all down with a nut. Make sure to position the solder lug pointing to the center of the the circle.   b) Slide a washer over the end of the tap switch wiper and install the wiper in the center hole.   c) Slide another washer over the screw and add a nut tightening it down so that the wiper turns with a some resistance so that it well not lose its setting when in use. Slide a solder lug onto the screw and add another nut tightening it down to the other nut locking the two together.   d) Cut the excess screw off.2) Installing the coil.   a) Install the 2\" coil mounting screws through the front of the panel and secure them with nuts.   b) Solder short, about 3\" to 4\" long, pieces of wire to each of the 8 coil taps.   c) Solder the tap wires to the tap switch contacts starting with the first tap a the fifth winding in the first contact and progressing all the way around the tap switch until all 8 taps are wired.   d) The ninth contact of the tap switch is connected to the end of the coil along with a piece of wire that well be used later.   e) Solder a length of wire to the tap switch wiper.    f) Install the coil onto the coil mounting screws with a washer and nut on each side.  3) Installing the remaining components.   a) Mount the stereo headphone jack to the panel.   b) Next mount the crystal holder with a screw, solder terminal and nut. If you are using a germanium diode instead of the crystal holder install a Fahnstock clip instead, still using a screw and solder lug.   c) Mount the binding post for the cats whisker tightening down only lightly so that the binding post can be swiveled back and forth to help aid in setting the detector. Again if using a diode install a Fahnstock clip using a screw and solder lug.   d) Now using 6 6-32 1/4\" long screws, mount the variable capacitors and turn the knob to make sure that the stator does not run into the ends of the screws, if it does you well need to place washers between the panel and the capacitor frames so that they clear.4) Wiring!!!   a) First solder the wire coming from the 9th tap switch contact/ end of coil to the bottom of the binding post.   b) Glue the impedance matching transformer to the back of the panel between detector and the headphone jack and solder one side of the primary winding to the detector crystal holder.   c) Solder one side of the matching transformer secondary to both the ring and tip terminals of the stereo headphone jack. Solder the other end to the sleeve terminal.   d) Solder a wire to connect the frames of the two variable capacitors together. Also solder the unused end of the matching transformer primary to the one of the two capacitor frames. Solder the wire coming from the tap switch wiper to one of the capacitor frames as well.(see photo)   e) Solder a wire from the stator of the tuning capacitor C1, the one closest to the antenna and ground binding posts, to the antenna binding post. Solder another wire from the ground capacitor C2 to the ground binding post.5) Final Assembly   a) Set the panel into the box onto the mounts and install the mounting screws.   b) Use glue stick to glue the dial faces to the front panel and install the knobs.   c) See next step on how to use the set.", "step_imgs": ["https://cdn.instructables.com/F5E/HSSD/F5VMX96A/F5EHSSDF5VMX96A.LARGE.jpg", "https://cdn.instructables.com/FOG/XWTP/F5VMX96C/FOGXWTPF5VMX96C.LARGE.jpg", "https://cdn.instructables.com/F2Z/O4AZ/F5VMX96E/F2ZO4AZF5VMX96E.LARGE.jpg", "https://cdn.instructables.com/F7A/V086/F5VMX96M/F7AV086F5VMX96M.LARGE.jpg", "https://cdn.instructables.com/FR5/BAV9/F5VMX96O/FR5BAV9F5VMX96O.LARGE.jpg", "https://cdn.instructables.com/FZ3/UH4E/F5VMX96L/FZ3UH4EF5VMX96L.LARGE.jpg", "https://cdn.instructables.com/F79/9LNM/F5VMX96N/F799LNMF5VMX96N.LARGE.jpg", "https://cdn.instructables.com/FTG/AQX0/F5VMX96J/FTGAQX0F5VMX96J.LARGE.jpg", "https://cdn.instructables.com/FZ6/P2HY/F5VMX96I/FZ6P2HYF5VMX96I.LARGE.jpg", "https://cdn.instructables.com/FNN/632L/F5VMX96K/FNN632LF5VMX96K.LARGE.jpg", "https://cdn.instructables.com/FJ1/4MKG/F5VMX96H/FJ14MKGF5VMX96H.LARGE.jpg", "https://cdn.instructables.com/FI3/L6RY/F5VMX96F/FI3L6RYF5VMX96F.LARGE.jpg", "https://cdn.instructables.com/FZR/C6B1/F5VMX96D/FZRC6B1F5VMX96D.LARGE.jpg", "https://cdn.instructables.com/FUM/M3J3/F5VMX968/FUMM3J3F5VMX968.LARGE.jpg", "https://cdn.instructables.com/FL7/GI5F/F5VMX969/FL7GI5FF5VMX969.LARGE.jpg", "https://cdn.instructables.com/FPY/FL3K/F5VMX964/FPYFL3KF5VMX964.LARGE.jpg", "https://cdn.instructables.com/F57/J0B1/F5VMX965/F57J0B1F5VMX965.LARGE.jpg", "https://cdn.instructables.com/F97/Z2I5/F5VMX966/F97Z2I5F5VMX966.LARGE.jpg", "https://cdn.instructables.com/FXI/FYWY/F5VMX967/FXIFYWYF5VMX967.LARGE.jpg", "https://cdn.instructables.com/FXR/D95G/F5VMX96G/FXRD95GF5VMX96G.LARGE.jpg", "https://cdn.instructables.com/FL0/7LA6/F5VMX9VR/FL07LA6F5VMX9VR.LARGE.jpg", "https://cdn.instructables.com/F9K/7RF6/F5VMX9VQ/F9K7RF6F5VMX9VQ.LARGE.jpg", "https://cdn.instructables.com/FTZ/6AUL/F5VMX9VM/FTZ6AULF5VMX9VM.LARGE.jpg", "https://cdn.instructables.com/FCF/TG2F/F5VMX9VL/FCFTG2FF5VMX9VL.LARGE.jpg", "https://cdn.instructables.com/FTH/YVCQ/F5VMX9VE/FTHYVCQF5VMX9VE.LARGE.jpg", "https://cdn.instructables.com/FM3/MGBH/F5VMX9VG/FM3MGBHF5VMX9VG.LARGE.jpg", "https://cdn.instructables.com/FF0/7P3X/F5VMX9VF/FF07P3XF5VMX9VF.LARGE.jpg", "https://cdn.instructables.com/FO1/5BP2/F5VMX9VN/FO15BP2F5VMX9VN.LARGE.jpg", "https://cdn.instructables.com/FL2/KE1D/F5VMX9VK/FL2KE1DF5VMX9VK.LARGE.jpg", "https://cdn.instructables.com/FXI/HQLZ/F5VMX9VJ/FXIHQLZF5VMX9VJ.LARGE.jpg", "https://cdn.instructables.com/F3O/WA3U/F5VMX9VC/F3OWA3UF5VMX9VC.LARGE.jpg", "https://cdn.instructables.com/FX1/DZHD/F5VMX9VD/FX1DZHDF5VMX9VD.LARGE.jpg", "https://cdn.instructables.com/F0M/U03D/F5VMX9VH/F0MU03DF5VMX9VH.LARGE.jpg", "https://cdn.instructables.com/FHT/8OSU/F5VMX9VB/FHT8OSUF5VMX9VB.LARGE.jpg", "https://cdn.instructables.com/F45/4JCN/F5VMX97Z/F454JCNF5VMX97Z.LARGE.jpg"], "step_title": "Step 8: Assembly"}, {"step": 9, "steps_text": "1) Start off by connecting up the antenna and ground. For the antenna you can use anything from a long piece of wire tacked up along the top edge of a wall to a nice long outdoor wire antenna. The ground can be any suitable ground connection, ie the center screw on a power outlet, a iron cold water pipe or an outdoor ground spike driven 5 feet into the ground.\r2) Connect up the headphones.\r3) Mount a small piece, about 1/4\", of iron pyrite in the jaws of the detector and position the cats whisker so that it is touching the surface of the iron pyrite. If you are using a germanium diode install it in the Fahnstock clips with the band facing the antenna and ground binding posts.\r4) Turn both knobs all the way to the left and select the 1st tap contact. Start turning the left tuning knob slowly to the right and see if you can find a station, if you find a station but it is towards the high end of the dial move the tap selector up one and turn the tuning knob down until you find it again.\r5) If you are using the antique style detector and the signal is coming in very weakly you can try moving the cats whisker around on the surface of the iron pyrite until it comes in more strongly, this well take some trial and error until you find were it works best.\r6) If you are receiving two stations at once and one is drowning the other out you can use the ground coupling knob to help single out one or the other.\r7) Make a logbook of what settings brought in what stations, this well help finding the station again later.\r8) Fiddle with it, it takes some practice to tune these kinds of radios and remember the only thing powering the radio is the radio waves received by the antenna so the signals well not always be that loud but a nice long antenna well collect more energy producing louder signals.\r", "step_imgs": ["https://cdn.instructables.com/FYN/QOLV/F5VMXADF/FYNQOLVF5VMXADF.LARGE.jpg"], "step_title": "Step 9: How to Use the Radio"}], "channel": "Science"}, {"category": "technology", "description": "This project and its tutorial were completed as part of our CPE 133 final project at Cal Poly San Luis Obispo. Our goal was to create a complete logical game in VHDL using a Nexys 3 FPGA board and an off-board component. Instead of a more conventional game, we designed a photosensitive keyboard to synthesize a range of tones for users to play. Having an actual \"keyboard\" made from photoresistors is what made our project a unique and exciting learning experience.  The \"game\" we made lets users play around with something fun without any winning or end game conditions.Materials:\u00b7      An FPGA board (we used a Nexys 3), and all its accouterments \u00b7      16 photoresistors (for 16 the different notes)\u00b7      16 high value resistors (to prevent noise in the circuit)\u00b7      a compatible speaker\u00b7      38 wires\u00b7      2 breadboards, or one large enough to fit the circuit components\u00b7 Xilinx software", "title": "VHDL Photosensitive Synth Machine", "url": "https://www.instructables.com/id/VHLD-Photosensitive-Synth-Machine/", "section": "technology", "steps": [{"step": 1, "steps_text": "To clarify and visualize the principal functions of our keyboard representation, we created a black box diagram. The various components of the black box diagram include:  a soundboard block, a note decoder block, a clock divider block, a sound wave generator block, and a note multiplexer block.The note decoder block receives the raw signal from the keys and feeds it the key data to the 16 sound wave generator modules.Each sound wave generator contains a clock divider which is constructed with a specific, static frequency for its respective note. All generators output either a low signal or a square wave which feed into a 16-bit wide bus.Finally, the waveform bus goes to a note multiplexer which time multiplexes the signals. The multiplexer selects each signal for 50000 cycles, then switches to the next live signal. The multiplexed output is sent to the speaker pin, which in turn produces a sound with the same frequency as the input square wave.", "step_imgs": ["https://cdn.instructables.com/FHY/EBWY/I3BHGS1U/FHYEBWYI3BHGS1U.LARGE.jpg"], "step_title": "Step 1: Create Black Box Diagram"}, {"step": 2, "steps_text": "The Note Decoder is the first digital logic in our circuit. It uses 16 D-latches within a behavioral architecture to store the input key data more reliably. It also switches the 16 key signals from active-low inputs (photoresistors block current, creating 0's) to active-high outputs. The current note decoder module we are using switches every 2000 cycles, but this value is not too sensitive to change between 100.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: Design Note Decoder Module"}, {"step": 3, "steps_text": "The purpose of the clock divider module is to produce different output frequencies by switching at various clock cycle intervals. Using VHDL, we designed this module consisting of a clock signal, a ten bit wide bus representing the various pitches of frequencies ranging from 262 Hz to 1022 Hz, and a single bit square wave output.The range of the frequencies is determined by the number of bits in the pitch input (10 bits = 1022 max).", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 3: Design Clock Divider Module"}, {"step": 4, "steps_text": "To create a sound process, we designed a sound wave generator in VHDL and instantiated it 16 times in our circuit.  The generator inputs are the clock, a ten bit wide bus representing the specific pitch an enable bit, and a sound output.The generator contains a clock divider that outputs to the generator's sound output. The pitch of the clock divider is the pitch of the generator. The generator's sound process outputs a square wave frequency signal if enabled, otherwise it outputs 0.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 4: Design Sound Wave Generator Module"}, {"step": 5, "steps_text": "A multiplexer is used to select one of the sixteen sound signals generated from the previous VHDL modules, allowing the key specified by the user to be played.  It receives the clock and 16 bits of square wave signals and outputs a single dynamic square wave.Our multiplexer switches at 50000 cycles and skips any notes that aren't playing.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: Design Note Multiplexer Module"}, {"step": 6, "steps_text": "Finally, we got to plug everything in together to see it work. In addition to the soundboard module, there is a switchboard module that relies on the switches on the Nexys 3 board for debugging purposes, however apart from differences in size and inputs, the circuits function the same way.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: Design Soundboard and Switchboard Module"}, {"step": 7, "steps_text": "Our project only had two pieces of hardware to implement off board: the speaker and the keyboard.Thanks to the known laws of physics, it turns out that any speaker with a square wave input will produce a tone with consistent with the tone it would produce if it received a sinusoidal wave. Obviously, with the use of a digital to analog converter, the sound would be cleaner and louder, but our method was much more simple. As you can see from the photos, we simply plugged speakers into the signal and ground pins and they made sounds.The keyboard took significantly more time to implement but was relatively simple:We split an analog power pin between 16 photoresistors. The photoresistors act as opens when they receive light  (not played) and shorts when light is blocked (played). These electrical properties led our circuit to have active-low enables. The other end of the photoresistor connects to a wire and a high-value (10K) resistor in parallel. The wire goes to one of 16 signal pins in the Nexys board and the resistor goes to ground. This completes a grounded input circuit that can send 16 bits of data to the Nexys board.", "step_imgs": ["https://cdn.instructables.com/FTZ/X5WJ/I3BH7VQR/FTZX5WJI3BH7VQR.LARGE.jpg", "https://cdn.instructables.com/F6A/DNSX/I3DQ8TM7/F6ADNSXI3DQ8TM7.LARGE.jpg", "https://cdn.instructables.com/FJM/GUKI/I395S6H9/FJMGUKII395S6H9.LARGE.jpg", "https://cdn.instructables.com/FZZ/EYMQ/I3DQ8TBA/FZZEYMQI3DQ8TBA.LARGE.jpg", "https://cdn.instructables.com/F8D/6FZD/I3DQ8TKL/F8D6FZDI3DQ8TKL.LARGE.jpg"], "step_title": "Step 7: Hardware Implementation"}, {"step": 8, "steps_text": "Create a ucf file that maps your circuit inputs to your keyboard's inputs. Synthesize the design and upload the .bit file to your Nexys board. Putting your finger over the photoresistors should produce a sound from the speaker, though its recommended to do only three or so at a time or the sound will get rather warped (Read: \"ALIENS!!!!\"). If the ambient light in the room is too diffused, you may need a more direct light source to create contrast between the photoresistor inputs.", "step_imgs": ["https://cdn.instructables.com/FBI/1YHU/I3DQ8TBP/FBI1YHUI3DQ8TBP.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 8: Establish Relationship Between Software and Hardware"}, {"step": 9, "steps_text": "To play the keyboard, simply wave your finger above the photoresistors.  For a more defined sound of a specific note, place one finger directly on the photoresistor surface. It spans about 2 octaves, the notes are written in the VHDL processes, starting with middle C and ending with the D two octaves up.  You can produce various tunes, from \"Mary Had a Little Lamb\" to \"Twinkle Twinkle Little Star,\" for example.  Be creative and have fun playing the VHDL photosensitive synth machine!", "step_imgs": [], "step_title": "Step 9: Play the Keyboard and Have Fun!"}], "channel": "Electronics"}, {"category": "technology", "description": "\u00a0This project was quite easy once I played around and figured it out, which took a while.\u00a0The idea is to be able to change the color with a switch, and have a led\u00a0dimming\u00a0options also. \u00a0These are the items you will need to complete this project:2 Pack push button lights found at the 1 dollar store.1 plastic switch (found inside the above lights) (2 if you want on/off function)1 RGB LEDWire (approx 1 foot)Standard volume\u00a0controller\u00a0can be found in cheap electronics such as a headphone cables (which are more advanced then the one i have, ill get into that later) \u00a0or any other device that requires simple volume control...2 AAA Batteries or 3V\u00a0equivalentElectrical TapeYou will need resistors if you are using 5 volts, however you may need resistors with 3volts in order to make the LED last longer, different colors require different resistors, but for this instructable i have left this up for you to decide.", "title": "RGB LED Cheap and Easy Color Changing Night Light", "url": "https://www.instructables.com/id/RGB-LED-cheap-and-easy-color-changing-night-light/", "section": "technology", "steps": [{"step": 1, "steps_text": "Wiring it all upThe steps are quite simple, wire it all up and this will product a blue / green when the button is pushed, you can also take the xtra button from the other light and add an on/off switch before the connection to the battery.\u00a0Volume Control\u00a0They are different in each type of electronics and i am not an expert on them, however i do know if you are able to find one with 5 metal prongs on them instead of the three prong that is used here, you can use it to fade to different RBG colors, it takes some\u00a0experimenting\u00a0but i have tried it you can fade from purple to red to blue to green etc, depending on how your wire setup is, however i soldered to close to the 5 prong volume control i had and messed up the prongs, so i moved onto the next one i found.", "step_imgs": ["https://cdn.instructables.com/FZI/BMB3/G0ZWR1BD/FZIBMB3G0ZWR1BD.LARGE.jpg"], "step_title": "Step 1: Breadboard Setup, Experiment at Will"}, {"step": 2, "steps_text": "\u00a0What not to doAs i mentioned on the previous step, don't solder to close to each prong, as you may end up ruining it.You may notice a metal bracket hanging off the edge of the PCB this was to add xtra support to the volume control, as it needs to be over the edge to fit through the slit in the side of the plastic light to be adjusted. With the three prong volume control it only dims the light.", "step_imgs": ["https://cdn.instructables.com/FKZ/OE2P/G0ZWH6RF/FKZOE2PG0ZWH6RF.LARGE.jpg"], "step_title": "Step 2: Solder the Final Product"}, {"step": 3, "steps_text": "Well its difficult, and you will have to cut a slit for the controls to be used on the outside.", "step_imgs": ["https://cdn.instructables.com/F3P/27JM/G0ZWH6RH/F3P27JMG0ZWH6RH.LARGE.jpg"], "step_title": "Step 3: Fitting It All in There"}], "channel": "LEDs"}, {"category": "technology", "description": "This is a school project in embedded programming. I have chosen to to make a little box that will measure noise. The idea was to figure out if the working area is too loud to work in, and IF it is, you should take precautions. Movie, in mp4, of the object you can find here belowe.", "title": "UCL - Embedded - Noise Meter", "url": "https://www.instructables.com/id/UCLeal-Embedded-Noise-Meter/", "section": "technology", "steps": [{"step": 1, "steps_text": "The box has a small microphone to measure the sound. It then shows the sound level with LED-lamps and on an LCD display how high it is. The display will show the current level and the previous level", "step_imgs": [], "step_title": "Step 1: Step 1: the Project"}, {"step": 2, "steps_text": "1 - Arduino MEGA 25601 - Breadboard 11 - 220 ohm resistors1 - potentiometer 1 - LCD screen 1 - Sound Module11 - LEDs (blue, red, yellow and green)jumpwires9v battery", "step_imgs": [], "step_title": "Step 2: Step 2: Parts"}, {"step": 3, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F9W/7Y09/JOONQI7M/F9W7Y09JOONQI7M.LARGE.jpg"], "step_title": "Step 3: Step 3: Wiring"}, {"step": 4, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FA8/PD7M/JOONQNM4/FA8PD7MJOONQNM4.LARGE.jpg", "https://cdn.instructables.com/F41/ZNIB/JOONRG5J/F41ZNIBJOONRG5J.LARGE.jpg"], "step_title": "Step 4: Step 4: IO List "}, {"step": 5, "steps_text": "//Include LCD library\n#include <liquidcrystal.h>\n\n// initialize the library with the numbers of the interface pins\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nconst int firstLED = 40;\nconst int lastLED = 50;\n\nconst int STATE_GREEN = 40;\nconst int STATE_YELLOW = 45;\nconst int STATE_RED = 48;\nconst int STATE_BLUE = 50;\nconst String STATE_GREEN_TEXT = \"LOW\";\nconst String STATE_YELLOW_TEXT = \"MEDIUM\";\nconst String STATE_RED_TEXT = \"HIGH\";\nconst String STATE_BLUE_TEXT = \"WAY TOO HIGH!\";\n\nint previousState = 0;\n\nunsigned long previousMillis = 0;     // will store last time display was updated\nconst long interval = 3000;           // interval at which to update display (milliseconds)\n\nString line0 = \"\";\nString line1 = \"\";\n\nvoid setup() {\n  Serial.begin(9600);\n\n  //sound sensor\n  pinMode(A0, INPUT);\n\n  //led pins\n  for(int i = firstLED; i <= lastLED; i++) { \n    pinMode(i, OUTPUT);\n  }\n\n  // set up the LCD's number of columns and rows: \n  lcd.begin(16, 2);\n}\n\nvoid loop() {\n  //storing the volume value\n  int volume = analogRead(A0);\n\n  // mapping volume value to make it easier to turn LEDs on (830 instead of 1023)\n  int volumeMapped = map(volume, 145, 160, firstLED, lastLED);\n\n  // we are going through all pins where we have LEDs and checking if the volume\n  // is bigger than pin number (that's why we are maping the volume)\n  for(int i = firstLED; i <= lastLED; i++) {\n    if (volumeMapped >= i) {\n      digitalWrite(i, HIGH); //if it is bigger we can turn on the LED\n    } else {\n      digitalWrite(i, LOW); //if it is smaller we can turn the LED off\n    }\n  }\n\n  // store the current time;\n  unsigned long currentMillis = millis();\n\n  // store the current state (GREEN, YELLOW, RED or BLUE)\n  int currentState = mapVolumeToState(volumeMapped);\n\n  // check to see if the current state is \"higher\" than the last state;\n  // if so, update the display immediately\n  if (currentState > previousState) {\n    // save the last time you updated the display\n    previousMillis = currentMillis;\n\n    displayState(currentState);\n    previousState = currentState;\n  }\n\n  // check to see if it's time to update the display; that is, if the difference\n  // between the current time and last time you updated the display is bigger than\n  // the interval at which you want to update the display.\n  if (currentMillis - previousMillis >= interval) {\n    // update only if the current state is \"lower\" than the last state\n    if (currentState < previousState) {\n      // save the last time you updated the display\n      previousMillis = currentMillis;\n\n      displayState(currentState);\n      previousState = currentState;\n    }\n  }\n}\n\nvoid displayState(int state) {\n  line1 = line0;\n  if (state == STATE_GREEN) {\n    line0 = STATE_GREEN_TEXT;\n  }\n  if (state == STATE_YELLOW) {\n    line0 = STATE_YELLOW_TEXT;\n  }\n  if (state == STATE_RED) {\n    line0 = STATE_RED_TEXT;\n  }\n  if (state == STATE_BLUE) {\n    line0 = STATE_BLUE_TEXT;\n  }\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(line0);\n  lcd.setCursor(0, 1);\n  lcd.print(line1);\n}\n\nint mapVolumeToState(int volume) {\n  if (volume >= STATE_BLUE) {\n    return STATE_BLUE;\n  }\n  if (volume >= STATE_RED) {\n    return STATE_RED;\n  }\n  if (volume >= STATE_YELLOW) {\n    return STATE_YELLOW;\n  }\n  return STATE_GREEN;\n}", "step_imgs": ["https://cdn.instructables.com/FF8/8FHT/JOONQS3C/FF88FHTJOONQS3C.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 5: Step 5: Code"}, {"step": 6, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FF7/EYHN/JOONQLCX/FF7EYHNJOONQLCX.LARGE.jpg", "https://cdn.instructables.com/FE4/7XND/JOONQL61/FE47XNDJOONQL61.LARGE.jpg", "https://cdn.instructables.com/FP9/CMM5/JOIXY0PN/FP9CMM5JOIXY0PN.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: Step 6: the BOX"}, {"step": 7, "steps_text": "The box was not as easy to make as I thought. The microphone is hard to calibrate and the led lights are easy to brake. The wires were far too long, so it was difficult to fit it all in the box in the right places. I have learned a lot, especially of my mistakes! ;-)", "step_imgs": [], "step_title": "Step 7: Step 7: Evaluation"}], "channel": "Arduino"}, {"category": "technology", "description": "\n          This project is related to new storage media.(This soudwaves are recorded messages from your precious.(And you can hear the message everytime you want.See this movie!Sound wave Media from Yusuke Nakamura on Vimeo.-Record-\n1.Record Messages (Rec&Restration.pd \u00a0 \u00a0 samplingrate:5000,arraysize:4000).\n2.Make Circle to cut by laser cutter (CircleMaker.pde)\n\u2193\nLaser cut & Fabrication\n\u2193-Playback-\n3.Take a picture of waveform object.\n(after take a picture of waveform object , you have to edit a picture to binary image. )\n4.Make txt file with soudtxtmaker.pde\n5.Read txt file and playback (Rec&Restration.pd).\n        ", "title": "Waveform Media", "url": "https://www.instructables.com/id/Waveform-Media/", "section": "technology", "steps": [], "channel": "Art"}]