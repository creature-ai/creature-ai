[{"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "In this project, take an old post-box and an Arduino, to create an incredibly functional monophonic synthesizer. This synthesizer includes such features as: - Dual oscillators - 6 wave forms (Sin, Triangle, Left Saw, Right Saw, Square, Flat) - Noise feature on the main oscillator - Adjustable mixing of the two oscillators - Adjustable cents, semitone, and octave for the second oscillator - LFO from 0 to 10 Hz - Routing the LFO to semitone, cents and octave control of the second oscillator - 20 note arpeggio feature with adjustable speed from 0 to 50Hz. - 5 banks for saving presets - Internal speaker and 3.5mm aux output with volume control - LCD - MIDI input - UART inputParts Filter: - 2X 4.7mH inductor - 2X 47nF capacitor - 1X 100nF capacitor - 2X 270 ohm resistor\u00a0 - PC board MIDI Input: - 1X Female MIDI connector - 1X 6N138 opto-isolator - 1X 220 ohm resistor - 1X 270 ohm resistor - 1X 1N194 diode Audio Output: - 1X 3.5mm Female audio jack - 1X 8 ohm speaker - 1X SPDT switch - 1X Amplifier (For this I used a ready made breakout from SparkFun\u00a0https://www.sparkfun.com/products/11044) - 1X 10k ohm potentiometer User Input/Output: - 1X Serial Enabled LCD (20x4 Character LCD from SparkFun\u00a0https://www.sparkfun.com/products/9568) - 6X Tactile Switches - 4X 10k ohm potentiometers Misc: - 1X DC Barrel Jack - 1X 7805 voltage regulator - 1X 5 pin male header - 1X 10k ohm resistor - 1X push switch (for the reset)", "title": "Post-Box Synthesizer", "url": "https://www.instructables.com/id/Post-Box-Synthesizer/", "section": "technology", "steps": [{"step": 1, "steps_text": "The synthesis method used in this project is called DDS, direct digital synthesis. With this method, a digital signal, 1's and 0's, can be turned into an analog signal without the addition of a DAC, digital to analog converter. In fact with DDS, there are very few extra components are actually required; only a low pass filter. The method works by creating a PWM, pulse width modulation, signal and modulating the duty cycle, the amount of time the signal stays on, in proportion to the amplitude of a wave form at a given time. So in the code there is a wave table of one period for various wave forms. The program then steps through the table at different speeds to create different frequencies. The output of the PWM is shown in the image below. As the duty cycle increase, the amplitude of the output wave increases. The filter removes the carrier frequency, the square wave, and leave the clean wave form from the table.", "step_imgs": ["https://cdn.instructables.com/FRQ/YRT9/HJ1WZ5O9/FRQYRT9HJ1WZ5O9.LARGE.jpg"], "step_title": "Step 1: Synthesis Method"}, {"step": 2, "steps_text": "There are a couple ways to create a filter. You can make an RC or LC filter, as long as it's built in a lowpass configuration with a 12.5 kHz cutoff frequency. I used a 2nd Order Chebyshef filter which removes the carrier frequency extremely well, and leaves a smooth sound for the output signal. The schematic is fairly simple, even though it requires inductors, and only needs 7 components. First I tried to just solder the leads together, but then I used a PC board to make is easier, and look a little more professional. It makes connecting the input and output easier and keeps all the components for the filter nice and segmented.", "step_imgs": ["https://cdn.instructables.com/F6P/7YAR/HJ1WZ5OW/F6P7YARHJ1WZ5OW.LARGE.jpg", "https://cdn.instructables.com/FKG/YA1P/HJ1WZ5NF/FKGYA1PHJ1WZ5NF.LARGE.jpg", "https://cdn.instructables.com/FNW/ZN6W/HJ1WZ5NM/FNWZN6WHJ1WZ5NM.LARGE.jpg", "https://cdn.instructables.com/FE1/J3UR/HJ1WZ5NN/FE1J3URHJ1WZ5NN.LARGE.jpg"], "step_title": "Step 2: The Filter"}, {"step": 3, "steps_text": "The first step is to create the wave table. The table is saved into the Atmega328 RAM using the pgmspace library. Each wave table has 256 values from 0 to 255, so each value can be mapped to a byte data type. The sine wave definition is shown below. Each value is the amplitude of the wave at a specific time. This represents one period of the wave. The higher the frequency that is played, the faster the program steps through the table. #include \"avr/pgmspace.h\" //Waveform definitions PROGMEM\u00a0 prog_uchar waveTable[]\u00a0 = { \u00a0 //sine wave \u00a0 0,0,0,0,1,1,1,2,2,3,4,5,5,6,7,9,10,11,12,14, 15,16,18,20,21,23,25,27,29,31,33,35,37,39, 42,44,46,49,51,54,56,59,62,64,67,70,73,76, 78,81,84,87,90,93,96,99,102,105,108,111,115, 118,121,124,127,130,133,136,139,143,146,149, 152,155,158,161,164,167,170,173,176,178,181, 184,187,190,192,195,198,200,203,205,208,210, 212,215,217,219,221,223,225,227,229,231,233, 234,236,238,239,240,242,243,244,245,247,248, 249,249,250,251,252,252,253,253,253,254,254, 254,254,254,254,254,253,253,253,252,252,251, 250,249,249,248,247,245,244,243,242,240,239, 238,236,234,233,231,229,227,225,223,221,219, 217,215,212,210,208,205,203,200,198,195,192, 190,187,184,181,178,176,173,170,167,164,161, 158,155,152,149,146,143,139,136,133,130,127, 124,121,118,115,111,108,105,102,99,96,93,90, 87,84,81,78,76,73,70,67,64,62,59,56,54,51,49, 46,44,42,39,37,35,33,31,29,27,25,23,21,20,18, 16,15,14,12,11,10,9,7,6,5,5,4,\u00a03,2,2,1,1,1,0,0,0, }; To get the Arduino to create the PWM signal, the timer has to be properly initialized. For this I used the C method to setup the timer so that I can better control it. The timer is created so that we have a 32 kHz sampling rate for our audio and the output of the signal is put on 11 of the Arduino. I also enable an overflow interrupt, so that when the timer value goes over 255, the interrupt triggers. void Setup_timer2() { \u00a0 // Timer2 Clock Prescaler to : 1 \u00a0 sbi (TCCR2B, CS20); \u00a0 cbi (TCCR2B, CS21); \u00a0 cbi (TCCR2B, CS22); \u00a0 // Timer2 PWM Mode set to Phase Correct PWM \u00a0 cbi (TCCR2A, COM2A0);\u00a0 // clear Compare Match \u00a0 sbi (TCCR2A, COM2A1); \u00a0 sbi (TCCR2A, WGM20);\u00a0 // Mode 1\u00a0 / Phase Correct PWM \u00a0 cbi (TCCR2A, WGM21); \u00a0 cbi (TCCR2B, WGM22); } This is the overflow interrupt. When the interrupt occurs I calculate the next value that should be pulled from the wave table and write that value to pin 11. A variable called the phase accumulator keeps track of where the program is in the table. ISR(TIMER2_OVF_vect) { \u00a0 phaccu=phaccu+tword_m; // soft DDS, phase accu with 32 bits \u00a0 icnt=phaccu >> 24;\u00a0\u00a0\u00a0\u00a0 // use upper 8 bits for phase accu as frequency information \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // read value fron ROM sine table and send to PWM DAC \u00a0 OCR2A=pgm_read_byte_near(waveTable + icnt + (waveSelect << 8));\u00a0\u00a0\u00a0 \u00a0 if(icnt1++ == 125) {\u00a0 // increment variable c4ms all 4 milliseconds \u00a0\u00a0\u00a0 c4ms++; \u00a0\u00a0\u00a0 icnt1=0; \u00a0\u00a0 }\u00a0\u00a0 } That value is calculated using a tuning word which is found by dividing the frequency you want by a reference clock, in this case the 32kHz reference clock. const double refclk=31376.6;\u00a0\u00a0\u00a0\u00a0\u00a0 // measured tword_m=pow(2,32)*dfreq/refclk;\u00a0 // calulate DDS new tuning word", "step_imgs": [], "step_title": "Step 3: PWM Code"}, {"step": 4, "steps_text": "The note values are stored to an array. You can find the values here:\u00a0http://en.wikipedia.org/wiki/Piano_key_frequencies double keyFreq[] = { \u00a0 27.5, 29.1352, 30.8677,\u00a0\u00a0\u00a0\u00a0 //Octave 0 \u00a0 32.7032, 34.6478, 36.7081, 38.8909, 41.2034, 43.6535, 46.2493, 48.9994, 51.9131, 55, 58.2075, 61.7354,\u00a0\u00a0\u00a0\u00a0 //Octave 1 \u00a0 65.4064, 69.2957, 73.4162, 77.7817, 82.4069, 87.3071, 92.4986, 97.9989, 103.826, 110, 116.541, 123.471,\u00a0\u00a0\u00a0 //Octave 2 \u00a0 130.813, 138.591, 146.832, 155.563, 164.814, 174.614, 184.997, 195.998, 207.652, 220, 233.082, 246.942,\u00a0\u00a0\u00a0 //Octave 3 \u00a0 261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 394.995, 415.305, 440, 466.164, 493.883,\u00a0\u00a0\u00a0 //Octave 4 \u00a0 523.251, 554.365, 587.330, 622.254, 659.255, 698.456, 739.989, 783.991, 830.609, 880, 932.328, 987.767,\u00a0\u00a0\u00a0 //Octave 5 \u00a0 1406.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760, 1864.66, 1975.53,\u00a0\u00a0 //Octave 6 \u00a0 2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96, 3322.44, 3520, 3729.31, 3951.07,\u00a0\u00a0 //Octave 7 \u00a0 4186.01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //Octave 8 }; So notes sent from the MIDI or over UART have an appropriate value, instead of having to be calculated on the fly. The second oscillator can be detuned from the first in 3 ways. 1. Is using a system called cents, which are fractions of a note. \u00a0Calculated like this: centMultiplier = pow(2.0,(cents + dC)/1200.0); That value is then multiplied to the note frequency. 2. Is using a system called semi, which are full note shifts from -1 to +1 octave 3. Finally by full octaves from -3 to +3 The two oscillators are then mixed by using an adjustable weight. byte osc1 = ((pgm_read_byte(waveTable + icnt1 + (osc1WaveForm<<8))*weight1)/MAX_WEIGHT); //first osc byte osc2 = ((pgm_read_byte(waveTable + icnt2 + (osc2WaveForm<<8))*weight2)/MAX_WEIGHT); //second osc The two values are then summed. The weight value goes from 0 to 16. So you can have entirely the first oscillator, entirely the second, or some mixture in between. The LFO adjusts the detuning of the second oscillator by adjusting the values in proportion to the amplitude of the wave.So it works in a similar way to the first 2 oscillators but instead of creating sound, it tweaks values.", "step_imgs": [], "step_title": "Step 4: Note Effects"}, {"step": 5, "steps_text": "The arpeggiator is a system that creates an arpeggio based upon the notes played when in arpeggio mode. When arpeggio mode begins, you play a note. That note becomes the root key. Every key hit afterward is saved to an array, of a max of 20 notes. The value stored to the array is the difference between the note played and the root key. if(appMode) //add notes to the app array \u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(appMaxCount == 0) //if just starting app mode \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 rootKey = note - MIDI_OFFSET; //get new root key, all notes in array are relative to this value \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 else \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 app[appMaxCount - 1] = noteSelect - rootKey; //calculate relative note \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appMaxCount++; //increment number of notes in app array \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(appMaxCount > MAX_APP_NOTES) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appMode = false; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appUpdate(); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0\u00a0\u00a0 } When playing, the arpeggio array is stepped through at a speed depending on the value from one of the control potentiometers. The value in the array is added to the note being played. noteSelect = rootKey + app[appCount]; \u00a0\u00a0\u00a0 appTimer = millisecs; \u00a0\u00a0\u00a0 appCount++; //move through the array \u00a0\u00a0\u00a0 if(appCount >= appMaxCount) \u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0 appCount = 0; \u00a0\u00a0\u00a0 }", "step_imgs": [], "step_title": "Step 5: Arpeggiator"}, {"step": 6, "steps_text": "To start, wire the MIDI connector according to the schematic. It's important to note that the MIDI connector is probably upside down in the schematic, make note before you start soldering. The point of the opto-isolator is to keep the signal from the MIDI controller from damaging the control board. The output from the opto-isolator is connected to the serial input, RX, pin on the Arduino. The MIDI in is serial at 32150 baud. The system is 3 bytes. The first byte is whether or not the note is on or off. The second is the note value and the third is the velocity, but I ignore that. I handle it with a serial event. void serialEvent() { \u00a0 if(Serial.available() >= 3) //messages in 3 byte packets \u00a0 { \u00a0\u00a0\u00a0 byte cmd = Serial.read(); \u00a0\u00a0\u00a0 byte note = Serial.read(); \u00a0\u00a0\u00a0 byte vel = Serial.read(); \u00a0\u00a0\u00a0 if(cmd >= 0x80 && cmd <= 0x8F && (rootKey == note - MIDI_OFFSET || noteSelect == note - MIDI_OFFSET)) //note off \u00a0\u00a0\u00a0 {\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 notePlaying = false; \u00a0\u00a0\u00a0 } \u00a0\u00a0\u00a0 else if(cmd >= 0x90 && cmd <= 0x9F) //note on \u00a0\u00a0\u00a0 { \u00a0\u00a0\u00a0\u00a0\u00a0 noteSelect = note - MIDI_OFFSET; \u00a0\u00a0\u00a0\u00a0\u00a0 notePlaying = true; \u00a0\u00a0\u00a0 }\u00a0 \u00a0 } } Because the synthesizer is mono, I connected the left and right channels of the audio jack together. The SPDT switch is used to switch between audio output to the jack or the speaker. The center pin is where the signal from the amplifier is connected. The right pin goes to the audio jack and the left to the speaker. The ground of the audio jack, the center pin, is connected to one of the pins of the speaker, then both are connected to ground.", "step_imgs": ["https://cdn.instructables.com/FJE/6MIG/HJ1WZ5NW/FJE6MIGHJ1WZ5NW.LARGE.jpg", "https://cdn.instructables.com/FVC/ZCFQ/HJ1WZ5NX/FVCZCFQHJ1WZ5NX.LARGE.jpg", "https://cdn.instructables.com/FK3/P2RQ/HJ1WZ627/FK3P2RQHJ1WZ627.LARGE.jpg", "https://cdn.instructables.com/FNK/WQWM/HJ1WZ6NP/FNKWQWMHJ1WZ6NP.LARGE.jpg"], "step_title": "Step 6: Control"}, {"step": 7, "steps_text": "The user control is composed of 3 parts, the LCD, the switches, and the potentiometers. If you look at the schematic, all the switches are connected via a common ground. Luckily I had a switch array from an old computer monitor that already had the right number of switches, all connected by common ground. It even had an LED, which isn't necessary but I included it anyway. Without this array each switch would have had to be connected together manually. One side of all the switches is connected to ground, then each switch's other side is connected to a pin on the Arduino. Each of the pins on the Arduino then has an internal pull-up enabled. The LCD is serial enabled, but because the MIDI in takes the main serial connection, the LCD requires a software serial connection. The software serial is enabled on pin 13, so that is connected to the receiving pin on the LCD. The LCD is also connected to the power and ground on the main board. The potentiometers are connected to the Arduino's analog input pins 0 through 3. The Arduino's AREF pin is connected to the 5 volts. In order to avoid sacrificing an entire Arduino board for this project, \u00a0I programmed the chip first, then remove it to a separate board with a separate crystal. This requires a PC board for the chip and crystal. Now this becomes the control board, having rails for power and ground and all the pins broken out.", "step_imgs": ["https://cdn.instructables.com/FMD/78RF/HJ1WZ5NA/FMD78RFHJ1WZ5NA.LARGE.jpg", "https://cdn.instructables.com/FB4/6LYM/HJ1WZ5NB/FB46LYMHJ1WZ5NB.LARGE.jpg", "https://cdn.instructables.com/FXP/VKHN/HJ1WZ5NT/FXPVKHNHJ1WZ5NT.LARGE.jpg", "https://cdn.instructables.com/FU1/58HF/HJ1WZ5NP/FU158HFHJ1WZ5NP.LARGE.jpg", "https://cdn.instructables.com/F0J/0JDU/HJ1WZ65C/F0J0JDUHJ1WZ65C.LARGE.jpg", "https://cdn.instructables.com/FBW/1J7F/HJ1WZ5NU/FBW1J7FHJ1WZ5NU.LARGE.jpg", "https://cdn.instructables.com/F95/LKWQ/HJ1WZ5NV/F95LKWQHJ1WZ5NV.LARGE.jpg"], "step_title": "Step 7: User Control"}, {"step": 8, "steps_text": "\n          First step is lay out the parts, mark spaces, then cut the holes. Using generous helping of hot glue I put the LCD and button array into place on the lid of the box. Then using the nuts and washers that came with the potentiometers, and attach them through the lid. Next I wire up the amplifier. I connect the power to the main power on the control board. Then I wire the volume potentiometer to the three spaces on the amp. The nice thing about the breakout board is all of the connections are appropriately labeled. I take the volume potentiometer and connect it through the left side of the box. The output from the filter is connected to the input on the amplifier. The output of the amplifier is connected to the switch. Only the positive output from the output on the amplifier is connected to the middle pin on the audio switch.\u00a0 I added an external reset switch just in case, next to the volume control potentiometer. It helps when reprogramming the board, or if the synthesizer get stuck. Wire up the power supply. I used a DC barrel jack and a 7805 voltage regulator. The back of the DC barrel is the positive, so by the schematic, that is connected to the input pin on the 7805. The control board and barrel jack share a common ground. The output from the voltage regulator is then run to the 5 volt line on the control board. The DC jack is glued to the back of the box. I only recommend putting in 9V to the jack, maximum. The FTDI connector is 5 male header pins connected as shown in the schematic. This allows for serial communication to the synthesizer if you don't have a MIDI controller. Using the speaker, I marked a space. Then using a compass, I created concentric circles to drill holes for the sound to come through. Once everything is properly wired, use that hot glue again to secure everything down. I put the MIDI In/Audio Out in the upper right hand corner, the control board in the upper left, speaker lower right, and the filter and amplifier in toward the center. Add a little paint, and that's it. Now a little demo...", "step_imgs": ["https://cdn.instructables.com/FH7/RZY1/HJ1WZ5NC/FH7RZY1HJ1WZ5NC.LARGE.jpg", "https://cdn.instructables.com/FHP/UGUS/HJ1WZ5NS/FHPUGUSHJ1WZ5NS.LARGE.jpg", "https://cdn.instructables.com/FVM/CFUZ/HJ1WZ5N9/FVMCFUZHJ1WZ5N9.LARGE.jpg", "https://cdn.instructables.com/FBW/1J7F/HJ1WZ5NU/FBW1J7FHJ1WZ5NU.LARGE.jpg", "https://cdn.instructables.com/FNW/ZN6W/HJ1WZ5NM/FNWZN6WHJ1WZ5NM.LARGE.jpg", "https://cdn.instructables.com/F95/LKWQ/HJ1WZ5NV/F95LKWQHJ1WZ5NV.LARGE.jpg", "https://cdn.instructables.com/F3K/DB6G/HJ1WZ5NK/F3KDB6GHJ1WZ5NK.LARGE.jpg", "https://cdn.instructables.com/FEF/NMYS/HJ1WZ5NL/FEFNMYSHJ1WZ5NL.LARGE.jpg", "https://cdn.instructables.com/FEU/LMYS/HJ1WZ5NO/FEULMYSHJ1WZ5NO.LARGE.jpg", "https://cdn.instructables.com/FVC/ZCFQ/HJ1WZ5NX/FVCZCFQHJ1WZ5NX.LARGE.jpg", "https://cdn.instructables.com/FNK/WQWM/HJ1WZ6NP/FNKWQWMHJ1WZ6NP.LARGE.jpg", "https://cdn.instructables.com/FUV/S8WT/HJ1WZ6LE/FUVS8WTHJ1WZ6LE.LARGE.jpg", "https://cdn.instructables.com/FJP/1SCG/HJ1WZ5NY/FJP1SCGHJ1WZ5NY.LARGE.jpg", "https://cdn.instructables.com/FJW/O8Z0/HJ1WZ5NZ/FJWO8Z0HJ1WZ5NZ.LARGE.jpg", "https://cdn.instructables.com/F7Q/VYSX/HJ1WZ5O4/F7QVYSXHJ1WZ5O4.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Putting It Together"}], "channel": "Electronics"}, {"category": "No category to show", "description": "Have you finished your Christmas shopping yet? Time to start wrapping those presents! If you're aiming to impress someone special this season why not level up the presentation with a custom made, rigid gift box?I use this technique to produce high quality mock ups for my customers. The result feels solid and substantial and oozes quality. Follow the simple instructions below and you can make a stunning, store bought quality, box that your loved one will want to keep hold of.You can design your box to snugly fit a rectangular gift like a phone or, with some tissue paper, it can be the perfect solution to package an awkwardly shaped item or something comprising multiple parts. In the example I\u2019ve used paper I had lying around to cover the box but you could use something more fancy like wrapping paper or perhaps something with a custom message printed onto it.This is my first Instructable so if you like this post please vote for me in the \"First Time Authors\" contest :)", "title": "Fancy Rigid Gift Boxes", "url": "https://www.instructables.com/id/Fancy-Rigid-Gift-Boxes/", "section": "craft", "steps": [{"step": 1, "steps_text": "Board (ideally 2mm thick) lined or unlinedLining Paper (if board is not lined) Covering paper, 100gsm-150gsm (high quality wrapping paper will do). Masking tape Utility knife Metal Ruler Pen or PencilGlue (PVA or Spray)Bone folder or something similar Ribbons or other embellishments", "step_imgs": ["https://cdn.instructables.com/FRV/HKPE/IWWFHDTC/FRVHKPEIWWFHDTC.LARGE.jpg"], "step_title": "Step 1: Supplies"}, {"step": 2, "steps_text": "First measure the item you want to put in the box to determine it's inside dimensions. Length (L), width (W) and height (L) If you're looking for a snug fit I would recommend adding 4mm to the Length and Width. You can also add a small lip at the top of the box. My Redmi 3 phone box measures L=149mm, W=80mm, H=63mm so the internal dimensions I'm using are L=153mm, W=84mm, H=66mm.To calculate the box dimensions you can use the formulas below or, if you don't have the time/patience, I've created a presentation box calculator that will do the leg work for you.Base Board Length A = 2 x H + L Base Board Width B = 2 x H + W Lid Board Length C = 2 x H + L + 8Lid Board Width D = 2 x H + W + 8Spacer Length E = 2 x H + L + 40 Spacer Width F = HBase Cover Length G = 2 x H + L + 40Base Cover Width H = 2 x H + W + 40Lid Cover Length I = 2 x H + L+ 8 + 40Lid Cover Width J = 2 x H + W + 8 + 40Use the resulting dimensions to cut some board for the base (A x B) and the lid (C x D)Cut a piece of board to E x F. This will be used as a spacer to help make sure all of the sides are creased to an equal size.Cut the cover paper for the base (G x H) and for the lid (I x J)If you\u2019re using unlined board you might want to cut some paper to the same dimensions and stick it to the inner side of the board at this point. Give the paper a good press down all over and allow to dry. I\u2019ve skipped this process as I\u2019m using board that is white lined on one side.", "step_imgs": ["https://cdn.instructables.com/F98/VO9U/IWWFHE3G/F98VO9UIWWFHE3G.LARGE.jpg", "https://cdn.instructables.com/F99/EQZG/IWWFHE8Q/F99EQZGIWWFHE8Q.LARGE.jpg"], "step_title": "Step 2: Preparing Your Materials"}, {"step": 3, "steps_text": "Turn the boards over so the unlined side is facing upwards.Take the lid board and align the the pacer along one edge. If you're concerned about accuracy you can butt them both up together against something flat to align them. Use your knife to score along the opposite edge of the spacer. You are looking to cut half way through the board so that the side can be easily folded up.This part can be tricky to start with so I\u2019d recommend practicing on some scrap board until you feel confident. A good tip is to do a number of light scores until you reach the required depth. This will help to avoid accidentally cutting all the way through the board. Repeat this process for the other 3 sides.Use your knife again to cut out the 4 corners, leaving a net of your box lid. Repeat this process with the base board.At this stage it is a good idea add some positioning marks to the cover. Draw a line 20mm from two perpendicular sides on the reverse of the lid cover paper. Use these to align the lid board to the centre as shown. With a pen or pencil, lightly trace around the corners of the board as shown. Repeat with the base cover.Following this next bit carefully will ensure your corners are neat and crisp:Measure 2mm from the corner outwards towards along the length of the lid cover and make a small mark as shown.Cut from this mark along the line all the way to the edge of the paper. Now cut a wedge out as shown as approximately 30 degrees from the first cut. It doesn\u2019t matter if it\u2019s not precise as it will be covered up anyway.  Next cut the corners out to create the tabs. I usually make the tabs 20mm wide but it is up to you and the size of box you are making.", "step_imgs": ["https://cdn.instructables.com/FBX/71BR/IWWFHEA2/FBX71BRIWWFHEA2.LARGE.jpg", "https://cdn.instructables.com/F6I/EQKB/IWWFHEB9/F6IEQKBIWWFHEB9.LARGE.jpg", "https://cdn.instructables.com/FM1/IRJ3/IWWFHECN/FM1IRJ3IWWFHECN.LARGE.jpg", "https://cdn.instructables.com/FCF/BDNP/IWWFHF0A/FCFBDNPIWWFHF0A.LARGE.jpg", "https://cdn.instructables.com/F5C/9UIJ/IWWFHERH/F5C9UIJIWWFHERH.LARGE.jpg", "https://cdn.instructables.com/FJU/E9EW/IWWFHF4P/FJUE9EWIWWFHF4P.LARGE.jpg", "https://cdn.instructables.com/FXJ/PINS/IWWFHF5W/FXJPINSIWWFHF5W.LARGE.jpg", "https://cdn.instructables.com/FWF/QMBP/IWWFHFDP/FWFQMBPIWWFHFDP.LARGE.jpg"], "step_title": "Step 3: Cutting the Board and Paper"}, {"step": 4, "steps_text": "Fold each side of the box over all the way so it touches the centre. This will break the fibres in the board and reduce bowing when finished.Fold two sides up 90 degrees so that the corners touch. To ensure a good fit make sure they are touching exactly on the corner as shown.Take a 3cm or 1\u201d piece of masking tape and wrap around the corner as shown. Ensure that you pull it tight to that the corners are forced together. This will make the box nice and rigid. If you box is quite tall you might want to add another piece of tape half way down the side for extra rigidity.Repeat with all 7 of the other corners. It\u2019s starting to look like a box now isn\u2019t it?Check that the lid fits over the base as expected. There should be quite a bit of play at this stage but don't worry, this will reduce once the cover is applied.", "step_imgs": ["https://cdn.instructables.com/F45/EAPH/IWWFHFOO/F45EAPHIWWFHFOO.LARGE.jpg", "https://cdn.instructables.com/FPQ/77X5/IWWFHFT3/FPQ77X5IWWFHFT3.LARGE.jpg"], "step_title": "Step 4: Taping the Corners"}, {"step": 5, "steps_text": "Now the tricky part!Apply a thin layer of glue to the back of the lid cover. You can use PVA but I like to use 3M Display Mount as it\u2019s quicker, less messy and gives a really strong bond.Place the box lid on to the paper as shown using the traced lines as a guide. You want to align the right angles of the guide marks with the corner profile of the corners. Turn over and rub the paper down on the surface.Fold the sides up and tabs round in the sequence shown. Make sure you pull the sides tight as you fold them round to prevent unsightly air pockets from developing.There is a bit of a knack to folding the corners round over the rim of the box. If you get it right it should result in a neat, flat corner. I've added some more photos in the next step to help illustrate what I mean.", "step_imgs": ["https://cdn.instructables.com/F2D/JKOM/IWWFHFXK/F2DJKOMIWWFHFXK.LARGE.jpg", "https://cdn.instructables.com/FT0/AM9Y/IWWFHG5A/FT0AM9YIWWFHG5A.LARGE.jpg", "https://cdn.instructables.com/FS9/7DCF/IWWFHG9K/FS97DCFIWWFHG9K.LARGE.jpg", "https://cdn.instructables.com/FUE/NDBE/IWWFHGDW/FUENDBEIWWFHGDW.LARGE.jpg", "https://cdn.instructables.com/FA1/N1GL/IWWFHGLG/FA1N1GLIWWFHGLG.LARGE.jpg", "https://cdn.instructables.com/F3F/8IS6/IWWFHGSZ/F3F8IS6IWWFHGSZ.LARGE.jpg", "https://cdn.instructables.com/FGQ/3HE5/IWWFHGXD/FGQ3HE5IWWFHGXD.LARGE.jpg", "https://cdn.instructables.com/FZR/GU01/IWWFHH1N/FZRGU01IWWFHH1N.LARGE.jpg"], "step_title": "Step 5: Wrapping the Box"}, {"step": 6, "steps_text": "Use your bone folder or something flat like the back of a comb to smooth down all the edges and prevent air bubbles from occurring.All that is left to do is add any decorations such as ribbons, glitter or anything else you like. That's it, you're finished!I've added some bonus images to this step to highlight how the edges should look.If you have any success with these instructions or if you think anything is missing I'd love to hear from you in the comments or visit my site www.showcasecreative.comMerry Christmas and good luck!", "step_imgs": ["https://cdn.instructables.com/FRT/4YJ1/IWWFHH9A/FRT4YJ1IWWFHH9A.LARGE.jpg", "https://cdn.instructables.com/FF9/CQ87/IWWFHHDK/FF9CQ87IWWFHHDK.LARGE.jpg", "https://cdn.instructables.com/F21/ZVL1/IWWFHHEQ/F21ZVL1IWWFHHEQ.LARGE.jpg", "https://cdn.instructables.com/FET/EX03/IWWFHHIZ/FETEX03IWWFHHIZ.LARGE.jpg", "https://cdn.instructables.com/FUD/B3J5/IWWFHHNA/FUDB3J5IWWFHHNA.LARGE.jpg", "https://cdn.instructables.com/F03/YXBP/IWWFHHUX/F03YXBPIWWFHHUX.LARGE.jpg", "https://cdn.instructables.com/FXX/6JWG/IWWFHHZ6/FXX6JWGIWWFHHZ6.LARGE.jpg", "https://cdn.instructables.com/FET/78RO/IWWFHI3E/FET78ROIWWFHI3E.LARGE.jpg", "https://cdn.instructables.com/FIG/D6GZ/IWWFHI7O/FIGD6GZIWWFHI7O.LARGE.jpg"], "step_title": "Step 6: Finishing Touches"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "The Duct Tape Display Wall is handy in our Makerspace. We have lots of colored tape available for craft activities. This makes it accessible for the kids, and it is nice to look at. Having a helper makes a big difference in this project, so don't do it alone if you can help it.If you work at a school Makerspace, you should propose this activity to the math instructor as a way to integrate making into math. Or, if you are a math teacher, you should consider having your students do this activity, possibly in the art room. This can be used as a way to teach measurement, as well as writing word problems to create and solve equations.", "title": "Duct Tape Display Wall", "url": "https://www.instructables.com/id/Duct-Tape-Display-Wall/", "section": "craft", "steps": [{"step": 1, "steps_text": "18 rolls of colored duct tape18 pieces of card stock (sturdy paper)paper and pencilutility knifepaper choppercutting matmeasuring taperulerlevel90 pushpinsIf you're not hanging 18 rolls, I suggest you start by measuring your wall space and sketching out your design. Otherwise, just follow these steps.", "step_imgs": ["https://cdn.instructables.com/F03/L8I3/IL5J5KMX/F03L8I3IL5J5KMX.LARGE.jpg", "https://cdn.instructables.com/FEA/7EKA/IL5J6EPY/FEA7EKAIL5J6EPY.LARGE.jpg", "https://cdn.instructables.com/FOZ/WC6Z/IL5J6EJ6/FOZWC6ZIL5J6EJ6.LARGE.jpg", "https://cdn.instructables.com/FC7/OY6M/IL5J5KN3/FC7OY6MIL5J5KN3.LARGE.jpg", "https://cdn.instructables.com/F30/V5AG/IL5J5KOX/F30V5AGIL5J5KOX.LARGE.jpg", "https://cdn.instructables.com/FB6/X0I8/IL5J6E9P/FB6X0I8IL5J6E9P.LARGE.jpg"], "step_title": "Step 1: Materials Needed:"}, {"step": 2, "steps_text": "Use three strips of tape, about 6\" long each,  on a piece of card stock to create a tape square. Place tape pieces next to each other and match the edges precisely to the edge of the cardstock. Try not to overlap or leave gaps between. Measure the length of the three pieces of tape. Trim excess tape and card stock with the paper chopper to the same length to make a perfect square. Repeat 18 times, with each color of tape you have. ", "step_imgs": ["https://cdn.instructables.com/FYF/GDL0/IL5J68I2/FYFGDL0IL5J68I2.LARGE.jpg", "https://cdn.instructables.com/F4S/JBKW/IL5J69TI/F4SJBKWIL5J69TI.LARGE.jpg", "https://cdn.instructables.com/FP4/JEDU/IL5J5KPL/FP4JEDUIL5J5KPL.LARGE.jpg", "https://cdn.instructables.com/FZ1/7HP8/IL5J69DP/FZ17HP8IL5J69DP.LARGE.jpg", "https://cdn.instructables.com/FOS/K2IO/IL5J5KQ2/FOSK2IOIL5J5KQ2.LARGE.jpg", "https://cdn.instructables.com/FW4/RAJD/IL5J68I5/FW4RAJDIL5J68I5.LARGE.jpg"], "step_title": "Step 2: Make Tape Squares"}, {"step": 3, "steps_text": "Measure the wall where you are planning to hang the tape. Then get out your pencil and paper to make a sketch and do some math. Calculate the dimensions of your grid, the location of the midpoint, and the number of pushpins you need(if you're not using 18 squares). Once you know the look of your grid, place your tape squares in a checker board pattern on the floor. Then rearrange them until the colors look right to you, and carefully stack them and label them on the back. I labelled them by row and column. You could also number the tape squares in your sketch with #1-18, and just put one number on each tape square.", "step_imgs": ["https://cdn.instructables.com/FJJ/NZUO/IL5J5KOS/FJJNZUOIL5J5KOS.LARGE.jpg", "https://cdn.instructables.com/F0F/W9H2/IL5J5KRL/F0FW9H2IL5J5KRL.LARGE.jpg", "https://cdn.instructables.com/FBI/NNK3/IL5J5KOV/FBINNK3IL5J5KOV.LARGE.jpg"], "step_title": "Step 3: Design It"}, {"step": 4, "steps_text": "Start by putting the bottom left corner of a tape square on the wall where you marked it with a pencil. Straighten it with a level. Insert a thumbtack in that corner, and another in the upper left corner. Place your second tape square below the first at a diagonal, straightening with a level and pinning two corners each time. Starting from the middle and tiling outward was the easiest way for me.", "step_imgs": ["https://cdn.instructables.com/FHK/ZE1K/IL5J5KQ0/FHKZE1KIL5J5KQ0.LARGE.jpg", "https://cdn.instructables.com/FZC/SGZB/IL5J68HT/FZCSGZBIL5J68HT.LARGE.jpg", "https://cdn.instructables.com/FH1/3YQR/IL5J6GLC/FH13YQRIL5J6GLC.LARGE.jpg"], "step_title": "Step 4: Hang It"}, {"step": 5, "steps_text": "As you are tacking up your squares, step back once in a while to see if it looks alright. After they are all up, place thumbtacks in the remaining corners of each square. Then, starting from the top middle of a tape square, measure 2 1/2\" down and insert a thumbtack. This is for hanging your tape rolls. Repeat with each tape square. Then hang tape rolls. Now, step back and admire your work!", "step_imgs": ["https://cdn.instructables.com/FFS/SD40/IL5J6IPO/FFSSD40IL5J6IPO.LARGE.jpg"], "step_title": "Step 5: Finishing Up"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "A didgeridoo made out of leather and sealed with epoxy.Leather is a great material for first-time didgeridoo builders, because it's relatively easy to obtain, not too expensive (especially if you keep an eye out for sales) and doesn't require any expensive tools or prior knowledge.You should expect to spend around 10-12 hours on this project, although it can be done in 6-8 hours after you have already made a couple. The initial cost for all of the materials and tools is around $200 and you'll have enough materials to make at least 2 didgeridoos, maybe 3. The cost per didgeridoo, excluding tools and re-usable materials, is around $50 - $75.I got started crafting didgeridoos out of leather because I don't have the know-how, tools or space needed to make \"split and hollow\" didges out of dried logs, and I don't live somewhere with a ready supply of yucca or agave stalks. After some brain-storming and searching, I found a guy that makes leather didgeridoos ( Marko Johnson ) which inspired me to try my hand at it.I've made a variety of styles of leather didgeridoos. Hand stiched, \"triangle\", \"triangle spiral\", sectional, and the simple \"wrap and epoxy\" style which I will describe in this instructable. I've added some pictures of some of the other styles of leather didges that I've made, if you're interested.After a while of building leather didgeridoos, I got interested in the physics of didgeridoos, especially in the area of how the bore shape affects the playability and sound of the didge. I did some reading in some acoustic journals, and eventually made a program to calculate what is called the \"acoustic impedance\" of a didgeridoo with an arbitrary circular bore shape. I've recently created a user-friendly interface and released the code as open source. You can get it here.One of the great things about this method of making didgeridoos is that it is relatively easy to construct the didgeridoo so that it has specific bore dimensions. This appeals to me because it allows me to design a didgeridoo before hand, using my DidjImp program, and then build the didge and see how it sounds. This allows me to experiment with different designs and learn more about how to make a didgeridoo with specific playing characteristics.I hope you find this instructable useful. If you do make a leather didge using these instructions, I would love to hear about it! And I would love to hear any feedback you have.Note: Some of the images are hard to see at the small size shown on the page. I've uploaded full size images, so you can click on the \"i\" buttton at the top left of the image and choose to view the original image which will be a lot larger.", "title": "Leather Didgeridoo", "url": "https://www.instructables.com/id/Leather-Didgeridoo/", "section": "craft", "steps": [{"step": 1, "steps_text": "Here are the tools needed:Razor/Utility knife - $4-$9For cutting out the leather. My favorite is thisYard stick - $5The metal ones are the best. The cheap wooden ones tend to be not very straight. Ideally it should have millimeter markings (1/32in works too, if you prefer the \"English\" system.)\"2 yard\" yard stick (optional) - $15Again the metal ones are best. The markings aren't important. This is only used in the first step, to draw a long straight line. You can use the \"1 yard\" yard stick instead, or anything else with a long, straight edge.Carpenter's square or similar - $5It's best if it has millimeter or 1/32in markings. If not, you can use the yard stick to measure instead.Hack saw or PVC pipe cutter (optional) - $4This is needed if you are going to build a PVC frameAnd the materials that that are needed:1 Leather hide - $90You want a thick vegetable tanned hide, at least 12oz or so. Tandy's cheap 13-15oz saddle skirting works well. This will be enough leather for at least 2 didges, possibly 3.Epoxy (at least 12-14oz) - $20You can buy 64oz of the \"Klear Koat\" epoxy here for $20 (not including shipping), or you can find a 16oz kit of Envirotex Lite in some local hardware stores for around $20. Other types/brands of \"tabletop/bartop epoxy\" would probably work too. You'll use around 12-14oz of epoxy per didge, so if you buy the Klear Koat you should have enough for several didges.Fumed Silica (Optional) - $3.50Used to thicken the epoxy for the final outside coat.Latex gloves - $10For working with epoxyPencil - $1Ye olde wooden pencilPencil sharpener - $1Any cheap pencil sharpener will doElastic Medical Bandages - $10You have a couple of options here. You can get a regular \"ACE\" type bandages, either the self-stick kind, or the kind with the little metal fastener things. You can reuse this type of bandage, assuming you don't get much epoxy on them. These are $2 a piece for a 2\" wide bandage, which is an easy size to work with. You can get a wider bandage, but it's a bit harder to keep \"flat\" while you wrap it on the didge. You'll need around 5 2\" bandages or possibly fewer if you use a wider bandage.You can also buy woven cotton bandages in bulk for pretty cheap, but they're not as re-usable. They tend to get stretched out after a couple of uses.String - $3 (or $25)Used to draw the curve at the wide end, and also to hang the didgeridoo from the PVC frame while epoxying. You can probably use cheap cotton string which you should be able to find at walmart on the cheap (froogle.com says $3 or so). However, I like to use a type of string called \"lacing tape\", which comes in either nylon or polyester (among other materials). It is a flat, braided string, is quite strong, and holds a knot very well. I use this stuff for *everything*. It's around $25 for a 500 yard spool, but it's a bit hard to find. The good thing is that 1 spool will last a long long time. The place I got it from last time isn't selling it any more unfortunately. After a bit of a search, it looks like you might be able to get it here. Either nylon or polyester is fine. You want size 3, with the synthetic rubber finish. White is cheaper, but you can get black if you want :)Masking Tape - $4Used to hold the string in place while drawing the curve at the wide end, and also to help seal the mouthpiece end of the didge when epoxying the inside. You don't want to use duct tape or packaging tape, because the tape will stick to the leather too much and damage the leather when you peel it off. I use 3M's blue masking tape.Plastic Drop Cloth - $3This is used while working with epoxy, to prevent it from getting on the floor.3 Plastic graduated mixing container - $1.50 total ($.50 each)To mix the epoxy1 package of mixing sticks - $2To mix the epoxySilly Putty - $1To help seal the end of the didge when epoxying the inside1 plastic grocery bag - $0Used to seal the end of the didge when epoxying the insideOptional - if you want to build a PVC frame to help hold the didge while youepoxy the inside and outside.4 10' long 1-1/4\" Schedule 40 PVC pipe - $4 each, $16 total8 'T' connectors to fit above pipe - $1.50 each, $12 total4 90 degree elbows to fit above pipe - $1 each, $4 totalNote: if you buy the Klear Kote epoxy from U.S. composites, you can order some fumed silica (aka aerosil-cabosil), graduated plastic tubs, wooding mixing sticks, and latex gloves from them at the same time.Total Cost: $220 - Assuming that you have to buy everything that is listed. There's a good chance you will have some/most of the tools and materials already, and you can leave off some of the optional items to save a bit more. Most of the stuff can be re-used if/when you make more leather didges in the future.", "step_imgs": [], "step_title": "Step 1: Tools and Materials"}, {"step": 2, "steps_text": "This frame is quite useful when epoxying the didge.You can use it to- hold the end of the didge up while epoxying the inside- hanging the didge to let the epoxy drain out- support the didge in a horizontal position while epoxying the outsideFirst, you need to cut the PVC pipe into smaller sections. Each line below represents the lengths to cut from one of the 10' lengths of PVC pipe.5' | 5'4' | 4' | 1' | 1'4' | 4' | 1' | 1'20\" | 20\" | 20\" | 20\" | 6\" | 6\" | 6\" | 6\"Assemble the frame. Each of the legs are made up of a 1' piece, a 4' piece, and a 6\" piece (from the bottom to top).The 2 long pipes along the top are 5', and the 4 pieces of pipe that run between the 2 legs on each side are 20\".See the picture to get an idea of  how it all fits together.", "step_imgs": ["https://cdn.instructables.com/FRH/OBFL/FITUPPEH/FRHOBFLFITUPPEH.LARGE.jpg", "https://cdn.instructables.com/FRI/X9A6/FITUPPWF/FRIX9A6FITUPPWF.LARGE.jpg"], "step_title": "Step 2: (Optional) Build a PVC Frame to Help Hold the Didge While Epoxying"}, {"step": 3, "steps_text": "The first step is to figure out what shape of bore you want to build. In general, you want a small enough mouthpiece that you can play easily (1.25\" to 1.5\" diameter or so), and a gradual taper towards the end.You can use my DidjImp program to help design the bore. You enter the bore dimensions, and then you can see what note that didge will play.Here are the dimensions for the didge that I will be building in this article. The first column is the distance from the mouthpiece, and the 2nd column is the diameter of the bore at that location.0m (mouthpiece) - 30mm.628m - 40mm1.256m - 60mm1.78m - 100mmThis didgeridoo should play a \"D\" (73hz)", "step_imgs": ["https://cdn.instructables.com/FEL/P5QE/FISZNFZP/FELP5QEFISZNFZP.LARGE.gif"], "step_title": "Step 3: Determine the Bore Dimensions"}, {"step": 4, "steps_text": "Now that you have the bore design, you need to do some calculations to determine the shape of leather to cut out. The idea is that at each \"section\" in the design, the leather needs to be wide enough that when you bend it into a circle, it is the diameter that you want.At first, you might think that you just need to calculate the circumference of a circle with the given diameter, but that will actually give you a smaller bore than you want, due to the thickness of the leather.In general, if you have a piece of leather with a certain width and thickness and you form it into a circle, the inner diameter of the circle will be:InnerDiameter = (width/Pi) - thicknessAnd the outer diameter will be:OuterDiameter = (width/Pi) + thickness The difference between the two is twice the thickness of the leather, which makes sense, because you go through 2 thicknesses of leather going from the outer edge of one side to the outer edge of the other side.You need to calculate the width of leather than will give you the bore (inner) diameter that you want. From above, we know thatInnerDiameter = (width/Pi) - thicknessAnd we need to solve for the width.width = (innerDiameter + thickness) * PiNow you need to find the average thickness of the leather. You can measure it at various places around the edge and guestimate the average thickness. It will typically be around 4-6mm.I happen to have a custom-made tool that can measure the thickness of the leather anywhere in the middle of the leather, so I was able to get a more accurate thickness measurement at each position (shown below)0m:          5.2mm.628m:    5mm1.256m:  4.6mm1.78m:    3.9mmNow you just need to plug in the thickness and the diameter for each section to get the width of leather at that position.0m:          (30mm + 5.2mm) * 3.14159 = 111mm.628m:    (40mm + 5mm) * 3.14159 = 141mm1.256m:  (60mm + 4.6mm) * 3.14159 = 203mm1.78m:    (100mm + 3.9mm) * 3.14159 = 326mmAnd finally, you need to calculate the curve at the wide end. If this was straight instead of curved, the bell of the didgeridoo wouldn't be flat on the bottom, but it would stick down where the seam is.The curve that is needed is a circular curve, so you need to calculate the radius of the circle. Later, you will use a string that is the length of the radius in order to draw the curve.The derivation of the calculation is a bit involved, so I'll skip it and just give the calculation itself.CurveRadius = (((LargeRadius - SmallRadius)2 + Height2)(1/2)) * LargeRadius / (LargeRadius - SmallRadius)See the images for this step for a better formatted version of the equation.In this equation, LargeRadius is the radius of the bore at the bell end, plus 1/2 the thickness of the leather.SmallRadius is the radius of the bore at the section just before the bell, plus 1/2 the thickness of the leather.Height is the distance between the bell and the section just before the bell.For the didge that I am building:LargeRadius = 50mm + (3.9mm/2) = 51.95mmSmallRadius = 30mm + (4.6mm/2) = 32.3mmHeight = 1780mm - 1256mm = 524mmAnd then plugging these into the CurveRadius equation:CurveRadius = (((51.95 - 32.3)2 + 5242)(1/2)) * 51.95 / (51.95 - 32.3) = 1386mm", "step_imgs": ["https://cdn.instructables.com/F4N/HD25/FITU5IWW/F4NHD25FITU5IWW.LARGE.gif", "https://cdn.instructables.com/F5F/JPN2/FITUPMY2/F5FJPN2FITUPMY2.LARGE.gif"], "step_title": "Step 4: Calculations"}, {"step": 5, "steps_text": "Lay out the leather so that it is flat, and lay the 2-yard yard stick onto the leather, where you want the center-line of the didge to be. You want to position it so that the outline of the didge that you are going to cut out is as close to the edge as possible, to minimize the amount of left-over leather on the side.Once you've placed the yard stick, draw a line along the edge of the yard stick with a pencil, using light pressure. You don't want to press to hard, or it will make an indention in the leather.If you only have a 1-yard yard stick, place the yard stick and trace a 1-yard line, and then move the yard stick along the line so that the end of the yard stick is approximately in the middle of the line you just drew, making sure that the yard stick is still lined up with the line. Then continue the line. You'll need to do that twice to get a long enough line.", "step_imgs": ["https://cdn.instructables.com/FO3/3ANC/FISZNG1E/FO33ANCFISZNG1E.LARGE.jpg", "https://cdn.instructables.com/FRV/07NX/FISZNG1D/FRV07NXFISZNG1D.LARGE.jpg", "https://cdn.instructables.com/FYK/HI4Z/FISZNG1C/FYKHI4ZFISZNG1C.LARGE.jpg"], "step_title": "Step 5: Draw the Center Line"}, {"step": 6, "steps_text": "In this step, you will make tick marks along the center line for each section in the design.Start off by placing a tick mark where the mouthpiece is going to be.Then measure along the center line from the mouthpiece, the distance to the next section of the bore design and make another tick mark.For this didge, the second section is .628m away from the mouthpiece, so I'll take the yard stick and measure the appropriate distance and make another tick mark.Do this for each remaining section.", "step_imgs": ["https://cdn.instructables.com/F6B/VFSP/FISZNG34/F6BVFSPFISZNG34.LARGE.jpg", "https://cdn.instructables.com/FK2/CLBH/FISZNG38/FK2CLBHFISZNG38.LARGE.jpg", "https://cdn.instructables.com/FV5/GYZG/FISZNG39/FV5GYZGFISZNG39.LARGE.jpg", "https://cdn.instructables.com/FVX/GUXS/FISZNG37/FVXGUXSFISZNG37.LARGE.jpg"], "step_title": "Step 6: Measure and Mark Along the Center Line"}, {"step": 7, "steps_text": "In this step you will draw lines perpendicular to the center line at each section, and measure out the required width of the leather at that section.Place the carpenter's square so that the long edge is lined up with the center line, and the other edge is lined up with the tick mark for the mouthpiece, and draw a line that is at least half of the width of leather at that position (using the width you calculated in step 3). You can just guestimate, and make sure the line is longer than needed.Now flip the carpenter's square over and line it up again, and draw a line on the other side of the center line.Now use either the carpenter's square or the yard stick to measure half of the required width, from the center line, and make a tick mark, and then measure and mark the same distance on the other side of the center line.For this didge, the required width of the mouthpiece is 111mm, so I will measure 55.5mm on either side of the center line.Do the above for each remaining section.", "step_imgs": ["https://cdn.instructables.com/F0E/K4E9/FITUIXF9/F0EK4E9FITUIXF9.LARGE.jpg", "https://cdn.instructables.com/F5I/Z4NQ/FITUIXFB/F5IZ4NQFITUIXFB.LARGE.jpg", "https://cdn.instructables.com/FQR/RSTF/FITUIXFA/FQRRSTFFITUIXFA.LARGE.jpg", "https://cdn.instructables.com/F06/5N7R/FIURAMKT/F065N7RFIURAMKT.LARGE.jpg", "https://cdn.instructables.com/FFZ/2A1F/FITUIXF8/FFZ2A1FFITUIXF8.LARGE.jpg", "https://cdn.instructables.com/FWF/D7RV/FITUIXF7/FWFD7RVFITUIXF7.LARGE.jpg", "https://cdn.instructables.com/F6D/QDR6/FITUIXF4/F6DQDR6FITUIXF4.LARGE.jpg", "https://cdn.instructables.com/FT3/J25H/FITUIXF3/FT3J25HFITUIXF3.LARGE.jpg", "https://cdn.instructables.com/FLF/G3J5/FITUIXF6/FLFG3J5FITUIXF6.LARGE.jpg"], "step_title": "Step 7: Measure and Mark the Width of Each Section"}, {"step": 8, "steps_text": "In this step, you will use a piece of string to draw the curve at the wide end.Cut a length of string that is a bit longer than the \"CurveRadius\" you calculated in step 4.Use the pencil to make a mark on the string near one of the ends, leave enough string past the end of the mark so that you can tape it down.Measure down the length of the string from the first mark you made and make another mark, so that the distance between the two marks is the \"CurveRadius\" value that you calculated in step 4.Take one of the ends of the string, and tape it so that the mark is right at one of the \"corners\" at the wide end of the didge.Pull the string tight, and bring it over until the other mark on the string lines up with the center line, and then tape that end of the string down so that the mark is directly over the center line. That is the center of the circle that makes up the curve you're going to draw.Go back to the other end and untape it, and the move the string a little bit towards the center, while keeping the a constant tension on the string. Don't pull so hard that you pull it out from the tape holding it on the other end. Now make a mark on the leather next to the mark on the string.Move the string towards the center a little bit more, and make another mark.. and keep doing this until you get to the other corner. If you did everything right, the marks that you made go from one corner to the other, and form a circular curve.Untape the other end of string and discard.", "step_imgs": ["https://cdn.instructables.com/F6G/L2MG/FITUIXNV/F6GL2MGFITUIXNV.LARGE.jpg", "https://cdn.instructables.com/F27/ZY3L/FITUIXNZ/F27ZY3LFITUIXNZ.LARGE.jpg", "https://cdn.instructables.com/FGY/VH1Q/FITUIXNW/FGYVH1QFITUIXNW.LARGE.jpg", "https://cdn.instructables.com/FT0/0DYR/FITUIXO0/FT00DYRFITUIXO0.LARGE.jpg", "https://cdn.instructables.com/F27/WV5N/FITUIXNX/F27WV5NFITUIXNX.LARGE.jpg", "https://cdn.instructables.com/FDE/LALV/FITUIXNY/FDELALVFITUIXNY.LARGE.jpg", "https://cdn.instructables.com/FIN/TZE5/FITUIXO1/FINTZE5FITUIXO1.LARGE.jpg", "https://cdn.instructables.com/FTD/MSXM/FITUIXO2/FTDMSXMFITUIXO2.LARGE.jpg"], "step_title": "Step 8: Draw the Curve on the Wide End"}, {"step": 9, "steps_text": "In this step you will draw the outline of the leather.Use the yard stick to draw a line between adjacent pairs of tick marks you made in step 7. Do this around the whole design. These will be the lines that you follow while cutting out the leather.", "step_imgs": ["https://cdn.instructables.com/FWJ/U3RD/FITUIXW5/FWJU3RDFITUIXW5.LARGE.jpg", "https://cdn.instructables.com/FFF/2PTD/FITUIXW1/FFF2PTDFITUIXW1.LARGE.jpg", "https://cdn.instructables.com/FF3/NV8C/FITUIXW6/FF3NV8CFITUIXW6.LARGE.jpg", "https://cdn.instructables.com/FNO/9499/FITUIXW2/FNO9499FITUIXW2.LARGE.jpg", "https://cdn.instructables.com/FQC/S053/FITUIXW4/FQCS053FITUIXW4.LARGE.jpg", "https://cdn.instructables.com/FBZ/DEZS/FITUIXW0/FBZDEZSFITUIXW0.LARGE.jpg"], "step_title": "Step 9: Draw the Outline"}, {"step": 10, "steps_text": "In this step, you will cut out the leather.Take the yard stick or carpenter's square (\"the ruler\") and lay it down beside the straight line at the mouthpiece end of the didge, so that when you cut with the utility knife along the straight edge, it cuts right on the line.Press down firmly on the ruler with one hand, holding it in place, and then take the utility knife with the other hand and cut along the edge of the ruler. You want to pull the blade toward you, while holding it against the edge of the ruler, to ensure that your cut is straight and on the line.Don't use too much downward pressure on the utility knife, you are just scoring the leather with the first cut. Once you cut along the line once, keep holding the ruler in place and pick up the utility knife and make another cut. You'll probably need to cut 3-4 times to get all the way through the leather.Use this same technique to cut along the whole outline, except for the curve at the wide end.Be careful when you get to one of the sections, where the outline changes direction. You don't want to cut past the end of the line and into the piece of leather that you are cutting out. Stop the cut where the outline changes direction, and then reposition the ruler and start the next cut on the next line.To cut out the curve at the wide end, you'll need to cut it free-hand. Start at the corner and start pulling the knife towards you, keeping a close eye on the cut that you're making, to make sure that it follows the marks that outline the curve. The key is to not get in a hurry. It also helps if you get close to the leather, so you can see better.On the first cut, you are just lightly scoring the leather. Once the leather is scored, you can use a little more pressure and you don't have to be as careful, because the blade tends to follow the score.Once you cut all around the outline, you should be able to remove the piece of leather that you cut out. You may need to do run the blade along some of the cuts again, where the leather didn't quite get separated.Once you remove the piece of leather that you cut out, you can erase the pencil lines on the leather.", "step_imgs": ["https://cdn.instructables.com/FNV/H2MQ/FITUIYBS/FNVH2MQFITUIYBS.LARGE.jpg", "https://cdn.instructables.com/FN5/ZRK5/FITUIYC0/FN5ZRK5FITUIYC0.LARGE.jpg", "https://cdn.instructables.com/FC6/TZ1Y/FITUIYBU/FC6TZ1YFITUIYBU.LARGE.jpg", "https://cdn.instructables.com/FY4/OV9F/FITUIYBM/FY4OV9FFITUIYBM.LARGE.jpg", "https://cdn.instructables.com/F5O/EUWY/FITUIYBP/F5OEUWYFITUIYBP.LARGE.jpg", "https://cdn.instructables.com/FSY/HRFC/FITUIYBZ/FSYHRFCFITUIYBZ.LARGE.jpg", "https://cdn.instructables.com/FCP/MPUP/FITUIYBL/FCPMPUPFITUIYBL.LARGE.jpg", "https://cdn.instructables.com/FTE/AW02/FITUIYBX/FTEAW02FITUIYBX.LARGE.jpg", "https://cdn.instructables.com/F3X/847S/FITUIYBK/F3X847SFITUIYBK.LARGE.jpg", "https://cdn.instructables.com/F1N/VQFG/FITUIYBY/F1NVQFGFITUIYBY.LARGE.jpg"], "step_title": "Step 10: Cut Out the Leather"}, {"step": 11, "steps_text": "In order to get the leather in a tube shape, it helps if you wet it down first to make it more pliable. You can let it soak in a bathtub for 5-10 minutes, or go outside and wet it down with a garden hose, somewhere where the leather won't get dirty.Once it's nice and wet, then bend the sides in towards the center with your hands. At this point you just want to get the leather to start bending, it won't stay in a tube shape without something to hold it.Take one of the elastic bandages and wrap it around the leather a little ways down from the mouthpiece, a foot to a foot and a half down. Make sure it's tight enough to hold the leather in a near-tube shape. This is just a temporary wrap, so you just need to do 3-4 wraps in the same spot - enough so that the wrap doesn't come off when you let go.Take another elastic bandage and start wrapping it around the leather at the mouthpiece end. Be sure to pull it tight enough that the edges of the leather are firmly pressed against each other, otherwise epoxy will leak out the seam.As you continue wrapping down the leather, you will start getting closer to the \"temporary wrap\" you made to hold the leather in place. You'll want to unwrap this and move it down another foot or so and make another temporary wrap.When you get to the end of one of the bandages, just grab another and start wrapping again from the same place.Once you get it fully wrapped, then you should be able to play it! Pick it up and give it a toot. The sound will be somewhat muffled, but you'll get a general idea of what it's going to sound like. I've added an mp3 file of what mine sounded like at this point, and another that I recorded after the leather had dried.If you can't play the didge, that's a good indicator that you didn't get the seam sealed up good, which means that epoxy will leak out when you epoxy the inside. Not good! You'll probably want to re-wrap it tighter.Once you are happy with how it's wrapped, you will need to let the leather dry before you epoxy the inside. If it's hot outside, lay it down on your porch and it should be dry after a day. Otherwise, just lay it down against a wall somewhere out of the way in your house. You'll probably want to leave it at least two days. You can tell if it's dry by feeling the leather on the inside at the bell end. Does it feel nice and dry? You may want to rotate it a couple of times so that the side that was facing downward has a chance to dry.", "step_imgs": ["https://cdn.instructables.com/FXB/2P2W/FIURAMSI/FXB2P2WFIURAMSI.LARGE.jpg", "https://cdn.instructables.com/FV4/OL5D/FIURAMS9/FV4OL5DFIURAMS9.LARGE.jpg", "https://cdn.instructables.com/FRS/UBF2/FIURAMSD/FRSUBF2FIURAMSD.LARGE.jpg", "https://cdn.instructables.com/FE6/52IZ/FIURAMSH/FE652IZFIURAMSH.LARGE.jpg", "https://cdn.instructables.com/FLD/RYCL/FIURAMXZ/FLDRYCLFIURAMXZ.LARGE.jpg", "https://cdn.instructables.com/F8W/1EAT/FIURAMXY/F8W1EATFIURAMXY.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 11: Wet the Leather and Wrap It"}, {"step": 12, "steps_text": "In this step, you will seal off the mouthpiece end of the didge, in preparation for coating the inside with epoxy.First, you'll want to make sure the leather has dried off from the last step. Feel the leather on the inside at the bell end. If it still feels damp, or slightly cool to the touch, let it sit for another day.Get a small piece of silly putty and roll it into a snake, and then press it onto the edge of the leather at the mouthpiece end.Place the plastic bag over the mouthpiece end of the didge, and pull it tight against the silly putty. This should make an air (and epoxy!) tight seal, to keep epoxy from leaking out.Put some of the masking tape around the plastic next to the edge of the didge, and then cut off any excess plastic.Then put some more tape across the top and down the side, to hold the plastic in place. You don't want the plastic coming off while you have epoxy in the didge!", "step_imgs": ["https://cdn.instructables.com/FDK/TIG3/FIV128LU/FDKTIG3FIV128LU.LARGE.jpg", "https://cdn.instructables.com/FBT/G5N4/FIV128M4/FBTG5N4FIV128M4.LARGE.jpg", "https://cdn.instructables.com/FG4/UR8X/FIV128LY/FG4UR8XFIV128LY.LARGE.jpg", "https://cdn.instructables.com/FM5/LS5C/FIV128LJ/FM5LS5CFIV128LJ.LARGE.jpg", "https://cdn.instructables.com/FJX/XHYX/FIV128LZ/FJXXHYXFIV128LZ.LARGE.jpg", "https://cdn.instructables.com/FDU/9PM2/FIV128M5/FDU9PM2FIV128M5.LARGE.jpg", "https://cdn.instructables.com/FHW/2QAE/FIV128M3/FHW2QAEFIV128M3.LARGE.jpg", "https://cdn.instructables.com/F8R/SIFS/FIV128M7/F8RSIFSFIV128M7.LARGE.jpg", "https://cdn.instructables.com/FMR/SRWI/FIV128M2/FMRSRWIFIV128M2.LARGE.jpg"], "step_title": "Step 12: Seal the Mouthpiece End of the Didge"}, {"step": 13, "steps_text": "In this step, you will epoxy the inside of the didge. This seals the leather and gives a hard surface for the sound to bounce off of on the inside, and it holds the seam together.First, you'll want to lay down the drop cloth, to keep the epoxy off the floor. Ideally, you'll want to work someplace that has good ventilation, so you don't breath in too much epoxy fumes.Mix the epoxy, per the manufacturer's instruction. You'll need to mix up around 8-10 oz of epoxy. The two types of epoxy I mentioned in the \"materials\" step use a 1:1 ratio, so just pour out 4-5 oz of each component into a plastic mixing cup, and stir thoroughly with a mixing stick. You want to make sure to scrape the sides and bottom of the container, so you don't leave any unmixed epoxy (or as little as possible at least).Don a pair of latex gloves (just in case), and pour the epoxy into the wide end of the didge.Pick up the didge and place the far end (the mouthpiece end) on something, to help hold it up - otherwise your arms will quickly get tired from trying to hold it up.Hold the open end of the didge lower than the sealed end, in order to let the epoxy run back towards the open end. You'll want to look inside the bore and watch for when the epoxy starts getting close to the open end, and then raise the open end back up a bit so it doesn't run out the open end. Slowly rotate the didge, letting the epoxy coat the bore as you rotate. You'll probably want to raise the open end back up and let the epoxy run pool in the sealed end, and then lower it again and run back towards the open end (several times), while occasionally rotating.Note that you don't need to worry about coating the leather at the very edge of the open end - it should get coated nicely when you let the epoxy drain out of the open end.Once you are comfortable that the entire bore has been coated, you can stand the didge back up and let the epoxy drain out onto the plastic drop cloth. The epoxy doesn't stick to the plastic, so once it has cured, you can peel it off the drop cloth and reuse the drop cloth.At this point, you can take off the tape, plastic and silly putty on the mouthpiece end.If you built the PVC frame, you take take some string and wrap it around the 2 horizontal bars on the top, and then take the end of the string and wrap it around the top of the didge, down far enough to hold the didge up off the ground.Otherwise, you can try and find something else to hang the didge off of. Put a hook in the ceiling..  Use an existing light fixture (with the light turned off!)... etc.Or you can just lean the didge against a wall or something. The only downside is that the epoxy will be thicker on the side of the bore that is facing downward.Now just let the epoxy drain and cure. It will be dry to the touch in 4-5 hours, and it will be fairly hard in about a day. It takes a week or two to reach full hardness, but it's \"good enough\" after a day.The attached sound file is what it sounded like the next day, after the epoxy had cured.Tips:Try not to get any epoxy on you. If you do, just wash as best as you can with soap and water.If you get epoxy on something that you don't want it on, you can clean it up before it cures with some mineral spirits, denatured alcohol, or something similar.", "step_imgs": ["https://cdn.instructables.com/FB5/YXSF/FIV128LT/FB5YXSFFIV128LT.LARGE.jpg", "https://cdn.instructables.com/FWX/K71K/FIV128LR/FWXK71KFIV128LR.LARGE.jpg", "https://cdn.instructables.com/F75/19D3/FIV128LL/F7519D3FIV128LL.LARGE.jpg", "https://cdn.instructables.com/FGI/2EQR/FIV128LS/FGI2EQRFIV128LS.LARGE.jpg", "https://cdn.instructables.com/F9Y/UCWP/FIV128LV/F9YUCWPFIV128LV.LARGE.jpg", "https://cdn.instructables.com/FZS/LJFI/FIV128M6/FZSLJFIFIV128M6.LARGE.jpg", "https://cdn.instructables.com/FS6/OX5M/FIV128LX/FS6OX5MFIV128LX.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 13: Epoxy the Inside of the Didge"}, {"step": 14, "steps_text": "Once the epoxy on the inside has cured, you can remove the elastic bandages from the outside. The epoxy will hold the seam together and the leather in the same shape.At this point, you can take the utility knife and trim off any excess epoxy off the bottom end of the didge. There will usually be several places where the epoxy was dripping. Or if you happen to have a dremel, a flap wheel is an easy way to remove the epoxy (wear a dust mask!).", "step_imgs": ["https://cdn.instructables.com/F4I/QF5N/FITUIYVU/F4IQF5NFITUIYVU.LARGE.jpg", "https://cdn.instructables.com/FTZ/Z050/FITUIYVX/FTZZ050FITUIYVX.LARGE.jpg", "https://cdn.instructables.com/FXB/QRYC/FITUIYVV/FXBQRYCFITUIYVV.LARGE.jpg", "https://cdn.instructables.com/FT7/H0ME/FITUIYVW/FT7H0MEFITUIYVW.LARGE.jpg"], "step_title": "Step 14: Unwrap the Didge"}, {"step": 15, "steps_text": "In this step you will coat the outside of the didge with epoxy.First, you need to figure out how you are going to position the didge while applying the epoxy.If you built the PVC frame in step 2, then hang some string from the two horizontal bars on the sides of the frame, and then run the 1/2\" pvc pipe through the didge, and hang the ends on the string.Otherwise, you can use the 1/2\" pvc pipe and let the pipe rest on something on either end, or just let the didge stand up vertically while you apply the epoxy - just don't let it fall over while you're applying the epoxy.Mix up another batch of epoxy, you only need about 2oz this time (1oz of each component).(Optional) It tends to be a bit easier if you pour the epoxy out onto something, instead of trying to dip your hand into the plastic mixing tub. You can put down some wax paper and pour the epoxy onto that. This lets you move the epoxy as you move along the didge.Don some latex gloves.While wearing the latex gloves, dip your fingers into the epoxy, and then spread the epoxy onto the didge. You don't want to apply it very thick, so spread it out good.Continue applying the epoxy to the outside of the didge. Once you get to the other end, the leather will probably have soaked up some/most of the epoxy on the end that you started on, so go back and apply more epoxy to the whole didge. I usually keep applying epoxy until I've used up the entire amount of epoxy that was mixed up.Once you are done applying epoxy, you'll want to remove the pvc pipe and let the didge stand up on its own, to prevent the didge from being bent in the middle.Now wait a day for the epoxy to cure. The leather will soak up nearly all of the epoxy that you applied, so once it's cured, you will have a hard, rough leather surface.", "step_imgs": ["https://cdn.instructables.com/FLD/TUNE/FITUPPJ7/FLDTUNEFITUPPJ7.LARGE.jpg", "https://cdn.instructables.com/FPC/C9LJ/FITUPPJ0/FPCC9LJFITUPPJ0.LARGE.jpg", "https://cdn.instructables.com/FXK/27GU/FITUPPJC/FXK27GUFITUPPJC.LARGE.jpg", "https://cdn.instructables.com/FWW/K9BT/FITUPPJ6/FWWK9BTFITUPPJ6.LARGE.jpg", "https://cdn.instructables.com/FSX/4F7R/FITUPPIZ/FSX4F7RFITUPPIZ.LARGE.jpg", "https://cdn.instructables.com/FYK/2HZ0/FITUPPJ9/FYK2HZ0FITUPPJ9.LARGE.jpg", "https://cdn.instructables.com/FT8/64PJ/FITUPPIY/FT864PJFITUPPIY.LARGE.jpg", "https://cdn.instructables.com/F4S/5HPQ/FITUPPJA/F4S5HPQFITUPPJA.LARGE.jpg", "https://cdn.instructables.com/FE7/TF57/FITUPPJB/FE7TF57FITUPPJB.LARGE.jpg", "https://cdn.instructables.com/FAB/A9DF/FITUPPJ8/FABA9DFFITUPPJ8.LARGE.jpg", "https://cdn.instructables.com/FUT/TU5H/FITUPR2Z/FUTTU5HFITUPR2Z.LARGE.jpg", "https://cdn.instructables.com/FLL/V4QA/FITUPR32/FLLV4QAFITUPR32.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 15: Epoxy the Outside of the Didge - First Coat"}, {"step": 16, "steps_text": "Once the first coat of epoxy on the outside has cured, you can apply a second coat.Use the same procedure to apply the 2nd coat as the first coat. Be sure to spread the epoxy nice and thin, so that the epoxy doesn't run. Since the first coat of epoxy soaked into the leather and sealed it, the leather won't absorb the 2nd coat, so you won't need to go back and keep applying epoxy as it soaks it up, like you did with the first coat. You won't need to use much epoxy, just mix up about 1oz (.5 oz of each component). You probably won't use all of it.(Optional) You can add some fumed silica to the epoxy to thicken it. This allows to you spread it thinner and prevents the epoxy from running, and from \"bunching up\" - Like when you try to spread water thinly on a piece of glass - it won't form a uniform film, but it will separate and bunch up. The epoxy will sometimes do this to a small extent if you apply it too thinly without a thickener.You should thoroughly mix the epoxy first, and then add some fumed silica to the mixed epoxy. Add small amounts at a time, to make mixing easier. Keep adding fumed silica until you get something like a \"snot-like\" consistency. Note that the fumed silica will make the epoxy a translucent white color. Don't worry, when you spread it thin enough it will still be quite clear.", "step_imgs": ["https://cdn.instructables.com/F8O/2C17/FITUPR5J/F8O2C17FITUPR5J.LARGE.jpg", "https://cdn.instructables.com/FUO/HIXN/FITUPR5O/FUOHIXNFITUPR5O.LARGE.jpg", "https://cdn.instructables.com/FNR/G15U/FITUPR5P/FNRG15UFITUPR5P.LARGE.jpg", "https://cdn.instructables.com/F3W/OCVE/FITUPR5Q/F3WOCVEFITUPR5Q.LARGE.jpg", "https://cdn.instructables.com/FH4/19HK/FITUPR5M/FH419HKFITUPR5M.LARGE.jpg", "https://cdn.instructables.com/FI0/89JW/FITUPR5H/FI089JWFITUPR5H.LARGE.jpg", "https://cdn.instructables.com/FXQ/976V/FITUPR5C/FXQ976VFITUPR5C.LARGE.jpg", "https://cdn.instructables.com/FHE/ZK30/FITUPR5G/FHEZK30FITUPR5G.LARGE.jpg", "https://cdn.instructables.com/FAU/PY2V/FITUPR5N/FAUPY2VFITUPR5N.LARGE.jpg"], "step_title": "Step 16: Apply Second Coat of Epoxy on the Outside"}, {"step": 17, "steps_text": "Once you've applied the 2nd coat of epoxy, wait a day for it to cure. Congratulations! The didge is finished. Enjoy!", "step_imgs": ["https://cdn.instructables.com/FCC/YA3P/FJ4VI9SJ/FCCYA3PFJ4VI9SJ.LARGE.jpg", "https://cdn.instructables.com/FE3/9NBI/FJ4VI9SI/FE39NBIFJ4VI9SI.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 17: Enjoy the Didge"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "If you're a college student with one too many paper bags from occasional trips to Trader Joes, or simply a person who has collected quite an amount of paper bags over some time, this project is for you.", "title": "Hexagonal Organizer Made From Paper Bags", "url": "https://www.instructables.com/id/Hexagonal-Organizer-Made-From-Paper-Bags/", "section": "craft", "steps": [{"step": 1, "steps_text": "12 paper bags (I'm using Trader Joes/Safeway bags)*liquid glueglue gunscissorsmarker*thin straw or skewer*thick/boba strawcardboard (big enough for your hexagonal organizer)matte board or a hard/not slippery surface to work on clothespin (optional)* depending on the amount or size of these materials, your end product may look a bit different. However, feel free to experiment and even expand this project even further by increasing the amount of paper bags!", "step_imgs": ["https://cdn.instructables.com/FJN/P776/IYYT8P7U/FJNP776IYYT8P7U.LARGE.jpg"], "step_title": "Step 1: Materials You Need"}, {"step": 2, "steps_text": "First, grab a paper bag and lay it out in front of you with the bottom side facing up.Look for the folds at the bottom and carefully open the bottom by ripping the bag so that it can unfold like so. (If you happen to rip the bag a bit during the process, don't worry! Ultimately, you just want to unfold the bag so that you can work with a flat single layer later.)Then, remove the handles of the bag by carefully ripping it out.", "step_imgs": ["https://cdn.instructables.com/FG3/UJXB/IYYT8PGJ/FG3UJXBIYYT8PGJ.LARGE.jpg", "https://cdn.instructables.com/FR7/WNA9/IYYT8PH3/FR7WNA9IYYT8PH3.LARGE.jpg"], "step_title": "Step 2: Carefully Rip the Bottom Side of the Paper Bag"}, {"step": 3, "steps_text": "After ripping it, your paper bag should look like the picture above. Next, cut along the side of the bag. Be careful notto cut the other side of the bag because you want to unfold the bag and lay it out in front of you so that all you see is one flat single layer.", "step_imgs": ["https://cdn.instructables.com/FVV/3ED2/IYYT8PU5/FVV3ED2IYYT8PU5.LARGE.jpg", "https://cdn.instructables.com/FJ5/28DD/IYYT8QS8/FJ528DDIYYT8QS8.LARGE.jpg", "https://cdn.instructables.com/F2L/NPVC/IYYT8R0R/F2LNPVCIYYT8R0R.LARGE.jpg"], "step_title": "Step 3: Flatten the Bag + Cut"}, {"step": 4, "steps_text": "Grab a ruler and a pencil.Ultimately, you want to create 6 equal sections of the entire sheet. (The total length of my bag was about 37.5 inches and the width was 18 inches. Dividing the total length of my bag by 6, each section should be 6.25 inches.)Draw marks on your bag to help guide you and then cut!", "step_imgs": ["https://cdn.instructables.com/F46/1SGY/IYYT8U8S/F461SGYIYYT8U8S.LARGE.jpg"], "step_title": "Step 4: Measure + Mark + Cut Your Bag"}, {"step": 5, "steps_text": "With one cut section, grab a thin straw (or skewer) and place it at the lower right corner.Angle your straw diagonally  or at about a 45 degree angle from that corner.Look at picture above if you need help knowing how to position strawCarefully start rolling the paper with the straw, making sure that it is tightly rolled.As you continue to roll, the rolled strip will get longer, and so from time to time, tug the straw out a bit from one end so that it won't get lost in your roll. Once you get near the end, put glue at the tip and then roll to finish the strip. Take out the straw.", "step_imgs": ["https://cdn.instructables.com/FJ2/YU73/IYYT8W0Z/FJ2YU73IYYT8W0Z.LARGE.jpg", "https://cdn.instructables.com/FVH/24HO/IYYT8WHV/FVH24HOIYYT8WHV.LARGE.jpg"], "step_title": "Step 5: Start Rolling"}, {"step": 6, "steps_text": "Next, flatten the roll with your marker. (Making it flat will help you in rolling the strip.)Once you have flattened it out, place the marker at the bottom perpendicular to the strip.Similar to the previous step, start rolling it carefully  and  tightly, this time making sure you roll it straight.Rolling the strip will be quite hard to do because we have rolled the strip once already, but you can do it! As you roll, from time to time place a tiny amount of glue on the strip so that the roll will stick together. And once you get near the end of the strip, put glue at the end to finish.", "step_imgs": ["https://cdn.instructables.com/F5J/J8O9/IYYT8WLD/F5JJ8O9IYYT8WLD.LARGE.jpg", "https://cdn.instructables.com/FQY/7PUV/IYYT8WLI/FQY7PUVIYYT8WLI.LARGE.jpg"], "step_title": "Step 6: Flatten + Roll Again"}, {"step": 7, "steps_text": "Carefully  remove the marker from the roll.If you have a clothespin, clamp the roll at the end of the strip.This step is not necessary, but it will help ensure that your roll will stay.", "step_imgs": ["https://cdn.instructables.com/F2R/24ZM/IYYT8XYC/F2R24ZMIYYT8XYC.LARGE.jpg"], "step_title": "Step 7: Clamp With a Clothespin"}, {"step": 8, "steps_text": "This is what one roll should look like. Repeat steps 5 - 7 to create more rolls. In the end you want a total of 54 rolls.", "step_imgs": ["https://cdn.instructables.com/F5I/KD8D/IYYT8YDS/F5IKD8DIYYT8YDS.LARGE.jpg"], "step_title": "Step 8: Repeat"}, {"step": 9, "steps_text": "The hexagonal organizer will be comprised of 6 sides/panels& One side = 3 x 3 rolls.Using a glue gun, stick the rolls together to make a 3 x 3 panel like the picture above.", "step_imgs": ["https://cdn.instructables.com/FXT/ZUF9/IYYT969Q/FXTZUF9IYYT969Q.LARGE.jpg", "https://cdn.instructables.com/FC5/OVSA/IYYT8YBM/FC5OVSAIYYT8YBM.LARGE.jpg"], "step_title": "Step 9: Glue Rolls Together to Make One Panel"}, {"step": 10, "steps_text": "Once you have one panel, create a long roll strip (step 5) and flatten it. This strip will act as a border.Using a glue gun to stick the strip, wrap it along the sides of the panel.Do this for all the 6 panels.", "step_imgs": ["https://cdn.instructables.com/FOY/K7SP/IYYT95YR/FOYK7SPIYYT95YR.LARGE.jpg", "https://cdn.instructables.com/F1W/B76P/IYYT961A/F1WB76PIYYT961A.LARGE.jpg", "https://cdn.instructables.com/FBR/03KK/IYYT9624/FBR03KKIYYT9624.LARGE.jpg", "https://cdn.instructables.com/FN9/UBEU/IYYT8YSZ/FN9UBEUIYYT8YSZ.LARGE.jpg"], "step_title": "Step 10: Glue One Long Strip As a Border"}, {"step": 11, "steps_text": "In order to make the 6 panels into a hexagon that could stand, we need to create a frame.Repeat steps 2 - 3 of unfolding the paper bag, but now instead of marking 6 equal sections, create 6 sections 5 inches in length. And with another paper bag, create 6 sections 6 inches in length.And then cut!The measurements of the frame may differ depending on the size of your panels, but you can also shorten them later.", "step_imgs": ["https://cdn.instructables.com/FZF/84IB/IYYTM719/FZF84IBIYYTM719.LARGE.jpg", "https://cdn.instructables.com/FV2/DCSP/IYYTM75B/FV2DCSPIYYTM75B.LARGE.jpg"], "step_title": "Step 11: Create a Frame - Measure and Cut"}, {"step": 12, "steps_text": "To make the frame, take the sections you cut and with a thicker straw (I'm using a boba straw), roll the strips straight.Once you get near the end, add glue. Do this for all the strips you cut.", "step_imgs": ["https://cdn.instructables.com/F7R/WHU4/IYYTM93M/F7RWHU4IYYTM93M.LARGE.jpg", "https://cdn.instructables.com/FKH/OA0B/IYYTM9MI/FKHOA0BIYYTM9MI.LARGE.jpg"], "step_title": "Step 12: Roll Once More"}, {"step": 13, "steps_text": "Taking the 5 inch roll, use a glue gun to stick it to one side of the panel. Right next on the other side of the panel, glue on the 6 inch roll.Look at the picture above for referenceThe 5 inch roll is where you will attach another panel, whereas the 6 inch roll will act as an edging frame. When attaching the panels together, make sure to glue it on at an angle.Continue to do this for all the panels until you attach all 6 panels together, creating a hexagon.", "step_imgs": ["https://cdn.instructables.com/FW5/9D0R/IYYTMA2S/FW59D0RIYYTMA2S.LARGE.jpg", "https://cdn.instructables.com/F2E/K10Z/IYYTMBYC/F2EK10ZIYYTMBYC.LARGE.jpg", "https://cdn.instructables.com/FQ2/CO4H/IYYTMB4G/FQ2CO4HIYYTMB4G.LARGE.jpg"], "step_title": "Step 13: Glue the Rolls to the Panel"}, {"step": 14, "steps_text": "Put the hexagon on top of the cardboard, making sure that the rolls of the panel are at the bottom (and not facing up.) Take a pencil and carefullytrace the inside of the hexagon. Then, cut your traced hexagon shape.Once cut, place inside your structure. ", "step_imgs": ["https://cdn.instructables.com/FTR/OCOW/IYYTMH05/FTROCOWIYYTMH05.LARGE.jpg", "https://cdn.instructables.com/FHZ/KQR2/IYYTMI8G/FHZKQR2IYYTMI8G.LARGE.jpg"], "step_title": "Step 14: Create a Backing for More Structural Support"}, {"step": 15, "steps_text": "Glue the cardboard backing onto the structure with a glue gun.Look at the picture above as reference to know where to glue", "step_imgs": ["https://cdn.instructables.com/F3S/2SAI/IYYTMMB3/F3S2SAIIYYTMMB3.LARGE.jpg", "https://cdn.instructables.com/FAD/A6O0/IYYTMMI9/FADA6O0IYYTMMI9.LARGE.jpg"], "step_title": "Step 15: Glue the Backing Onto the Structure"}, {"step": 16, "steps_text": "Great job, now you're done! Feel free to add mod podge for a bit of a glossy finish or personalize it even further by painting it. You can have this hexagonal organizer standing up or simply laying flat like a basket. Enjoy your hexagon however you see fit!", "step_imgs": ["https://cdn.instructables.com/F3U/ADE1/IYYTMNYH/F3UADE1IYYTMNYH.LARGE.jpg", "https://cdn.instructables.com/FNL/JYUR/IYYTMNYL/FNLJYURIYYTMNYL.LARGE.jpg"], "step_title": "Step 16: Finish"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "I love hidden compartments. I also love paper. This photo frame has 3 Hidden compartments. One on the left side, one on the right, and a large one on the back. So there plenty of places to hide something while keeping your photos sat on your desk or hung on your wall.  Even better, the photos can be removed and changed at will. If you want to learn how to make this then read on. ", "title": "Multi Hidden Compartment Photo Frame", "url": "https://www.instructables.com/id/Multi-Hidden-compartment-photo-frame/", "section": "craft", "steps": [{"step": 1, "steps_text": "You'll need:Glue and q tips to spread it.2 Sheets of cardstock 8 1/2\" by 11\" (can be colored or white)RulerScissors and a craft knifePencil and eraserPaper Embossing pen or something like a bone folder that you can score paper with. Optional:Paint (I used acrylic in matte black, Metallic black and metallic silver) Tin foil Q tipsIf you are using nice colored card stock the paint in unnecessary, I chose to paint mine because I don't like white and white card stock is all that I had. ", "step_imgs": ["https://cdn.instructables.com/F5A/S2R3/I4VQ68M9/F5AS2R3I4VQ68M9.LARGE.jpg"], "step_title": "Step 1: Supplies"}, {"step": 2, "steps_text": "Before I begin a project I work it out on paper. I try and think through problems before even constructing something. I even use small scraps of paper to roughly sketch out ideas and designs to give me an idea of how things are going to come together at the end. I play around with folds and I keep track of failures by writing the word fail on them. I store these for use later because they can help in projects down the road as well. My plan never exactly matches the actual steps but it is always my way of brainstorming and getting the idea down. I work out a lot of the kinks using visualization as well, which is why what I wrote for the cuts doesn't match what I ended up cutting out as you will see in the next step. The planning phase for me is more of a rough sketch of what my end result will be, rather than a complete step by step of how I will make it. ", "step_imgs": ["https://cdn.instructables.com/FAY/56YJ/I4VQ69VS/FAY56YJI4VQ69VS.LARGE.jpg", "https://cdn.instructables.com/FR6/6RJK/I4VQ69XH/FR66RJKI4VQ69XH.LARGE.jpg"], "step_title": "Step 2: Planning It Out"}, {"step": 3, "steps_text": "Page 1:Cut into two, 5 inch by 8 1/2 inch strips, then you will have one 1 inch wide strip remaining (3 Strips total)Take the first  5 by 8 1/2 inch strip and cut it into two, 4 inch by 5 inch pieces. Take the Second 5 by 8 1/2 strip and cut it to 5 inches by 8 inches. Take the 1 inch by 8 1/2 inch piece and cut Four 1 inch by 2 inch pieces.Page 2:Cut one 6 inch by 8 1/2 inch strip, then  the remaining piece will be 5 inches by 8 1/2 inchesTake the 5 by 8 1/2 inch strip and cut this to 5 inches by 8 inches.Take the 6 by 8 1/2 inch strip and cut this to one 4 by 6 inch piece and one 3 by 6 inch piece. I think I made that sound more complicated than it really is, so just to be clear when you have finished cutting you will have the following pieces:1:  4 by 6 inch piece1:  3 by 6 Inch piece2:  4 by 5 Inch pieces2:  5 by 8 Inch pieces4:  1 by 2 inch piecesThere are 10 pieces in total. The 1 by 2 inch pieces are not shown in the photos above because I did not cut them until I needed them as I didn't want to loose track of a smaller piece, So I just kept the 1 inch strip to the side until I reached nearly the end and cut them then. You can cut them now or you can wait, These are the last component that you will add to the finished frame. ", "step_imgs": ["https://cdn.instructables.com/FOW/61TF/I4VQ69ST/FOW61TFI4VQ69ST.LARGE.jpg", "https://cdn.instructables.com/FZU/X4FJ/I4VQ69RZ/FZUX4FJI4VQ69RZ.LARGE.jpg", "https://cdn.instructables.com/FFI/FSUH/I4VQ69V1/FFIFSUHI4VQ69V1.LARGE.jpg", "https://cdn.instructables.com/F9U/0L9Z/I4VQ69TK/F9U0L9ZI4VQ69TK.LARGE.jpg"], "step_title": "Step 3: Cut Your Pieces"}, {"step": 4, "steps_text": "Begin by scoring the 3 by 6 inch piece. Score one inch in from the left and right hand sides, and one inch up from the bottom, as seen in the photos above. Then mark and cut a 1 inch square off of each corner. Sit this aside for later. ", "step_imgs": ["https://cdn.instructables.com/FRW/C6ON/I4VQ6HP5/FRWC6ONI4VQ6HP5.LARGE.jpg", "https://cdn.instructables.com/FXM/HE83/I4VQ6HJD/FXMHE83I4VQ6HJD.LARGE.jpg"], "step_title": "Step 4: Score the 3 by 6 Inch Piece"}, {"step": 5, "steps_text": "Begin by scoring this into 1 inch increments as shown in the first photo.  (1 inch wide by 4 inches long)Then measure an inch down and in from each corner and mark these as shown in the first photo in pencil. Then draw a diagonal line from the corner of the line you just made up to the edge of the paper within the second 1 inch increment that you previously scored. Repeat this on each corner so that you get something like is shown in the third photo. Then cut this out and repeat this for the second 4 by 5 inch piece. These are going to be the short 4 inch long sides of your finished frame. ", "step_imgs": ["https://cdn.instructables.com/FYO/R0I2/I4VQ6KTC/FYOR0I2I4VQ6KTC.LARGE.jpg", "https://cdn.instructables.com/F25/QUVI/I4VQ6L2G/F25QUVII4VQ6L2G.LARGE.jpg", "https://cdn.instructables.com/FJF/2S1F/I4VQ6KVR/FJF2S1FI4VQ6KVR.LARGE.jpg", "https://cdn.instructables.com/FL9/CVK5/I4VQ6L99/FL9CVK5I4VQ6L99.LARGE.jpg"], "step_title": "Step 5: Score the 2, 4 by 5 Inch Pieces"}, {"step": 6, "steps_text": "This is probably the most difficult step of the process, because there is a lot to score. First start by scoring it into 1 inch increments (1 inch by 8 inch increments to be precise)Then measure down from your outer edge 2 inches and score the outside 1 inch increment. Repeat this for all four corners. Then measure 1 inch down from the top and score across the three interior 1 inch increments. Repeat this on the other end.When you are finished you will have scored the lines as shown in the first photo. Now you want to score diagonally as shown in photo two. Once you have scored the entire page then you will need to cut along the previously scored lines up to the areas that you have just scored. This is drawn in photo three. Each of these will be glue flaps. The fourth image shows you the cut lines on the left hand side and the score lines on the right hand side. Score and cut both of the 5 by 8 inch pieces, then proceed to the next step. These will be identical to one another when finished (so don't score one and cut the other, you score and cut both pieces) ", "step_imgs": ["https://cdn.instructables.com/FUN/QZ41/I4VQ6QOG/FUNQZ41I4VQ6QOG.LARGE.jpg", "https://cdn.instructables.com/FQ6/H56P/I4VQ6RUR/FQ6H56PI4VQ6RUR.LARGE.jpg", "https://cdn.instructables.com/FNK/E8OI/I4VQ6SPY/FNKE8OII4VQ6SPY.LARGE.jpg", "https://cdn.instructables.com/FH7/IC93/I4VQ6SUM/FH7IC93I4VQ6SUM.LARGE.jpg"], "step_title": "Step 6: Score the 5 by 8 Inch Pieces"}, {"step": 7, "steps_text": "Basically you just want to fold and crease you paper along all of the lines that you just scored.  On the 5 by 8 inch pieces. I kept the parts that I had wrote on towards the inside, so I folded  all but the center 1 inch increment to the outside of the piece while I folded the center flap towards the inside. Your flap folds don't have to be perfect at this point as you end up moving them quite a bit while assembling this, so mostly focus on the 1 inch increment folds as shown in the last photo. On the 4 by 5 inch piecesJust fold the 1 inch increments this is shown in the last photo. ", "step_imgs": ["https://cdn.instructables.com/FTH/U8G5/I4VQ6X2N/FTHU8G5I4VQ6X2N.LARGE.jpg", "https://cdn.instructables.com/FIJ/H5FT/I4VQ6X3U/FIJH5FTI4VQ6X3U.LARGE.jpg", "https://cdn.instructables.com/F4D/J6BB/I4VQ6X5O/F4DJ6BBI4VQ6X5O.LARGE.jpg", "https://cdn.instructables.com/FCA/GPWQ/I4VQ6X6F/FCAGPWQI4VQ6X6F.LARGE.jpg", "https://cdn.instructables.com/FQH/O2CU/I4VQ6XRL/FQHO2CUI4VQ6XRL.LARGE.jpg", "https://cdn.instructables.com/FVS/NUVO/I4VQ74VA/FVSNUVOI4VQ74VA.LARGE.jpg"], "step_title": "Step 7: Fold the 5 by 8 Inch and the 4 by 5 Inch Frame Pieces"}, {"step": 8, "steps_text": "The first time I made this I colored 3 of the one inch increments blue in an attempt to demonstrate where you will glue and what each increment becomes. After completing the frame I thought of a better way to label and describe them.  So above what you see in the photos are Each of the frame pieces, With the glue flaps rounded to make them easier to distinguish. You don't want to actually round your flaps though, keep them straight. The above is for demonstration  purposes only.  I also broke the pieces up into sections a, b, c, d, e (these are the 1 inch wide increments you scored on the 4 by 5 inch and 5 by 8 inch pieces) A is your inside, b is the back, C is the center (frame edge) and D is the front, while E is also the inside but glues under A. You can add secret compartments any where you want, Although adding them to the Front and the Inside was more difficult than I wanted to try, as you would have to cut through 6 pieces of paper on the inside of the frame and into the 4 by 6 inch piece that will become the front of the frame. I would suggest adding secret compartments on b, the back, or c, the center.  Both of mine in the finished piece are on C, which is the center. You can add them any where you want.  If you add one where the flaps come together, As I did, then you will want to glue your flap into place first then cut the flap, Which I show in detail in the next steps.Decide, where you want your flaps to be before proceeding to the next step, and mark them and cut them.Also look at the second photo and you can see what each piece will become. This will help you if you decide to put your hidden compartments in different places on the frame than I did. Otherwise you can probably ignore this step completely. ", "step_imgs": ["https://cdn.instructables.com/FWB/7CJX/I4VQ8QTV/FWB7CJXI4VQ8QTV.LARGE.jpg", "https://cdn.instructables.com/FML/JAJS/I4VQ8R08/FMLJAJSI4VQ8R08.LARGE.jpg"], "step_title": "Step 8: A Bit of an Explanation and Some Information on Adding the Frames Hidden Compartments. "}, {"step": 9, "steps_text": "Keep in mind that the blue is the first build and the white is the second demonstration build. Start by laying your pieces out as illustrated in photo 1. Next determine where you want your hidden compartment flaps to be and cut them out. You can put them in different places than I did, however keep them to the back (b) or the center (c)At this point I actually glued the bottom of my frame together (The 5 by 8 inch piece). Glue flap e under flap A. Then I attached the center flap with glue to one of the 4 by 5 inch side pieces. Then I cut the Secret compartment flap. (Glue your flaps to the inside, not the outside)I then cut a flap in my second 4 by 5 inch piece. This compartment won't cross any of the flaps when glued so I didn't glue the pieces down yet. ", "step_imgs": ["https://cdn.instructables.com/F21/62L9/I4VQ6ZZ5/F2162L9I4VQ6ZZ5.LARGE.jpg", "https://cdn.instructables.com/FZI/7VP0/I4VQ7DST/FZI7VP0I4VQ7DST.LARGE.jpg", "https://cdn.instructables.com/FTI/BLFZ/I4VQ7DTS/FTIBLFZI4VQ7DTS.LARGE.jpg", "https://cdn.instructables.com/F5H/J5G0/I4VQ7B5Q/F5HJ5G0I4VQ7B5Q.LARGE.jpg", "https://cdn.instructables.com/FNY/1FEG/I4VQ76PB/FNY1FEGI4VQ76PB.LARGE.jpg", "https://cdn.instructables.com/FMO/RU8I/I4VQ76S5/FMORU8II4VQ76S5.LARGE.jpg", "https://cdn.instructables.com/FX6/QTAK/I4VQ78P8/FX6QTAKI4VQ78P8.LARGE.jpg"], "step_title": "Step 9: Cut the Secret Compartments and Start Building the Frame."}, {"step": 10, "steps_text": "On the Bottom frame piece that you have already constructed in the last step, Glue the diagonal flaps down. There are 4 of these on the bottom piece, so glue each of them as shown in the first two photos.Then glue the second 4 by 5 inch side piece to the center flap. As shown in photo 3 Now you will have 3 pieces glued together by the center flap. This is shown in photo 4 Go ahead and glue the last 5 by 8 inch piece together on it's own. Glue flap e under flap a, like you did in the last step for the bottom piece, and then glue the diagonal flaps down on the top piece. Then attach the top piece to your chain by the center flap. This is shown in photo 5.Now attach the first 4 by 5 inch side piece to the top of the frame by gluing the last remaining center flap to the center of the 4 by 5 inch piece on the left hand side as seen in the last photo. ", "step_imgs": ["https://cdn.instructables.com/FTW/LQD2/I4VQ76QQ/FTWLQD2I4VQ76QQ.LARGE.jpg", "https://cdn.instructables.com/FMK/2WLI/I4VQ76S4/FMK2WLII4VQ76S4.LARGE.jpg", "https://cdn.instructables.com/FA4/244X/I4VQ7FZD/FA4244XI4VQ7FZD.LARGE.jpg", "https://cdn.instructables.com/F91/8B9F/I4VQ7FLO/F918B9FI4VQ7FLO.LARGE.jpg", "https://cdn.instructables.com/FT0/GBK4/I4VQ7KHT/FT0GBK4I4VQ7KHT.LARGE.jpg", "https://cdn.instructables.com/FKF/WODZ/I4VQ7KIX/FKFWODZI4VQ7KIX.LARGE.jpg"], "step_title": "Step 10: Continue Constructing the Frame"}, {"step": 11, "steps_text": "Photo 1, on the inside from the top and bottom of the frame which is 4 inches tall by six inches wide now, you will find 4 flaps, You will need to glue all four of these flaps together so that you end up with something like shown in photo 2. Repeat this on both the left and right hand side of the frame. Next add glue to the triangular flaps you previously glued into place, and glue the edge of the frame these corners. Do the back left hand and right hand sides first as seen in photo 4 and 5, and then turn the frame and attach the front as seen in photos 6 and 7. Now you only have two more flaps to glue down on the right side and on the left side. These are on the center of the frame so they can be a bit tricky to reach, but because you already glued the flaps together you can put pressure on the flaps to make them glue down just by pushing. So start with adding glue to the area shown in photo 8, then push the flap that comes from the front side of the frame (white side in the photos above) down into place. Add glue to the bottom of your last center flap that comes from the backside of the frame and push this up onto the flap you just glued down. As seen in photo 9. Repeat this on the right hand side of the frame. Now you should have a finished 1 inch wide 4 by 6 inch frame with a hole in the center. In the last two photos shown you can see it from the front (white side) and from the back (blue side)", "step_imgs": ["https://cdn.instructables.com/FP1/RTFR/I4VQ7LGD/FP1RTFRI4VQ7LGD.LARGE.jpg", "https://cdn.instructables.com/FEV/6N99/I4VQ7LGK/FEV6N99I4VQ7LGK.LARGE.jpg", "https://cdn.instructables.com/FK8/0JJA/I4VQ7LGT/FK80JJAI4VQ7LGT.LARGE.jpg", "https://cdn.instructables.com/FV8/8GIK/I4VQ7LH0/FV88GIKI4VQ7LH0.LARGE.jpg", "https://cdn.instructables.com/FWV/5PF2/I4VQ7LHF/FWV5PF2I4VQ7LHF.LARGE.jpg", "https://cdn.instructables.com/FON/B38D/I4VQ7LHM/FONB38DI4VQ7LHM.LARGE.jpg", "https://cdn.instructables.com/FV1/UO2W/I4VQ7LHV/FV1UO2WI4VQ7LHV.LARGE.jpg", "https://cdn.instructables.com/FR8/OHVD/I4VQ7LI4/FR8OHVDI4VQ7LI4.LARGE.jpg", "https://cdn.instructables.com/F9F/XOP0/I4VQ7LIB/F9FXOP0I4VQ7LIB.LARGE.jpg", "https://cdn.instructables.com/FWT/M5X7/I4VQ7LIK/FWTM5X7I4VQ7LIK.LARGE.jpg", "https://cdn.instructables.com/FJ0/LXB7/I4VQ7LIV/FJ0LXB7I4VQ7LIV.LARGE.jpg"], "step_title": "Step 11: Constructing the Frame Continued"}, {"step": 12, "steps_text": "Add glue around the edge of the frame and attach the 4 by 6 inch piece that you cut at the beginning to the frame. Next take the 3 by 6 inch piece that we cut and scored earlier and add glue to the bottom flap, then glue this on the back of the frame.Now I ended up painting mine, and I couldn't paint the inside of the flap, so if your picky and want everything painted I would paint the inside areas of the frame now, before gluing the last to flaps in place. Otherwise you want to glue the last two flaps to the inside of the frame as shown in photo 5. If you find it difficult to get your fingers in there you can use the end of a pencil. Glue the flaps on the left and the right into place, at which point yours should look like it does in photo 6. If needed as shown in photo 7 you can trim the top and then add a notch in the center as well. I forgot to take a photo of cutting the notch in this piece but you do need to add a notch too it, especially if you intend on hanging this on a wall, the nail goes through the notch when it's hung up. ", "step_imgs": ["https://cdn.instructables.com/FPM/W23Y/I4VQ7QG2/FPMW23YI4VQ7QG2.LARGE.jpg", "https://cdn.instructables.com/FS6/J9R3/I4VQ7QG3/FS6J9R3I4VQ7QG3.LARGE.jpg", "https://cdn.instructables.com/FAS/5AV3/I4VQ7R4T/FAS5AV3I4VQ7R4T.LARGE.jpg", "https://cdn.instructables.com/F2M/3K5L/I4VQ7R58/F2M3K5LI4VQ7R58.LARGE.jpg", "https://cdn.instructables.com/FNB/IOXA/I4VQ7R6B/FNBIOXAI4VQ7R6B.LARGE.jpg", "https://cdn.instructables.com/FRP/QIOR/I4VQ7R6L/FRPQIORI4VQ7R6L.LARGE.jpg", "https://cdn.instructables.com/F66/TBSW/I4VQ7R61/F66TBSWI4VQ7R61.LARGE.jpg"], "step_title": "Step 12: Add the Front Piece. "}, {"step": 13, "steps_text": "Take the four 1 by 2 inch pieces that you cut. Go one corner at time, so that you get the curves and the edges placed correctly. The left hand side is going to be opposite of the right, and the top is going to be opposite the bottom.  It's easier to see if you have it correct if you focus on one piece at a time. Use the frame that you constructed and bend the 2 inch long piece around the edge to the front of your frame as seen in the second photo. These will be what holds your photos in place.I decided I wanted to round my edges. So I used a bottle and made a curve. Then I cut the curved part out. The longer side is going to the outside of the frame. Then I made a tiny cut on the longer side of my curve. see photo 5. and folded the edge up as seen in photo 6.next I had to trim this piece so that it didn't cover the access point to the hidden compartment that I made, so if necessary trim yours as well. Next glue this to the bottom edge of the frame as shown in photo 9.Fold the top up and make a crease where it folds over the edge of your frame, then add glue to that edge as seen in photo 10. Do not get glue anywhere other than the very edge. Press this down and attach it to the side of your frame as seen in photo 11.Then you repeat this for each edge. Remember that the left and right mirror each other, so the long side of you curved edge should be on the right side of the right piece but it will be on the left side of the left piece. The top and the bottom are opposite as well but if you turn the frame so the top is at the bottom then it's the same. The photos above all show the right hand side being constructed. I kept the bottom of the 1 by 2 inch pieces to the top and bottom of the frame, so they aren't visible from the left and right hand sides which is where my hidden compartments were cut. If you cut hidden compartments at different places that I did, then you may need to play around with positioning these on the frame before cutting a curve in them. Otherwise, just do to the top what you did to the bottom so it's symmetric.When your finished you should have 4 pockets on the front of your frame that you can slip the corners of a 4 by 6 inch photo into. Because of the back hidden compartment, you will want a 4 inch tall photo by a 6 inch wide photo, otherwise, what you put in the pocket won't stay in the pocket.Also if you used a nice colored card stock then your frame is done at this point if not, I'll describe how I painted mine in the next step. ", "step_imgs": ["https://cdn.instructables.com/FTM/6OJG/I4VQ7UJT/FTM6OJGI4VQ7UJT.LARGE.jpg", "https://cdn.instructables.com/FGE/XMQ3/I4VQ7ULP/FGEXMQ3I4VQ7ULP.LARGE.jpg", "https://cdn.instructables.com/FON/FWL9/I4VQ7UM8/FONFWL9I4VQ7UM8.LARGE.jpg", "https://cdn.instructables.com/FR9/PX69/I4VQ7UML/FR9PX69I4VQ7UML.LARGE.jpg", "https://cdn.instructables.com/FVI/EKI2/I4VQ7UO1/FVIEKI2I4VQ7UO1.LARGE.jpg", "https://cdn.instructables.com/FPD/UOV9/I4VQ7UPK/FPDUOV9I4VQ7UPK.LARGE.jpg", "https://cdn.instructables.com/FH1/P7MQ/I4VQ7UR0/FH1P7MQI4VQ7UR0.LARGE.jpg", "https://cdn.instructables.com/FFC/N872/I4VQ7USG/FFCN872I4VQ7USG.LARGE.jpg", "https://cdn.instructables.com/FGI/TUZX/I4VQ7UTL/FGITUZXI4VQ7UTL.LARGE.jpg", "https://cdn.instructables.com/FW4/Y1QS/I4VQ7UUZ/FW4Y1QSI4VQ7UUZ.LARGE.jpg", "https://cdn.instructables.com/FFZ/K4DT/I4VQ7UWC/FFZK4DTI4VQ7UWC.LARGE.jpg", "https://cdn.instructables.com/F1D/FCRW/I4VQ7UYM/F1DFCRWI4VQ7UYM.LARGE.jpg"], "step_title": "Step 13: Finish the Frame"}, {"step": 14, "steps_text": "So first I painted this with a Matte black acrylic paint. I covered all of the white up, paying special attention to the edge. I did this with my fingers because I am lazy and didn't want to have to clean up a brush. If you don't like making a mess then use a brush or use a q tip. Because I used my fingers I wasn't able to use my phone to take a photo. I'm not sure if you can get acrylic paint off a touch screen. Next I went over the black matte paint with a metallic black. This might seem redundant but I have found that metallic paints tend to be less opaque than other acrylic paints, so if I had painted with the metallic black first I would have had to use several coats to get all of the white from the paper hidden. Now is the fun part. I take a ball of tin foil. and a q tip and dip the tin foil into my paint, then I tap it onto the surface of the frame over and over again. Basically I'm using the tin foil like a stamp. This adds paint in random places, Then while the paint is still wet I carefully use the qtip to smear in some mid tones. I just roll it from a wet spot towards a black spot. If you end up with too much silver paint in one area you can add metallic black down again to that area and then reapply the tin foil with silver paint. If you push too hard on your tin foil it will flatten, leaving paint in larger areas, so you may need to use more than one ball of tin foil. You don't need very large pieces of it however so just aim at a ball that is big enough to pinch between two fingers. Stop when your happy with how it looks. It's really easy to do and though it looks kind of odd up close, it looks like a roughly textured surface from a distance. It also kind of looks like it's made of silver, because I used silver paint. You can use other colors if you want and play around with texture that this gives you as well. It's fun to paint with tin foil so I use it on a lot of projects. ", "step_imgs": ["https://cdn.instructables.com/FEA/SUZ6/I4VQ8AOI/FEASUZ6I4VQ8AOI.LARGE.jpg", "https://cdn.instructables.com/FOJ/YW2D/I4VQ8AYU/FOJYW2DI4VQ8AYU.LARGE.jpg", "https://cdn.instructables.com/F3W/BQTD/I4VQ8B7C/F3WBQTDI4VQ8B7C.LARGE.jpg", "https://cdn.instructables.com/F8I/KRM7/I4VQ8B8D/F8IKRM7I4VQ8B8D.LARGE.jpg", "https://cdn.instructables.com/F3N/U5KY/I4VQ8B9E/F3NU5KYI4VQ8B9E.LARGE.jpg"], "step_title": "Step 14: Paint the Completed Frame. "}, {"step": 15, "steps_text": "So your done, and it's all painted. Now just add a photo, and hang it on your wall. You can store some usb sticks in the frame or a pencil or some extra money in the back pocket. and unless someone looks closely at the sides or pulls it off the wall to look at the back, they're not likely to see the hidden compartments.Plenty of secret places to store whatever you want to hide. Oh and since I forgot to mention this previously to open the compartments you insert the tip of a pencil or a paper clip into the v shaped hole, the pop it open. A bit of added security so what you store inside them doesn't fall out, To close the hidden compartments you just push them in past the edge of the paper.", "step_imgs": ["https://cdn.instructables.com/FXN/X499/I4VQ8J21/FXNX499I4VQ8J21.LARGE.jpg", "https://cdn.instructables.com/FEF/82LO/I4VQ8J5K/FEF82LOI4VQ8J5K.LARGE.jpg", "https://cdn.instructables.com/F74/J1PI/I4VQ8J8W/F74J1PII4VQ8J8W.LARGE.jpg", "https://cdn.instructables.com/F7E/QOJP/I4VQ8JCA/F7EQOJPI4VQ8JCA.LARGE.jpg", "https://cdn.instructables.com/F3R/NKSB/I4VQ8JDC/F3RNKSBI4VQ8JDC.LARGE.jpg", "https://cdn.instructables.com/FLI/ZPQZ/I4VQ8JGO/FLIZPQZI4VQ8JGO.LARGE.jpg", "https://cdn.instructables.com/F9Q/W1X4/I4VQ8JL3/F9QW1X4I4VQ8JL3.LARGE.jpg", "https://cdn.instructables.com/FIB/YKH2/I4VQ8JOH/FIBYKH2I4VQ8JOH.LARGE.jpg", "https://cdn.instructables.com/FOC/YY4O/I4VQ8JRX/FOCYY4OI4VQ8JRX.LARGE.jpg"], "step_title": "Step 15: All Finished"}], "channel": "No channel to show"}, {"category": "workshop", "description": "Have you ever been working on homework or playing a board games with friends and think, \"Man I wish i had a big enough and strong enough table to hold everything\"? I did and I decided to do something about it. I used to work construction so I had all of the required tools and knowledge to build one, so I took some time to design what I consider, \"The Ultimate Coffee Table\". After collecting all of the materials, cutting and assembling the table took me around 3 hours . I know I could make it faster, but I took my time to document each step. Depending on your skill level, I would assume it would take you the same amount of time to build this table. If you have never touched a tool in your life and don't know how to use a tape measure, it will probably take you quite a bit longer. The Cost of this table, assuming that you have your own tools, will be right around $40.  This may vary depending on where you buy your materials, I bought mine at Lowe's. If you do not have all of the tools to complete this project, which are listed in the first step, I would recommend asking a friend to borrow their or else you will be spending anywhere between $70-$330.  This will vary depending on the quality of the tools. Tip: Make sure that you have a flat, level surface to assemble the table on.", "title": "The Ultimate Coffee Table", "url": "https://www.instructables.com/id/The-Ultimate-Coffee-Table-1/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Lumber : (Prices vary by store) 1-12'x2\"x6\", Pine 1-16'x2\"x4\", Pine 1- 3/4\"x24x48, Stain Grade Wooden Panel Recommendation: If you do not have a truck to haul the lumber to your house you can ask to get the 12' 2\"x6\" and 2\"x4\" boards cut into two 6' studs to fit them into your vehicle.Hardware: 54-2 1/2\" torque screws ($6.93+tax for 87 screws)Tools: (Price of my tools) Tape Measure ($15) Drill ($200) Star drill-bit (will come in box of Screws) Circular Saw ($100) Square ($5) Safety Glasses ($10)", "step_imgs": ["https://cdn.instructables.com/F8S/ON57/GTV9WKH6/F8SON57GTV9WKH6.LARGE.jpg", "https://cdn.instructables.com/FEJ/3DAH/GTUYA3HS/FEJ3DAHGTUYA3HS.LARGE.jpg"], "step_title": "Step 1: Gathering Your Materials"}, {"step": 2, "steps_text": "When cutting with a saw there are some safety measures you should follow. 1. Always wear safety glasses when cutting material 2. Never place fingers in path of the saw. 3. Always make sure the power chord is in a dry location and is not frayed.", "step_imgs": ["https://cdn.instructables.com/FLD/OPPR/GTXK8EJZ/FLDOPPRGTXK8EJZ.LARGE.jpg"], "step_title": "Step 2: Cutting Safety"}, {"step": 3, "steps_text": "The frame is made out of 2\"x6\" lumber and consists of two sides, one front and back, and 4 braces.Cut from 12' 2\"x6\" Board: 2 @24\" Boards (front and back) (A) 2 @45\" Boards (sides) (B)Cut from 16' 2\"x4\" Board: 2 @24\" Boards (braces) (C) 2 @6\" Boards (braces) (D)", "step_imgs": ["https://cdn.instructables.com/FAW/MWBY/GTQVP2BB/FAWMWBYGTQVP2BB.LARGE.jpg", "https://cdn.instructables.com/FDS/CQT2/GTUYA3HP/FDSCQT2GTUYA3HP.LARGE.jpg", "https://cdn.instructables.com/FCE/83FL/GTV9UA31/FCE83FLGTV9UA31.LARGE.jpg", "https://cdn.instructables.com/FJV/RIEZ/GTV9UA2R/FJVRIEZGTV9UA2R.LARGE.jpg"], "step_title": "Step 3: Cutting the Frame"}, {"step": 4, "steps_text": "Cut the wooden panel to length. 2\"x6\" boards are technically 1 1/2\"x5 1/2\", so to determine the size we need to cut the panel to we need to remove 1 1/2\" +1 1/2\"=3\" from the length to allow it to fit snugly into the frame.Cut tabletop to 24\"x45\" You will be able to use the scrap from the wooden panel to make the shelf to hold your laptop under the table. This piece will be attached to the two long supports, which will be 15\" apart on center to fit any size laptop. The scrap piece will be 6\"x24\".Cut the scrap piece to 6\"x16 1/2\" to make the shelf.", "step_imgs": ["https://cdn.instructables.com/FSW/X1WF/GTV9WKH4/FSWX1WFGTV9WKH4.LARGE.jpg"], "step_title": "Step 4: Cutting Tabletop (E) & Laptop Shelf (F)"}, {"step": 5, "steps_text": "To make this table extremely sturdy and eliminate the possibility of it swaying once it is build, I put two sets of legs in each corner, creating a 90 degree angle. The length of the leg can be adjusted if you would like to make your table sit either lower of higher. If you decide to make the table taller, however, you will need to initially purchase a longer 2\"x 4\" board. The leg height I used and would recommend, was 17\". To make the legs, cut eight 2\"x4\" pieces at this length.Cut from remainder of 16' 2\"x4\"board: 8-17\" Boards (legs) Hint: Make sure all of the legs are EXACTLY the same length to ensure that the table is level when completed.", "step_imgs": ["https://cdn.instructables.com/F9E/3513/GTQVP2B0/F9E3513GTQVP2B0.LARGE.jpg"], "step_title": "Step 5: Cutting the Legs (G's)"}, {"step": 6, "steps_text": "A-  Front and back of frameB-  Sides of frameC-  Center supportsD- Edge supportsE- Table topF-  Laptop shelfG- Legs", "step_imgs": ["https://cdn.instructables.com/F2T/JBMR/GTW60DI1/F2TJBMRGTW60DI1.LARGE.jpg"], "step_title": "Step 6: List of Pieces"}, {"step": 7, "steps_text": "All of the pieces are cut to the correct, length so now it is time to put it all together. To assemble the frame start by laying out the pieces as shown below. Place the A 's on the ground so that they are parallel to each other and the B 's are perpendicular to them, on the very edge of the A 's. Start 3 screws, evenly spaced vertically, 3/4\" away from the edge of the frame. Place the square in the corner and ensure that the two boards are snug against the square, making a 90 degree angle. Drive the screws into B  while pushing B  down onto A to ensure a tight fit. Repeat this step for the remaining 3 corners of the frame. Tip:To easily space screws, use width of the square for a even 1 1/2\" spacing.", "step_imgs": ["https://cdn.instructables.com/FQS/U2ST/GTW608YV/FQSU2STGTW608YV.LARGE.jpg", "https://cdn.instructables.com/FUQ/1G67/GTW2B3RI/FUQ1G67GTW2B3RI.LARGE.jpg"], "step_title": "Step 7: Assemble Frame (A & B)"}, {"step": 8, "steps_text": "Now that the exterior of the frame is assembled, place the table top (E ), in the bottom of the frame. Measure horizontally along either A, from the inside edge of a perpendicular B , 12 3/4\" and make a mark. Place the right edge of the square on the measured and the handle tight against the table top. Make lines on both sides of the square, perpendicular to the table top. Start two screws on the outside of the frame, in between the lines you just made, 1 3/4\" and 3 1/4\"(width of square) from the top of the table. Measure from the ground since the table is upside down. Measure 12 3/4\" and start screws for the other end of board before inserting board C . Place board C in between the lines. The fit should be snug since C is the same length as B . Make sure that the board is between the lines, which will make a 90 degree angle with the table top. Drive the screws into board C  while pushing C  down onto E to ensure a tight fit. Repeat Step 7 for the other C on the opposite side of the table.", "step_imgs": ["https://cdn.instructables.com/FVU/WU4O/GTW65RRM/FVUWU4OGTW65RRM.LARGE.jpg", "https://cdn.instructables.com/F88/8RHD/GTW609C0/F888RHDGTW609C0.LARGE.jpg", "https://cdn.instructables.com/FCK/EYHN/GTW609C2/FCKEYHNGTW609C2.LARGE.jpg", "https://cdn.instructables.com/FC6/FWR1/GTW609C3/FC6FWR1GTW609C3.LARGE.jpg"], "step_title": "Step 8: Install Center Supports (C's)"}, {"step": 9, "steps_text": "Measure 9\" horizontally along either B , from the inside edge of the perpendicular A . Measure 9\" horizontally again, along the same B , from the opposite A . Place a D vertically in between the two marks. Start two screws, staggered and angled so the drill can reach the screw, as show above. Screw the two screws into D while pushing D  down onto E to ensure a tight fit. Repeat Step 8 on the inside of the opposite B .", "step_imgs": ["https://cdn.instructables.com/FPV/96RG/GTW65RZV/FPV96RGGTW65RZV.LARGE.jpg"], "step_title": "Step 9: Install Edge Supports (D's)"}, {"step": 10, "steps_text": "Flip the entire table over so that E  is on top of the supports. If you pushed down on the supports while screwing them in, E  should be flush with the top of the frame, A &B . Measure 3/4\" into the table top E,  from center of each edge of the supports C&D . Drive screws into measured mark. Repeat 5 more times until you have E  secured.", "step_imgs": ["https://cdn.instructables.com/FOA/TS6P/GTW65RZJ/FOATS6PGTW65RZJ.LARGE.jpg", "https://cdn.instructables.com/FBR/Z4MW/GTQVP9XE/FBRZ4MWGTQVP9XE.LARGE.jpg"], "step_title": "Step 10: Secure Table Top (E's) Onto Frame"}, {"step": 11, "steps_text": "Flip table back onto its top to attach the legs. Set the first leg into a corner where A  and B intersect. Butt the wide side of G  up against B and butt the narrow side of G  up against A.  Start two screws in the bottom of the leg, staggered and slightly angled (approximately 30 degrees) away from the table top. Use square to ensure that the leg is perpendicular to the table top and also parallel to B . Drive the screws through G , into B. This will help with the strength of the table since the legs will be straight. Repeat this step for the remaining 3 corners. Once the first set of legs is in repeat the step again, except this time butt the wide side of G  up against A  and butt the skinny side up against the first leg you installed. Also, make sure that the second set of legs are parallel to A  as well and drive the screws through G,  into A . This will ensure that the legs make a 90 degree angle and minimal, if any, wiggle room.", "step_imgs": ["https://cdn.instructables.com/FUC/M4ZH/GTW2B5FL/FUCM4ZHGTW2B5FL.LARGE.jpg", "https://cdn.instructables.com/F2B/884R/GTQVP9XD/F2B884RGTQVP9XD.LARGE.jpg"], "step_title": "Step 11: Attach Legs (G's)"}, {"step": 12, "steps_text": "Measure and mark 4\" from both intersections of back A  and C's . Place edge of shelf F  on marks so that the edges are flush with the outsides of both C's . Drive a screw into each corner of F , offsetting each screw 3/4\" from each edge of the shelf.", "step_imgs": ["https://cdn.instructables.com/FKR/N6R7/GTW60DQE/FKRN6R7GTW60DQE.LARGE.jpg"], "step_title": "Step 12: Attaching Laptop Shelf (F)"}, {"step": 13, "steps_text": "Flip the table back over and set it up on its legs.", "step_imgs": ["https://cdn.instructables.com/FBE/AQ0D/GTWPB4RK/FBEAQ0DGTWPB4RK.LARGE.jpg"], "step_title": "Step 13: Completed Table"}, {"step": 14, "steps_text": "Once I had completed my original table, I make a few additions to make this table truly unique. I had one of my artistic friends burn my Fraternity's letters into the table top after I had sanded it smooth. I then applied 7 layers of clear coat to help maintain the wood and keep it from absorbing liquids. Later on I got sick of always having to plug and unplug my computer's charger from behind the couch, so I mounted a power strip underneath it. Once I had power to my table I installed a LED rope lights underneath the table, which allows me to know whether or not the power strip is on and charging my laptop under the table. The lights, which I initially installed during the Christmas season, also gives the table a nice golden glow.", "step_imgs": ["https://cdn.instructables.com/FO0/UO0Q/GTW60DM0/FO0UO0QGTW60DM0.LARGE.jpg", "https://cdn.instructables.com/FHS/SR9R/GTQVPD0H/FHSSR9RGTQVPD0H.LARGE.jpg", "https://cdn.instructables.com/FDL/SWQX/GTW60DMQ/FDLSWQXGTW60DMQ.LARGE.jpg", "https://cdn.instructables.com/FHW/2MQM/GTW60DMD/FHW2MQMGTW60DMD.LARGE.jpg"], "step_title": "Step 14: Conclusion-Additional Modifications"}], "channel": "Woodworking"}, {"category": "workshop", "description": "A hexagonal deck takes a lot more time to build than a rectangular one but it is a lot more interesting to look at.  ", "title": "Hexagonal Deck", "url": "https://www.instructables.com/id/Hexagonal-Deck/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Level the area where the deck is going to go.  Laying out the outside frame is really important.  If you get the angles exact, you will be able to mass cut all of your deck boards.  If you are off  even slightly in your angles, you will have to measure and then cut every angle on the deck boards.  If your deck is sitting on the ground, you can use pressure treated 2 x 4's as framing.  Decide how big across your deck is going to be.  Here are some distances.  The diagonal is the distance from a corner to the opposite corner.  The deck in the picture has a 14 foot diagonal.A diagonal of 96 inches (8 feet) needs a side length of 48 inches   A diagonal of 108 inches (9 feet) needs a side length of 54 inchesA diagonal of 120 inches (10 feet) needs a side length of 60 inchesYou'll notice that for every additional diagonal foot, the side length increases six inches.  Cut the ends of six side pieces exactly 60 degrees.  Remember to put end cut paint on all newly cut ends.  Screw them together with deck screws, making sure that they are exactly matched up.  Put this hexagon in place on the ground and make sure that each angle is 120 degrees.  Cut one end of the diagonal piece into a V with the angles being 60 degrees.  Place it against one inside corner of the hexagon and then measure and cut the other end of the diagonal piece by putting it on the opposite corner and drawing a pencil line underneath.  Screw this diagonal in place when it is cut and painted. ", "step_imgs": ["https://cdn.instructables.com/FRM/WGHA/JRGOJ9MR/FRMWGHAJRGOJ9MR.LARGE.jpg", "https://cdn.instructables.com/FKY/JTYT/JRGOJ9NR/FKYJTYTJRGOJ9NR.LARGE.jpg"], "step_title": "Step 1: Leveling and Outside Frame"}, {"step": 2, "steps_text": "Mark the center by finding half of the diagonal.  Cut and screw in rays that go from the center to each corner.  Make a smaller hexagon by cutting cross pieces 16 inches long and screwing them in between the rays.  Fill in the additional framing by adding joists and more angled pieces so that there is not a span of over 16 inches.  This is for deck boards which are 1 1/4 inches thick.  If you are using thicker stock for the deck, your span can be greater.  Screw in all the pieces and check all the outside angles again to see if they have shifted. ", "step_imgs": ["https://cdn.instructables.com/FOV/58EG/JRGOJ9QO/FOV58EGJRGOJ9QO.LARGE.jpg", "https://cdn.instructables.com/FON/C3NC/JRGOJ9RK/FONC3NCJRGOJ9RK.LARGE.jpg"], "step_title": "Step 2: Inside Framing"}, {"step": 3, "steps_text": "Measure one outside piece of the frame and add 1/2 inch to it.  Cut six pieces of deck board with 60 degree angles to this length.  Place them along the outside of the framing and screw them on.  They should extend past the edge of the framing a bit.  Put a pencil mark 1/2 inch inside two adjacent rays and in the middle of the rays.  Measure the distance between these two pencil marks and cut your next set of six deck boards that length.  Screw them on and continue in towards the inside of the hexagon.  When you are about four feet from the center, measure the distance from the last board to the center.  Each deck board should be 5 1/2 inches wide with a 1/2 inch gap between them.  If your measurement is slightly off a multiple of six inches, make the gap between all of the next boards slightly more or less so that you will end up with the last boards close to the center. ", "step_imgs": ["https://cdn.instructables.com/F5L/D8DN/JRGOJ9U8/F5LD8DNJRGOJ9U8.LARGE.jpg", "https://cdn.instructables.com/FRD/2LHX/JRGOJ9W1/FRD2LHXJRGOJ9W1.LARGE.jpg"], "step_title": "Step 3: Deck Boards"}], "channel": "Home Improvement"}, {"category": "workshop", "description": "In the developing world, one of the most accessible and affordable treatments for cancer is radiation therapy. In order for radiation therapy to be effective, the radiation must be targeted specifically to the area affected by the cancer. This requires the use of an immobilization device to keep the patient in a fixed position with the least amount of movement possible, and for this position to be replicable between treatments. For breast cancer specifically, such a device must allow for the patient\u2019s torso to be positioned at a desired angle that allows for the best possible targeting of the radiation therapy to the thoracic region. While such devices are already being manufactured in developed nations, they cost thousands of dollars and are not readily obtained in the developing world.The goal of this project in the broadest sense is to create such a device that is effective at keeping patients immobilized with their torso propped up at a desired angle, while ensuring that the materials are both cheap and available in the developing world.", "title": "Immobilization Device for Radiation Therapy Fall 2016", "url": "https://www.instructables.com/id/Immobilization-Device-for-Radiation-Therapy-Fall-2/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Materials:1 Pine 2x12x121 Pine 4x4x8 1 Pine 1x4x12 1 Circular Pine Fence Post1 1in diameter x 18in long dowel rod ~10oz of wood glue 12 8x1-5/8in deck screws Latex Paint/Primer 2 Hinges EpoxyTools:Table sawBand sawJig sawMilling MachineElectric Powered HandsawJointerChop sawDrillPaint Brush", "step_imgs": [], "step_title": "Step 1: Materials & Tools"}, {"step": 2, "steps_text": "Refer to images for measurements and relative locations of cuts.2x12x12Using the table saw, cut the 2x12x12 into the following pieces:-Two 42\" length pieces-Two 21.5\" length piecesUsing the jig saw, cut a rounded hole out of the edge of each 21.5\" piece as shown in the drawing labeled SHORT. The hole should be 3.5\" wide at the base, 3\" tall, and begin 2\" from the bottom of the board.These will be used to form the main body of the board, divided into the upper and lower sections.4x4x6 Using the chop saw, cut the 4x4x6 into the following pieces:-Two pieces that are 9.74\" tall on the back end and 10.87\" tall on the front end. Use the chop saw at an angle of 15 degrees for the first cut and then 0 degrees for the second cute so that the length and angle are exactly the same for both blocks. -Two pieces that are 6.58\" tall on the back end and 7.29\" tall on the front end. Use the chop saw at angle of 10 degrees for the first cut and then 0 degrees for the second cut so that the length and angle are exactly the same for both blocks.-Two pieces that are 3.31\" tall on the back end and 3.66\" tall on the front end. Use the chop saw at angle of 5 degrees for the first cut and then 0 degrees for the second cut so that the length and angle are exactly the same for both blocks.These pieces will form the angled blocks that hold the breast board up at an angle.1x4x10 Using the table saw, cut the 1x4x10 into the following pieces:-Three 22\" length pieces (or whatever twice the width of the 2x12x12 board is - it may not be exact)These pieces will be used as the supports across the back of the main boards.Dowel RodUsing the chop saw, cut the dowel rod into the following pieces:-Eight 2\" length piecesThese will be used as the pegs that attach the angle blocks and butt stop to the board.Pine Fence PostUsing the chop saw, cut the pine fence post into the following pieces:-One piece 22\" in length (or whatever twice the width of the 2x12x12 board is - it may not be exact)Then, using the jointer cut the pine fence post in half lengthwise. This should result in two pieces 22\" in length with a semicircular cross section.", "step_imgs": ["https://cdn.instructables.com/F37/0FYN/IWH3584K/F370FYNIWH3584K.LARGE.jpg", "https://cdn.instructables.com/FLE/JI7J/IWH3583V/FLEJI7JIWH3583V.LARGE.jpg", "https://cdn.instructables.com/FYR/DHMM/IWH35837/FYRDHMMIWH35837.LARGE.jpg", "https://cdn.instructables.com/FKZ/HGXV/IWH35GTM/FKZHGXVIWH35GTM.LARGE.jpg"], "step_title": "Step 2: Cuts"}, {"step": 3, "steps_text": "Refer to images for locations and dimensions of notches and holes.NotchingThe notches will be used as a space to hold the 1x4 planks that go across the back of the 2x12 boards as supports. Using the mill, make notches that span the entire width of the board, about 3.5\" tall (or whatever the exact width of the 1x4 is), and about 3/4\" deep (or whatever the exact thickness of the 1x4 is) by covering the entire area with at about 1/10\" of depth at a time. Alternatively, you can raise the blade on a table saw the correct thickness and go 1/8 in of length at a time down the width. Make notches at the following locationsL-10\" from one end of both 42\" 2x12s boards. Make sure the notches line up across both boards when placed side by side so that the 1x4 support will fit when the boards are glued together. -7 1/2\" from the other end of both 42\" 2x12 boards. Make sure the notches line up across both boards when placed side by side so that the 1x4 support will fit when the boards are glued together.-9\" from one end of both 21.5\" 2x12 boards. Make sure the notches line up across both boards when placed side by side so that the 1x4 support will fit when the boards are glued together.Drilling Holes-Drill holes that are 1\" deep and 1\" in diameter with centers in the locations shown in the images above on the 2x12 boards.-Drill holes that are 1\" deep and 1\" in diameter into the exact center of each of the angled 4x4 blocks.-Drill two holes that are 1\" in deep and 1\" in diameter with centers 9\" apart at the top end of the 21.5\" 2x12s - this is the end that will be hinged to the 42\" 2x12s. -Drill two holes that are 1\" deep and 1\" in diameter with centers 11\" (or however far apart the holes in the center of the 2x12 boards are) in the flat side of the semicircular pine fence post. These holes should be exactly lined up with those in the board so that once the pegs are glued in to the butt stop, they will fit in the holes on the board.", "step_imgs": ["https://cdn.instructables.com/F2Y/KKP1/IWH358AS/F2YKKP1IWH358AS.LARGE.jpg", "https://cdn.instructables.com/FW9/PITL/IWH3589Z/FW9PITLIWH3589Z.LARGE.jpg", "https://cdn.instructables.com/F6C/KEED/IWH3589C/F6CKEEDIWH3589C.LARGE.jpg", "https://cdn.instructables.com/FJO/QHIB/IWH35H9E/FJOQHIBIWH35H9E.LARGE.jpg"], "step_title": "Step 3: Notching & Drilling"}, {"step": 4, "steps_text": "Top Boards:1. Apply wood glue liberally to the inside edge of one of the top boards. This should be the edge of the board that does not have the semicircular section cut out.2. Lay the board on a flat surface and push the corresponding edge of the other top board against the glue. Both semicircular cutouts should be on the outside edges of the glued together board.3. Apply clamps so that the glued portion of the boards are held firmly together, without clamping so hard that the boards buckle and are no longer flat on the ground or other surface they are laying on.4. Leave boards clamped for at least 8 hours, and allow the glue at least 24 hours total to dry before moving the boards.Bottom Boards:1. Apply wood glue liberally to the inside edge of one of the bottom boards. The inside edge of each board can be determined by looking at the back of the boards and lining up the holes drilled for the index, making sure that they are the correct width apart.2. Lay the board on a flat surface and push the corresponding edge of the other bottom board against the glue. 3. Apply clamps so that the glued portion of the boards are held firmly together, without clamping so hard that the boards buckle and are no longer flat on the ground or other surface they are laying on.4. Leave boards clamped for at least 8 hours, and allow the glue at least 24 hours total to dry before moving the boards.Butt Stop:1. Apply wood glue liberally to one end of each peg and place one in each hole drilled in the butt stop.2. Clamp each peg into place. Leave pegs clamped for at least 8 hours, and allow the glue at least 24 hours total to dry before moving the butt stop.Angle Blocks:1. Apply wood glue liberally to one end of each peg and place each in its corresponding hole cut in the top of the blocks.2. Clamp each peg into place. Leave pegs clamped for at least 8 hours, and allow the glue at least 24 hours total to dry before moving the butt stop.", "step_imgs": ["https://cdn.instructables.com/F60/F65B/IWH35J3A/F60F65BIWH35J3A.LARGE.jpg"], "step_title": "Step 4: Gluing"}, {"step": 5, "steps_text": "1. Fill each hole drilled in the back of the bottom board in with epoxy and let the epoxy cure for 24 hours.2. A 0.5\" hole will need to be drilled into each well of epoxy. Mark the center of each hole so that the centers are square with the top of the board and exactly 9\" apart.3. Drill 0.5\" holes in the epoxy, centered at the points marked in Step 2. begin by drilling a very small hole and gradually increase the size of the drill bit until reaching 0.5\". **Note: it is important that the holes be drilled as straight up and down as possible. Use a drill press if available.**", "step_imgs": ["https://cdn.instructables.com/FGS/CIMY/IWH358FF/FGSCIMYIWH358FF.LARGE.jpg"], "step_title": "Step 5: Epoxy"}, {"step": 6, "steps_text": "1. Paint all components of the board: the top half, bottom half, butt stop, and angle blocks. **Note: be  careful not to paint dowels or holes so that they still fit together, or  drill slightly larger holes to account for paint thickness.**2. Once paint has dried, write the corresponding angle (in degrees) on the back of each set of angle blocks.3. Screw hinges on the front of the top board, one on each edge as far towards the outside of the board as possible.4. Line bottom board up so that the holes for the butt stop are closest to the top board. Fasten the two boards together by screwing the free end of the hinge onto the bottom board.", "step_imgs": ["https://cdn.instructables.com/FFG/8X3Y/IWH35U8F/FFG8X3YIWH35U8F.LARGE.jpg", "https://cdn.instructables.com/FMW/2NLA/IWH358GJ/FMW2NLAIWH358GJ.LARGE.jpg", "https://cdn.instructables.com/F10/VVBN/IWH358NW/F10VVBNIWH358NW.LARGE.jpg"], "step_title": "Step 6: Paint & Assembly"}], "channel": "Woodworking"}, {"category": "workshop", "description": "  This is a Vertical Axis Wind Turbine which uses wind energy to drive things like air and water pumps for cooling, irrigation and similar, or an alternator/generator for producing electricity.  Note: this tutorial is also available at http://solarflower.org/tutorial.php?lang=en&tut=vawt with a slightly more usable layout.  The turbine uses the 35-40% mechanically efficient Lenz2 lift+drag design. It is made entirely from scrap materials except for the bolts and pop rivets, and should cost about $15-$30 for the six vane version, which can be made by two people in six hours without much effort.   The three vane version has been successfully survival tested to 80 km/h sustained winds and the six vane version to 105 km. Both will do more, but exactly how much has not yet been ascertained.  Full power curves have yet to be calculated for this particular build, but according to Mr Ed Lenz's calculator (http://windstuff.org/calc/calc.php) a six vane at 0.93 meters diameter and 1.1 meters high with a 90% efficient alternator should produce at least 135 watts of electricity in a 30 km/h wind, and 1.05 kilowatts at 60 km/h.  The materials listed in this tutorial are to make the three vane version. Double everything except the bike wheel for six vanes.", "title": "$30 Vertical Axis Wind Turbine From Scrap Materials", "url": "https://www.instructables.com/id/Vertial-Axis-Wind-Turbine-from-30-Of-Scrap-Materia/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Tools:Power drill 4mm metal drill bit Craft knife / scalpel / exacto 20mm x 20mm angle aluminium  About 1 meter long, an extra ~30cm length can also be handy. To be used for ruling and bending.Tape MeasurePop RiveterSpanners  Probably 7mm, 15mm and 17mm - to fit your M4 nuts and the nuts on the bike wheel axleBike Cone SpannerMarker PenSticky Tape4 Clothes Pegs  Springy or the other kind.A small bit of wood  For drilling into.Computer and printer  Low quality black and white is fine.2 pieces A4 paperMaterials:12 Aluminium lithographic offset printing plates  These are pure aluminium sheets used in a printing process fairly common with newspapers and magazines. A medium sized printing company may scrap hundreds of plates every week, so it's usually easy to pick them up cheap. Ring around any local companies offering offset printing.  This tutorial is for plates which are 67cm wide by 56cm tall. There doesn't really seem to be any size in particular which is standard, if you can only get plates which are larger than 67cm then either scale up the measurements (though that is the size which best fits a 27 inch bike wheel, which is generally the largest you can get) or trim the plates down to that size. If you can only get smaller than scale the design down and use a smaller wheel.  The 56cm length really doesn't matter at all. The taller the vanes the more energy you'll get. The relevant steps in the tutorial will tell you how to accommodate other lengths.126 4mm diameter pop rivets   About 5mm long.18 M4 bolts and nuts  About 15-20mm long18 spring washers   To fit the M4 bolts42 washers   4mm inner diameter to fit the pop rivets, about 10-15mm outer27 inch bike wheel  Exactly how bike wheels are measured is slightly complicated, basically you want one which is 64cm total outer rim diameter. You can use other sizes for smaller turbines, adjust the other dimensions accordingly.  It doesn't matter if it's a bit rusty but needs to run smoothly and not wobble. You don't need the tire or inner tube.6 bike wheel spokes  Any length. Some kind of thickish wire or similar would also suffice.", "step_imgs": ["https://cdn.instructables.com/FXO/AEUP/HSVGHF9Q/FXOAEUPHSVGHF9Q.LARGE.jpg"], "step_title": "Step 1: Tools and Materials"}, {"step": 2, "steps_text": "  These steps relate to the construction animation. You might want to open this in a new window to make it easier to cross-reference with the steps text.  You can download the animation here (right click, 'save link as'):High quality (21.2 Mb)Low quality (8.8 Mb)Step 1:  Download (right click, 'save as') and print the two template files onto A4 paper:vawt_template1.pdfvawt_template2.pdf  Make sure they're printed at 100% and centered, the images should be 21cm by 29.7cm at 40 dpi. You may get a warning that the image is larger than the printable area of the page, you can ignore that. When printed measure the distance between the + marks, it should be 10cm on both pages.2:  Tape the pages together so that the + registration and circular marks overlap as closely as possible. Best way to do this is on a window pane during the day, so you can see both pages showing through.  With a craft knife and the angle aluminium as a straight edge, cut the surrounding paper off the template.  Any time you're cutting, always make sure your other hand is never in front of the knife, so if you slip you're not going to slice yourself. The angle aluminium is good for this, as the vertical bit effectively shields the hand holding it.3:  Take an aluminium sheet and measure a box 43cm by 48cm. Score the lines with the craftknife and straight edge. You're not trying to cut through the metal, just create a line that can then be torn out later. A good method is to score once lightly, then a second time a bit deeper.  Draw a line 24cm up the long side, halving it.4:  Flex the metal so that it bends at a score line, then flex back the other way. Do this a couple times and it should split. Do the same for the other score and remove the outer metal. Keep it for later.5:  Tape the template to the metal (from now on to be referred to as a 'former') so that the long edge of the paper sits on the middle line and the right edges of both line up. Don't worry if the other edges don't align perfectly.6:  With blade and straight edge, score out the template curve, including the triangles at each end. It's not essential that this be 100% perfect, but try to get the first one reasonably nice as you can then use it as a template for the rest.7:  Score, flex, and remove the two triangles of metal outside the template.8:  Flip the paper template over so that the printed side is down on the other half of the former, keeping the long edge on the middle line. Retape so it doesn't shift too much. Check that you can see the circular marks through the paper. If you can't then punch small holes or similar so that those marks can be seen from the back.  Give the curved score a couple of flexes and tear it out. Remove the two small triangles. A video on how best to do this will be posted here soon.9:  You now have your first former. Repeat steps 3 through 7 so that you have a total of 6 formers. You can use the first former as a cutting template rather than the paper.  Take 3 formers and peg them together so that they are as nicely aligned as possible.  Use tape to attach them if you don't have clothes pegs.10:  Drill 13 4mm holes through all three formers, one for each of the circular marks on the template. Drill the center hole first, as this is the only one that needs to be reasonably accurate.11:  Remove the template and unpeg the formers. Peg and drill 3 more formers so that all 6 are drilled.  Place a former with the middle line slightly overhanging the edge of the table. Place the straight edge on the middle line and bend 90 degrees. Repeat with all 6, with three formers bent up and 3 bent down. A video of this will be posted here soon.  Put the formers aside.12:  Take a aluminium sheet and draw a line 2cm in from one of the 67cm edges.13:  repeat with 2 more sheets and peg all 3 together so that each drawn line is aligned to the edge of the sheet above it.14:  Mark the edge at 4cm, 6, 8, 10, 18, 26, 34, and then every 2cm up to and including 64cm.  Score at each mark, starting from the drawn line on the top sheet and across all 3 sheets. Keep in mind that one side has a score at 4cm from the edge, the other at 3cm.  Flip the sheets over, making sure they don't lose their alignment, draw another line 2cm in from the edge of the now top sheet.  Mark and score the same as the first edge. Make sure you start from the 4cm edge.15:  Tap the sheets on the table so that they are aligned on top of each other.  From the 4cm edge draw a vertical line at 19cm in, and one at 33cm.  Mark each line at 3cm and 18cm from both ends. If you're using sheets which aren't 56cm tall then mark at 3cm and divide the rest into thirds. ie if the sheet is 75cm tall then mark from each end at 3cm and 23cm. The 3cm marks need to be at least vaguely accurate, the others don't hugely matter.16:  Drill all 3 sheets with 4mm holes at all 8 marks.  Unpeg the sheets.17:  Place a sheet so that the 3cm edge is overhanging the table. Put the straight edge on the 3cm mark (if you can't make out the score marks then mark them with pen) and triangulate the edge as shown in the animation. Video coming soon.18:  Triangulate the 4cm edge.19:  Pre-bend the sheet so that it'll be easier to place in the formers.20:  Flip the sheet upright and insert into the curve cut into a top former (the uncut half of the former should be pointing upwards).  The best way to do this is to first place the 4cm edge triangle into its slot, then the 3cm edge, then work the rest of the sheet through the cut.21:  Fold down the flaps as shown in the animation. You will probably need to give the score marks a couple of flexes before tearing them.  Push up the former so that it's level with the bent flaps.22:  Fold over the rest of the former.  Flip the vane, place the other former, and fold down the tabs. Place 2 bike spokes or thick wire in the fold of the former and bend it closed.23:  Slice and remove the former's two outer corners. Cut the smaller triangle level with the edge of the other former half, but give the larger triangle a 2cm offset, so that it overlaps.  Repeat for the other former.24:  Take one of the offcuts left over from cutting a former. Cut out a strip which is 7cm wide and 52cm long. (This is assuming you're using a 56cm sheet, for any other size just cut off 4cm. ie For a 75cm sheet cut the strip to 71cm).25:  Draw lines from one edge at 2cm and 4cm, so that there are two 2cm strips and one 3cm strip.  Triangulate the strip as shown in the animation.26:  Mark the middle of the ends of the 3cm wide face with lines a couple of centimeters long.27:  Place the triangulated strut inside the vane so that the 3cm face sits on the row of drilled holes closer to the back edge. Sight the drawn lines through the top and bottom holes to check that it's centered.28:  Drill the strut through the holes in the vane and attach with rivets. Do the top and bottom holes first, then the two in the middle.29:  Take a fresh sheet and cut in half. (This is assuming a 67cm wide sheet, for any other size just cut at 33.5cm).  Remove 4cm from one of the short edges.30:  Repeat twice more so that you have three 33.5cm sheets. Align and peg all three together.31:  From one of the long edges, draw three vertical lines at 1cm, 9cm, and 19cm.  Mark these lines in from both ends at 1cm and 17cm. If you're using other than 56cm high sheets then just mark so that the lines are divided into thirds, more or less.  Drill a 4mm hole at each of the twelve marks.32:  Mark the sheet at 3cm and 5cm in from the opposite edge.  Triangulate the edge as shown.33:  Place the half sheet inside the vane so that its un-triangulated edge is aligned with the vane's back tip.34:  Drill and rivet the row of holes closest to the back edge. Keep the half sheet as flat and unbuckled as possible. It's ok to have a small gap or bowl at either end if it doesn't fit perfectly in the vane.35:  Stand the vane upright. Push the half sheet's triangulated edge in and forward so that it's against the other sheet and somewhat tight over the strut.  Drill through the row of holes on which the triangle is sitting and rivet in place.36:  Drill through one of the middle holes in the half sheet's second row, making sure to keep the drill reasonably straight, and attach with a rivet and washer, so that the washer is on the inside of the vane.  Repeat for the other three holes.37:  Drill, rivet and washer the third row. The half sheet should be fairly tight across the strut.38:  Fold up the overlap on both formers to 90 degrees.39:  Drill through all the holes on the bottom former (the one which will be attached to the bike wheel). Drill into a small block of wood or similar so that the metal doesn't get pushed in and so that you don't risk drilling your hand.40:  Rivet each of the holes, except for the ones marked as in the animation, as these will be bolted to the wheel rim.41:  Drill the holes in the top former and rivet all except the center one.42:  Take your bike wheel. You may want to give the inside of the hub a clean, in which case use spanners to remove the axle from the hub and wipe everything down with paper tissue or similar. Be careful not to lose any ball bearings.  Set the nuts so that as much length of axle as possible is on one side of the wheel (away from the sprockets if your wheel has them) and retighten so that the wheel runs smoothly and doesn't wobble. There are various videos on Youtube on how to do all this.  Drill three 4mm holes evenly spaced around the the rim, as close to the edge as possible. Your wheel should have 36 spokes, so drill a hole every 12 spokes.43:  Poke an M4 bolt up through one of the holes and through the backmost unriveted hole in the bottom former of the vane. You may need to poke the former's bike spoke out of the way, make sure it's on the outside of the bolt.  Place a washer, a spring washer, and a nut. Don't fully tighten yet.  Align the vane so that the other two unriveted holes sit on the edge of the wheel rim and mark with a pen through the hole.44:  Rotate the vane away so that you can drill the two marks.45:  Move the vane back and lock down with bolts, washers, spring washers, and nuts. Fully tighten all three.  You may need to drill out a part of the rim to allow the head of the bolt to sit close. If the bolt is poking out to much it may hit on the chain you'll probably be using to drive your application.46:  Assemble two more vanes from your remaining formers and sheets and attach them to the wheel.47:  Take another sheet offcut and slice out a strip 9.5cm wide and 67cm long.48:  Mark with lines so that you have widths of 3.5cm, 2cm, 3cm, and 1cm. Mark the 1cm width on both sides.  Flip the strip over and bend the 1cm width to 45 degrees. Flip back and triangulate as shown.49:  Drill a 4mm hole 8mm in from each end of the strut on the 1cm flat area. Drill and rivet a hole at the midpoint.  Repeat twice more so you have three struts.50:  Place an M4 bolt up through the unriveted center hole in the top of one of the vanes, and through the end holes in two of the struts. Add a washer, spring washer, and nut.  Repeat with the other two vanes and the last strut. Lock all tight.51:  The top of the vanes need to not be twisted relative to their base. Place the turbine on the ground so you can look down on it, stand over one of the vanes so that you can see the long edge of both formers. Twist the top former so that it lines up with the bottom one, over correct a degree or two as it will slip back.  Drill a hole through one of the struts and the former 1-2cm from the edge. Add bolt, washer, spring washer, and nut. Recheck the alignment, drill the other strut and nut bolt etc. Tighten all three.  Repeat for for the other two vanes.  You're done!52:  Optionally, you can add an extra three vanes to the underside of the wheel.", "step_imgs": ["https://cdn.instructables.com/FRE/MDFT/HSVGHL4K/FREMDFTHSVGHL4K.LARGE.jpg"], "step_title": "Step 2: Construction Steps"}, {"step": 3, "steps_text": "  This section will be added to as I do some more pre-vis animations and videos on potential uses for the turbine, but there are essentially two main ways to attach a pump/alternator/whatever else you want.For low to medium rpm applications:  Run a bike chain from the sprocket set of the turbine's wheel to a sprocket on the application. As in:  The good thing about this setup is you can set your gearing anywhere between about 2.5:1 up to the same down. The bad thing is that if you're using a six vane turbine your application will need to sit inside the whole thing as you won't be able to take a chain out through the spin radius.For high rpm applications:  I'm in the process of doing up a quick animation to demonstrate this, but basically you put the chain (or rather two chains attached and trimmed for length) around the bike wheel rim itself, effectively using it as a large sprocket. It engages surprisingly well, and gives a ratio of about 12:1 with a small sprocket on your application.  This is necessary for things like car alternators, which require about 12,000 to 15,000 rpm to start. The good thing about them being that the voltage regulation and charge control is built in, so you can just attach directly to your 12v battery.", "step_imgs": ["https://cdn.instructables.com/FWE/4XVX/HSVGHLJZ/FWE4XVXHSVGHLJZ.LARGE.jpg"], "step_title": "Step 3: Mounting and Applications"}], "channel": "Energy"}, {"category": "workshop", "description": "<!--\t@page { margin: 0.79in }\tP { margin-bottom: 0.08in }\t-->The following instructable details 2 ways to find out if something is square, 1 way to draw an accurate perpendicular line, and 1 way to draw an accurate parallel line. These tricks involve virtually no math to do and are scalable to any dimensions from millimetres, to miles. The 4 tricks are probably not something you will use every day but are really handy to know and will allow you to amaze others with your skill and mental prowess. I have embedded the video podcast of this because it is sometimes easier to see it done than to try to understand a written description. my part is at 5:24\u00a0 Don't be shy about watching my other episodes or checking out my other instructables.", "title": "Handy Tricks to Find Square", "url": "https://www.instructables.com/id/handy-tricks-to-find-square/", "section": "workshop", "steps": [{"step": 1, "steps_text": "<!--\t\t@page { margin: 0.79in }\t\tP { margin-bottom: 0.08in }\t-->Note* this trick is the only one that uses math and it is only really to explain how it works. So don't be scared off.\u00a0According to Pythagoras, a right angle triangles sides can be described by the equationa squared + b squared = c squaredwhere c= the hypotenuse (the longest side).By a lucky fluke of math 3 squared + 4  squared just happens to = 5 squared.  So all you have to remember is 3,4,5.  Simple so far right?\u00a0If you have something you are working on, for example a wooden frame, cut plywood, a tacked metal structure or even brickwork, and you want to see if it is square, this trick is for you.  Just measure 3 units across from the corner and make a mark, then 4 units up and make a mark.  Now measure the distance between the two marks and you should get 5 units.  If not then it is not square.  If it is more than 5 units it is more than 90 degrees.  If it is less than 5 units it is less than 90 degrees.  I am saying units because it does not matter what you use to measure, what matters is that the 3,4,5 ratio is correct.  Just know that the longer measurements you can take, the more accurate it will be.  You can even do multiples of the ratio, for example 12\u201dx16\u201dx20\u201d.", "step_imgs": ["https://cdn.instructables.com/FKF/UJL4/G2L3C0GE/FKFUJL4G2L3C0GE.LARGE.jpg"], "step_title": "Step 1: Trick #1 - the 3,4,5 Trick"}, {"step": 2, "steps_text": "<!--\t\t@page { margin: 0.79in }\t\tP { margin-bottom: 0.08in }\t-->This method is a little easier than the 3,4,5 trick but requires access to all 4 corners of a rectangle or square.  This would work great for a picture frame.  Just measure across the diagonals from corner to corner.  If the measurements are equal then the corners are square.", "step_imgs": ["https://cdn.instructables.com/FVP/0SIT/G2L3C0GF/FVP0SITG2L3C0GF.LARGE.jpg"], "step_title": "Step 2: Trick #2 - the Equal Diagonals Trick"}, {"step": 3, "steps_text": "<!--\t\t@page { margin: 0.79in }\t\tP { margin-bottom: 0.08in }\t-->This is great for marking things like fences or deck foundations, I use this at work sometimes to layout and locate machinery in factories.  We assume you already have a straight line to go off of, like an existing wall or a reference line on the ground.  You need a piece of string to do this one, mark where you want your new perpendicular line to come out of the reference line or wall.  Using the string, tie a knot about 1/3 or so from the end.  Measure with the string out along the reference line both ways and make marks at the knot.  From each of these two marksand using the whole string, draw an arcs like in the picture.  Where the two marks intersect, that is perpendicular to your reference line at the point you started from.", "step_imgs": ["https://cdn.instructables.com/F0T/RST4/G2HE0FZ5/F0TRST4G2HE0FZ5.LARGE.jpg"], "step_title": "Step 3: Trick #3 - 90 Degree Arc Trick"}, {"step": 4, "steps_text": "<!--\t\t@page { margin: 0.79in }\t\tP { margin-bottom: 0.08in }\t-->This has the same uses as trick number 3 but is used to make parallel lines instead of perpendicular.  From any 2 points along the reference line (the further apart the better) make an arc with the radius of the desired offset.  If you pulled a string, layed a straight edge or shot a laser line that just touched (tangent to) both arcs, it would be parallel to your reference line.", "step_imgs": ["https://cdn.instructables.com/FKE/JL92/G2HE1O8Q/FKEJL92G2HE1O8Q.LARGE.jpg"], "step_title": "Step 4: Trick #4 - the Parallel Arcs Trick"}], "channel": "Tools"}, {"category": "workshop", "description": "I enjoy relaxing on a sofa and in my bed, and so it may come as no surprise that I would wish to combine the two. After searching Ikea and several other shops, I found the average price for a \"tri-fold\" futon was in the region of 120GBP ($150). I found this pretty steep for what is basically some planks of pine and a mattress.\nSo I decided to make my own.Let me make this clear before I begin: This Instructable is only how to build the frame. I have not yet worked out how I will make the mattress or if I will attempt to buy one, but in the instructables spirit if anyone has any suggestions, suggest away.\nThis futon folds in three sections to give a comfortably wide (4ft) and long (6ft-ish) bed that could sleep two (if proximity is not an issue!). When it is folded up it forms a sofa that is close to the ground and has an open angle (about 100 degrees) which I find very comfortable to sit on.\nI am not a carpenter, crafstman or a great DIY-er, I didn't even take wood tech in school, so this instructable is very accessable. So get up off your computer and turn that empty space in your bedroom or living room into a versatile piece of furniture! If I can do it, so can you!", "title": "How to Make a Fold Out Sofa/Futon/Bed Frame", "url": "https://www.instructables.com/id/How-To-Make-A-Fold-out-SofaFutonBed-Frame/", "section": "workshop", "steps": [{"step": 1, "steps_text": "This is the list of materials and tools I used during the project. The wood I used was pine as it is cheap, relatively strong yet a little springy to make the futon a bit more comfortable. The type of wood you use is up to you but in my opinion, pine works best. My local hardware store cut the planks for me at no extra cost, but depending on where you go they may charge 10% extra: this is worth it.Wood:12 x 1200mm x 95mm planks (20mm thickness: I think this is standard)2 x 770mm x 70 mm planks (20mm thickness)2 x 700mm x 70 mm planks (20mm thickness)2 x 690mm x 70 mm planks (20mm thickness)\nAlso some kind of stain, oil or wax to protect it and make it look good.Nuts, Bolts and Screws:46 x 40mm screws (4mm head)4 x 6mm bolts (6mm is the diameter: length needs to be no less than 45mm, 50mm is ideal)4 x 6mm wingnuts (or regular nuts, but wingnuts are easier to use in assembly and disassembly)Tools:\nPencil\nRuler (graduated in millimetres)\nSet Square (or similar)\nProtractor\nElectric Screwdriver/Drill\n2.5mm drill bit\n6.5mm drill bit\nManual Screwdriver\nSaw\nMedium Grade Sandpaper\nRasp or planer (a rasp is a bit like reusable, very coarse sandpaper, but a planer would work just as well)Optional\nScrap piece of wood to test drill bits and screws\nCat\nThe total cost of the wood came to around 33GBP ($40) and the screws, bolts and nuts totalled about 2GBP ($2.50). I alreday had the teak oil so the total cost for this project (assuming you have all the tools) is around 35GBP ($45), but again this depends on where you shop.", "step_imgs": ["https://cdn.instructables.com/FNQ/E2OG/FVW22WTQ/FNQE2OGFVW22WTQ.LARGE.jpg", "https://cdn.instructables.com/F61/6N30/FVW22WTP/F616N30FVW22WTP.LARGE.jpg", "https://cdn.instructables.com/F9N/8KAB/FVW22X43/F9N8KABFVW22X43.LARGE.jpg", "https://cdn.instructables.com/FUX/TEM9/FVW22WTO/FUXTEM9FVW22WTO.LARGE.jpg"], "step_title": "Step 1: Materials and Tools"}, {"step": 2, "steps_text": "When doing any measurements throughout this instructable, remember to MEASURE TWICE, CUT ONCE. This is very important as mistakes are easy to make and rushing things is not a good idea.Other notes to do with safety:         - Always clamp wood that you are drilling or cutting         - Work in a clean, dry and well ventilated area         - Make sure you know how to use the saw and electric drill correctly and safely         - DO NOT work when you are tired or have drunk alcohol: you will make mistakes and you could injure yourself", "step_imgs": ["https://cdn.instructables.com/FDA/1WPI/FW4JU26D/FDA1WPIFW4JU26D.LARGE.jpg"], "step_title": "Step 2: IMPORTANT NOTE"}, {"step": 3, "steps_text": "For this step you will need the rasp or planer, and the glasspaper. You will be working on the 12000mm x 95mm planks.\n1. Use the rasp to shamfer the edges slightly.\n2. Glasspaper the plank to smooth the edges and surfaces, paying particular attention to the ends.(The glasspapering is easier if you wrap the glasspaper around a small block of wood. I cut a piece of scrap I had lying around.)\nDo this for all 12 planks.", "step_imgs": ["https://cdn.instructables.com/F2F/J79M/FVW2513M/F2FJ79MFVW2513M.LARGE.jpg", "https://cdn.instructables.com/FMJ/2M1U/FVW2513L/FMJ2M1UFVW2513L.LARGE.jpg", "https://cdn.instructables.com/FKS/9A6P/FVW2513K/FKS9A6PFVW2513K.LARGE.jpg"], "step_title": "Step 3: Preparing the Large Planks"}, {"step": 4, "steps_text": "***Look at step 7 before doing the measuring to get an idea of what they should look like***The smallest planks (690mm x 70mm) need to have a small section cut out of one end, the other end tapered slightly and one drill hole.Small Section(requires some accurate measuring)1. Measure 85mm down from one end and mark it.2. At this mark draw a perpendicular line across the wood using the set square.3. Measure an angle of 7 degrees from one of the edges. Rule a line.4. Measure 37mm along this line (starting from the edge) and mark it.5. From this point measure an angle of 95 degrees towards the end of the plank. Rule a line.6. Shade in the section in the 95 degree angle and the other side of the 7 degree angle. This is the bit to be cut out (main picture).Drill Hole(mark this before the tapered end)1. Measure 30mm down and mark it.2. At this mark draw a perpendicular line across the wood using the set square.3. Halfway in (35mm) mark the drill hole.Tapered End(basically two triangles)1. At the end with the drill hole, measure 20mm down and 20mm across the top. Draw a line.2. This is the triangle to be cut out.3. Repeat on other side.", "step_imgs": ["https://cdn.instructables.com/FKG/HI1M/FVW2515I/FKGHI1MFVW2515I.LARGE.jpg", "https://cdn.instructables.com/F2V/O742/FVW25150/F2VO742FVW25150.LARGE.jpg", "https://cdn.instructables.com/FAT/X17P/FVW25151/FATX17PFVW25151.LARGE.jpg", "https://cdn.instructables.com/F14/6GM1/FVW25153/F146GM1FVW25153.LARGE.jpg", "https://cdn.instructables.com/FE1/H1QG/FVW25152/FE1H1QGFVW25152.LARGE.jpg", "https://cdn.instructables.com/FZV/0FNO/FVW1Z9BF/FZV0FNOFVW1Z9BF.LARGE.jpg", "https://cdn.instructables.com/FLZ/KSVM/FVW1Z9BD/FLZKSVMFVW1Z9BD.LARGE.jpg", "https://cdn.instructables.com/FNW/MDF4/FVW1Z9BE/FNWMDF4FVW1Z9BE.LARGE.jpg", "https://cdn.instructables.com/FHO/5RJ6/FVW2515R/FHO5RJ6FVW2515R.LARGE.jpg", "https://cdn.instructables.com/FIP/83OT/FVW2511E/FIP83OTFVW2511E.LARGE.jpg", "https://cdn.instructables.com/F1M/YEBF/FVW1UTYO/F1MYEBFFVW1UTYO.LARGE.jpg"], "step_title": "Step 4: Marking the Smallest Planks (690mm X 70mm)"}, {"step": 5, "steps_text": "***Look at step 7 before doing the measuring to get an idea of what they should look like***The medium small planks need on end tapered and a small triangle taken off the other end. They also need a drill hole at each end.Drill Holes(mark these first)1. At one end, measure 30mm down and mark it.2. At this mark draw a perpendicular line across the wood using the set square.3. Halfway in (35mm) mark the drill hole.4. At the other end, measure 50mm down and mark it.5. At this mark draw a perpendicular line across the wood using the set square.6. Measure 15mm in and mark the drill hole.Tapered End(at the end with the hole in the middle)1. Measure 20mm down and 20mm across the top. Draw a line.2. This is the triangle to be cut out.3. Repeat on other side.Triangle(at the end with the hole 15mm in)1. Measure 25mm down on the side opposite the drill hole.2. Measure 25mm across the top.3. Rule a line between the marks. This is the bit needed to be cut out.", "step_imgs": ["https://cdn.instructables.com/FO0/2UPM/FW4JU20O/FO02UPMFW4JU20O.LARGE.jpg"], "step_title": "Step 5: Marking the Medium Small Planks (700mm X 70mm)"}, {"step": 6, "steps_text": "***Look at step 7 before doing the measuring to get an idea of what they should look like***The long planks need one drill hole and one triangle cut out at one end.Drill hole1. Measure 165mm down from one end and mark it.2. At this mark draw a perpendicular line across the wood using the set square.3. Measure 15mm in and mark the drill hole.Triangle1. On the opposite side to the drill hole, measure 35mm down and mark it.2. Then measure 35mm across the top and mark it.3. Rule a line. This is the triangle to be cut out.", "step_imgs": ["https://cdn.instructables.com/FTA/F7I0/FW4JU224/FTAF7I0FW4JU224.LARGE.jpg"], "step_title": "Step 6: Marking the Medium Long Planks (770mm X 70mm)"}, {"step": 7, "steps_text": "1. Cut and Drill where you have marked on the planks. (6mm drill bit)\n2. On the tapered ends, triangles and cut outs smooth and sand roughly (not too much as some measuring is yet to be done).Now your six small planks should look like this:\nThis is a good time to test the folding mechanism of your futon. It should be fairly obvious where the hinges attach and so forth but incase it isn't...- The tapered ends attach to each \n- The other end of the middle section attaches to the long section\n- The cut out section of the smallest planks should rest on the longest planks when folded up", "step_imgs": ["https://cdn.instructables.com/FAH/PCLX/FW4JU0ZS/FAHPCLXFW4JU0ZS.LARGE.jpg", "https://cdn.instructables.com/FPS/C5YT/GIH8N9LN/FPSC5YTGIH8N9LN.LARGE.jpg", "https://cdn.instructables.com/F67/G618/GI0TKBEL/F67G618GI0TKBEL.LARGE.jpg", "https://cdn.instructables.com/FKE/WVQT/GI0TKBEV/FKEWVQTGI0TKBEV.LARGE.jpg"], "step_title": "Step 7: Cutting and Drilling"}, {"step": 8, "steps_text": "Now we need to add some screw guide holes on the planks. These will make sure the screws go in straight ensuring the best fit and so the wood doesn't crack. This is the most tedious part of the build and also one of the most important. This is a dangerous combination so concentrate. It should not take much longer than 30 minutes.ACCURACY IS KEY", "step_imgs": ["https://cdn.instructables.com/FDA/1WPI/FW4JU26D/FDA1WPIFW4JU26D.LARGE.jpg"], "step_title": "Step 8: Note: Measuring the Screw Holes"}, {"step": 9, "steps_text": "These need to be measured differently:\n- 7 planks need to be measured one way\n- 4 planks another\n- 1 plank is uniqueThe \"7\" planks(there will be 4 holes)\n1. Measure 150mm down from one side.\n2. Draw a perpendicular line across the plank.\n3. Measure halfway and make a mark.\n4. Now measure 20mm either side of the middle and mark your screw holes.\n5. Repeat at the other end.The \"4\" planks(same as last time only they are 170mm down)\n1. Measure 170mm down from one side.\n2. Draw a perpendicular line across the plank.\n3. Measure halfway and make a mark.\n4. Now measure 20mm either side of the middle and mark your screw holes.\n5. Repeat at the other end.The \"1\" plank(2 holes)\n1. Measure 150mm down from one side.\n2. Draw a perpendicular line across the plank.\n3. Measure halfway and mark the screw hole.\n4. Repeat at the other end.", "step_imgs": ["https://cdn.instructables.com/FZP/9Q92/FW4JU2E9/FZP9Q92FW4JU2E9.LARGE.jpg", "https://cdn.instructables.com/F97/VM4Z/FW4JU2E8/F97VM4ZFW4JU2E8.LARGE.jpg", "https://cdn.instructables.com/FV6/PNA2/FW4JU2EA/FV6PNA2FW4JU2EA.LARGE.jpg"], "step_title": "Step 9: Measuring the Screw Holes on the Long Planks (1200mm X 95mm)"}, {"step": 10, "steps_text": "The different planks need to be measured differently. On the four shorter ones there should be 4 pairs of holes (8) and on the two longer ones there should be 3 pairs of holes and one single hole (7). They all need to be measured along the top edge (see step 7: the top edges are the edges farthest up on the picture).Shortest planks(690mm x 70mm)\n1. Measure 85mm in from the tapered end along the top edge and mark it. (85mm from the original end of the plank: in retrospect this would have been easier before tapering the end).\n2. Measure 40mm from this mark and mark it.\n3. Measure 135mm from this mark and mark it.\n4. Repeat steps 2 and 3 twice.\n5. Measure 40mm from the last mark and mark it.\n6. You now should have 8 marks (4 pairs).\n7. Rule perpendicular lines across the wood on all the marks.\n8. Measure halfway in on these lines (10mm) and mark the drill holes.\n9. Use this plank as a template for the second plank (see picture).Medium small planks(700mm x 70mm)\n1. Measure 145mm from the end with one corner cut off along the top edge and mark it.\n2. Measure 40mm from this mark and mark it.\n3. Measure 110mm from this mark and mark it.\n4 Repeat steps 2 and 3 twice as with the small planks.\n5. Measure 40mm from the last mark and mark it.\n6. You now should have 8 marks (4 pairs).\n7. Rule perpendicular lines across the wood on all the marks.\n8. Measure halfway in on these lines (10mm) and mark the drill holes.\n9. Use this plank as a template for the second plank (see picture).Medium long planks (770mm x 70mm)\n1. Measure 30mm in from the flat end along the top edge and mark it. (This is the single hole).\n2. Measure 135mm from this mark and mark it\n3. Measure 40mm from this mark and mark it.\n4. Measure 125mm from this mark and mark it.\n5. Repeat steps 3 and 4 once.\n6. Measure 40mm from the last mark and mark it.\n7. You now should have 7 marks (3 pairs and one single).\n8. Rule perpendicular lines across the wood on all the marks.\n9. Measure halfway in on these lines (10mm) and mark the drill holes.\n10. Use this plank as a template for the second plank (see picture).Measure these twice to avoid errors. It will save you time, effort and money in the long run.", "step_imgs": ["https://cdn.instructables.com/FPJ/RWUP/GI0TMPWQ/FPJRWUPGI0TMPWQ.LARGE.jpg", "https://cdn.instructables.com/F60/F3M2/GI0TKBFO/F60F3M2GI0TKBFO.LARGE.jpg", "https://cdn.instructables.com/F7H/ZIM0/GI0TKBFS/F7HZIM0GI0TKBFS.LARGE.jpg"], "step_title": "Step 10: Measuring the Screw Holes on the Other Planks"}, {"step": 11, "steps_text": "Using the 2.5mm drill bit, carefully drill on the marks as close to vertical as possible.\nOn the large planks, the holes should go all the way through the planks.\nOn the smaller planks, the holes only need to extend about 20mm in (doesn't have to be exact).", "step_imgs": ["https://cdn.instructables.com/FJI/KPS8/GI0TMPY7/FJIKPS8GI0TMPY7.LARGE.jpg", "https://cdn.instructables.com/FYP/DUOD/GI0TKBIW/FYPDUODGI0TKBIW.LARGE.jpg"], "step_title": "Step 11: Drilling the Screw Holes"}, {"step": 12, "steps_text": "After drilling the screw holes we can finish the small planks. The top edge (the one with the holes) should only be lightly sanded as it needs to sit flush with the large planks. I gave the bottom edge a strong bevel.", "step_imgs": ["https://cdn.instructables.com/FGU/PLR0/GI0TMPZW/FGUPLR0GI0TMPZW.LARGE.jpg", "https://cdn.instructables.com/F1W/9L1N/GI0TKBZ3/F1W9L1NGI0TKBZ3.LARGE.jpg", "https://cdn.instructables.com/F3C/RMB9/GI0TKBJ8/F3CRMB9GI0TKBJ8.LARGE.jpg"], "step_title": "Step 12: Finishing the Small Planks"}, {"step": 13, "steps_text": "Now comes the interesting part. The key to the assembly is preparation. Firstly, screw all of the screws through the long planks so that the ends are just poking out the bottom. This will make lining up the planks on the smaller planks infinitely easier.\nThe 4 long planks measured earlier attach to the medium short planks (700mm x 70mm) the 7 planks attach to the other planks (the 770mm x 70mm one and the 690mm x 70mm one) and the single holed plank goes on the 770mm x 70mm one). It should be fairly obvious but it is important to get them in the right place so the futon folds properly.\nScrew the planks in place to end up with the three sections of the futon. Before finishing the futon, check that\u00a0everything\u00a0works. Assemble the futon using the wing nuts and bolts and test it. Everything should work smoothly but if not, you may need to make some adjustments.\n(EDIT) I have added an extra diagram which should help you see what I mean.", "step_imgs": ["https://cdn.instructables.com/FHU/LYHW/H0AR6GRL/FHULYHWH0AR6GRL.LARGE.jpg", "https://cdn.instructables.com/F0K/QMK8/GI0TMQ08/F0KQMK8GI0TMQ08.LARGE.jpg", "https://cdn.instructables.com/FII/YBQK/GI0TDYL6/FIIYBQKGI0TDYL6.LARGE.jpg", "https://cdn.instructables.com/FVK/GT4A/GI0TDYL7/FVKGT4AGI0TDYL7.LARGE.jpg", "https://cdn.instructables.com/F9U/6Z7H/GI0TDYLC/F9U6Z7HGI0TDYLC.LARGE.jpg", "https://cdn.instructables.com/FPS/M71F/GI0TKC2E/FPSM71FGI0TKC2E.LARGE.jpg"], "step_title": "Step 13: Assembly"}, {"step": 14, "steps_text": "Disassemble the futon into its three parts. Give the whole thing a good sanding to get rid of sharp edges and to prepare it \u00a0for treating. Then treat the futon with what you like. I used 3 coats of teak oil which gives it a lovely colour and smell and protects it. However you could use wax or even stain, whatever works. Reassemble and you have a fully functional folding futon frame.", "step_imgs": [], "step_title": "Step 14: Finishing the Futon"}], "channel": "Furniture"}, {"category": "workshop", "description": "This Instructable covers how to build the mobile tool stations that we use at Digital Harbor Foundation. These stations keep tools organized and accessible wherever you are in your makerspace. Assembling a rolling tool cart takes only one or two people and minimal tools, and materials can be pre-cut at your local hardware store.For more project guides and makerspace resources, head over to Blueprint by Digital Harbor Foundation.", "title": "Digital Harbor Foundation's Tool Cart", "url": "https://www.instructables.com/id/Digital-Harbor-Foundations-Tool-Cart/", "section": "workshop", "steps": [{"step": 1, "steps_text": "First, let's gather the tools you'll need for this project.Tools:Power drill (or get this economy version)Bit set, driver set, and socket set with sizes shown in the imageTape measurePencilCost per rolling tool cart: About $170 for construction materials About $130 to stock with tools and supplies", "step_imgs": ["https://cdn.instructables.com/FJP/J4SH/JE4KM3HH/FJPJ4SHJE4KM3HH.LARGE.jpg"], "step_title": "Step 1: Gathering Tools"}, {"step": 2, "steps_text": "Three 6-Foot 2x4'sNow let's gather the materials. We've provided cut list templates that can be downloaded as PDFs.Cut three 6-foot 2\u00d74\u2018s into seven planks as shown in the cut list shown in the image. 6-foot lengths will waste the least amount of material, but 8-foot lengths may be easier to find. We recommend spending an extra dollar or two per beam for \u201ctop choice\u201d lumber, which is much better quality and less likely to be bowed or twisted. Also note: 2x4s actually measure only 1 1/2\u2033 x 3 1/2\u2033.The two 48\u2033 planks will be called the side postsThe three 21\u2033 planks will be called the cross beamsThe two 18\u2033 planks will be called the foot boardsSheet of Peg BoardPegboard, also known as perforated hardboard, is generally available in two thicknesses: 1/4\u2033 and 1/8\u2033. For this project, make sure that you purchase 1/4\u2033 pegboard; it is much sturdier and fits most standard size pegs. Most hardware stores carry 1/4\u2033 pegboard in a dark brown color and will cut sheets down to size for you according to the cut list shown in the image. We purchased 4\u00d74 sheets in a lighter brown color which blends nicely with the natural wood color of the 2x4s, and cut each sheet in half ourselves using a circular saw.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Gathering Materials"}, {"step": 3, "steps_text": "After gathering the tools and materials, you'll need to gather the hardware and peg kits.Hardware:2 x 5 1/2\u2033 handle sets, with included screws4 x full-locking 3\u2033 swivel caster wheels(\u201cfull-lock\u201d means that the break locks both the wheel rotation and the swivel; choose \u201cplate\u201d casters as opposed to the \u201cstem\u201d variety)4 x 3\u2033 deck screws (deck screws have much greater holding power than regular screws)38 x 2\u2033 wood screws16 x 1\u2033 lag screws, 5/16\u2033 diameter (lag screws can bear a lot of weight, which is important for securing the caster wheels)Peg Kits:A basic Durahook multi-pack will contain everything that you need for one tool cart. In fact, it will contain more than you need, so you might want to consider buying peg hardware individually.  Pro tip: sometimes peg board hooks can pop out when you remove a tool. To eliminate this problem we chose Durahooks, which come with mounting screws to semi-permanently attach each hook. The pegs can still be rearranged when you want, but the screws prevent them from coming off while you are working.", "step_imgs": ["https://cdn.instructables.com/FUY/MVJE/JE4KM3FW/FUYMVJEJE4KM3FW.LARGE.jpg", "https://cdn.instructables.com/FCS/KMCP/JE4KM3FX/FCSKMCPJE4KM3FX.LARGE.jpg"], "step_title": "Step 3: Gathering Hardware"}, {"step": 4, "steps_text": "At the end of one of the two 48\u2033 side posts, use a pencil and tape measure to mark a line 3/4\u2033 from one end. Then mark cross lines 1\u2033 in from each side edge to indicate screw hole targets, as shown in the figure.  Repeat these marks halfway down the side beam at the 24\u2033 mark, and again 3/4\u2033 from the other end of the beam, for a total of six screw hole marks.  Then repeat these six marks on the other side beam.", "step_imgs": ["https://cdn.instructables.com/F1Q/1G0F/JE4KM3FY/F1Q1G0FJE4KM3FY.LARGE.jpg"], "step_title": "Step 4: Measure and Mark the Side Posts"}, {"step": 5, "steps_text": "Select a drill bit the same width as the shank of the 2\u201d screws, and use it to drill pilot holes through the side posts at each of your earlier marks., for a total of six pilot holes on each of the two 48\u2033 side posts. Drill each pilot hole approximately the depth of the length of the screw; for more information see Wikihow\u2019s helpful step-by-step guide for How To Drill Pilot Holes.", "step_imgs": ["https://cdn.instructables.com/FE6/O1RQ/JE4KM3FZ/FE6O1RQJE4KM3FZ.LARGE.jpg"], "step_title": "Step 5: Drill Pilot Holes"}, {"step": 6, "steps_text": "Place the three 21\u201d cross beams standing up on the floor in an evenly-spaced line. Then lay one of the 48\u201d side posts across the top, with the pilot holes facing up so they are visible. Make sure that the center cross beam is centered with the pilot holes you made at the 24\u2033 mark of the side beam.", "step_imgs": ["https://cdn.instructables.com/F4T/2HC1/JE4KM3G2/F4T2HC1JE4KM3G2.LARGE.jpg"], "step_title": "Step 6: Arrange One Side of the Frame"}, {"step": 7, "steps_text": "Line up the corners of the frame so that the side post is flush with each of the three cross beams.", "step_imgs": ["https://cdn.instructables.com/FD2/12DX/JE4KM3G4/FD212DXJE4KM3G4.LARGE.jpg"], "step_title": "Step 7: Check Alignment"}, {"step": 8, "steps_text": "Drive 2\u2033 screws into each of the six pilot holes on the side post, two through each of the three cross beams. An extra set of hands is helpful for this step, but it can also be done standing over the boards and using your legs to help hold them in place while you drill.", "step_imgs": ["https://cdn.instructables.com/FS3/UWMV/JE4KM3G8/FS3UWMVJE4KM3G8.LARGE.jpg"], "step_title": "Step 8: Screw the Side Post to the Cross Beams"}, {"step": 9, "steps_text": "Once secure, flip the frame over and repeat the process: Lay the other side post across the cross-beams so that the pilot holes face upwards, check alignment, and then drive 2\u2033 screws into the pilot holes to secure the frame.", "step_imgs": ["https://cdn.instructables.com/FA3/JUY6/JE4KM3GA/FA3JUY6JE4KM3GA.LARGE.jpg"], "step_title": "Step 9: Repeat on the Other Side of the Frame"}, {"step": 10, "steps_text": "At each of the four corners of one of the pegboard pieces, use a pencil and tape measure to mark a screw hole location 1\u2033 in from each edge. Note that although this will not be directly centered on the beam, it is more likely to avoid matching up with one of the existing peg holes. Repeat marks for the other piece of pegboard.", "step_imgs": ["https://cdn.instructables.com/F2S/DOJG/JE4KM3GD/F2SDOJGJE4KM3GD.LARGE.jpg"], "step_title": "Step 10: Measure and Mark the Pegboard"}, {"step": 11, "steps_text": "Lay the frame flat on the floor and line up one sheet of peg board on the top. Make sure that edges are aligned and square all around the board.", "step_imgs": ["https://cdn.instructables.com/FXX/3J2G/JE4KM3GH/FXX3J2GJE4KM3GH.LARGE.jpg"], "step_title": "Step 11: Align the Pegboard With the Frame"}, {"step": 12, "steps_text": "Use 2\u201d wood screws to attach each of the four corner of the pegboard to the frame. It is not necessary to drill pilot holes for this step; just start the drill with a few quick bursts to drive in the sharp tip of the screw. Once the screw bites into the pegboard you can drill full speed to drive it the rest of the way in.", "step_imgs": ["https://cdn.instructables.com/FGU/3YER/JE4KM3GI/FGU3YERJE4KM3GI.LARGE.jpg"], "step_title": "Step 12: Screw the Corners of the Pegboard to the Frame"}, {"step": 13, "steps_text": "Repeat the step above, adding more screws around the pegboard to secure it to the frame. We suggest the placements shown in the figure.  Be sure that the center screw location passes through the center cross beam of the frame.", "step_imgs": ["https://cdn.instructables.com/FEX/1WZJ/JE4KM3GK/FEX1WZJJE4KM3GK.LARGE.jpg"], "step_title": "Step 13: Add More Screws Around the Frame"}, {"step": 14, "steps_text": "Flip the frame over and repeat the process: align the pegboard with marks facing upward, check alignment, and then drive in 2\u2033 screws to secure the pegboard to the frame.", "step_imgs": ["https://cdn.instructables.com/F0L/49I5/JE4KM3GN/F0L49I5JE4KM3GN.LARGE.jpg"], "step_title": "Step 14: Repeat With the Remaining Pegboard"}, {"step": 15, "steps_text": "Mark each of the two 18\u2033 foot boards halfway in the center, at the 9\u2033 mark. Then make a cross-mark 1\u201d from each side.", "step_imgs": ["https://cdn.instructables.com/F94/WF2W/JE4KM3GP/F94WF2WJE4KM3GP.LARGE.jpg"], "step_title": "Step 15: Measure and Mark the Foot Boards"}, {"step": 16, "steps_text": "Place a wheel the end of one of the foot boards, centered about 1/2\u201d from the edges. Use a pencil to draw a small X to mark the center of each hole and then set the wheels aside. Repeat for the other end of the foot board and for both ends of the other foot board.", "step_imgs": ["https://cdn.instructables.com/F18/C1VS/JE4KM3GT/F18C1VSJE4KM3GT.LARGE.jpg"], "step_title": "Step 16: Mark the Wheel Hardware Holes"}, {"step": 17, "steps_text": "Select a drill bit that has the same width as the shank of the lag screws.", "step_imgs": ["https://cdn.instructables.com/F46/VKC8/JE4KM3GX/F46VKC8JE4KM3GX.LARGE.jpg"], "step_title": "Step 17: Get a Lag Screw Drill Bit"}, {"step": 18, "steps_text": "Pro Tip! To prevent drilling too far into the legs, place a piece of tape 1\u201d from the tip of the drill bit to \u201cflag\u201d it. You\u2019ll know when to stop when the flag reaches the surface of the board.", "step_imgs": ["https://cdn.instructables.com/FAW/17UX/JE4KM3GZ/FAW17UXJE4KM3GZ.LARGE.jpg"], "step_title": "Step 18: Flag the Drill Bit"}, {"step": 19, "steps_text": "Drill pilot holes into each X-mark on the foot boards, stopping when the drill bit flag reaches the wood.", "step_imgs": ["https://cdn.instructables.com/FVA/KYU4/JE4KM3H0/FVAKYU4JE4KM3H0.LARGE.jpg"], "step_title": "Step 19: Drill Pilot Holes Into the Foot Boards"}, {"step": 20, "steps_text": "Position each wheel over a set of pilot holes in the foot boards and secure the wheels by using the socket wrench to drive the lag screws into the holes.", "step_imgs": ["https://cdn.instructables.com/FVV/46O3/JE4KM3H1/FVV46O3JE4KM3H1.LARGE.jpg"], "step_title": "Step 20: Attach the Wheels to the Foot Boards"}, {"step": 21, "steps_text": "Turn the frame so that it stand up on the floor. Position each leg at the edge of the top of the frame, and align the 9\u201d mark on the leg with the center of the frame.", "step_imgs": ["https://cdn.instructables.com/F7O/SSXJ/JE4KM3H2/F7OSSXJJE4KM3H2.LARGE.jpg"], "step_title": "Step 21: Align the Foot Boards With the Frame"}, {"step": 22, "steps_text": "Choose a drill bit that corresponds to the 3\u201d deck screws, and use it to drill pilot holes at the marked locations on each of the foot boards.", "step_imgs": ["https://cdn.instructables.com/FB7/ACZR/JE4KM3H3/FB7ACZRJE4KM3H3.LARGE.jpg"], "step_title": "Step 22: Drill Pilot Holes Into the Foot Boards"}, {"step": 23, "steps_text": "Find a driver that corresponds to the 3\u2033 deck screws. Deck screws often have star-shaped heads and come with the matching driver in the box.  Drive the deck screws through the pilot holes to secure the foot boards to the frame.", "step_imgs": ["https://cdn.instructables.com/FJF/B65D/JE4KM3H4/FJFB65DJE4KM3H4.LARGE.jpg"], "step_title": "Step 23: Screw the Foot Beams to the Frame"}, {"step": 24, "steps_text": "Flip the frame over so that it stands upright on its wheels. Lock the wheels in place by stepping down on the \u201cOn\u201d switch on each lever.", "step_imgs": ["https://cdn.instructables.com/FVP/XY1X/JE4KM3H5/FVPXY1XJE4KM3H5.LARGE.jpg"], "step_title": "Step 24: Turn Over the Frame and Lock the Wheels"}, {"step": 25, "steps_text": "Place top of the handle flush with the top of the frame and put a mark on the frame at the bottom edge of the handle, about 5 1/2\u2033 down from the top. Repeat for the other side of the frame.", "step_imgs": ["https://cdn.instructables.com/FRB/3Y5L/JE4KM3H6/FRB3Y5LJE4KM3H6.LARGE.jpg"], "step_title": "Step 25: Use the Handle to Make a Measurement"}, {"step": 26, "steps_text": "Move the handle down so that your mark passes through the top holes, and then mark a small X in each of the four hardware holes. Repeat for the other side of the frame.", "step_imgs": ["https://cdn.instructables.com/F3O/GGCP/JE4KM3H7/F3OGGCPJE4KM3H7.LARGE.jpg"], "step_title": "Step 26: Mark the Handle Holes"}, {"step": 27, "steps_text": "Drive in the screws that came with the handle hardware set to secure the handle to the frame. Repeat for the second handle on the other side of the frame.", "step_imgs": ["https://cdn.instructables.com/F7J/V4PS/JE4KM3H8/F7JV4PSJE4KM3H8.LARGE.jpg"], "step_title": "Step 27: Attach the Handle to the Frame"}, {"step": 28, "steps_text": "Now that you have a tool cart, what tools should you put in it? Below is a list of the tools that we\u2019ve found the most useful, and how we chose to arrange our tools on the rolling cart pegboard.Basic Tools:HammerFull-size screwdriver setPrecision screwdriver setAdjustable wrench3-piece plier setSmall hobbyist plier set", "step_imgs": ["https://cdn.instructables.com/F5O/FX8J/JE4KM3HA/F5OFX8JJE4KM3HA.LARGE.jpg"], "step_title": "Step 28: Stocking the Cart - Basic Tools"}, {"step": 29, "steps_text": "Measuring Tools:Tape measurePlastic rulerDigital caliper8\u2033 level7\u2033 carpenter\u2019s squareMechanical pencils", "step_imgs": ["https://cdn.instructables.com/F8M/GXRU/JE4KM3HD/F8MGXRUJE4KM3HD.LARGE.jpg"], "step_title": "Step 29: Stocking the Cart - Measuring Tools"}, {"step": 30, "steps_text": "Tape and Glue:Duct tapeMasking tapeHot glue gunGlue sticks", "step_imgs": ["https://cdn.instructables.com/FFO/DOCQ/JE4KM3HE/FFODOCQJE4KM3HE.LARGE.jpg"], "step_title": "Step 30: Stocking the Cart - Tape and Glue"}, {"step": 31, "steps_text": "Cutting Tools:ScissorsUtility knifeUtility knife replacement bladesX-Acto knife with capX-Acto replacement bladesHand sawCoping saw", "step_imgs": ["https://cdn.instructables.com/FP4/U21O/JE4KM3HC/FP4U21OJE4KM3HC.LARGE.jpg"], "step_title": "Step 31: Stocking the Cart - Cutting Tools"}, {"step": 32, "steps_text": "Safety Equipment:Safety glassesSafety gogglesProtective gloves", "step_imgs": ["https://cdn.instructables.com/FIR/0309/JE4KN8N3/FIR0309JE4KN8N3.LARGE.jpg"], "step_title": "Step 32: Stocking the Cart - Safety Equipment"}, {"step": 33, "steps_text": "Here\u2019s how all these tools look when hung on the front and back sides of our tool cart. Click the image to zoom in if you want more detail.", "step_imgs": ["https://cdn.instructables.com/FH7/JX03/JE4KM3HF/FH7JX03JE4KM3HF.LARGE.jpg"], "step_title": "Step 33: Arranging the Tools"}], "channel": "Workbenches"}, {"category": "workshop", "description": "Materials/tools Needed:Stock - Something at least 3 inches thick and 8-10 inches wide. I found this piece of reclaimed beam that had been converted into a mantel and then broken again, so I made it into this bench. Whatever you have will need to be at least 33 inches longer than you want your bench to be.Glue - Just your normal wood glue. I used Titebond OriginalWood Shims - Just some little wedges of scrap wood, about 1/16 inches thick or less.Hammer/mallet - pretty self explanatory. A wooden or rubber mallet would be better for not dinging up the wood.Saw - You can use a handsaw (panel saw) like the one in the video, or a circular saw which would go much fasterChisel - A good, sharp chisel, sized about an inchSquare - A speed square (you can find a cheap one anywhere) is good or you can use a carpenter's or framing square if you want to or know what those are. Measuring device - measuring tape, a yardstick, or anything that can measure up to 18 inchesMarking Device - A pencil or a marking knife works bestFinish - finishing product of your choice. Polyurethane, urethane, lacquer, paint, or wax all work perfectly fine", "title": "\"3 Tool\" Rustic Bench", "url": "https://www.instructables.com/id/3-Tool-Rustic-Bench/", "section": "workshop", "steps": [{"step": 1, "steps_text": "-Make sure the ends of your stock are square (perfectly perpendicular to the long edge of the beam)-If they are not, use the square and mark a perpendicular line as close to the edge as you can, then use your saw to cut that edge straight down through the line- Measure 16 1/2 inches in from the edge and use your square to draw a line perpendicular to the long edge of the beam- Use your saw to cut at the line all the way, straight down, through the beam- repeat this step measuring in, marking, and then cutting from the other end of the beam", "step_imgs": ["https://cdn.instructables.com/FB4/60YI/J70QMX8I/FB460YIJ70QMX8I.LARGE.jpg", "https://cdn.instructables.com/F2W/R4EB/J70QMX8C/F2WR4EBJ70QMX8C.LARGE.jpg"], "step_title": "Step 1: Measure and Cut the Legs"}, {"step": 2, "steps_text": "-Pick which side you want to be the top of your bench-Turn the beam over so the top side faces down, as you are now working on the underside of the bench-Using the square, mark a line a few inches in from the edge of the beam. The distance will be relative to the overall length of your bench, but about 15% of the way in from the edge works well.- Place one of your legs on the line, toward the inside of the bench, and make sure it's lined up perfectly, as pictured-Mark a second line on the opposite side of the leg, on the face of the bench, to mark the width of the leg slot-Remove the leg and continue these lines down 1.5 inches on the edges of the beam to mark the slot depth using your square-Use your square to connect the bottoms of the 1.5 inch lines on the edges to show where the bottom of the leg slot will be-Reproduce these marks on the opposite end of the beam", "step_imgs": ["https://cdn.instructables.com/FG0/ZXS2/J70QMX8L/FG0ZXS2J70QMX8L.LARGE.jpg", "https://cdn.instructables.com/FIK/ZIWG/J70QMX8M/FIKZIWGJ70QMX8M.LARGE.jpg"], "step_title": "Step 2: Marking the Slots for the Legs"}, {"step": 3, "steps_text": "-Starting JUST INSIDE of your outermost mark on the beam face, saw straight down to your depth line you marked in the last step (the mark should be touching your cut, but still be visible when you're done, this ensures a tight fit later)-Repeat this step incrementally (at least every 1/4 inch) until you reach the VERY INSIDE EDGE of the next mark. It should look like the picture when you are done.-Reproduce these steps on the opposite end of the beam", "step_imgs": ["https://cdn.instructables.com/F4V/Y5V4/J70QMX8B/F4VY5V4J70QMX8B.LARGE.jpg"], "step_title": "Step 3: Cut Kerfs Between Your Lines"}, {"step": 4, "steps_text": "-Stand the beam on end, and place your chisel on the depth mark, with the flat side facing the mark as pictured-Use your mallet to gently tap downward on the chisel and remove the waste material from the slot.-After you have the bulk of the waste removed, use the chisel to flatten the bottom of the slot. It's very important that you get it as evenly flat as possible, so that your time here-Reproduce these steps on the opposite side of the beam", "step_imgs": ["https://cdn.instructables.com/FJR/JL2H/J70QMX8A/FJRJL2HJ70QMX8A.LARGE.jpg", "https://cdn.instructables.com/F51/HTXP/J70QMX8E/F51HTXPJ70QMX8E.LARGE.jpg"], "step_title": "Step 4: Chisel Out the Waste"}, {"step": 5, "steps_text": "Here's the exciting part, where your bench really takes shape-Dry fit the legs into the slots. If the slots are a little too wide, the next step will take care of that. If they are too tight, you can widen them in small increments with your saw, checking with the legs again each pass.-The legs should fit very snugly into the slots, but not to much that they need to be forced in with great strength. If you have to do anything more than smack it down with your open palm, then it's too tight.-Coat the inside edges of the slot with glue. Don't use a ton of glue, but make sure that you get an ample amount on every surface as pictured- Insert the legs into the slot, being certain to line up the front and back edges of the joint flush with each other.", "step_imgs": ["https://cdn.instructables.com/FUB/K8C3/J70QMX8J/FUBK8C3J70QMX8J.LARGE.jpg", "https://cdn.instructables.com/FX1/AX1P/J70QMX8H/FX1AX1PJ70QMX8H.LARGE.jpg"], "step_title": "Step 5: Check, Glue, and Fit the Legs"}, {"step": 6, "steps_text": "If your legs don't fit snugly enough into the slots, and there is any space or wobble side to side:-Place glue on the flat sides of your shim and push, then gently hammer it into the slot on the inside edge of the leg-Use your chisel and mallet to chop the protruding part of the wedge away, making it flush with the face of the beam-Make sure the legs are perpendicular to the beam using your square. If they are not, use the wedges to adjust them until they are.-Clean up any glue squeeze out around the leg joints with a damp rag or shop towel.", "step_imgs": ["https://cdn.instructables.com/FOO/9QZO/J70QMX8G/FOO9QZOJ70QMX8G.LARGE.jpg"], "step_title": "Step 6: Adding Some Shims"}, {"step": 7, "steps_text": "My bench stock had already accumulated enough oils and whatnot over the years to where i did not need to finish it. If you need to finish yours:-A Spray lacquer is quick and easy, just do it in a well ventilated area and follow the directions on the can-Polyurethane is also a great option. Again, follow the directions on the can.-If you want this bench to reside outdoors, consider using cedar or white oak as your material, or finishing it with urethane, paint, or an outdoor stain.-In fact, just follow the instruction on whatever you choose to use-Give the top surface a few more coats of finish than the rest, so people's butts don't rub it all off.-Your bench is done! Once everything is dry, have a seat and give yourself a nice pat on the back!", "step_imgs": ["https://cdn.instructables.com/FMB/OSSU/J70QMX8D/FMBOSSUJ70QMX8D.LARGE.jpg"], "step_title": "Step 7: Finishing"}], "channel": "Woodworking"}, {"category": "workshop", "description": "In the USA we have all heard that analog TV signals will disappear on February 17, 2009.  Everyone receiving a signal through the air on an older television will need a converter box for Digital TV.  We bought a box, but it was a while later that we learned we needed a special antenna to go with it.  We bought the one shown in the photo.  It also comes with an active (powered by a voltage adapter) signal amplifier.  This one is $37 at Amazon.com (plus shipping and handling).  I must be slow mentally, because it took me a while to realize the Digital TV signal utilizes a basic UHF antenna. We live 30 miles (48 km) from the local broadcast towers.  An antenna like this should give us super fine reception.  But, pointing it in the exact direction of the tower is critical.  It does not function well without the signal amplifier, and the picture pixelates or goes to \"No Signal\" when someone walks across the signal path in another room.  Mounting it in the attic might help, but one of our stations is located about 45 degrees clockwise from most of our stations.For pennies I made a better antenna.     ", "title": "Good Digital Antenna Cheap!", "url": "https://www.instructables.com/id/Good-HDTV-antenna-cheap/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Cut two strips of thin sheet aluminum 1 1/8 inch (3 cm) by 6 3/4 inches (17 cm).  I considered cutting the aluminum from old soft drink cans.  To get the needed length I would have needed to cut down the side and across the bottom.  Do that if you have no other sheet aluminum. ", "step_imgs": ["https://cdn.instructables.com/FKL/PHO4/FMSGGNUI/FKLPHO4FMSGGNUI.LARGE.jpg"], "step_title": "Step 1: Start Making the Antenna"}, {"step": 2, "steps_text": "I drilled a small hole in each piece of aluminum and used carpet tacks to mount the outer end of each to a piece of furring strip commonly known as 1 x 2.  The distance between the two pieces at the center is 7/8 inch (2.2 cm).  That means you need about 15 inches (38 cm) of furring strip.  ", "step_imgs": ["https://cdn.instructables.com/FI1/7WZZ/FMSGGNVH/FI17WZZFMSGGNVH.LARGE.jpg"], "step_title": "Step 2: Mount the Aluminum Strips"}, {"step": 3, "steps_text": "Strip and attach a piece of 300 ohm twin lead (TV antenna wire) with two sheet metal screws.  Attach a 300 to 75 ohm signal or impedance matching transformer to the other end of the twin lead.", "step_imgs": ["https://cdn.instructables.com/FLW/PQDW/FMSGGNWS/FLWPQDWFMSGGNWS.LARGE.jpg"], "step_title": "Step 3: Attach Twin Lead"}, {"step": 4, "steps_text": "I used to make \"T\"-shaped VHF antennae from twin lead.  The connections always twisted and pulled until the thin wires broke off.  Add a strain relief to keep that from happening.  I used some electrical tape to keep the twin lead from twisting.", "step_imgs": ["https://cdn.instructables.com/FR5/VY6T/FMSGGO0N/FR5VY6TFMSGGO0N.LARGE.jpg"], "step_title": "Step 4: Provide a Strain Relief"}, {"step": 5, "steps_text": "I wanted the furring strip to rest so the face of the aluminum strips, not their edge, would receive the signal.  Twin lead is stiff and stubborn stuff.  I drilled into the back of the furring strip and added a dowel rod to prop the furring strip up.Connect the 300 to 75 ohm transformer to the input on your converter box.  Connect the converter box to the TV.  Run a scan so the converter finds available stations.  Experiment with the placement of the antenna for your best reception and enjoy.  Also try placing your antenna so it is vertical rather than horizontal.When I was finished, I found this cheap antenna performs better than the commercial antenna in the first panel of this Instructable.  It is not as dependent on directional alignment and once properly aligned, no channels pixelate or fail with \"No Signal.\"  It did not lose a picture when someone walked across the signal path.      ", "step_imgs": ["https://cdn.instructables.com/F7Z/I5P5/FMSGGO1K/F7ZI5P5FMSGGO1K.LARGE.jpg"], "step_title": "Step 5: Add a Support to the Furring Strip"}, {"step": 6, "steps_text": "You can add passive (no electrical power needed) amplification to your signal by using a parabolic reflector made of sheet aluminum.  The graphic shows the aluminum strips (here in dark red) set off from a flat parabolic reflector also known as a parabolic trough.  You would devise your own scheme for mounting the reflector and the aluminum strips.Note: I have always wanted to try making the reflector from a wire screen.  It should work, but it would need more support to hold its proper shape.", "step_imgs": ["https://cdn.instructables.com/FGZ/9OAQ/FMSGGO2Q/FGZ9OAQFMSGGO2Q.LARGE.jpg"], "step_title": "Step 6: Need Amplification?"}, {"step": 7, "steps_text": "The definition of a parabolic curve is \"a line equidistant between a point and a straight line.\"  Go to a large table top and make a large sheet of paper from small pieces of paper.  Newsprint works if you are using a felt tip marker.  Make it a color like red or green so it stands out from the printing on the newspaper.  Draw a straight line across the bottom.  At its center make a line perpendicular to the straight base line.  At about 14 inches (35.5 cm) mark the focal point.  The distance from the base line to the focal point is completely your choice, but it affects the size of the reflector you make.  Mark a point midway between the base line and the focal point.  This is the first point you have plotted on your parabolic curve.The \"B\" lines are always perpendicular to the base line.  The \"A\" lines change their angle in order to connect with the \"B\" lines.  Use two yardsticks and a square.  Plot points where the yardsticks cross over one another while the measurement shown on each yardstick is the same.  The more points you plot, the more accurate your parabolic curve will be.  If you are careful, you can plot only the left half of the curve and then flip it over to copy it onto the right half of the paper.  The end result is that any signal (TV, radio, sound, light) coming to the parabolic curve in parallel rays will be gathered in strength at the focal point and amplified because they are concentrated.    ", "step_imgs": ["https://cdn.instructables.com/F8B/LP9O/FMSGGO5P/F8BLP9OFMSGGO5P.LARGE.jpg"], "step_title": "Step 7: What Is a Parabola and How Do I Make One?"}], "channel": "Home Theater"}, {"category": "workshop", "description": "One of my biggest motivating factors in growing my understanding and skill in woodworking is simple: to replace all of the Ikea cardboard furniture that fills my house, one piece at a time.  Just about everyone who has furnished an apartment or home with Ikea stuff has bought one of their cube towers which, among other things, happen to be the perfect size to house a burgeoning record collection.I wanted to replace this cheap block shelving with something more sleek and handsome, with a modern but organic look, and a piece that could house my record collection, speaker system and other stereo gear. A while back, a friend of mine showed me a picture of a LP stand he found online that he wanted to build - though he never did - and I was inspired to try this design out in my project.  I couldn't find the image of the piece online so I was going largely from memory, but the key design element was having interlocking beams that create a segmented look.Something I had been meaning to try in some previous builds was using tension via threaded rods to assemble a piece of furniture.  This offers several benefits and does not require the use of any of the more traditional means of wood engineering, such as nails, screws, and glue.  Since I had all the tools and finishing products that I wanted to use for this build already in my garage, the only cost for me was the wood (about $40) and the hardware (about $10).  Here's what you'll need to build this:Materials:Eight 10' 2x4sTwo 36\" Aluminum Threaded Rods (you'll be cutting these down to four pieces - these come in a variety of diameters, but I used 1/2\" rods)Eight Washers and Nuts (sized to fit your threaded rods, obviously)Stain and/or Finish (depending on how you want your final product to look)Tools:Power Miter Saw (this is your primary saw in this build, and it would be tough to make this without one)HacksawPower Drill & Bit SetFileSander (I prefer using a random orbit sander)Jigsaw (optional)Dremel (optional)--------------------------------------And if you like the build, I'd appreciate your vote in the Shelving Contest!", "title": "Record & Stereo Shelves", "url": "https://www.instructables.com/id/Record-Stereo-Rack/", "section": "workshop", "steps": [{"step": 1, "steps_text": "This rack is made up almost entirely of 2x4s, and the design is all about angles.  Lots and lots of angles.  Oh, and I hope you like fractions.  Lots and lots of fractions...  But not to deter you!  Despite this piece being entirely wood, there is surprisingly little cutting involved.  You'll essentially be needing three types of 2x4s:Top Rack: Four boards 55\" in lengthBottom Rack: Four boards 60\" in lengthLegs: Ten boards 44\" in lengthNow, it should be stated that these lengths were designed to maximize what I could get out of 10' 2x4s, but can obviously be adapted to any size you wish, based on desired length and height of the final product.  The only thing that's really important when cutting these to size is that the boards are all the same length as the other boards of the same group.Once the boards are cut to length, it's time to angle the edges.  When planning this project, I wasn't entirely sure how angled I wanted the leg pieces to appear.  I decided to play it safe and go with 10\u00ba initially, so I took two leg pieces and cut off 10\u00ba of each end using my miter saw.Note: Not to give you flashbacks of your high school geometry class, but based on how we're cutting our angles, we'll be turning our leg boards into parallelograms, and our top boards into trapezoids... Sorry, that is to say that the ends of our leg boards will be parallel, while the ends of the top boards will be mirrored reflections of one another.With two leg pieces cut, I laid out one layer of the shelf on the floor to see if I liked how angled the frame looked (see picture).  Well, I didn't, so I decided to throw caution to the wind, ignore all regard for sensibility and step over to the dark side. 15\u00ba.  That's right, I'm a mad man.  This looked much better, so I went ahead and cut the angled edges of my first top board to test out the final shape (again, these top boards will be cut in a trapezoidal shape with the longest side edge at 55\" in length).With the final angles and lengths determined, you can now cut all of the pieces to length, using your initial ones as guides.  Needless to say, you want all of these to be cut precisely identically to avoid issue later on.", "step_imgs": ["https://cdn.instructables.com/FQQ/RF7H/IE17VN4Q/FQQRF7HIE17VN4Q.LARGE.jpg", "https://cdn.instructables.com/FMS/CJ3V/IE17VN51/FMSCJ3VIE17VN51.LARGE.jpg", "https://cdn.instructables.com/FYD/5VTW/IE17VN4T/FYD5VTWIE17VN4T.LARGE.jpg", "https://cdn.instructables.com/FCI/7IC2/IE17VN4U/FCI7IC2IE17VN4U.LARGE.jpg", "https://cdn.instructables.com/FSD/SY7D/IE17VN54/FSDSY7DIE17VN54.LARGE.jpg", "https://cdn.instructables.com/FDK/4UPP/IE17VN55/FDK4UPPIE17VN55.LARGE.jpg", "https://cdn.instructables.com/FDZ/8FK7/IE17VN56/FDZ8FK7IE17VN56.LARGE.jpg", "https://cdn.instructables.com/FEH/QASG/IE17VN5B/FEHQASGIE17VN5B.LARGE.jpg"], "step_title": "Step 1: Cut 2x4s to Length"}, {"step": 2, "steps_text": "With all of the pieces cut, let's talk about how we'll fit them together. As mentioned earlier, I wanted to try a furniture design that didn't use your standard hardware or joinery - i.e. screws, nails and glue.  Using tension as an engineering principle in your furniture builds offers the ability to make slight adjustments in setting the individual pieces with only the turn of a wrench, and when tightened can make for a piece of furniture as sturdy as one filled with wood screws and glue.That being said, the key to a successful build using tension is having perfectly drilled holes.  Measure twice, drill once will be our motto with this rack.  So, let's figure out where we want to drill.  There will be four tension points in this polygonal design, so let's start with the top pair.While the sides of the top shelf will be flush with the outside of the leg pieces, the legs will protrude past the top shelf.  I decided I wanted this to sick out 6\" past the top shelf.   But since 2x4s that you buy at big-shop hardware stores aren't really 2\" by 4\", you'll need to make sure you're drilling in the precise mid-point in the board.  My boards were 3 1/2\" wide, so I want to measure 6\" from the top angled edge of the leg pieces and 1 3/4\" from the side edge, marking these intersections with a pen or pencil.  Since the top shelf boards had their ends cut to 15\u00ba, you need to find the center point on these boards and measure 1 3/4\" from the middle of the angled edge.With the hole positions marked on both ends of your top shelf boards and the top end of your end boards, you can begin drilling.  Since I will  be using 1/2\" threaded rods, I drilled these holes with a 5/8\" bit.  This extra eighth of an inch will make it easier on you when assembling the final piece.As for the bottom shelf, I decided that I wanted about a foot of clearance between the bottom 2x4s and the ground.  To make a nice even number (and since the boards are really only 3.5\" wide), I chose to drill my bottom holes 13\" from the angled end of the leg pieces, and once again 1 3/4\" from the edge.  However, since the bottom shelf boards will be protruding from the sides of the leg pieces, I had to do a little extra math to figure out the exact points along these boards that I need to drill, relative to the angled leg pieces.  Time to bust out the Pythagorean Theorem!----------Disclaimer: I'll be honest with you here.  Although it's entirely possible to determine the precise points to drill using angles and equations, I was a few beers in at this point, and my head started to hurt when I pulled out the protractor and calculator.  A much simpler (yes, slightly less precise, but much simpler) way is to lay out your pieces on the floor and line them up by eye.  With the top pair of holes drilled in my legs and top shelves, I used a tension rod to line up these holes and keep them in place.  Then I took a 2x4 and laid it on the bottom edge of my leg pieces, rotating them until their 15\u00ba angled edges sat flush against the base piece.  With three of my four pieces sitting in place, I was able to lay out my bottom board, ensure that it was sitting perfectly symmetrically relative to the leg pieces, and measured 13\" from the base piece and 1 3/4\" from the edge of the board.  Voila! I now have the hole locations for the last pair of holes, and with (hopefully) only a couple millimeters of error.----------Now that I have a top shelf board, bottom shelf board, and a leg board fully drilled, I can essentially rinse and repeat on all of the subsequent pieces.  Although my last example of precision left a lot to be desired, it's really important that you take every precaution when measuring and drilling the rest of your holes relative to your initial pieces, as you want everything to line up perfectly flush in our next step...", "step_imgs": ["https://cdn.instructables.com/FBD/37MJ/IE17VN5X/FBD37MJIE17VN5X.LARGE.jpg", "https://cdn.instructables.com/FJE/K86S/IE17VN63/FJEK86SIE17VN63.LARGE.jpg", "https://cdn.instructables.com/FMG/A7E9/IE17VN5I/FMGA7E9IE17VN5I.LARGE.jpg", "https://cdn.instructables.com/F3H/GAQ2/IE17VN5Q/F3HGAQ2IE17VN5Q.LARGE.jpg", "https://cdn.instructables.com/FEU/TMSN/IE17VN5U/FEUTMSNIE17VN5U.LARGE.jpg", "https://cdn.instructables.com/FUW/6PE8/IE17VN62/FUW6PE8IE17VN62.LARGE.jpg"], "step_title": "Step 2: Drill Rod Holes"}, {"step": 3, "steps_text": "With all of your pieces now cut and drilled, you've almost finished your assembly process.  Stack them on top of one another roughly and you'll have a close approximation of how deep your finished project will be.  To see exactly how long you need your threaded rods to be, you can slide one through a couple of your newly-drilled holes until it's flush with the floor.  It's important to note that, when fully tightened, your wood boards will be more tightly compressed together than they are lying on the floor right now.  With that being said, mark off the edge of your threaded rod relative to the depth of your leg boards using a Sharpie.  For me, this was right at 16\" long.Remember that hacksaw mentioned in the tool inventory earlier?  Well it's time for it to shine.  Make sure your rod is clamped down nice and securely.  Aluminum threaded rods are pretty soft when it comes to metals, so it shouldn't take you long to cut right through it.  When you get close to the end of your cut, you should be able to bend the rod and snap the end off.  This end will be very sharp, so we'll need to file it down to be soft to the touch.  Be careful with this step, however, because you need to preserve the integrity of the threads while filing off the sharp edges left from cutting.  If the tip of your thread isn't filed properly, you'll be unable to get the nut on during your assembly (trust me on this one...).I decided I wanted to use a spade bit to make recessed holes in my front and back leg pieces to conceal the rod tip and nuts when the  tension rods were secured.  If you haven't done so already, now is the time to decide which two leg pieces you want displayed in the front of your finished product.  Once assembled, the only board faces that you'll be able to see well will be the four front-most boards, so choose your two leg pieces that have the best wood grain pattern.  For the back two, it honestly doesn't matter.  Using a 1 1/8\" spade bit (large enough to accommodate the size of my washers), I drilled approximately 1/2\" into the pre-existing rod holes for my front and back pieces.Speaking of which, I encountered an issue that I had not seen up to this point in my woodworking journey: it's a huge pain trying to drill holes on top of already-drilled holes.  This is especially true with a spade bit, which is really doing more cutting than it is drilling.  If you go this route, be prepared for a bucking drill and some curse words.  It's really all about finding the right ratio of speed and pressure to prevent your spade bit from getting stuck.  In retrospect, a hole saw probably would have done a better job.At any rate... now you're all set for a test assembly!  I found the easiest method here (and for the final assembly) is to lay all of the pieces down on the floor and, one by one, thread the rods through the holes.  This will take some effort, as the pieces wont just slide together harmoniously.  Having a hammer or mallet to help tap the rods in further as they get stuck will save you some stress.  Once the rods are in, you can carefully tip the structure up and crank down the washers and nuts to see how it fits together.  The top and bottom edges of all your boards should (hopefully) be level.", "step_imgs": ["https://cdn.instructables.com/F4D/KMS0/IE17VN64/F4DKMS0IE17VN64.LARGE.jpg", "https://cdn.instructables.com/FG8/NTAZ/IE17VN65/FG8NTAZIE17VN65.LARGE.jpg", "https://cdn.instructables.com/F9P/TFPL/IE17VN6K/F9PTFPLIE17VN6K.LARGE.jpg", "https://cdn.instructables.com/FJJ/IAV1/IE17VN6L/FJJIAV1IE17VN6L.LARGE.jpg", "https://cdn.instructables.com/F49/856H/IE17VN69/F49856HIE17VN69.LARGE.jpg", "https://cdn.instructables.com/FGR/ZX82/IE17VN67/FGRZX82IE17VN67.LARGE.jpg", "https://cdn.instructables.com/F3S/T0SE/IE17VN6Q/F3ST0SEIE17VN6Q.LARGE.jpg", "https://cdn.instructables.com/FE0/MQE7/IE17VN6M/FE0MQE7IE17VN6M.LARGE.jpg", "https://cdn.instructables.com/FLL/0PY8/IE17VN6W/FLL0PY8IE17VN6W.LARGE.jpg", "https://cdn.instructables.com/FRV/L030/IE17VN71/FRVL030IE17VN71.LARGE.jpg", "https://cdn.instructables.com/F1C/GVK0/IE17VN74/F1CGVK0IE17VN74.LARGE.jpg", "https://cdn.instructables.com/FGV/FTX3/IE17VN76/FGVFTX3IE17VN76.LARGE.jpg"], "step_title": "Step 3: Cut Threaded Rods and Test Assemble"}, {"step": 4, "steps_text": "Now that you got it all together, standing up nicely and looking great, it's time to... lay it down and take it apart again.  I know, I know... but you do want to make sure it fits well before you finish it, right?  If any of your pieces weren't cut or drilled right, or if the ends of any of your boards weren't flush with the others, this is your chance to go back and fix or replace it with a new board.There are a couple of things we'll need to do before we get to my all-time least favorite step of the woodworking process: sanding.  The first thing is cleaning up the recessed holes that we just drilled.  A Dremel and small grinding stone worked perfectly for me, but if you don't have these at your disposal you can accomplish the same result with some small scraps of loose sandpaper.  Lastly, I decided that I wanted to give the piece a slightly sleeker look by rounding the edges of the protruding ends of my bottom shelf boards (and I foresaw the inevitable incident of me hitting my shin on them as I turned the corner into my living room...).  I didn't want the ends to be completely rounded off, just the edges, so I grabbed a pencil and my jigsaw and set off to trim off a bit of the edge.Now it's time to grab your sander (I prefer using a random orbit for most jobs) and get to work.  You'll want to be thorough here since this is a piece that you'll be showing off in your home and setting your prized record collection on.  I still wanted the final look to be very angular and clean, but also not something that had edges and corners that were too sharp.Once completed, it's time to stand and/or finish your wood.  I feel like I rave about Danish Oil in every Instructable I author, but it's just so easy to work with and I've never met a stain that's given a result I've been happier with.  I feel like most stains hide the natural wood grain of your materials, but Danish Oil really makes it shine and gives it character.  I chose to use two different colors to give the leg boards and top/bottom shelves slightly different looks, but the difference in color was slight.  I may have chosen some more highly contrasting shades in retrospect.  Whatever you decide upon, whether it's just stain or just finish or both, you're almost done.The last thing I decided to do was a poor man's powder coating on my washers and nuts.  I thought this would make the finished product look less like it was just 2x4s and cheap aluminum hardware, and I think it definitely helped.  I just took a can of matte black spray paint and coated all of my nuts and washers.  It certainly doesn't offer the durability of powder coating in terms of chipping, but it was a quick/easy solution.", "step_imgs": ["https://cdn.instructables.com/F0Z/QGNB/IE17VN7D/F0ZQGNBIE17VN7D.LARGE.jpg", "https://cdn.instructables.com/FUH/TB4Z/IE17VN7K/FUHTB4ZIE17VN7K.LARGE.jpg", "https://cdn.instructables.com/FNW/PGV0/IE17VN7Q/FNWPGV0IE17VN7Q.LARGE.jpg", "https://cdn.instructables.com/FMG/WWGL/IE17VN7S/FMGWWGLIE17VN7S.LARGE.jpg", "https://cdn.instructables.com/FZS/D6QH/IE17VN7H/FZSD6QHIE17VN7H.LARGE.jpg", "https://cdn.instructables.com/F05/6DV8/IE17VN7U/F056DV8IE17VN7U.LARGE.jpg", "https://cdn.instructables.com/F4X/P4VZ/IE17VN7Z/F4XP4VZIE17VN7Z.LARGE.jpg", "https://cdn.instructables.com/FYJ/IR58/IE17VN80/FYJIR58IE17VN80.LARGE.jpg", "https://cdn.instructables.com/FQU/DVC8/IE7A80DM/FQUDVC8IE7A80DM.LARGE.jpg", "https://cdn.instructables.com/FD2/89PW/IE7A80EC/FD289PWIE7A80EC.LARGE.jpg"], "step_title": "Step 4: Final Cutting, Sanding, and Applying Stain / Finish"}, {"step": 5, "steps_text": "It's dejavu all over again!  Time to reassemble.  With your wood fully dried after staining/finishing, you can carefully reassemble just as you did before.  Take caution when cranking down your nuts and washers so that the hardware's paint doesn't chip when tightening down.Since you're now dealing with about 90 or so total feet of 2x4s it may be on the heavy side, but once you have your piece in place, you can make sure that the shelves are level before cranking down the nuts all the way.  Once fully assembled and tightened, this will be very sturdy, all without a single screw, nail or drop of glue.Now it's just a matter of setting up your stereo equipment and hooking everything up.  You can use small hook screws to help hide your cabling along the back edges of your frame.  One great thing about this design is that your records will sit naturally angled, allowing you to easily flip through your collection.  That should be it!  Hopefully you get inspired by this design, and share your builds below!And... if you enjoyed this Instructable, please vote for me in the Shelving Contest!  Thanks!", "step_imgs": ["https://cdn.instructables.com/F7E/IDN3/IE17VN81/F7EIDN3IE17VN81.LARGE.jpg"], "step_title": "Step 5: Final Assembly and Display"}], "channel": "Furniture"}, {"category": "workshop", "description": "I created this at TechShop, San Jose...\nI often want to see how different speed/power settings will etch into a variety of woods.\nI did a bit of learning and created a group of files to help me run a Test Grid of Speed and Power Settings.\u00a0\nThese are for an Epilog Helix laser engraver.\nHere's the (slightly out-of-focus...) picture showing the results:\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "title": "Laser Engraving Test Grid Using Color Mapping", "url": "https://www.instructables.com/id/Laser-Engraving-Test-Grid-using-Color-Mapping-Cr/", "section": "workshop", "steps": [{"step": 1, "steps_text": "\nThe file itself looks pretty simple.\u00a0\u00a0 I used Arial font for all the text, and the font size is 14. \nOf course, the font style and size can be modified to best suit the etching you'll be doing.\u00a0 In Corel, you can ungroup the 50%-speed, 40%-speed, and 30%-speed text groups, then modify each individual text/font setting.I am using Raster settings for my fonts.\u00a0 I do not, as a rule, have a need to use Vectors in the fonts I use.\nIn my case, I set the drawing size to 11\" x 8.5\" , or basic Landscape settings for standard paper.\nThe filename is 50_40_30_SPEED at 5_to_90_POWER.cdr\nThis shows what the file looks like when opened.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/FVL/61B7/H5IRWNYQ/FVL61B7H5IRWNYQ.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 1: Load the CorelDraw V15 File"}, {"step": 2, "steps_text": "\nI'd have liked to load all 30 color mappings at once and run a single print job to the Laser, but there seems to be a 16-mapping limitation in the driver.\nSo...\u00a0 I went ahead and separated my mappings by speed settings (in groups of 10)...\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": [], "step_title": "Step 2: Note on Color Mapping With the Epilog Print Driver"}, {"step": 3, "steps_text": "\nHa! There's a method to this madness!\nWhen I'm learning about the etch-ability of a material, I first work at the speeds which have the lowest chance of etching too deep into the material.\nThis way, I can work my way up to etching which applies more laser energy and may end-up burning or charring my material. Going from 50% to 40% to 30% speed will help this.\nI can track the progress of the laser burns and cancel the job if I'm getting into a burn that is just not working.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": [], "step_title": "Step 3: Why Did I Put the 50% Speed As First in This Grid??"}, {"step": 4, "steps_text": "\nAnd here's what the drawing looks like with CorelDraw settings.\u00a0\nYou might want to look a larger size of the drawing (here in Instructables) by clicking the drawing and selecting one of the size options that has sufficient detail.\nSome details to tune-in to:\n1. Right side of window\n\n\tHere I've selected an individual power/speed text block to show its settings.\u00a0 Because I've selected it, the text block is outlined with marks for sizing and centering.\n\t\u00a0\n2. Bottom Right of window:\u00a0\n\n\tYou'll see the RGB color settings.\u00a0 In this case, R=105, G=0, and B=0.\n\tThese settings are used with Color Mapping in the Epilog Engraver print driver to modify speed and power settings.\n\t\u00a0\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/F75/UOPN/H5IRWOO4/F75UOPNH5IRWOO4.LARGE.jpg"], "step_title": "Step 4: More Drawing Details"}, {"step": 5, "steps_text": "\nOnce the Printer icon or Print is selected from the File Menu, you'll get a window that looks similar to this.\n1. If you've got more than one printer attached to your computer, then make sure the appropriate Laser is selected as the printer.\n2. If the Preview on the right-hand side does not look exactly correct yet, Don't Panic!\u00a0 The paper size/dimensions in the Preferences window will need to match the sheet size/dimensions from the Drawing before the Preview will look correct.\n3. Select the Preferences button and go to the next step.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/F2L/139L/H5IRWNYI/F2L139LH5IRWNYI.LARGE.jpg"], "step_title": "Step 5: Let's Start the Print Process Using Color Mapping..."}, {"step": 6, "steps_text": "\nOnce you've selected Properties, the Properties Window comes up.\nStuff to do here:\n\t\tMake sure the Piece Size dimensions match the Page dimensions that were used in the drawing.\u00a0 This screenshot shows 24\" width by 18\" height, but I will modify that in a later step to match the 11\" width by 8.5\" height I used in my drawing.\n\t\tSince I'm using a Raster font, I made sure that Raster or Combined is selected under Job Type.\n\t\tAll Speed and Power settings can remain as they are for now.\u00a0 These need to be checked in a later step.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": ["https://cdn.instructables.com/FT6/3B32/H5JVY1SC/FT63B32H5JVY1SC.LARGE.jpg"], "step_title": "Step 6: Properties Window Settings"}, {"step": 7, "steps_text": "\nAnd once you're in the Color Mapping Window, select the Color Mapping button at the Top Left.\u00a0 This allows us to remove all the existing, default Color Mapping settings that you see in the picture.\nYou can see that the Red (RGB 255,0,0) row is automatically selected. Hit the - (minus sign) button in the middle of the window to remove this row.\nRepeat this step to remove all default existing Color Mapping rows.\nI make sure that the Raster and Air Assist buttons are selected.\u00a0 The second picture here shows the result.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/FSJ/2QBQ/H5IRWNYX/FSJ2QBQH5IRWNYX.LARGE.jpg", "https://cdn.instructables.com/FS2/5UAX/H5ECNGJ3/FS25UAXH5ECNGJ3.LARGE.jpg"], "step_title": "Step 7: Now Select the Color Mapping Tab..."}, {"step": 8, "steps_text": "\nSelecting the Advanced Tab will show you this window.\n\t\tMake sure Raster Type is set to Basic.\n\t\tClassic UI and Update Firmware buttons should NOT be selected.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": ["https://cdn.instructables.com/FX1/0I0O/H5IRWNY2/FX10I0OH5IRWNY2.LARGE.jpg"], "step_title": "Step 8: Now Go to the Advanced Window..."}, {"step": 9, "steps_text": "\nI have zipped-up the following 3 files, and you'll need to download and unzip them into a handy folder.Limitation of the Print Driver!\n\tI suggest putting the zip file in a directory very close to the root.\u00a0 That will make it easier to locate the files when you will soon Load them.\n\t\u00a0\nHere's the instruct.zip file.\nOnce unzipped, the files are:30 percent speed.DAT\n40 percent speed.DAT\n50 percent speed.DAT\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 9: Save the Zip File With 3 .dat Files to Your Computer..."}, {"step": 10, "steps_text": "\nSelect the Browse button in the top right corner and locate the folder with your unzipped .DAT files.\nOnce you've found the directory, select OK.\u00a0 The folder will now appear next to the Browse button.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/FZY/RNFA/H5IRWNYJ/FZYRNFAH5IRWNYJ.LARGE.jpg"], "step_title": "Step 10: Locate the Folder With the .DAT Files..."}, {"step": 11, "steps_text": "\nThe .DAT files will now appear in the Advanced window.NOTICE THE PIECE SIZES for these files.\u00a0 One of them will show Portrait settings of 8.5\" x 11\", while the others show Landscape settings of 11\" x 8.5\".\u00a0 These can be modifed as needed after the Color Mapping is done.\nIn this screenshot, you can see that the 40 percent speed mapping is already selected.Select 50 percent speed and select Load to add these mappings.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/F5J/NWAT/H5IRWNYS/F5JNWATH5IRWNYS.LARGE.jpg"], "step_title": "Step 11: Now Load the 50 Percent Speed .DAT File..."}, {"step": 12, "steps_text": "\nSelect the Color Mapping Tab to see the 50 percent speed mappings.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/FWB/1CPR/H5IRWNYU/FWB1CPRH5IRWNYU.LARGE.jpg"], "step_title": "Step 12: View the 50 Percent Speed Color Mappings..."}, {"step": 13, "steps_text": "\nSelect the General Tab and do the following:NOTE: The print driver will send non-color-mapped text to be sent to the Laser!\u00a0 Step 2 below will keep the text from printing.\n\t\tConfirm the Piece Size dimensions are correct. Change them if needed. (mine are NOT correct in this screen capture)\n\t\tSet Raster Power to 0% ( this prevents any non-color-mapped text from being burned into your piece! )\n\t\tSelect OK.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": ["https://cdn.instructables.com/FHO/72DX/H5EDUJ6V/FHO72DXH5EDUJ6V.LARGE.jpg"], "step_title": "Step 13: Now Get Ready to Print the 50% Speed Text..."}, {"step": 14, "steps_text": "\nNow select Apply, then Print, and let the file load onto the Laser. This will also save the Raster settings from the previous step.\nAssuming you've focused the laser, hit the GO button while the Job is selected.Monitor your laser job!Once the 50% speed text has printed, you can hit STOP on the Laser, or lift the lid to turn off the Laser.Once the Laser gantry and mirrors are stopped, hit RESET to end the job.\n\t\tLeave the piece you are burning on the Laser table for the next steps.\n\t\tClose the Laser's lid.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": ["https://cdn.instructables.com/FZR/C23M/H5JVY15R/FZRC23MH5JVY15R.LARGE.jpg"], "step_title": "Step 14: Now Print the 50% Speed Text..."}, {"step": 15, "steps_text": "\n\t\tSelect Print from the drawing icon or the File menu.\n\t\tSelect Preferences\n\t\tSelect Color Mapping\n\t\tClear all default Color Mapping\n\t\tSelect the Advanced tab.\n\t\tSelect the 40 percent speed color mappings.\n\t\tLoad the color mappings.\n\t\tConfirm the color mappings under the Color Mapping tab.\n\t\tSelect the General tab and confirm Raster power is 0% (zero percent), piece size is correct, and Raster or Combined is selected.\n\t\tSelect OK and return to the main Print window.\n\t\tSelect Print to send the print job to the Laser.\n\t\tSelect GO on the Laser.Monitor your laser job!Once the 40% speed text has printed, you can hit STOP on the Laser, or lift the lid to turn off the Laser.Once the Laser gantry and mirrors are stopped, hit RESET to end the job.\n\t\tLeave the piece you are burning on the Laser table for the next step.\n\t\tClose the Laser's lid.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": [], "step_title": "Step 15: 40% Speed Mapping and Printing..."}, {"step": 16, "steps_text": "\nSelect Print from the drawing icon or the File menu.\n\n\t\tSelect Preferences\n\t\tSelect Color Mapping\n\t\tClear all default Color Mapping\n\t\tSelect the Advanced tab.\n\t\tSelect the 30 percent speed color mappings.\n\t\tLoad the color mappings.\n\t\tConfirm the color mappings under the Color Mapping tab.\n\t\tSelect the General tab and confirm Raster power is 0% (zero percent), piece size is correct, and Raster or Combined is selected.\n\t\tSelect OK and return to the main Print window.\n\t\tSelect Print to send the print job to the Laser.\n\t\tSelect GO on the Laser.\n\t\tMonitor your laser job!\n\t\tOnce the 30% speed text has printed, you can hit STOP on the Laser, or lift the lid to turn off the Laser.\n\t\tOnce the Laser gantry and mirrors are stopped, hit RESET to end the job.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n        ", "step_imgs": ["https://cdn.instructables.com/FQA/3U2M/H5IRWNY1/FQA3U2MH5IRWNY1.LARGE.jpg"], "step_title": "Step 16: Print the 30% Speed Text..."}, {"step": 17, "steps_text": "\nOf course this can be done in whatever wood or other material you are working with.\nI hope this Instructable helps, and that if you're planning on using Color Mapping, there are some handy pointers here.\nMaybe I'll catch you at TechShop in San Jose!\nCheers!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "step_imgs": [], "step_title": "Step 17: Okay.  You're Done..."}], "channel": "Laser Cutting"}, {"category": "workshop", "description": "Yes, this layout tool can be made for $1 !!!  I bought this framing square at the dollar store and decided to make it into a marking center and shelf pin layout square.  What are those things?  Well, a marking center helps to find the center of square tubing or a wooden board.  A shelf pin layout tool is basically just way to easily mark 1\" increments. It can also be used to draw a circle!  In this Instructable I'll show how I turned a $1 framing square into a very handy shop tool.", "title": "The $1 Marking Center, Circle Maker and Shelf Pin Layout Tool", "url": "https://www.instructables.com/id/The-1-Marking-Center-and-Shelf-Pin-Layout-Tool/", "section": "workshop", "steps": [{"step": 1, "steps_text": "Take the framing square and lay a piece of tape along the wider 1.5\" side.  Then mark at one inch increments.  This is super easy because the framing square is already marked!  I used a combination square to get my lines straight.  I also marked a center line along the length, again using the ruler marks on one edge and a mark I measured out on the opposite end.  Once the marks are made, use a centering punch to make a mark for drilling.On the thinner 1\" wide side of the framing square no tape was needed.  I center punched at the very tip of the ruler marks, which luckily happened to be in the center of the width.  ", "step_imgs": ["https://cdn.instructables.com/FGV/SL0F/J8YRK5ZB/FGVSL0FJ8YRK5ZB.LARGE.jpg", "https://cdn.instructables.com/FVV/ZS4A/J8YRK5ZC/FVVZS4AJ8YRK5ZC.LARGE.jpg", "https://cdn.instructables.com/FF5/CEIT/J8YRK613/FF5CEITJ8YRK613.LARGE.jpg"], "step_title": "Step 1: Layout Where to Drill"}, {"step": 2, "steps_text": "Here I'm at the drill press making some holes.  Not much to explain here, probably the biggest question is what size holes to drill?  I chose to drill 1/4\" holes on the 1.5\" wide side of the framing square.  I chose 1/4\" because that's a common size for shelf pins and a common size for bolts, which is how the marking center portion of the tool is used.  More on that later.   On the 1\" wide side of the framing square I chose to drill a 17/64\" hole because the point of a sharpie fits through well and that's what I use most for layout on metal.  17/64\" also works well for my non automatic centering punch.  Really the hole size just depends on what tools you use for marking or perhaps what you have laying around.   ", "step_imgs": ["https://cdn.instructables.com/FWE/VLHA/J8YRK61Q/FWEVLHAJ8YRK61Q.LARGE.jpg"], "step_title": "Step 2: What Size Holes to Drill?"}, {"step": 3, "steps_text": "Here's the framing square after I drilled some holes.  The larger holes on the wider side of the framing square are 1/4\".  On the thinner side the holes are 17/64\".  I included a picture where I messed up while drilling.  Fortunately it was at the end of the thinner side at the 7\" ruler mark.  To avoid using that hole by accident in the future, I went ahead and cut off the end.Also notice I scribe marked a center line down the length through all of the drilled holes.  This simply makes a nice reference later when using the tool. ", "step_imgs": ["https://cdn.instructables.com/F2I/CZMU/J8YRK643/F2ICZMUJ8YRK643.LARGE.jpg", "https://cdn.instructables.com/FIQ/S0RR/J8YRK65U/FIQS0RRJ8YRK65U.LARGE.jpg"], "step_title": "Step 3: Holes Drilled (and Fixing My Mistake)"}, {"step": 4, "steps_text": "After drilling out the larger 1/4\" holes on the wide 1.5\" side of the framing square, I then marked off the 1/2\" ruler marks and center punched.  Here I drilled 3/32\" holes.  I chose a 3/32\" bit because it fits a fine point sharpie tip and also my automatic centering punch.  I decided not to use my drill press for this step.  Honestly, I shouldn't have used the drill press for the 17/64\" holes.  At least not my ancient drill press.  On smaller bits I find my press not to work as well.  Hand drilling offers a more precise feel with the smaller drill bits.Slightly off topic... Notice the old Sriracha bottle I'm using to hold my drilling/tapping oil.  This is an excellent reuse of these bottles.  The tip works far better and is far less messy than the standard square tip that folds into the cap.  ", "step_imgs": ["https://cdn.instructables.com/FJ0/0VO4/J8YRK65V/FJ00VO4J8YRK65V.LARGE.jpg", "https://cdn.instructables.com/FYQ/VH1F/J8YRK67M/FYQVH1FJ8YRK67M.LARGE.jpg", "https://cdn.instructables.com/F4X/GIQ5/J8YRK67N/F4XGIQ5J8YRK67N.LARGE.jpg"], "step_title": "Step 4: Center Punch and Drill Some More Holes!"}, {"step": 5, "steps_text": "We're all done making the tool, now let's test it out!  First up I use the tool to mark the center of this 2\" piece of square steel tubing.  This is done by placing two 1/4\" bolts through the holes and twisting the framing square until those bolts touch the edge of the work piece.  Then simply mark the center using a fine point sharpie in the 3/32\" hole and drag the whole assembly down while holding carefully with the opposite hand.  It takes some practice and coordination, but once you get the hang of it, it's pretty simple.  The nice part about this tool is that it is adjustable and can mark wider material too.  This may of course require finding a better way to hold the bolts into the framing square, but it's certainly doable.  Please see the captions in the pictures for more details.The other pictures show how I use the thinner 1\" wide part of the framing square to quickly mark some points 1\" apart on a piece of 1\" square tubing.  Here I simply use my hands to line it up by feel and then take the sharpie and peck down into the holes.  Quick and easy layout.  The layout tool can also be used as a circle maker.  Simply add a push pin, small nail, or the appropriate sized drill bit through one of the holes and then secure the tool onto the material.  Then use that point to rotate around to draw a circle while using a pencil/scribe in another hole.  ", "step_imgs": ["https://cdn.instructables.com/FR2/OLZW/J8YRK6CH/FR2OLZWJ8YRK6CH.LARGE.jpg", "https://cdn.instructables.com/FV0/1242/J8YRK6G0/FV01242J8YRK6G0.LARGE.jpg", "https://cdn.instructables.com/FJQ/QI3J/J8YRK6E8/FJQQI3JJ8YRK6E8.LARGE.jpg", "https://cdn.instructables.com/FU1/N1O3/J8YRK6E9/FU1N1O3J8YRK6E9.LARGE.jpg", "https://cdn.instructables.com/F24/1OVB/J8YRK6BT/F241OVBJ8YRK6BT.LARGE.jpg", "https://cdn.instructables.com/F1F/TS1U/J8YRK6HR/F1FTS1UJ8YRK6HR.LARGE.jpg", "https://cdn.instructables.com/F3D/C41S/J8YRMSNM/F3DC41SJ8YRMSNM.LARGE.jpg", "https://cdn.instructables.com/FFA/9H2Y/J8YRMSNS/FFA9H2YJ8YRMSNS.LARGE.jpg"], "step_title": "Step 5: Using the Tool"}, {"step": 6, "steps_text": "I wanted to add a few more tips and thoughts about using this layout tool.  First, can it still be used as a framing square?  Yes, it can, but you'd want to check the accuracy of the framing square before actually using it as a square.  There is a way to do this, and videos can be found on youtube that explain the process of how to check a framing square for accuracy.  Keep in mind that a lot of center punching has been done and holes have been drilled, so this can disturb the accuracy of the framing square itself.  The scribe mark along the length that connects all the holes can be used to align with the center line that you marked.  This is why I went through the trouble of making the scribe mark in the first place!  It's simply another way to check and to stay accurate.  If marking a wider piece of material and you can't hold the 1/4 bolts with your fingers, they of course can be bolted in place.  The issue here is that now it raises the layout tool off of the material because of the nuts.  I've found a better way to deal with this is to temporarily hot glue the bolts on the layout tool.  Also tape works okay.  Without having the full support of your fingers, simply be gentle and go slower so as not to knock loose the temporarily secured bolts.  If however, you are always marking the same stock over and over again, a dedicated tool can be made and then simply tack weld the bolts onto the framing square.  If using on wood, the 1/4\" holes can just be lined up and drilled.  If you have a good enough eye, or simply want to get some pins marked on the quick, then the square itself can be used as a drill jig.  I don't however, recommend doing this as it's just too thin to actually guide a drill bit.  And there's a chance the drill bit can get caught on and twist the framing square.  It would be better, in my humble opinion, to use this to make a drilling jig out of thick aluminum stock.  Or purchase a commercially made jig.  This tool is intended as a layout tool, not a jig.  The $1 framing square also has metric markings on the opposite side.  So if you're a metric user/fan then of course you'd adjust the marks accordingly.  I hope you've enjoyed this Instructable!  Thanks so much for stopping by!  ", "step_imgs": ["https://cdn.instructables.com/FWR/QORJ/J8YRK6A2/FWRQORJJ8YRK6A2.LARGE.jpg"], "step_title": "Step 6: More Tips and Thoughts About Using the Layout Tool"}], "channel": "Home Improvement"}, {"category": "technology", "description": "\n          Many social web sites now allow to post animated pictures (GIF). Instructable does. Facebook does not (as of now). In this Instructable, you will learn how to:   generate images with math (contour plot type),     define colors,     generate an animation,     let images interact with the user.     You will also learn elements of the Processing programming language. This Instructable is to be viewed from a web browser, as the apps do not handle the animated GIFs. I hope you will enjoy the examples, get an idea of the endless possibilities, and of course, try it, and share your results!", "title": "Play With Math: Make Animated GIF and HTML5", "url": "https://www.instructables.com/id/MathVision/", "section": "technology", "steps": [{"step": 1, "steps_text": "Visit this link.Firefox and Chrome work best. Safari does not work well for saving files. Internet Explorer needs more testings... Find some bug? just PM me! You should then see the page as represented in the picture of this step.Formula area: where to write your formula, or paste formulas copied from the next steps.   Canvas area: where your image or animation will appear.   Save and Export section: offers various ways of saving your work, and will be covered in one of the last steps. ", "step_imgs": ["https://cdn.instructables.com/F8D/FASF/HSM5349Y/F8DFASFHSM5349Y.LARGE.jpg"], "step_title": "Step 1: Get and Start the Software"}, {"step": 2, "steps_text": "  For the impatient ones Get your MathVision.html page up and running as described before. Skip the rest of this step and copy-paste the formula code blocks of the next steps into the Formula box, to try them.  Creating FormulasMathVision.html is based on Processing.js, which is a particular implementation of Processing, to run in a web browser. The syntax is hence a simplified flavor of the Java programming language. You will need to learn three things:     Assigning values, like WIDTH = 300;   Using functions, like color(...), dist(...), cos(...)   Defining the rgb(...) function  Ah, and the semicolons are just here to separate the statements. A typical formula consists of two parts:Part 1: Defining the parametersWIDTH = 300;\nRATIO = 1;\nX_MIN = -16; X_MAX = 16;\nY_MIN = -16; Y_MAX = 16;\n  These parameters determine the image size in pixels, its size proportion, and the x and y ranges. Click [Show/hide formula usage] to get a list of possible parameters.Part 2: Defining the rgb() functioncolor rgb(x, y) {\n  return color(x*x+y*y);\n}  Simply put, the rgb() function defines the color for a pixel at a given (x, y) coordinate.Comments Comments are prefixed by a double slash //. In the next steps, I insert comments in the formula to mark locations deserving explanations. Comments are just ignored when the formula is executed.  // this is a comment\nVariablesint a = 234;\nfloat b = cos(PI/3);\n  Variables are storages to receive temporary work values. Usual types are integers (int) and floating-point numbers (float). In the above example, we have created a variable named a, of integer type, initialized with 234. Then we have created a variable named b,of floating point type, and initialized with the cosine of \u03c0/3.Calling functions You will likely use math functions, see http://processingjs.org/reference/ and look for the Math group.Running your formula Once you have either pasted a formula into the entry box, or created and typed your own one, click the Run button below the entry area. It is easy to make syntax errors. In such a case, after clicking Run, MathVision will alert you by a message box. Unfortunately, the alert message may not be very obvious to locate the issue.Save your work periodically Define a base name for your exports and saves. Save your work by clicking Save Formula as...", "step_imgs": ["https://cdn.instructables.com/FNX/DMCM/HSNFXHPW/FNXDMCMHSNFXHPW.LARGE.jpg"], "step_title": "Step 2: Formula Basics"}, {"step": 3, "steps_text": "  First let's start with a simple example: vertical stripes. For this, we will only consider the x coordinate.  Run MathVision.html in another tab of your browser, and copy-paste the sample formulas that you will find below.  FormulaWIDTH = 200;\nRATIO = 1;\nX_MIN = 0; X_MAX = 10;\nY_MIN = 0; Y_MAX = 10;\n\ncolor rgb(x, y) {\n  int value = (int)x % 2; // (a)\n  int luma = value * 255; // (b)\n  return color(luma);     // (c)\n}\n  Explanation  (a) We take the integral part of x (the (int)x here), and determine whether it is odd or even (the % 2 means modulo 2). This yields a value that is either 0 or 1.  (b) We multiply the value by 255 to obtain a greyscale luma number (from 0 to 255). Because value is either 0 or 1, luma will be either 0 or 255 here.  (c) We return a greyscale color, by calling the color() function with only one parameter.  Exercises   Make diagonal stripes. Hint: use also y. ", "step_imgs": ["https://cdn.instructables.com/FU1/W6MJ/HSICZBT1/FU1W6MJHSICZBT1.LARGE.jpg"], "step_title": "Step 3: Basics - Stripes"}, {"step": 4, "steps_text": "This is quite similar to the previous step, but this time, y is also considered.  FormulaWIDTH = 200;\nRATIO = 1;\nX_MIN = 0; X_MAX = 10;\nY_MIN = 0; Y_MAX = 10;\n\ncolor rgb(x, y) {\n  float value = (int)x % 2 == (int)y % 2; // (a)\n  float luma = value * 255;               // (b)\n  return color(luma);                     // (c)\n}  Explanation (a) In the previous step, we have seen how to determine whether x is even or odd. Now we do the same for x and y, and compare (the == operator) if they are equally odd or even. The result is either 0 or 1.   - Then, it is exactly like in the previous step: - (b) We multiply the value by 255 to obtain a greyscale luma number (0 to 255). Because value is either 0 or 1, luma will be either 0 or 255 here. (c) We return a greyscale color, by calling the color() function with only one parameter.  Exercises   Make larger squares.      Make black and red squares. Hint: use color(luma, 0, 0).      Make red and white squares. ", "step_imgs": ["https://cdn.instructables.com/F5F/7LDF/HSICZBT0/F5F7LDFHSICZBT0.LARGE.jpg"], "step_title": "Step 4: Basics - Checkerboard"}, {"step": 5, "steps_text": "  Now let's draws a spiral.  FormulaWIDTH = 250;\nRATIO = 1;\nX_MIN = -1; X_MAX = 1;\nY_MIN = -1; Y_MAX = 1;\n\ncolor rgb(x, y) {\n  float radius = dist(x, y, 0, 0);        // (a) Cartesian to polar\n  float angle = atan2(x, y);              // (a) Cartesian to polar\n  float value = angle*3 - log(radius)*12; // (b) the spiral\n  float stripe = cos(value);              // (c) the smooth stripes\n  float luma = (stripe + 1) * 127;        // (d) map to luma range\n  return color(luma);\n}  Explanation  (a) Convert Cartesian coordinates (x,y) to polar coordinates (angle,radius).  (b) Determine the color by using the angle and the logarithm of the radius.  (c) Apply a cosine in order to generate smooth greyscale stripes.  (d) Map stripe (-1 to 1) to luma range (0 to 255).  Note:  You can also generate black and white (instead of greyscaled) stripes by replacing the two lines (c) and (d) by this single one:  float luma = cos(value)>0 ? 0 : 255;  Then, notice how the stripes borders are jagged. Not so nice, so let's stick with greyscales!  Exercises   Make the spiral turn in opposite direction. ", "step_imgs": ["https://cdn.instructables.com/FNR/OZJ6/HSICZBSZ/FNROZJ6HSICZBSZ.LARGE.jpg"], "step_title": "Step 5: Basics - Spiral"}, {"step": 6, "steps_text": "There are two very common ways of defining a color: the RGB and HSB models. The two are supported by MathVision, and their usage is described in this step.  RGB Model With the so-called RGB model, a color is defined by its Red, Green and Blue components. To use the RGB color model, you shall define your formula as rgb(x,y) or rgb(x,y,t). In the previous steps, remember that your rgb function used color(luma) with one single argument, to produce black and white or gray scales. Now, for color output, you should call rgb with three arguments: color(red,green,blue). Each argument should range from 0 to 255.color(255,0,0) is primary red, color(0,255,0) is primary green, color(0,0,255) is primary blue;   color(0,0,0) is black, color(255,255,255) is white;   color(127,0,0) is dark red. Formula 1 (RGB)WIDTH = 250; RATIO = 1;\nX_MIN = 0; X_MAX = 255;\nY_MIN = 0; Y_MAX = 255;\n\ncolor rgb(x, y) {\n  int radius = 80;\n  int d1 = dist(x, y, 80, 175);\n  int d2 = dist(x, y, 175, 175);\n  int d3 = dist(x, y, 127, 80);\n\n  int r = d1 < radius ? 255 : 0;\n  int g = d2 < radius ? 255 : 0;\n  int b = d3 < radius ? 255 : 0;\n\n  return color(r, g, b);\n}\n  The above formula generates the first image of this step.     For the red circle, we have full-red contribution (255) if we are inside a circle centered at x=80 and y=175, otherwise we have 0.      Similar for green and blue, with different centers.      If we are outside any circle, r, g and b are all zero; we get black, because color(0, 0, 0) is black.  What if, instead of a black background, we want a white background? This is our second picture and second formula for this step.Formula 2 (RGB)WIDTH = 250; RATIO = 1;\nX_MIN = 0; X_MAX = 255;\nY_MIN = 0; Y_MAX = 255;\n\ncolor rgb(x, y) {\n  int radius = 80;\n  int d1 = dist(x, y, 80, 175);\n  int d2 = dist(x, y, 175, 175);\n  int d3 = dist(x, y, 127, 80);\n\n  int r = d1 < radius ? 255 : 0;\n  int g = d2 < radius ? 255 : 0;\n  int b = d3 < radius ? 255 : 0;\n\n  return r+g+b ? color(r, g, b) : color(255);\n}\n  The above formula is similar to the previous one, with this change in the last line:     If all components are zero (i.e. r+g+b is zero) then we are outside any circle, and we return color(255) which is white (and which is the same as color(255,255,255) );      otherwise. return color(r,g,b) as before.   HSB Model For the HSB model, instead of using red, green and blue components, a color is defined by three other kind of arguments:     H, the hue -- the pure color in the range of possible colors: 0=red, 150=blue;      S, the saturation -- how the color is vivid or faded: 50=pastel, 255=vivid;      B, the brightness: 50=dark, 255=lightest. Formula 3 (HSB)WIDTH = 250; RATIO = 1;\nX_MIN = 0; X_MAX = 255;\nY_MIN = 0; Y_MAX = 255;\n\ncolor hsb(x, y) {\n  int radius = 80;\n  int b = dist(x, y, 127, 127) < 80 ? 64 : 255;\n  return color(x, y, b);\n}\n  In the above formula, which yields the third picture of this step, we do the following:     Vary the hue with x (horizontally), and the saturation with y (vertically). The top of the picture is vivid, whereas the bottom is so faded that it becomes white.      In addition, we darken a disc centered at the middle of the image at (127,127); if we are outside the disk, we set b to 255 (full brightness), otherwise to 64 (quite dark). ", "step_imgs": ["https://cdn.instructables.com/F9P/OYB4/HSM5170M/F9POYB4HSM5170M.LARGE.jpg", "https://cdn.instructables.com/FZ3/LPLL/HSM5172Y/FZ3LPLLHSM5172Y.LARGE.jpg", "https://cdn.instructables.com/FOC/SFX8/HSM51B8H/FOCSFX8HSM51B8H.LARGE.jpg"], "step_title": "Step 6: Basics - Colors"}, {"step": 7, "steps_text": "(link to HTML5 animated version) So far so good, but weren't animated GIF images promised in the intro? For animation, there are three new ingredients:  t: the time value. You just have to add t to the arguments of rgb() or hsb(). Then of course, t shall be used smartly in the formula.   TIME_INCREMENT: the time leap between each frame.   FRAMES: the number of frames for the animated GIF. If you don't want to export as animated GIF, you may leave that out.   FormulaTIME_INCREMENT = 0.2;                  // (a)\nFRAMES = 10;                           // (b)\nFRAMES = TWO_PI / TIME_INCREMENT / 3;  // (b2)\nOUT_PAUSE = false;\nWIDTH = 250;\nRATIO = 1;\nX_MIN = -1; X_MAX = 1;\nY_MIN = -1; Y_MAX = 1;\n\ncolor rgb(x, y, t) {                   // (c)\n  float radius = dist(x, y, 0, 0);\n  float angle = -atan2(x, y);\n  angle = angle + t;                   // (d)\n\n  float value = angle*3 - log(radius)*12;\n  float stripe = cos(value);\n\n  float luma = (stripe + 1) * 127;\n  return color(luma);\n}\n  The non-animated spiral was explained in the previous tutorial. We will here only cover the modifications necessary to generate an animation.     (a) TIME_INCREMENT defines the time increment, i.e. how the time varies from one frame to the next one.      (b) FRAMES defines the number of frames that we want to pack into the animation file (anim GIF). The number really depends on your formula. It shall be chosen so that the transition between the last frame and the first frame is smooth. Here in (b2), we compute it to take the TIME_INCREMENT into account (the smaller the increment, the more the number of frames).      (c) The rgb() function is declared here with the t argument. This states that we want an animation. The rgb() function will be called with various values of t, starting from 0, and incremented with TIME_INCREMENT at each new frame.      (d) In this formula, this is how we decided to use t. Here, t is added to the angle, making the whole spiral spin with the time.   Exercises   Make the spiral spin in the opposite direction.      Make the spiral spin faster or slowlyer. ", "step_imgs": ["https://cdn.instructables.com/FNV/ICWN/HSICZBWN/FNVICWNHSICZBWN.LARGE.gif"], "step_title": "Step 7: Basics - Animated Spiral"}, {"step": 8, "steps_text": "Now, the following formula will render a spot following the mouse, and colored after the x position. This is a simple form of user interaction. Note: To experience the interactivity, follow http://www.openprocessing.org/sketch/138963  FormulaWIDTH = 250;\nRATIO = 1;\nX_MIN = -20; X_MAX = 20;\nY_MIN = -20; Y_MAX = 20;\nMOUSE_MOVE = true;             // (a)\n\ncolor hsb(x, y) {\n  float d = dist(u, v, mouseX, mouseY) / WIDTH * 10;  // (b)\n  float shift = mouseX / WIDTH;                       // (c)\n\n  float bright = (1/d) * 255;      // (d)\n  float hue = shift * 255;         // (e)\n\n  return color(hue, 255, bright);  // (f)\n} \n  Explanation   (a) Setting MOUSE_MOVE to true will insure to redraw upon any mouse move.      (b) We calculate the distance of the current pixel to the mouse. Instead of x and y, u and v are used, as they represent the pixel coordinate. WIDTH is used to normalize and be independent of the actual canvas size. The value 10 controls the size of the spot.      (c) The color shift is proportional to the mouse horizontal position mouseX. WIDTH is used so that shift ranges from 0 to 1.      (d) The brightness will be maximal under the mouse, and will tend to zero for pixels away from the mouse.      (e) For the hue, we scale the color shift, to range between 0 and 255.      (f) We create the pixel color by using the computed hue, brightness, and a maximal saturation (255, for strong colors).  Notes:   To draw simple flat shapes following the mouse, MathVision is far less efficient than the usual graphics primitives of Processing.js. This is because MathVision recomputes each pixel (applying the formula to each one) for every redraw of the canvas.      On the other hand, effects, such as the halo you can see here, are very easily obtained. ", "step_imgs": ["https://cdn.instructables.com/FQ2/Y06I/HSICZBSV/FQ2Y06IHSICZBSV.LARGE.jpg"], "step_title": "Step 8: Basics - User Interaction"}, {"step": 9, "steps_text": "(link to HTML5 animated version) From now on, I will offer you some more complex formulas, with not much detailed explanations -- artistic results often come with lots of tweakings. You can study them and spot some comments within. This one produces wave effects on the water.  FormulaWIDTH = 200;\nfloat RATIO = 1;\nTIME_INCREMENT = .08;\nOUT_PAUSE = false;\n\nX_MIN = 0; X_MAX = 30;\nY_MIN = 0; Y_MAX = 30;\n\nfloat wave(x, y, fx, fy, a, vx, vy) {\n  return sin((x+2*sin(y*fx*3))*fx + t*vx) * sin(y*fy + t*vy) * a;\n}\n \nfloat dx, dy;\nbool preDraw(t) {\n  dx = pow(sin(t/20), 2)/3;\n  dy = pow(cos(t/20), 2)/3;\n  return true;\n}\n \ncolor rgb(x, y, t) {\n  float value = 0;\n \n  //                  fx    fy    a     vx    vy\n  value += wave(x, y, 0.20, 0.10, 0.4,  dx ,  dy );\n  value += wave(x, y, 0.31, 0.31, 0.4,  0.2,  0.2);\n  value += wave(x, y, 0.09, 0.07, 0.4,  0.2,  0.2);\n  \n  value = sin(value*7);\n  value = pow(value*value, .1);\n  float normed = value*255;\n  return color(24, 255-normed/2, 255);\n}\n  Notes   Did you notice the preDraw() function? It is called, if defined, before each frame. It allows to compute variables that do change over frames, and not over pixels. And hence, to do the computation once per frame instead of redoing it uselessly for each pixel.      The function wave() is an arbitrarily named function, that we call several times per pixel, with different arguments. ", "step_imgs": ["https://cdn.instructables.com/FHE/FV9Y/HSICZBT8/FHEFV9YHSICZBT8.LARGE.gif"], "step_title": "Step 9: Advanced - Animated Water"}, {"step": 10, "steps_text": "(link to HTML5 animated version) This is one of my favorites. Making the spiral was easy (as seen in previous steps), but making the chambers divisions was a real challenge.  FormulaOUT_PAUSE = false;\nFIRST_FRAME_TIME = PI/4;\nWIDTH = 250;\nRATIO = 1;\nTIME_INCREMENT = 0.02;\nX_MIN = -6; X_MAX = 6;\nY_MIN = -6; Y_MAX = 6;\nFRAMES = PI / TIME_INCREMENT;\n\ncolor rgb(x, y, t) {\n  float radius = dist(x, y, 0, 0);    // cartesian to polar\n  float angle = atan2(x, y);          // cartesian to polar\n\n  float sint = sin(t);\n  if(sint<0) {\n    // for negative pitch, have sint positive and negate angle\n    sint = -sint;\n    angle = -angle;\n  }\n\n  float lrad = log(radius) * 4 * sint;\n\n  float spiral = cos(angle/2 + lrad);\n  float divisions =\n    spiral > 0\n    ?  sin(sin(angle*4 + sint * lrad * sin(angle/2+lrad - PI/4)/8)*PI/2)\n    : -sin(sin(angle*4 - sint * lrad * sin(angle/2+lrad - PI/4)/8)*PI/2 + PI);\n\n  float value = spiral * divisions;\n  value = pow(value*value, .05); // make lines thinner\n\n  float luma = value * 255;\n  return color(luma);\n}\n", "step_imgs": ["https://cdn.instructables.com/FL0/8XSV/HSICZBTJ/FL08XSVHSICZBTJ.LARGE.gif"], "step_title": "Step 10: Advanced: - Animated Nautilus"}, {"step": 11, "steps_text": "Another crazy one... It is the distort variable which is giving the depth effect. For best animation colors, please visit http://www.openprocessing.org/sketch/126463  FormulaFRAMES = 40;\nWIDTH = 250;\nX_MIN = -TWO_PI; X_MAX = TWO_PI;\nY_MIN = -TWO_PI; Y_MAX = TWO_PI;\nRATIO = AUTO;\nTIME_INCREMENT = PI/2;\nOUT_PAUSE = false;\n\nvoid preSetup() {\n    colorMode(HSB, 255);\n}\n\ncolor rgb(x, y, t) {\n  float xx, yy;\n  xx = x - y/4;\n  yy = y + x/4;\n\n  if(xx==0)\n    return color(0);\n\n  if(xx<0) {\n    xx = -xx;\n    yy = yy;\n  }\n  else {\n    xx = xx*2;\n    yy = yy*2;\n  }\n  float distort = 1 - 1/exp(xx*3);\n  float tt = xx<0 ? t : t*2;\n  xx = cos(xx + distort + tt/10);\n  yy = sin(yy + distort + tt/20);\n\n  float value = pow(xx+yy, 6)*2;\n  value = value > 1 ? 1 : value;\n  float luma = value * 255 * distort;\n  return color(u/width*100, 200, luma);\n}\n", "step_imgs": ["https://cdn.instructables.com/FZE/AXUK/HSICZBVJ/FZEAXUKHSICZBVJ.LARGE.jpg", "https://cdn.instructables.com/FWW/AMCZ/HSICZHH6/FWWAMCZHSICZHH6.LARGE.gif"], "step_title": "Step 11: Advanced - Animated Fabric Rolls"}, {"step": 12, "steps_text": "(link to HTML5 animated version) For best results when aiming at exporting an animated GIF, you should generate as few different hues (colors) as possible, otherwise the GIF encoder will have troubles building a good color palette. In this example, the statement (int)(value/127) * 127  is here to limit the color resolution.  FormulaFRAMES = 20;\nWIDTH = 150;\nRATIO = 1;\nX_MIN = -2; X_MAX = 2;\nY_MIN = -2; Y_MAX = 2;\nTIME_INCREMENT = PI/10;\nOUT_PAUSE = false;\n \nfloat flower(x, y, t, n, k1, k2) {\n  float radius = dist(x, y, 0, 0)/k1;   // cartesian to polar\n  float angle = atan2(x, y) + t*k2;      // cartesian to polar; turns with time\n \n  float value = sin(angle*n)-radius + pow(radius, exponent);\n  value = min(255, max(0, (1+value) * 127));\n  return (int)(value/127) * 127;\n}\n \nfloat exponent;\nbool preDraw(t) {\n  exponent = cos(t);\n  return true;\n}\n \ncolor rgb(x,y,t) {\n  float r = flower(x+1, y+1, t, 6, 0.5, -1);\n  float g = flower(x+0.5, y-0.20, t, 5, 0.7, .2);\n  float b = flower(x-1, y-1, t, 21, 0.5, .5);\n  return color(255-r, 255-g, 255-b); \n}\n", "step_imgs": ["https://cdn.instructables.com/FM3/ATTS/HSICZG8A/FM3ATTSHSICZG8A.LARGE.gif"], "step_title": "Step 12: Advanced - Animated Flowers"}, {"step": 13, "steps_text": "This formula generates a perspective dotted sky and road. Note: To experience the interactivity, and get the best colors, definitely follow http://www.openprocessing.org/sketch/138961. Moving the mouse up and down changes the color; moving horizontally changes the perspective angle.  FormulaWIDTH = 300;\nX_MIN = -1; X_MAX = 1;\nY_MIN = 0.5; Y_MAX = -0.5;\nRATIO = 2;\nTIME_INCREMENT = 0.5;\nOUT_PAUSE = false;\nFRAMES = TWO_PI / TIME_INCREMENT;\n \ncolor hsb(x, y, t) {\n  if(y==0)\n    return color(0); // avoid zero-divide\n \n  ay = abs(y);\n  float direction = ((mouseX - WIDTH/2) / WIDTH) * TWO_PI;\n  float val = cos(1/ay+t) * cos(x/ay - direction); // perspective spots raster\n  val = 1 - pow(val,4);                            // increase contrast\n  val *= y/Y_SPAN*2;                               // fade horizon to avoid moiree\n  float band =  sq(1/(x/ay - direction));          // V mask for central band\n  float color_shift = mouseY/height;               // H offset\n \n  // pack all into HSV\n  float h = 1+sin(val/2) + color_shift;\n  float s = 3;\n  float v = y<0 ? 3:band;\n  return color(h*85, s*85, v*85);\n}\n", "step_imgs": ["https://cdn.instructables.com/FT4/IJ0C/HSM53KUW/FT4IJ0CHSM53KUW.LARGE.jpg", "https://cdn.instructables.com/FXY/9HVM/HSNFXBW5/FXY9HVMHSNFXBW5.LARGE.gif"], "step_title": "Step 13: Crazy - Alien Sky and Road"}, {"step": 14, "steps_text": "This is an interactive fractal: Moving the mouse horizontally over the image will change the fractal depth. To experience the interactivity, follow http://www.openprocessing.org/sketch/138956  FormulaWIDTH = 700;\nX_MIN = 0; X_MAX = 1;\nY_MIN = 0; Y_MAX = 1;\nRATIO = AUTO;\nMOUSE_MOVE = true;\n\n// recursion\n// ---------\nint sierpinski(u, v, w, h, depth, maxdepth) {\n  int val = ((int)(u/w * 3) % 2) * ((int)(v/h * 3) % 2);\n\n  if(val==0 && depth<maxdepth) {\n    return sierpinski((u*3 % w)/3, (v*3 % h)/3, w/3, h/3, depth+1, maxdepth);\n  }\n  else\n    return val;\n}\n\n// start the computation and convert 0/1 to color\n// ----------------------------------------------\ncolor rgb(x, y) {\n  return color(sierpinski(x,y,X_SPAN,Y_SPAN, 1, maxdepth) * 255);\n}\n\n// redraw only on effective maxdepth change\n// ----------------------------------------\nint maxdepth = -1;\nbool preDraw(t) {\n  int d = (int)(mouseX/width*6) +1;\n  bool doit = maxdepth!=d;\n  maxdepth = d;\n  return doit;\n}\n", "step_imgs": ["https://cdn.instructables.com/FOV/N7R7/HSNFXPKH/FOVN7R7HSNFXPKH.LARGE.jpg"], "step_title": "Step 14: Fractals"}, {"step": 15, "steps_text": "MathVision offers the following exporting possibilities:Formula  Text file containing the formula text (= your design work). You can load such files by clicking Load formula from text file.Image  Image of the current canvas state. Gets loaded in another browser window or tab; then it is up to you to save it (e.g. as .PNG) using your browser (Save page as...)Animated GIF  For formulas designed for animation, compute all frames, and load the resulting animated image in another browser window or tab; then it is up to you to save it (as .GIF) using your browser (Save page as...)Processing sketch  A sketch that you can use in http://www.openprocessing.org. Formulas designed for animation yield animated sketches; user mouse interaction is supported.HTML page  An HTML5 page that is standalone and full-featured: formulas designed for animation are animated; user mouse interaction is supported.  Thank you for reading. Now try MathVision, and post your work! Create formulas, export static or animated images, and post them along with your formula code!Visit this link to run MathVision.Visit this link on Github for more information.", "step_imgs": ["https://cdn.instructables.com/F8U/Z4DT/HSM53Q17/F8UZ4DTHSM53Q17.LARGE.jpg"], "step_title": "Step 15: Exporting Your Work"}], "channel": "Science"}, {"category": "technology", "description": "It would seem that such simple things as a rainbow effect or smoothly changing random colors on an RGB LED are pretty trivial. However, time and again I come upon projects using strange approaches to this matter. The most common strangeness is the use of the HSV color model for RGB LED programming. Really, people! An RGB LED consists of three LEDs: red, green and blue. What\u2019s better suited to control such a thing than the red, green and blue color model? Why complicate matters by additional algorithms converting data from a very different set of rules to the native one? Still, HSV persists; it\u2019s even present in an excellent ShiftPWM library...In any case, one of the readers asked for a code in my previous instructable dealing with RGB LED strips connection to an Arduino, and I promised an article. Here it goes, hopefully it\u2019s not too late for some of the readers to make some quick Christmas lights. Here you\u2019ll learn of different possible approaches to an RGB rainbow, random colors and their transitions, as well as some bits on the usefulness of a sine wave and lookup tables.You\u2019ll need just an Arduino and an RGB LED to run the sketches present.But first, let\u2019s deal with the HSV. If you want to get to the sketches ASAP, you may skip to the second step now.", "title": "How to Make Proper Rainbow and Random Colors With the RGB Color Model", "url": "https://www.instructables.com/id/How-to-Make-Proper-Rainbow-and-Random-Colors-With-/", "section": "technology", "steps": [{"step": 1, "steps_text": "The most important HSV achievement is bringing together two color worlds: the light-emitting one (RGB) and the light-reflecting one (CMYK). These worlds are very different: for example, mixing red and green on the screen results in pure yellow, but try mixing them on paper and you\u2019ll get a dirty blot. Thus HSV is pretty useful for graphic designers \u2014they can do everything in one model and be reasonably sure that the result will look the same on the screen and on paper. However, as with all the other universal solutions, some constraints are imposed, thus, people who work exclusively with printed designs have to rely on CMYK, and people dealing with LEDs are better off with the RGB model. It\u2019s just way better suited for light-emitting sources!Let me dig a bit deeper into this. HSV stands for Hue, Saturation and Value (or Brightness). Hue is a circle, it has values from 0 to 360. Saturation and Value are measured in percents (0 to 100). Not exactly suited for a world of bytes... And what\u2019s more, two of these values are almost useless when dealing with LEDs, because they are made for complex hi-res designs, not single pixels (aka RGB LEDs).Saturation can be used to produce soft, pastel colors, without the complex calculations needed with RGB model. But with LEDs you don\u2019t want pastel colors (they look just like different shades of white, in fact): you need your colors as bright and clear as possible, so Saturation is at 100% almost all the time (excluding the animation/transformation moments, but they are done with algorithms; more on that later).With Brightness you can achieve some dark colors on screen. Lower brightness in red (H=0) and you get burgundy, lower brightness in orange (H=40) and get brown. Do the same with LEDs and you\u2019ll get the same red and yellow colors, just a bit dimmer; there\u2019s no such thing as a \u2018brown LED\u2019. You see deep dark red on the screen because there are different colors present there; try to fill it with dark red entirely, turn off all the lights and you\u2019ll see a red rectangle; you won\u2019t be able to tell whether it\u2019s \u2018burgundy\u2019 or \u2018scarlet\u2019 due to absence of any reference. Same with LEDs: even if you have a bunch of them, they are still separate. Thus the use of Value in HSV model with RGB LEDs is limited to setting global brightness, fadeouts and transitions; all this can be easily done in RGB by simple simultaneous division applied to each channel. Another thing that makes HSV Value/Brightness useless with LEDs is the fact that diodes, unlike computer monitors, are not calibrated, and are slow; their brightness is not linear. At 50% they look almost the same as at 100%, which, in fact, is very good, because it helps control power consumption.Which leaves us with Hue: a nice circle containing all the colors of a rainbow in a neat 0-360\u00b0 sequence. Seems like producing a rainbow with it is the easiest thing imaginable: the simple for (int k=0; k<360; k++) cycle will do the trick. What can be wrong with that?See the picture with normal HSV graph above. As the model was made to contain every possible color, it considers yellow (HSV = 60, 100, 100) to have both red and green of the RGB model at maximum (255, 255, 0). With RGB LED it means that both red and green diodes are fully on. Which means that every composite color (yellow, cyan, magenta) consumes two times more current than a base one (red, green, blue). Not good, especially if you\u2019re dealing with long LED strips or a matrix of RGB LEDs powered by USB. The second graph (\u2018Power-conscious HSV\u2019) looks better, but it\u2019s not the pure Hue of HSV, and is easier implemented with RGB model.The third graph shows a sine wave rainbow. In my opinion it\u2019s the best one, as it produces deeper base colors and is devoid of spikes. And it can be implemented only in the RGB model. On to the next step.", "step_imgs": ["https://cdn.instructables.com/FTI/O536/IIG9YHKA/FTIO536IIG9YHKA.LARGE.jpg"], "step_title": "Step 1: To HSV or Not to HSV"}, {"step": 2, "steps_text": "The video above shows same five LEDs running rainbow in three modes: regular HSV (top), \u2018power-conscious\u2019 HSV (middle) and sine wave (bottom). Filming LEDs is not an exactly rewarding experience, but hopefully you can see the difference between different modes. There\u2019s a B&W footage at the end, it clearly shows the spikes of HSV modes. In any case, here is the code that\u2019ll let you repeat the experience yourself:// uint8_t is the same as byte// uint16_t is unsigned int\n// I just noticed that I mixed these in this sketch, sorryconst uint8_t lights[360]={\n  0,   0,   0,   0,   0,   1,   1,   2, \n  2,   3,   4,   5,   6,   7,   8,   9, \n 11,  12,  13,  15,  17,  18,  20,  22, \n 24,  26,  28,  30,  32,  35,  37,  39, \n 42,  44,  47,  49,  52,  55,  58,  60, \n 63,  66,  69,  72,  75,  78,  81,  85, \n 88,  91,  94,  97, 101, 104, 107, 111, \n114, 117, 121, 124, 127, 131, 134, 137, \n141, 144, 147, 150, 154, 157, 160, 163, \n167, 170, 173, 176, 179, 182, 185, 188, \n191, 194, 197, 200, 202, 205, 208, 210, \n213, 215, 217, 220, 222, 224, 226, 229, \n231, 232, 234, 236, 238, 239, 241, 242, \n244, 245, 246, 248, 249, 250, 251, 251, \n252, 253, 253, 254, 254, 255, 255, 255, \n255, 255, 255, 255, 254, 254, 253, 253, \n252, 251, 251, 250, 249, 248, 246, 245, \n244, 242, 241, 239, 238, 236, 234, 232, \n231, 229, 226, 224, 222, 220, 217, 215, \n213, 210, 208, 205, 202, 200, 197, 194, \n191, 188, 185, 182, 179, 176, 173, 170, \n167, 163, 160, 157, 154, 150, 147, 144, \n141, 137, 134, 131, 127, 124, 121, 117, \n114, 111, 107, 104, 101,  97,  94,  91, \n 88,  85,  81,  78,  75,  72,  69,  66, \n 63,  60,  58,  55,  52,  49,  47,  44, \n 42,  39,  37,  35,  32,  30,  28,  26, \n 24,  22,  20,  18,  17,  15,  13,  12, \n 11,   9,   8,   7,   6,   5,   4,   3, \n  2,   2,   1,   1,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0, \n  0,   0,   0,   0,   0,   0,   0,   0};const uint8_t HSVlights[61] = \n{0, 4, 8, 13, 17, 21, 25, 30, 34, 38, 42, 47, 51, 55, 59, 64, 68, 72, 76,\n81, 85, 89, 93, 98, 102, 106, 110, 115, 119, 123, 127, 132, 136, 140, 144,\n149, 153, 157, 161, 166, 170, 174, 178, 183, 187, 191, 195, 200, 204, 208,\n212, 217, 221, 225, 229, 234, 238, 242, 246, 251, 255};const uint8_t HSVpower[121] = \n{0, 2, 4, 6, 8, 11, 13, 15, 17, 19, 21, 23, 25, 28, 30, 32, 34, 36, 38, 40,\n42, 45, 47, 49, 51, 53, 55, 57, 59, 62, 64, 66, 68, 70, 72, 74, 76, 79, 81, \n83, 85, 87, 89, 91, 93, 96, 98, 100, 102, 104, 106, 108, 110, 113, 115, 117, \n119, 121, 123, 125, 127, 130, 132, 134, 136, 138, 140, 142, 144, 147, 149, \n151, 153, 155, 157, 159, 161, 164, 166, 168, 170, 172, 174, 176, 178, 181, \n183, 185, 187, 189, 191, 193, 195, 198, 200, 202, 204, 206, 208, 210, 212, \n215, 217, 219, 221, 223, 225, 227, 229, 232, 234, 236, 238, 240, 242, 244, \n246, 249, 251, 253, 255};uint8_t outputPins[6] = {3, 5, 6, 9, 10, 11}; // PWM pins// setRGBpoint (0, ...) for pins 3, 5, 6; setRGBpoint (1, ...) for pins 9, 10, 11.\n// See array above\nvoid setRGBpoint(byte LED, uint8_t red, uint8_t green, uint8_t blue)\n{\n  // this code is for common anode LEDs. If you use common cathode ones,\n  // remove the '255-' bits.\n  analogWrite(outputPins[LED*3], 255-red);\n  analogWrite(outputPins[LED*3+1], 255-green);\n  analogWrite(outputPins[LED*3+2], 255-blue);\n}// the real HSV rainbow\nvoid trueHSV(byte LED, int angle)\n{\n  byte red, green, blue;  if (angle<60) {red = 255; green = HSVlights[angle]; blue = 0;} else\n  if (angle<120) {red = HSVlights[120-angle]; green = 255; blue = 0;} else \n  if (angle<180) {red = 0, green = 255; blue = HSVlights[angle-120];} else \n  if (angle<240) {red = 0, green = HSVlights[240-angle]; blue = 255;} else \n  if (angle<300) {red = HSVlights[angle-240], green = 0; blue = 255;} else \n                 {red = 255, green = 0; blue = HSVlights[360-angle];} \n  setRGBpoint(LED, red, green, blue);\n}// the 'power-conscious' HSV rainbow\nvoid powerHSV(byte LED, int angle)\n{\n  byte red, green, blue;\n  if (angle<120) {red = HSVpower[120-angle]; green = HSVpower[angle]; blue = 0;} else\n  if (angle<240) {red = 0;  green = HSVpower[240-angle]; blue = HSVpower[angle-120];} else\n                 {red = HSVpower[angle-240]; green = 0; blue = HSVpower[360-angle];}\n    setRGBpoint(LED, red, green, blue);\n}// sine wave rainbow\nvoid sineLED(byte LED, int angle)\n{\n  setRGBpoint(LED, lights[(angle+120)%360], lights[angle],  lights[(angle+240)%360]);\n}void setup() {\n}void loop() {\n  \nfor (int k=0; k<360; k++)\n{// uncomment the mode (or modes) you need below.\n// with all six PWM outputs connected you may use 2 modes, change one 0 to 1.trueHSV(0, k);//powerHSV(0, k);//sineLED(0, k);delay(30);\n}\n}Just connect one or two RGB LEDs to your Arduino and uncomment the needed routines in the loop(). Note that this code was written for common anode LEDs, if you have common cathode ones remove all three \u2018255-\u2018 from the setRGBpoint() function.The setRGBpoint() function itself is included for easier transition between PWM outputs and LED drivers. Change it accordingly if you\u2019re using the latter. Note that you can still use one byte values, just multiply them in the function with \u2018<<4\u2019 for 12-bit output and \u2018<<8\u2019 for 16-bit one.This code is enough to get you started, but if you want it explained a bit, read on (and yes, the random colors will follow shortly).", "step_imgs": [], "step_title": "Step 2: Rainbow Time!"}, {"step": 3, "steps_text": "A large first part of the code in previous step consists of big constant arrays. These are lookup tables storing pre-calculated values for sine wave and HSV functions. Of course, it is possible instead to calculate the exact value of each LED the time it is turned on, for example, for normal HSV:byte red, green, blue;  if (angle<60) {red = 255; green = round(angle*4.25-0.01); blue = 0;} else\n  if (angle<120) {red = round((120-angle)*4.25-0.01); green = 255; blue = 0;} else \n  if (angle<180) {red = 0, green = 255; blue = round((angle-120)*4.25-0.01);} else \n  if (angle<240) {red = 0, green = round((240-angle)*4.25-0.01); blue = 255;} else \n  if (angle<300) {red = round((angle-240)*4.25-0.01), green = 0; blue = 255;} else \n                 {red = 255, green = 0; blue = round((360-angle)*4.25-0.01);} \n  setRGBpoint(LED, red, green, blue);These calculations will free some dynamic memory, but at the cost of program memory and processing time. While it is more or less OK with simple multiplication of HSV, doing sine waves in realtime requires operations with floating point and most certainly should be avoided, hence the lookup tables.Note that the sine wave lookup table even contains an array of zeroes at the end \u2013 that\u2019s because I use these tables a lot and found that a hundred more filled bytes of dynamic memory is a good trade-off for a cleaner code.You can calculate these tables during setup() instead of inserting them in the code \u2013 again, as I use them a lot, I prefer to do them once and then just copy-paste the arrays.You may want to make your own table of different size or with different values, so here\u2019s the sketch. It will print all three arrays in the Serial Monitor window, it\u2019s easy to copy-paste them from there.uint8_t lights[360];uint16_t kkk;void setup() {Serial.begin(9600);  //sine wave\nSerial.println(\"const uint8_t lights[360]={\");\nfor (float k=PI; k<(3*PI); k=k+PI/120) \n  {\n    lights[kkk]=int((cos(k)+1)*127.7); // I use cosinus\n    if (lights[kkk]<10) Serial.print(\" \"); // I like to keep the table clean\n    if (lights[kkk]<100) Serial.print(\" \"); // told you I use them a lot!\n    Serial.print(lights[kkk]);\n    if (kkk<255) Serial.print(\", \"); //'if' portion is useful if you're not filling the\n                                     // rest of the table with zeroes. It makes sure there's\n                                     // no extra comma after the final value of array.\n                                     // I keep it here just for that situation\n    if (kkk%8==7) Serial.println();  // new line for cleaner table!\n    kkk++;\n  }for (; kkk<360; kkk++) // fill the rest with zeroes\n  {\n    Serial.print(\"  0\");\n    if (kkk<359) Serial.print(\", \");\n    if (kkk%8==7) Serial.println();\n  }\nSerial.println(\"};\");// HSV\n// note that unlike the previous one these two just print out the numbers without storing them\n// change the Serial.print to lights[k]= if you need to store the values in lights[] array\n// for later use in the loop()\nSerial.println(\"const uint8_t HSVlights[61] = {\");\nfor (int k=0; k<61; k++)\n  {\n    Serial.print(round(k*4.25-0.01));\n    if (k<60) Serial.print(\", \");\n  }\nSerial.println(\"};\");\n \n//power-conscious HSV\nSerial.println(\"const uint8_t HSVpower[121] = {\");\nfor (int k=0; k<121; k++)\n  {\n    Serial.print(round(k*2.125-0.01));\n    if (k<120) Serial.print(\", \");\n  }\nSerial.println(\"};\");\n}void loop() {\n}It is a good idea to keep the lookup-table-generating code in the setup() portion of your sketch until you are perfectly satisfied with their results, then copy-paste the const table and remove the code.", "step_imgs": [], "step_title": "Step 3: Lookup Tables"}, {"step": 4, "steps_text": "Ok, rainbow done, let\u2019s do some nice random colors. What can be easier? Justbyte r, g, b;r = random(255);\ng = random(255);\nb = random(255);\nsetRGBpoint(LED, r, g, b);will do, right? I guess you already see that this will result in uncontrollable power fluctuations. What\u2019s more, this thing mostly looks like just slightly tinted shades of white, as it fills all three channels with some garbage (in HSV model that will be an average of 50% Saturation \u2013 but we want 100%!).Look at this:r = random(256);g = random(256-r);\nb = (255-r-g);\nsetRGBpoint(LED, r, g, b);Here there is no problem with power consumption, but you can see that this particular algorithm favors the first channel (red): it gets 50% of random values, and the other half is shared between the two remaining ones. This is not as bad as it looks and you should not dismiss this algorithm. Human eye is not very good in dealing with blue and green colors (in fact, I\u2019ve read somewhere that we learned to distinguish those colors not that long ago; for ancient Egyptians they were the same). But we are pretty OK with reds. We can easily tell apart scarlet, orange, ochre, yellow and lemon \u2013 these colors are between red and green in the RGB model. Same is true for violet, purple, fuchsia, magenta, rose and pink. But can you remember the same amount of cyan tints? Emerald? Err\u2026 sky-blue?.. So, cheating a bit with red in your random algorithm can be perfectly ok if you know what you\u2019re doing.Let\u2019s try a real random that doesn\u2019t favor any single color channel. For this I prefer to use a small array of bytes and a counter that\u2019s incremented each time the function is run:byte color[3];byte count, a0, a1, a2;\ncolor[count]=random(256);\na0=count+random(1)+1;\ncolor[a0%3]=random(256-color[count]);\ncolor[(a0+1)%3]=255-color[a0%3]-color[count];\nsetRGBpoint(LED, color[0], color[1], color[2]);\ncount+=random(15); // to avoid repeating patterns\ncount%=3;It\u2019s ok, but these three randoms are not saturated enough because we fill three channels with some values. If we want nice deep colors we should fill only two of them, leaving the last one at zero. This algorithm will produce such colors (in fact, it totally corresponds to the \u2018power-conscious\u2019 HSV model giving us clear Hues at 100% Saturation):color[count]=random(256);a0=random(1);\na1=((!a0)+count+1)%3;\na0=(count+a0+1)%3;\ncolor[a0]=255-color[count];\ncolor[a1]=0;\nsetRGBpoint(LED, color[0], color[1], color[2]);\ncount+=random(15); // to avoid repeating patterns\ncount%=3;What about the sine-wave lookup table we did earlier? It can also be used, and it produces even deeper and clearer colors, shifted a bit more towards base red, green and blue:a0=random(240);color[count]=lights[a0];\na1=random(1);\na2=((!a1)+count+1)%3;\na1=(count+a1+1)%3;\ncolor[a1]=lights[(a0+100)%240];\ncolor[a2]=0;\nsetRGBpoint(4, color[0], color[1], color[2]);\ncount++;\ncount%=3;These are just a few examples, test them out to find which one suits you best. There are tons of ways to do random colors, and it\u2019s a good idea to mix them for better results.", "step_imgs": [], "step_title": "Step 4: Random Colors"}, {"step": 5, "steps_text": "Now that you\u2019re doing your favorite run of random colors let\u2019s make them change seamlessly. Again the HSV model is of no help: it will make us go through the neighboring spectrum colors. The RGB model provides a shortcut: you have three color channels and you just need to move each of them from their starting points to their targets. We\u2019re avoiding floating point operations, so need to change the types of some variables:uint16_t color[3], nextColor[3];long colorStep[3];\nbyte count, a0, a1, a2;void setNextColor(){\n  nextColor[count]=random(256)<<8;\n  a0=random(1);\n  a1=((!a0)+count+1)%3;\n  a0=(count+a0+1)%3;\n  nextColor[a0]=(255-nextColor[count])<<8;\n  nextColor[a1]=0;\n}void loop() {setNextColor();\nfor (byte k=0; k<3; k++) colorStep[k]=((long)nextColor[k] - color[k])/100;\nfor (byte k=0; k<100;k++)\n  {\n    for (byte i=0; i<3; i++) color[i]+=colorStep[i];\n    setRGBpoint(0, color[0]>>8, color[1]>>8, color[2]>>8);\n    delay(10);\n  }\nfor (byte k=0; k<3; k++) color[k] = nextColor[k];\nsetRGBpoint(0, color[0]>>8, color[1]>>8, color[2]>>8);\ndelay(500);\ncount+=random(15);\ncount%=3;\n}And what about using the lookup table of the sine waves? Here we go, this one is even better as it doesn\u2019t need any stops to show the exact color we\u2019re moving to (it gets enough showtime from the sine wave):void setNextColorSine(){\n  a0=random(240);\n  nextColor[count]=lights[a0]<<8;\n  a1=random(1);\n  a2=((!a1)+count+1)%3;\n  a1=(count+a1+1)%3;\n  nextColor[a1]=lights[(a0+100)%240]<<8;\n  nextColor[a2]=0;\n}void loop() {setNextColorSine();\nfor (byte k=0; k<3; k++) colorStep[k]=((long)nextColor[k] - color[k])/255;\nfor (byte k=0; k<120;k++)\n  {\n    setRGBpoint(0, (color[0]+colorStep[0]*lights[k])>>8,\n                   (color[1]+colorStep[1]*lights[k])>>8,\n                   (color[2]+colorStep[2]*lights[k])>>8);\n    delay(10);\n  }\nfor (byte k=0; k<3; k++) color[k] = nextColor[k];\nsetRGBpoint(0, color[0]>>8, color[1]>>8, color[2]>>8);\ndelay(10); // no need for extra delay, the sine wave will keep the color long enough\ncount++;\ncount%=3;\n}Hopefully by this time you get the idea how to do fade-outs and fade-ins\u2026And that\u2019s it for today! Next time I hope to finally get to my favorite topic of OnePixel information displays (yes, the RGB model is vital there too)...Until then \u2014 comments and questions welcome.", "step_imgs": [], "step_title": "Step 5: Color Shifting"}], "channel": "Arduino"}, {"category": "technology", "description": "The Arduino Serial Plotter function has been added to the Arduino IDE, allowing you to natively graph serial data from your Arduino to your computer in real time. If you\u2019re tired of seeing your Arduino\u2019s analog sensor input data pour onto your screen like The Matrix, this looks like a prettier way to visualize what\u2019s going on. A Serial plotter is an offline tool allowing you too Visualize data and troubleshoot your code offline without having to use third-party services like Processing or Plotly. Since there is no official documentation on the Arduino website regarding the use & functionality of the Serial Plotter, I decided to documents its uses and features.FeaturesPlotting of Multiple Graph  Offline  Auto-Resize Graph  Supports Negative Value graphs  Auto-scroll along X-axis  Different colors for each variableApplicationsOffline Data Visualization  Code Troubleshooting  Waveform AnalysisParts RequiredArduino - AliExpress or Arduino Starter Kit - AliExpress", "title": "Adruino Serial Plotter", "url": "https://www.instructables.com/id/Ultimate-Guide-to-Adruino-Serial-Plotter/", "section": "technology", "steps": [{"step": 1, "steps_text": "Now that you have installed the latest version of the Arduino IDE(1.6.7 or above) its time to understand how the Serial Plotter actually works. The Arduino Serial Plotter takes incoming serial data values over the USB connection and is able to graph the data along the X/Y axis, beyond just seeing numbers being spit out on to the Serial Monitor. The vertical Y-axis auto adjusts itself as the value of the output increases or decreases, and the X-axis is a fixed 500 point axis with each tick of the axis equal to an executed  Serial.println() command. In other words the plot is updated along the X-axis every time the Serial.println() is updated with a new value.       Remember to set the Baud Rate  of the Serial Plotter so that it matches that of the code.  Multiple PlotsWhen displaying multiple waveforms, every separate variable/value/parameter is displayed using a different colour like shown below.Inorder to plot multiple variables or waveforms simultaneously a 'space' is printed between the two print statements.Serial.print(temperature);\nSerial.print(\" \");\nSerial.println(humidity);ORSerial.print(temperature);\nSerial.print(\"\\t\");\nSerial.println(humidity);   In this case the values of the variables 'temperature & humidity will have separate waveforms plotted on the same graph simultaneously. ", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 1: Plotting a Graph"}, {"step": 2, "steps_text": "I used the Arduino Serial Monitor in my Automatic Plant Watering System to visualize & plot Moisture Sensor Data.The main purpose of having the Serial plotter is that you do not need to be connected to the Internet in-order to visualize the data from a sensor or your project. And hence for the purpose of Data Visualization the Serial plotter excels at its job.Whether its a singular wave or a multiple plot graph the Serial Plotter auto-resizes itself and color codes each wave. In-order to test the Data Visualization function you can follow the following steps:Connect a couple of sensors to your ArduinoPrint the values of the sensors & Upload the code. Open the Serial Plotter.I have used the Serial Plotter in my Tweeting Weather Station to visualize the reading of the various sensors on the Weather Station. The above waveforms show the plot of the Temperature(26\u00b0C) & Humidity(65%RH) readings of the SL-HS-220 sensor.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Offline Data Visulization"}, {"step": 3, "steps_text": "One of the best uses of the Serial Plotter is to troubleshoot the code & circuit. Faulty connections or incorrect coding logic can sometimes return an undesired output. In such cases where there too many lines of code or too many wires to debug the Serial Plotter can show the exact point of error. With the help of the Serial Plotter you can check if a sensors reading is incorrect or even if the sensor is not connected properly to the Arduino. The Serial Plotter will also help debugging code by displaying the  values various conditional statements and variables or even the states of the pins of the Arduino.A good example of would be troubleshooting a Obstacle Avoidance Robot. In this example the Blue waveform represents the Ultrasonic sensor and the Yellow and Red waveforms represent the left and right motors. As the distance between the obstacle & the robot decreases, the Blue waveform decreases. At a threshold value(minimum distance) of 10, the robot turns right hence the two motors have different value's;Right=50,Left=100. You can see the Red waveform decreasing and the Yellow waveform remaining constant speed which represents the right turn.Troubleshooting whether a wire was not connected properly or a component was malfunctioning or your coding logic was incorrect would have cost you a lot of time. But with the help of the Serial Plotter the amount of time it takes to troubleshoot the problem can be significantly reduced by analyzing the waveforms.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Troubleshooting "}, {"step": 4, "steps_text": "With a basic programming sense and a couple of lines of code, the Arduino is able to act as a Function Generator. The Arduino is capable of producing Square,Triangular, Sine & Sawtooth waveforms. In previous versions of the Arduino IDE one could only observe the values of the type of waveform being produced in the Serial Monitor without any visualization. It would be time consuming to analyze the output solely on the basis of numerical value's; and this is the place where the Serial Plotter comes handy; in visualizing the waveforms being produced. Function Generator.ino", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Function Generation & Analysis"}, {"step": 5, "steps_text": "The Arduino IDE has for long needed the addition of the Serial Plotter. It has increased the functionality of the Arduino IDE but still lacks some features:Autoscroll ToggleSimultaneous use of Serial Plotter & Serial Monitor. X-axis Scale/Time scale required.As these features are added to the Arduino IDE, I will continue to make changes and add new steps to this Instructable.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: Future Improvement & Additions"}], "channel": "Arduino"}, {"category": "technology", "description": "Cycflix: Exercise Powered Entertainment \u00a9 Ronan Byrne July 2017Now that the cheesy title has pulled you(Fitflix was taken and I didn't want to be sued) I'll tell you about the project, it uses a stationary exercise bike connected to an Arduino Nano to control the streaming of Netflix on a PC, I started this project hoping I could get it working on just a Raspberry Pi but ran into a few problems I couldn't overcome which I'll discuss at the end. But the main gist of the project at the click of a button and some user input, Firefox will open and play Netflix and monitor your speed for the Workout routine you designed, if you are going below the speed for too long, Netflix will be paused until you get back up to speed. If you want to use some other streaming service, it'll only take a few changes.The main reason I did this project was to learn some python and finally use my Raspberry Pi(which didn't get used in the end) so the code won't be perfect as I was learning as I went but thought I might as well publish the project.Components:Arduino(any)     PC     USB Cable    10K resistor     Wires     Copper Strip board     Stationary Exercise Bike(Can't guarantee this will work with your bike)    2 Nuts and Bolts", "title": "Cycflix: Exercise Powered Entertainment", "url": "https://www.instructables.com/id/Cycflix-Exercise-Powered-Entertainment/", "section": "technology", "steps": [{"step": 1, "steps_text": "Before I started this project, I've never tried to hack into an exercise bike but I assumed it would output a variable frequency square wave or an analog voltage proportional to the speed, well it looks like my first guess was correct. But I thought it would be a rotary encoder which would be a high frequency due to the number of slots on the encoder but from my testing which I'll describe below, the frequency of the square wave was very slow, at slower speeds the period of the wave was greater than a second. Either this is a very low resolution encoder, high gear ratio or something else, but it doesn't really matter whats in the black box once we know how to use it .I found out the output was a square wave with varying frequency from hooking up my Bitscope to the speed input of the display(which the manufacturers were nice enough to clearly label) and started pedaling. With the help of a friend, I took multiple screenshots of the waveforms at different speeds. To get the period of the square wave, measure the time between two rising or two falling edges(use TB in bottom left of window not Time/Div). From these waveforms, I found a formula to convert period of waveform to speed on the bike(these pictures are shown above). I did this by plotting the points on a graph and getting the equation from the treadline. You of course draw your own line of best fit, pick two point off the graph and solve:y = m*x+CWhere y = Speed(Km), m is slope(Km/ms), x is Period(ms) and C is the offset (Km)I rounded the slope and offset to this: Speed=Period*-0.0384+60.372I did run into a problem that I couldn't recorded the lower speed(around 10Km) because the frequency was so slow that the Bitscope couldn't display the whole period. From my testing it looks accurate enough between 20Km and 40Km but below and above can be inaccurate making me think either the output is none linear, the display isn't accurate or my formula is accurate. But it gives me close enough answers to the real value for most speeds, if I took more points, the equation would be more accurate but this will do.", "step_imgs": ["https://cdn.instructables.com/FLM/OQU6/J4OFJY4I/FLMOQU6J4OFJY4I.LARGE.jpg", "https://cdn.instructables.com/FFF/GXBJ/J4OFJZC0/FFFGXBJJ4OFJZC0.LARGE.jpg", "https://cdn.instructables.com/FUW/HSS9/J4OFJR8I/FUWHSS9J4OFJR8I.LARGE.jpg", "https://cdn.instructables.com/FNR/IMPM/J4OFJR8J/FNRIMPMJ4OFJR8J.LARGE.jpg", "https://cdn.instructables.com/FHO/4N4G/J4OFJR8K/FHO4N4GJ4OFJR8K.LARGE.jpg", "https://cdn.instructables.com/FBT/17RQ/J4OFJR8L/FBT17RQJ4OFJR8L.LARGE.jpg", "https://cdn.instructables.com/FR7/LDCF/J4OFJR8M/FR7LDCFJ4OFJR8M.LARGE.jpg"], "step_title": "Step 1: Speed Calculation"}, {"step": 2, "steps_text": "CircuitThe circuit is very simple, its just a pull down resistor and two wires connecting to the speed input and ground of the bike circuit. There was four holes already in the back of the casing so I soldered my circuit to some copper strip board, drilled two holes in it and attached it to the casing with two nuts and bolts. If you do use copper strip board, make sure the traces are cut in between the Arduino pins and that the bolt doesn't touch and of the copper.And that's it! See the first few pics for the schematic and my circuitCodeThe code is here on my Github(clone the whole repo and do not change directory structure) but I'll briefly go through bits of the code here.Arduino Code There isn't too much to the Arduino code, it first waits for the PC to send something to establish a connection. After that it starts looping and reading the analog pin to see if its high or low and calculates the speed by measuring the period of the square wave. I couldn't use interrupts as the voltage from the bike is roughly 1V(when connected to the Arduino) so less than the logic level of the Arduino, you could amplify it but it was easier to fix in code than in circuitry(I have op amp circuits on my other Instructables and on my blog if you want to use them, an optocoupler would work too). Because the shortest period of the waveform is going to be between 100's of milliseconds(Unless you are insert-famous-cyclist-here) we didn't need the speed of interrupts. Every half second a timer interrupt is triggered and if PC has requested the current speed, the Arduino will send it. If the speed hasn't been updated after a few seconds, the speed will be reset to zero.Python CodeFor the python code, you will of course have the appropriate packages and geckodriver downloaded. This project uses Python3 and I used pip3 to install the packages but you could also use easy_installExample:pip3 install selenium   (Linux users would need sudo)For the geckodriver, download the one for your system from here and extract it and follow below:For Windows:Place the geckdriver.exe in the Cycflix folder, you can place it somewhere else and add to your PATH if you likeFor Linux:Place the geckodriver in /usr/local/bin and type 'geckodriver in you terminal to test it if worksAfter both of them are setup you can do a test of the script, below is the basic flow of the code(pictures for most steps are above, I show the terminal output for the extra info)Run the python script(running the script in your terminal or IDLE will show some extra information)    A popup window will show you all the Serial ports connected to your PC, pick the one connected to your Arduino    Another window will popup(I went a bit tkinter crazy with the windows :) ) while you PC waits for a message from your Arduino. Press the reset button on the Arduino if you're waiting too long    Firefox will now start and open the sign in page of Netflix(it could take a few seconds for FireFox to start). If you have you login details saved in the \"login.txt\", you will be signed in automatically but if you don't, you will be prompted to enter you sign in details with the option to save them for next time    You will be prompted to enter in the details for for workout such as work time, work speed, sets, time until pause etc    Now the script will wait for you to choose a Programme/Movie to watch and your workout will start    During the workout you will see a window in the top left corner of your screen with your current round details such as your speed, time to next round, nominal speed and round. When a round ends, you will see a popup with the details for the next round(this closes after 5 seconds automatically). If you go below the nominal speed for the current round for half the pause time, you will get a warning saying you are going too slow. If you are still going too slow for the whole pause time, Netflix will be pause until you get back up to speed for a few seconds    Once your workout if finished, the script will close but Netflix will remain playingYou shouldn't go fullscreen when watching Netflix as you won't be able to see you current round details.I did most of my development and testing on Linux Mint, but from doing some quick tests on Windows, it all worked fine", "step_imgs": ["https://cdn.instructables.com/FLN/6U4P/J4OFJRHW/FLN6U4PJ4OFJRHW.LARGE.jpg", "https://cdn.instructables.com/FWV/RX23/J4OFJRIB/FWVRX23J4OFJRIB.LARGE.jpg", "https://cdn.instructables.com/FWL/7FSY/J4OFJRIC/FWL7FSYJ4OFJRIC.LARGE.jpg", "https://cdn.instructables.com/FGS/WJA6/J4OFJRID/FGSWJA6J4OFJRID.LARGE.jpg", "https://cdn.instructables.com/FHX/XUK0/J4OFJXNW/FHXXUK0J4OFJXNW.LARGE.jpg", "https://cdn.instructables.com/FEN/L63D/J4OFJXNX/FENL63DJ4OFJXNX.LARGE.jpg", "https://cdn.instructables.com/FU5/04P7/J4OFJXNY/FU504P7J4OFJXNY.LARGE.jpg", "https://cdn.instructables.com/FCH/7X4F/J4OFJXNZ/FCH7X4FJ4OFJXNZ.LARGE.jpg", "https://cdn.instructables.com/FW3/B59J/J4OFJXO0/FW3B59JJ4OFJXO0.LARGE.jpg", "https://cdn.instructables.com/F57/IQ2A/J4OFJXO1/F57IQ2AJ4OFJXO1.LARGE.jpg", "https://cdn.instructables.com/FFI/2BFV/J4OFJXO2/FFI2BFVJ4OFJXO2.LARGE.jpg"], "step_title": "Step 2: Circuit and Code"}, {"step": 3, "steps_text": "Why I Couldn't Use a Raspberry PiAs I said at the start I couldn't get this to work on a Raspberry Pi, the reasons for this was the browsers and selenium, I couldn't get a browser that could be controlled by selenium that could also stream Netflix. The problem with Firefox was you need the Widevine extension to enable 'Play DRM' which is required to stream Netflix, this extension isn't supported on the Pi. I also tried Chromium and after a while of searching I did find a version of Chromium which could stream Netflix on the Pi but Google stopped supporting Arm for the Chromedriver so I couldn't control it with selenium, I did find an old version of Chromedriver but couldn't get it working. Last WordsThere is of course a lot of extras I could put in this such as stopping the user unpausing Netflix, adding sound when switching rounds, saving workout details and a few others but if I kept adding these features, the project would never be \"done\" and right now it has enough functionality for me and after all, it was to help me learn some python and maybe(a big maybe) get me using the exercise bike.If you would like to add some features or improve the code, open a pull request on the repo and I'll have a look when I get the chance.If you have any problems, drop them below and if you liked this project, look at my other Instructables and visit my blog", "step_imgs": ["https://cdn.instructables.com/FOK/36VY/J4SQ31RB/FOK36VYJ4SQ31RB.LARGE.jpg"], "step_title": "Step 3: Conclusion"}], "channel": "Arduino"}, {"category": "technology", "description": "In the lab, one often needs a repetitive signal of a certain frequency, shape and amplitude. It may be to test an amplifier, check out a circuit, a component or an actuator. Powerful waveform generators are available commercially, but it is relatively easily to make a useful one yourself with an Arduino Uno or Arduino Nano, see for example:https://www.instructables.com/id/Arduino-Waveform-...https://www.instructables.com/id/10-Resister-Ardui...Here is the description of another one with the following features:* Accurate waveforms: 8-bit output using R2R DAC, 256-sample shape* Fast: 381 kHz sampling rate* Precise: 1mHz steps frequency range. As accurate as the Arduino crystal.* Easy operation: waveform and frequency settable with single rotary encoder * Wide range of amplitudes: millivolts to 20V * 20 pre-defined waveforms. Straightforward to add more. * Easy to make: Arduino Uno or Nano plus standard components", "title": "Arduino Waveform Generator", "url": "https://www.instructables.com/id/Arduino-Waveform-Generator-1/", "section": "technology", "steps": [{"step": 1, "steps_text": "Making an analog signalOne shortcoming of the Arduino Uno and Nano is that it does not have a digital-to-analog (DAC) converter, so it is not possible to make it output an analog voltage directly on the pins. One solution is the R2R ladder: 8 digital pins are connected to a resistor network so that 256 levels of output can be reached. Through direct port access, the Arduino can set 8 pins simultaneously with a single command. For the resistor network, 9 resistors with value R are needed and 8 with value 2R. I used 10kOhm as a value for R, that keeps the current from the pins to 0.5mA or less.  I guess R=1kOhm could work as well, since the Arduino can easily deliver 5mA per pin, 40mA per port. It is important that the ratio between the R and the 2R resistors is really 2. That is most easily achieved by putting 2 resistors of value R in series, for a total of 25 resistors.  Phase accumulatorGenerating a waveform then comes down to repetitively sending a sequence of 8-bit numbers to  the Arduino pins. The waveform is stored in an array of 256 bytes and this array is sampled and sent to the pins. The frequency of the output signal is determined by how fast one advances through the array. A robust, precise and elegant way to do that is with a phase accumulator: a 32-bit number gets incremented at regular intervals, and we use the 8 most significant bits as the index of the array.Fast sampling Interrupts allow to sample at well-defined times, but the overhead of interrupts  limit the sampling frequency to ~100kHz.  An infinite loop to update the phase, sample the waveform and set the pins takes 42 clock cycles, thus achieving a sampling rate of 16MHz/42=381kHz.  Rotating or pushing the rotary encoder causes a pin change and an interrupt that gets out of the loop to change the setting (waveform or frequency). At this stage the 256 numbers in the array are recalculated so that no actual calculations of the waveform need to be performed in the main loop. The absolute maximum frequency that can be generated is half of this, 190kHz, but then there are only two samples per period, so not much control of the shape.  The interface thus doesn't allow to set the frequency above 100kHz. At 50kHz, there are 7-8 samples per period and at 1.5 kHz and below all 256 numbers stored in the  array get sampled each period. For waveforms where the signal changes smoothly, for example the sine wave, skipping samples is no  problem. But for waveforms with narrow spikes, for example a square wave with a small duty cycle, there is the danger that for frequencies above 1.5 kHz missing a single sample can result in a the waveform not behaving as expected Accuracy of the frequency The number by which the phase is incremented at each sample is proportional to the frequency. The frequency can thus be set to an accuracy of 381kHz/2^32=0.089mHz. In practice such accuracy is hardly ever needed, so the interface limits to set the  frequency in steps of 1mHz. The absolute precision of the frequency is determined by the precision of the Arduino clock  frequency. This depends on the Arduino type but most specify a frequency of 16.000MHz, so a precision of  ~10^-4. The code allows to modify the ratio of the frequency and the phase increment to correct for small deviations of the 16MHz assumption. Buffering and amplificationThe resistor network has a high output impedance, so its output voltage quickly drops if a load is attached. That can be solved by buffering or amplifying the output.  Here, the buffering and amplification is done with an opamp. I used the LM358 because I had some. It is a slow opamp (slew rate 0.5V per microsecond) so at high frequency and high amplitude the signal gets distorted. A good thing is that it can handle voltages very close to 0V. The output voltage is however limited to ~2V below the rail, so using +5V power limits the output voltage to 3V.  Step-up modules are compact and cheap and feeding +20V to the opamp, it can generate signals with voltage up to 18V. (NB, the schematic says LTC3105 because that was the only step-up I found in Fritzing. In reality I used an MT3608 module, see pictures in the next steps). I choose to apply a variable attenuation the output of the R2R DAC then use one of the opamps  to buffer the signal without amplification and the other to amplify by 5.7, so that the signal can reach a maximum output of about 20V.  The output current is rather limited, ~10mA, so a stronger amplifier may be needed if the signal is to drive a large speaker or electromagnet.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 1: Technical Considerations"}, {"step": 2, "steps_text": "For the core waveform generatorArduino Uno or Nano 16x2 LCD display + 20kOhm trimmer and 100Ohm series resistor for backlight 5-pin rotary encoder (with integrated pushbutton) 25 resistors of 10kOhmFor the buffer/amplifier LM358 or other dual opamp step-up module based on the MT3608 50kOhm variable resistor 10kOhm resistor47kOhm resistor 1muF capacitor", "step_imgs": [], "step_title": "Step 2: Required Components"}, {"step": 3, "steps_text": "I soldered everything on a 7x9cm prototype board, as shown in the picture. Since it got a bit messy with all the wires I tried to colour the leads that carry positive voltage red and those that carry ground black.The encoder I used has 5 pins, 3 on one side, 2 on the other side. The side with 3 pins is the actual encoder, the side with 2 pins is the integrated pushbutton.On the 3-pin side, the central should be connected to ground, the other two to D10 and D11.on the 2-pin side, one pin should be connected to ground and the other to D12.It's the ugliest thing I've ever made but it works. It'd be nice to put in  an enclosure, but for now the extra work and cost doesn't really justify it. The Nano and the display are attached with pin-headers. I wouldn't do that again if I'd build a new one.  I did not put connectors on the board to pick up the signals.  Instead, I pick them up with crocodile leads from protruding pieces of copper wire, labelled as follows:R - raw signal from the R2R DACB - buffered signalA - amplified signalT - timer signal from pin 9G - ground+ - positive 'high' voltage from the step-up module", "step_imgs": ["https://cdn.instructables.com/FOF/K0BD/JN3HUGRM/FOFK0BDJN3HUGRM.LARGE.jpg", "https://cdn.instructables.com/FQR/IVHG/JN3HUGRK/FQRIVHGJN3HUGRK.LARGE.jpg"], "step_title": "Step 3: Construction"}, {"step": 4, "steps_text": "The code, an Arduino sketch, is attached and should be uploaded to the Arduino.20 waveforms have been pre-defined. It should be straightforward to add any other  wave. Note that the random waves fill up the 256-value array with random values,  but the same pattern gets repeated every period. True random signals sound like noise, but this waveform sounds much more like a whistle.The code sets a 1kHz signal on pin D9 with TIMER1. This is useful to check the  timing of the analog signal. That is how I figured out that the number of clock cycles is 42: If I assume either 41 or 43, and generate a 1kHz signal, it clearly has a different  frequency from the signal on pin D9. With the value 42 they match perfectly.Normally, the Arduino interrupts every millisecond to keep track of time with the  millis() function. This would disturb the accurate signal generation, so  the particular interrupt is disabled.The compiler says: \"Sketch uses 7254 bytes (23%) of program storage space. Maximum is 30720 bytes. Global variables use 483 bytes (23%) of dynamic memory, leaving 1565 bytes for local variables.  Maximum is 2048 bytes.\" So there is ample space for more sophisticated code.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 4: The Code"}, {"step": 5, "steps_text": "The apparatus can be powered simply through the mini-USB cable of the Arduino Nano. It is best done with a power bank, so that there is no  accidental ground loop with the apparatus that it may be connected with.When switched on it will generate a 100Hz sine wave. By rotating the knob, one of the other 20 wave types can be chosen. By rotating while pushed, the cursor can be set to any of the digits of the frequency, which can then be changed to the desired value.The amplitude can be regulated with the potentiometer and either the buffered or the amplified signal can be used.It is really helpful to use an oscilloscope to check the signal amplitude,  in particular when the signal supplies current to another device.  If too much current is drawn, the signal will clip and the signal is  heavily distortedFor very low frequencies, the output can be visualised with an LED in series with a 10kOhm resistor. Audio frequencies can be heard with a speaker.  Make sure to set the signal very small ~0.5V, otherwise the current gets too high and the signal starts clipping.", "step_imgs": [], "step_title": "Step 5: Usage"}], "channel": "Arduino"}, {"category": "technology", "description": "Introduction _______________________________________________________________________  Though there are many Instructables on some aspect of how to make circuit boards, this one is different. It's an instructable on how to make the things you need to make circuit boards, specifically, a flamboyant business card toy. Over the past six months I have set up fairly complete printed circuit board fabrication lab in my apartment, cheaply and safely, and I intend to cover all aspects of the process, from start to finish. Some of it you may have seen before, but here it is all in one place, with references.  All in all, I had to design and build an airtight etch tank out of laser cut acrylic, an SMD vacuum pickup tool, a reflow oven and temperature controller, refine the toner transfer process with a modified laminator, build a custom programming jig, and of course design, program and build from scratch every aspect of the thing I did all this for in the first place: my business card. In the end it was well worth the time to have the ability to make circuit boards appear in my hands in an evening.The Business Card _______________________________________________________________________  The POV Business Card uses the classic persistence of vision  optical illusion to flash your name and number in midair as you wave the card. Based on the PIC12F508, an 8-pin 6 I/O ultra-low cost microcontroller, it is entirely surface mount and extremely thin- it uses PCB laminate that is as thin as a standard business card. And at roughly $2 apiece in parts, depending on how good you are at sourcing components, they are cheap enough to hand out (to the right people).  But why go to all this trouble simply to make something to give away to someone I just met? Why not just have them printed up in an afternoon for less than 10 bucks at Kinko's? Why, because I want  a card that would not get thrown out. A card that would embody exactly what I do, instead of clumsily trying to sum it up in an clever job title. A card that would get me places.The Scenario  ______________________________________________________________________  Picture the following scenario, if you will: you have just met someone who you need to know. In actual fact, they need to know you. Having exchanged introductions, \"The Man,\" complete with dark suit and power tie, casually hands you his cloned, company-issue business card.  \"Here's my card,\" he grins, knowing that you will impressed by his Ownership Of Card, or at least his Power Over Someone Who Owns An Embossing Machine .  Probably he expects to see you to scribble your number on a torn scrap of paper. But when you reach into your pocket and pull out your card,  certainly he doesn't expect to see...your name glowing in midair, floating before his very eyes!  \"It's called persistence of vision,\" you say, as you hand him your card. \"I make these in my basement. From scratch.\"   You didn't even need to say another word; anything more would just be gloating. You can see the look in his eyes; he's already sold.\"Look at that subtle off-white coloring. The tasteful thickness of it. Oh my God, it even has a watermark.\" - Patrick Bateman, American PsychoDisclaimer: I should note here that this Instructable involves a lot of things that could be dangerous if done without caution and informed planning, including fire hazards, risk of electrocution in various horrible ways, handling of nasty chemicals, and very toxic fumes. This one really has it all, folks. So be safe! ", "title": "Complete Circuit Board Lab & POV Business Card", "url": "https://www.instructables.com/id/Circuit-Board-Lab-POV-Business-Card/", "section": "technology", "steps": [{"step": 1, "steps_text": "We'll start with the hard one: Build a leakproof, acid proof, and airtight etch tank, using no metal parts. Others have done this before, but I had to make it difficult for myself. I had built one before out of a plastic ammo can, but it was much too large. This time, I wanted to do it right. I designed it from scratch in illustrator and then had the parts laser cut out of acrylic to my specifications by a friend (laser cutter use number one!). For those new to this, you need an etch tank to hold the acid you use to eat away the copper on your circuit board that is not covered in some kind of etch resist. It can be pretty nasty stuff, depending on the kind of acid you use, and you need to safely contain it if you plan on doing this both regularly and in the house that you live and breathe in. Or anywhere near your kitchen sink. This is doubly important if you plan on storing it for any amount of time, though to be sure this not a safe permanent storage container.The Design _______________________________________________________________________  The tank should be airtight, with a secure lid, have an air inlet for a bubbler, to agitate and oxygenate the solution, and an air outlet to a house that will vent out the window. I also added a check valve to the air intake on the tank so that any exhaust gases stay out of the air pump. It should hold the board upright for the minimum amount of acid, and it should be opaque to light so that the solution does not degrade from exposure to the sun. However, I left one side clear so I can look at the board to see if it is done etching, and also because it looks cooler that way.   I designed my tank for a total volume of roughly 2 Liters, planning on filling it to only 1.6L to leave room for the air bubbler and hose, the board itself, and a little extra for a safe lip on the top. The 1.6L value was determined with the figure of .016 liters per cm2 of board area as reported here. Assuming a a, 8x10in double sided PCB with 50% coverage of 36 \u03bcm (\"1oz\") copper.   For reasons I'll elaborate on later, I chose to use Cupric Chloride (CuCl2) as my circuit board etchant. CuCl2 is corrosive to most metals, and a few plastics.   When researching the materials you plan on using, datasheets abound under the search terms \"xyz chemical resistance.\" Understanding the properties of materials is critical in engineering something like this, so plan ahead. Finding out that a hose melted in your acid bath and contaminated the solution, and then having to fish out each and every little tiny chunk is no fun.  Very few things will survive highly concentrated acids forever. We aren't using anything highly concentrated,as far as these things go, but the effect is the same; it's acid-resistant, not acid proof.The following materials are generally safe to use for the construction of the tank:   Polyethylene (PE) and High Density Polyethylene (HDPE)      Polypropylene (PP)      Viton      EPDM      Teflon      Glass      Acrylic      Polycarbonate (especially mar-resistant polycarbonate) The following are definitely NOT safe, and should be avoided anywhere directly exposed to the solution:   Any metal (except titanium!)      Nylon      Silicone ", "step_imgs": ["https://cdn.instructables.com/FKC/WWDC/GLGCJKSQ/FKCWWDCGLGCJKSQ.LARGE.jpg", "https://cdn.instructables.com/FMN/7ZFE/GLGCJYFG/FMN7ZFEGLGCJYFG.LARGE.jpg", "https://cdn.instructables.com/FMM/9PSL/GLGCJKT7/FMM9PSLGLGCJKT7.LARGE.jpg", "https://cdn.instructables.com/F03/U328/GLGCJKYX/F03U328GLGCJKYX.LARGE.jpg", "https://cdn.instructables.com/F37/ZDN7/GLFUDNE5/F37ZDN7GLFUDNE5.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 1: Design an Etch Tank"}, {"step": 2, "steps_text": "The hardest part of building this thing is just finding the finding the parts. It seems like my entire life is just an endless quest for the parts I need. The most difficult part to find was a pair of bulkhead fittings that were small enough for the tank. Small fittings are not common locally, as everything is plumbing sized, and online, the lab grade small fittings are only orderable in bulk. Some of these parts are scrounged, most of them I had to order special, and most of them took several rounds of searching and receiving of parts that didn't fit together. US Plastics Corporation is the source of pretty much all of it; they are like the Digi Key of tubes and lab fittings, as far as I'm concerned. Sources listed where available.Construction _______________________________________________________________________  As far as the tank is concerned, the first step is getting it together. The standard for watertight acrylic bonding is Methylene Chloride, which is very nasty stuff, and cancerous, so do it outside. Just leaving a window open is definitely not sufficient. Accordingly, it is pretty hard to find given the recent regulation, so you may have to order a methylene chloride based glue online, such as IPS Weld-On 4, which is water thin as well. I got a tiny little bottle from a friend who does acrylic fabrication professionally.  To be sure, you could probably get by with just the right kind of epoxy, but ideally the parts should be chemically bonded to each other, instead of a mysterious foreign agent. If you want to play it safe, just use Weld-on 16 and be done with it. It is a more viscous solvent that can be treated as a glue, and will seal up any gaps. I had to use Methylene chloride for lack of the alternative.  When bonding parts with Methylene Chloride, you are after as tight a fit as possible. Laser cut edges need special attention, as they are melted and rounded off. I spent about an hour with a file and sandpaper cleaning up the parts for a good fit.. Even for parts that fit together perfectly from the start, especially the uncut face of the acrylic, it is important to roughen the abutting faces with sandpaper or there is no grab.  Once the parts fit together well, hold the parts  together and run the needle of a syringe or modified squeeze bottle full of the solvent along the crack; capillary action will draw it in. Within about 60 seconds the part will be secure enough to leave alone. It only takes about 30 minutes, for it to set up, sometimes a lot less. I left it overnight just to be sure, but it's actually waterproof after about an hour.  After that, you need to make a lid. I cut a self adhesive gasket for both the lid and the lip of the tank to fill the gap, and to seal it up I mounted a pair of wings to either side of the tank with magnets to pull it down and hold it in place. What happens is the lid tends to line itself up, and because the two sides are reversed in polarity, it is impossible to put the lid on backwards. I still feel clever about that one. The only caveat being that the magnets need to be sealed in heatshrink tubing to resist corrosion.  The bulkhead fittings I wanted only came in straight, not 90 degree, so I needed to cut down the one side and weld on an angled fitting. It works surprisingly well with polypropylene, which has melting point low enough that you can fuse parts with just a hot air gun.ReferencesHow to Glue AcrylicParts   1/4 inch acrylic or polycarbonate sheet   EPDM or Viton self adhesive gasket1/4\" ID Tygon chemical resistant tubing, or high purity PVC      1 air pump   1/4\" hose barb Polypropylene wye fitting1/4\" hose barb Polypropylene barbed bulkhead fitting x 2 (GVC Product Code: 119-116746 )   1/4\" hose barb elbow   1/4\" NPT nut (I cut down a steel hex bushing)   1/4\" hose barb Polypropylene check valve1/4\" hose barb  3/8\" NPT HDPE (3/8\" fits the bubble wand perfectly)   3/8\" NPT plug (for the end of the bubble wand)      1/4\" to 1/8\" hose barb reducer      Rubber end plugs for bubble wand      bubble wand      4 x neodymium bar magnets      plastic handle, with screws      Plastic epoxy, to fill any gaps   Plastic Slide bar clip, from report cover (office max # 21936700) Tools & Supplies   Methylene Chloride or IPS Weld-on 16   heatshrink tubing      Dremel or other rotary tool w/ cut off wheel      Hot air gun      Rubber gloves      Hot glue gun      Cyanoacrylate Superglue      Clamps      Hacksaw      Powerdrill      Hobby knife      Straightedge ", "step_imgs": ["https://cdn.instructables.com/FZT/L8TA/GLGCJKT8/FZTL8TAGLGCJKT8.LARGE.jpg", "https://cdn.instructables.com/F00/BD6Z/GLGCJYFW/F00BD6ZGLGCJYFW.LARGE.jpg", "https://cdn.instructables.com/F8G/B3D5/GLGCJKTR/F8GB3D5GLGCJKTR.LARGE.jpg", "https://cdn.instructables.com/FSK/CHDK/GLFUDNDL/FSKCHDKGLFUDNDL.LARGE.jpg", "https://cdn.instructables.com/FVV/FOW0/GLGCJYFI/FVVFOW0GLGCJYFI.LARGE.jpg", "https://cdn.instructables.com/FQV/PXHG/GLGCJKU8/FQVPXHGGLGCJKU8.LARGE.jpg", "https://cdn.instructables.com/FR1/2N5T/GLGCJKWE/FR12N5TGLGCJKWE.LARGE.jpg", "https://cdn.instructables.com/F7F/JAUP/GLGCJKYU/F7FJAUPGLGCJKYU.LARGE.jpg", "https://cdn.instructables.com/FQP/42N3/GLGCJKYV/FQP42N3GLGCJKYV.LARGE.jpg", "https://cdn.instructables.com/F48/VNZ7/GLGCJYFR/F48VNZ7GLGCJYFR.LARGE.jpg", "https://cdn.instructables.com/FYG/LIRP/GLFUDNE0/FYGLIRPGLFUDNE0.LARGE.jpg", "https://cdn.instructables.com/F8U/FFI9/GLGCJKYA/F8UFFI9GLGCJKYA.LARGE.jpg", "https://cdn.instructables.com/F74/0F44/GLGCJYFZ/F740F44GLGCJYFZ.LARGE.jpg", "https://cdn.instructables.com/F9Z/ADCI/GLGCJYG0/F9ZADCIGLGCJYG0.LARGE.jpg", "https://cdn.instructables.com/FLF/POX4/GLFUDNE7/FLFPOX4GLFUDNE7.LARGE.jpg", "https://cdn.instructables.com/F10/369U/GLGCJYFU/F10369UGLGCJYFU.LARGE.jpg", "https://cdn.instructables.com/F76/N6B6/GLGCJKUL/F76N6B6GLGCJKUL.LARGE.jpg", "https://cdn.instructables.com/F6S/FN9D/GLGCJKYT/F6SFN9DGLGCJKYT.LARGE.jpg", "https://cdn.instructables.com/F5B/U8O3/GLGCJYFV/F5BU8O3GLGCJYFV.LARGE.jpg", "https://cdn.instructables.com/FDP/OXXQ/GLGCJKWF/FDPOXXQGLGCJKWF.LARGE.jpg", "https://cdn.instructables.com/F1H/JS5C/GLGCJKWO/F1HJS5CGLGCJKWO.LARGE.jpg", "https://cdn.instructables.com/F6G/FZP0/GLFUDNDY/F6GFZP0GLFUDNDY.LARGE.jpg", "https://cdn.instructables.com/FYU/OVXW/GLFUDNE1/FYUOVXWGLFUDNE1.LARGE.jpg", "https://cdn.instructables.com/FVA/MQPC/GLGCJKYR/FVAMQPCGLGCJKYR.LARGE.jpg", "https://cdn.instructables.com/FHC/EBEY/GLFUDNDP/FHCEBEYGLFUDNDP.LARGE.jpg", "https://cdn.instructables.com/FXG/43I2/GLGCJYFL/FXG43I2GLGCJYFL.LARGE.jpg", "https://cdn.instructables.com/FLI/UGS9/GLGCJKVN/FLIUGS9GLGCJKVN.LARGE.jpg", "https://cdn.instructables.com/F0T/BV96/GLGCJYFH/F0TBV96GLGCJYFH.LARGE.jpg", "https://cdn.instructables.com/F8G/M4RO/GLGCJYFJ/F8GM4ROGLGCJYFJ.LARGE.jpg", "https://cdn.instructables.com/F2K/4BKW/GLFUDNDN/F2K4BKWGLFUDNDN.LARGE.jpg", "https://cdn.instructables.com/FWS/KD70/GLGCJYFK/FWSKD70GLGCJYFK.LARGE.jpg", "https://cdn.instructables.com/FVI/1YP7/GLFUDNDM/FVI1YP7GLFUDNDM.LARGE.jpg", "https://cdn.instructables.com/FBT/268V/GLGCJYFF/FBT268VGLGCJYFF.LARGE.jpg", "https://cdn.instructables.com/FCH/AS0G/GLFUDNDI/FCHAS0GGLFUDNDI.LARGE.jpg", "https://cdn.instructables.com/FDH/4EK8/GLGCJYFM/FDH4EK8GLGCJYFM.LARGE.jpg", "https://cdn.instructables.com/F08/EOR0/GLFUDNDQ/F08EOR0GLFUDNDQ.LARGE.jpg", "https://cdn.instructables.com/FC3/0GHB/GLFUDNDR/FC30GHBGLFUDNDR.LARGE.jpg", "https://cdn.instructables.com/FMJ/HOGE/GLGCJYFN/FMJHOGEGLGCJYFN.LARGE.jpg", "https://cdn.instructables.com/FM1/SMV1/GLFUDNDS/FM1SMV1GLFUDNDS.LARGE.jpg", "https://cdn.instructables.com/FTK/MCFE/GLGCJYFO/FTKMCFEGLGCJYFO.LARGE.jpg", "https://cdn.instructables.com/FIX/EJM7/GLGCJYFS/FIXEJM7GLGCJYFS.LARGE.jpg", "https://cdn.instructables.com/FPV/WL6B/GLFUDNE2/FPVWL6BGLFUDNE2.LARGE.jpg", "https://cdn.instructables.com/FC5/4O0T/GLGCJYFT/FC54O0TGLGCJYFT.LARGE.jpg", "https://cdn.instructables.com/F9S/IQVZ/GLGCJKYS/F9SIQVZGLGCJKYS.LARGE.jpg", "https://cdn.instructables.com/FDI/U07V/GLGCJKYW/FDIU07VGLGCJKYW.LARGE.jpg", "https://cdn.instructables.com/FCY/DS2R/GLGCJYFX/FCYDS2RGLGCJYFX.LARGE.jpg", "https://cdn.instructables.com/F19/ZP5Z/GLFUDNDZ/F19ZP5ZGLFUDNDZ.LARGE.jpg", "https://cdn.instructables.com/FQ7/S1M0/GLGCJYFQ/FQ7S1M0GLGCJYFQ.LARGE.jpg", "https://cdn.instructables.com/FZI/9Z4S/GLFUDNE3/FZI9Z4SGLFUDNE3.LARGE.jpg", "https://cdn.instructables.com/F62/GW68/GLGCJYFY/F62GW68GLGCJYFY.LARGE.jpg", "https://cdn.instructables.com/F5Y/XQ6D/GLQCL9XT/F5YXQ6DGLQCL9XT.LARGE.jpg", "https://cdn.instructables.com/FZU/VO9R/GLQCL9XU/FZUVO9RGLQCL9XU.LARGE.jpg"], "step_title": "Step 2: Build the Etch Tank"}, {"step": 3, "steps_text": "Be aware that the device you have modified is a now a potential fire and electrical hazard!  As such, you probably shouldn't leave it unattended. And make sure it's unplugged before you do any of this.The Toner Transfer Process _______________________________________________________________________    To create positive etch resist mask, the most straight-forward approach, with components readily and cheaply available, is known as the Toner Transfer method. The basic idea is that you print out your design onto a glossy paper and apply the printout to your board with heat and pressure. The paper is removed, leaving only the toner as an etch resist, thereby protecting the copper below from the acid bath.  There are a lot of variables involved, so it is easy to see why a lot of people give up on it. Given enough time, though, it is very possible to get the process dead on. If you have tried and given up on this method before, I'd recommend that you don't give up! The payoff in time and money saved is well worth it.  The process can also be used to add a black component label or text mask to the board, as a final touch after the copper traces are cleaned off. For the POV Card, I used this method to add my name to the back of the card in case the LEDs were too hard to read.Modifying the Laminator _______________________________________________________________________  The most important part of the process is a balance between heat and pressure that is consistent over the entire board. Proper pressure is easily achieved with a standard bag laminator. You just need to be sure to find one with heated rollers or you won't get the same results. GBC makes two commonly available models, the GBC Creative and the GBC Personal; they are functionally identical, except that the Personal has an extra switch.    Now all we need is to get the temperature right. Since both of the laminators I mentioned are controlled by a simple thermal switch, all we have to do is swap it out with a higher temperature rating. It's pretty simple; the switch contacts open when the rollers are too hot, turning off the heaters, and close when it's too cold, turning it back on.  It's a very simple kind of hysteresis, where the heater is never exactly the right temperature as it is almost always slightly above or below the proper temperature, maintaining a +/- of about 7 degrees. It is very unlike the Watlow PID temperature controller I use later on in the reflow oven, which learns about the system and compensates dynamically.  Instead of a fixed value switch, you want try and find a variable thermal switch. Just like a fixed value thermal switch, it uses a bimetallic strip that warps with the changes in temperature. The two metals have two different coefficients of thermal expansion, and the whole piece bends forward at the proper temperature to close the contact.  Unlike a fixed value switch, however, it has a screw that can be adjusted, changing the tension on the bimetallic strip, and thus changing the distance it has to travel to close the contact and turn on the heater. It's all very clever and simple and perfect for our laminator; we can calibrate it to our hearts desire, even to the point of matching it to the melting point of the toner from the specific model of printer we use. Huzzah!  If you can't find an adjustable switch, don't worry; a 160-190\u00ba C fixed value switch will work just fine.  For safety's sake, we will have to swap out the low temperature thermal fuse (as opposed to bypassing it entirely. Definitely not recommended!) with one of a higher rating, so the whole unit will lose power if it overheats and hopefully doesn't catch fire. BTW, you do this mod at your own risk, so don't leave it on unsupervised! It's kinda dangerous. At its new temperature it may fume a little bit initially as gets worn in, but anything more means it's melting and you need to turn the temperature down. :)  My laminator is set to around 180\u00ba C (356\u00ba F). It varies +/- about 10 degrees, tested with a handy thermocouple directly on the rollers, taking care, of course, not to let the probe get pulled into the laminator. The fuse is for 240\u00ba C, for a good safe margin.PartsGBC Creative/Personal Laminator   Variable temperature thermal switch, ranged between roughly 100-200\u00ba C      Crimp-on butt connectors      Crimp-on screw terminal connectors, with appropriate sized miniature screw/nut   240\u00ba C thermal fuseTools & Supplies   Wire strippers      Crimping tool      #2 Phillips Screwdriver      Temperature probe ", "step_imgs": ["https://cdn.instructables.com/FD5/YBYM/GLFUDNGX/FD5YBYMGLFUDNGX.LARGE.jpg", "https://cdn.instructables.com/FIY/PXMZ/GLFUDNHG/FIYPXMZGLFUDNHG.LARGE.jpg", "https://cdn.instructables.com/F1R/BEA8/GLGCJYNT/F1RBEA8GLGCJYNT.LARGE.jpg", "https://cdn.instructables.com/FOD/26PH/GLGCJLGX/FOD26PHGLGCJLGX.LARGE.jpg", "https://cdn.instructables.com/FOT/N580/GLFUDNHI/FOTN580GLFUDNHI.LARGE.jpg", "https://cdn.instructables.com/F7F/SC2S/GLFUDNGY/F7FSC2SGLFUDNGY.LARGE.jpg", "https://cdn.instructables.com/FW3/CE2C/GLGCJYNW/FW3CE2CGLGCJYNW.LARGE.jpg", "https://cdn.instructables.com/FZT/FFXW/GLFUDNGZ/FZTFFXWGLFUDNGZ.LARGE.jpg", "https://cdn.instructables.com/FYP/L920/GLGCJYO0/FYPL920GLGCJYO0.LARGE.jpg", "https://cdn.instructables.com/F4H/9UDP/GLFUDNH0/F4H9UDPGLFUDNH0.LARGE.jpg", "https://cdn.instructables.com/FR0/LXBH/GLFUDNH2/FR0LXBHGLFUDNH2.LARGE.jpg", "https://cdn.instructables.com/FCR/YHKO/GLGCJLHD/FCRYHKOGLGCJLHD.LARGE.jpg", "https://cdn.instructables.com/FIN/E878/GLFUDNH8/FINE878GLFUDNH8.LARGE.jpg", "https://cdn.instructables.com/FS1/9A3K/GLFUDNHE/FS19A3KGLFUDNHE.LARGE.jpg", "https://cdn.instructables.com/FV3/E9YY/GLGCJLI6/FV3E9YYGLGCJLI6.LARGE.jpg", "https://cdn.instructables.com/FD6/LFEN/GLFUDNHF/FD6LFENGLFUDNHF.LARGE.jpg", "https://cdn.instructables.com/FX2/N0XO/GLGCJYPE/FX2N0XOGLGCJYPE.LARGE.jpg", "https://cdn.instructables.com/FUX/P366/GLGCJYOO/FUXP366GLGCJYOO.LARGE.jpg", "https://cdn.instructables.com/F06/TF8P/GLFUDNH9/F06TF8PGLFUDNH9.LARGE.jpg", "https://cdn.instructables.com/F4O/EHL0/GLGCJLI7/F4OEHL0GLGCJLI7.LARGE.jpg", "https://cdn.instructables.com/FDL/8TNE/GLFUDNHH/FDL8TNEGLFUDNHH.LARGE.jpg", "https://cdn.instructables.com/FYF/8EM1/GLGCJLIA/FYF8EM1GLGCJLIA.LARGE.jpg", "https://cdn.instructables.com/F39/12PV/GLQCL9X4/F3912PVGLQCL9X4.LARGE.jpg", "https://cdn.instructables.com/FLH/OBMF/GLFUDNHL/FLHOBMFGLFUDNHL.LARGE.jpg"], "step_title": "Step 3: Modify a Laminator"}, {"step": 4, "steps_text": "You may have noticed a trend here toward automation, and I don't deny it. This whole project was an attempt at small scale mass production. So here we go: instead of hand soldering every board, hey, guess what- I can just stencil on solder paste, glob it on real good sorta, and stuff the whole thing in a toaster for a minute or two?  Yup, that's the general idea.Surface Mount Technology _______________________________________________________________________    The part that makes this possible is choosing Surface Mount components over conventional through-hole components. They are significantly smaller and less expensive, there are no holes to drill, and board size is reduced. Any disadvantages they have are just side effects of their advantages; they can easily be too small to manipulate without the proper tools.  Typical SMT fabrication works like this: solder paste is spread through a stencil unto the solder pads of the board. Then the components are stuck into the paste, and the entire thing is ramped at a set rate to several set temperature points, depending on the solder and heat resistance of the components. In our case, every component except two can be baked; the battery and the switch will need to be hand soldered later.  Regardless, the higher entry cost is outweighed by the long term advantages, so it's time to build a temperature controlled reflow oven so we don't need to get carpal tunnel soldering hundreds of little grains of sand.The Controller _______________________________________________________________________     The cheapest commercially available reflow oven is certainly several thousand dollars. On the other end of the spectrum, the cheapest stand alone controllers are in the $100 range. Since the expensive ones are too expensive, and the cheap ones are too crippled, I had to build my own.  All the controller has to do is monitor the temperature of the oven and change it when it need to be changed. The ideal way to do this is with a Ramp/Soak temperature controller, used in factory automation for just such a purpose. I was lucky enough to get a Watlow SD6R-LCJE-AARG ramp./soak controller for less than 50 dollars, and I built the whole thing around it. You should be able to find something similar in the same price range without too much trouble. Just make sure it can ramp the temperature to multiple setpoints, as opposed to simply maintaining one stable temperature.  The Walow is pretty forgiving; it will take 24 AC/DC as power input it can display temperature in Fahrenheit or Celsius, and it accepts almost any type of thermocouple. More importantly, it has low voltage DC as a control output that we will use to drive a solid state relay, which will in turn switch on and off the heaters of a standard toaster oven.The Toaster Oven  _______________________________________________________________________  Any toaster oven will work, though the smaller the better, as the smaller volume of air will mean it can heat up much faster. Try and look for a newer oven with quartz heaters, but ceramic heaters would also be suitable. If your oven has a setting for always on operation, such as bake, you'll be fine. Otherwise, you will need to open it up and wire the heaters to always be on - a dangerous affair that I would not recommend.  You'll also need a thermocouple with a heat-resistant insulation, as our oven will reach temperatures of 260\u00ba C. This presents yet another fire hazard, so don't leave it unattended, keep it away from the walls, and don't set anything on it (unless it has heat resistant plastic feet!). The last thing to do is simply to drill a hole in the back of the over large enough for the thermocouple to fit through. There is no need to worry too much about heat loss with our oven, but the hole shouldn't be too much larger than the thermocouple. On the other hand, too small a hole and the fiberglass insulation on the wire will begin to fray from repositioning it. The hole should be placed slightly above where the center rack in the oven would be, so that the thermocouple can just touch the surface of the circuit board.ReferencesSolder Reflow Guide for Surface Mount Devices, Paul N. Houston, et. allDesign and Construction of a Reflow Soldering Oven, Dept of EE, University of WashingtonConversion of a toaster oven into a SMT reflow ovenBuilding A Reflow Controller For Griddle/Hotplate/Toaster OvenParts   Toaster oven, preferably small volume, with four quartz heating elements      Metal project enclosure      Ramp/Soak Temperature Controller, here's one option, but you should try eBay first      10A or greater Solid State Relay, Crydom d2410fHigh temp thermocouple K-Type, 270 to +1372\u00ba C (-454 to +2501\u00ba F)      heat resistant rubber or plastic feet & hardware      indicator lamp, panel mount 120V      electrical socket, panel mount      two wire screw down terminals, panel mount Tools & Supplies   Power Drill      Dremel or other rotary tool, with cutoff wheel      Crimping tool      Soldering iron, solder       mounting hardware      various crimp on connectors sized for your parts      several feet of 14-16 gauge wire, various colors      Thermal heatsink paste ", "step_imgs": ["https://cdn.instructables.com/FK3/86JG/GLFUDNIS/FK386JGGLFUDNIS.LARGE.jpg", "https://cdn.instructables.com/FTE/B4X5/GLPH1N5L/FTEB4X5GLPH1N5L.LARGE.jpg", "https://cdn.instructables.com/FTG/6PKH/GLGCJYZE/FTG6PKHGLGCJYZE.LARGE.jpg", "https://cdn.instructables.com/FN2/W4JF/GLGCJYZC/FN2W4JFGLGCJYZC.LARGE.jpg", "https://cdn.instructables.com/FMR/CRKI/GLGCJZ2Q/FMRCRKIGLGCJZ2Q.LARGE.jpg", "https://cdn.instructables.com/FGL/IMOG/GLGCJYZD/FGLIMOGGLGCJYZD.LARGE.jpg", "https://cdn.instructables.com/FA1/O4B7/GLGCJLMA/FA1O4B7GLGCJLMA.LARGE.jpg", "https://cdn.instructables.com/FVG/G54R/GLFUDNIX/FVGG54RGLFUDNIX.LARGE.jpg", "https://cdn.instructables.com/F71/N6Y2/GLFUDNIZ/F71N6Y2GLFUDNIZ.LARGE.jpg", "https://cdn.instructables.com/FKA/RR5I/GLGCJZ02/FKARR5IGLGCJZ02.LARGE.jpg", "https://cdn.instructables.com/FB6/7WJW/GLFUDNIW/FB67WJWGLFUDNIW.LARGE.jpg", "https://cdn.instructables.com/FHF/0NY5/GLFUDNJ1/FHF0NY5GLFUDNJ1.LARGE.jpg", "https://cdn.instructables.com/FTO/MQCX/GLGCJYZF/FTOMQCXGLGCJYZF.LARGE.jpg", "https://cdn.instructables.com/FZN/4M1N/GLFUDNIN/FZN4M1NGLFUDNIN.LARGE.jpg", "https://cdn.instructables.com/FGA/VXD0/GLFUDNIY/FGAVXD0GLFUDNIY.LARGE.jpg", "https://cdn.instructables.com/F4H/BY1O/GLGCJZ1V/F4HBY1OGLGCJZ1V.LARGE.jpg", "https://cdn.instructables.com/F2O/4MNX/GLGCJLML/F2O4MNXGLGCJLML.LARGE.jpg", "https://cdn.instructables.com/FRY/Z710/GLFUDNIQ/FRYZ710GLFUDNIQ.LARGE.jpg", "https://cdn.instructables.com/F75/6O4I/GLGCJLM7/F756O4IGLGCJLM7.LARGE.jpg", "https://cdn.instructables.com/FWE/G3KB/GLFUDNIT/FWEG3KBGLFUDNIT.LARGE.jpg", "https://cdn.instructables.com/F23/AM3A/GLGCJZ20/F23AM3AGLGCJZ20.LARGE.jpg", "https://cdn.instructables.com/FNA/ZE8G/GLGCJLM9/FNAZE8GGLGCJLM9.LARGE.jpg", "https://cdn.instructables.com/FBN/UCFY/GLGCJZ03/FBNUCFYGLGCJZ03.LARGE.jpg", "https://cdn.instructables.com/F68/AOOO/GLGCJLLV/F68AOOOGLGCJLLV.LARGE.jpg", "https://cdn.instructables.com/F25/F0CB/GLFUDNIP/F25F0CBGLFUDNIP.LARGE.jpg", "https://cdn.instructables.com/FHR/R4UG/GLGCJZ0Z/FHRR4UGGLGCJZ0Z.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Build a Reflow Oven & Controller"}, {"step": 5, "steps_text": "Now we need some way of getting the parts onto our PCB quickly an efficiently, and when a tweezers won't cut it, it just has to be a vacuum pen. Not satisfied with the old spring-in-a-syringe trick? A modified aquarium pump will do the job nicely.The Pump _______________________________________________________________________  I found that the best aquarium pump for our purposes is a Tetra Whisper. With a few exceptions, only diaphragm pumps from five or ten years ago are easily reversible, and they all require some kind of permanent modification of the valve system. Most modern pumps (like the Marina 100) are single-piece designs that have been refined to the point where they can't be modified in the same way - except for the Whisper series!  The way it is designed, it can be reversed simply by pulling out the one-way valve assembly, turning it around, and putting it back in. It is a tool-free modification that can be returned to normal operation by doing the mod in reverse. Unplug it first!  If you would prefer to go the cheap route, it is still a safe bet on the older pumps. Any thrift store (Goodwill, Savers, etc.) is liable to have one for under $5.The Pen _______________________________________________________________________  We also need to make a vacuum pen. Any cheap pen with a plastic tube body will do just fine. Keep a lookout for Luer lock connectors, the standard for syringe needles. They come in handy for a lot of things. In this case, it will make swapping tips much easier. They can be hard to find; my local surplus store had them in quantity and they turned out to be just what the doctor ordered (groan). I even found a Luer lock valve for adjusting the airflow, though it turned out to be totally unnecessary, since we want as much vacuum as we can get.  I also managed to piece together a miniature lazy susan with some odd parts. I found this to be an indispensable tool, given the ability to turn the circuit board to the orientation of the part you picked up. There is no comparison to even the nicest clamp-style PCB holder.PartsVacuum PumpTetra Whisper air pump (single output)      BIC pen      1/8\" flexible hose      assorted luer syringe needles (try your local needle exchange :)   Luer lock fittingsVarious sizes of heatshrinkTurntable   bearing assembly      flat board or piece of plastic      self-adhesive rubber sheet      self-adhesive rubber feet      4 short sheet metal screws Tools & Supplies   Power drill      #2 Phillips screwdriver      Hobby knife      Hot air gun      metal fil ", "step_imgs": ["https://cdn.instructables.com/F15/7SR1/GLGCJZHO/F157SR1GLGCJZHO.LARGE.jpg", "https://cdn.instructables.com/FSL/5YZD/GLGCJLMR/FSL5YZDGLGCJLMR.LARGE.jpg", "https://cdn.instructables.com/FS8/GG5X/GLFUDNKA/FS8GG5XGLFUDNKA.LARGE.jpg", "https://cdn.instructables.com/FPH/O3JA/GLFUDNK8/FPHO3JAGLFUDNK8.LARGE.jpg", "https://cdn.instructables.com/F92/FEU3/GLFUDNJV/F92FEU3GLFUDNJV.LARGE.jpg", "https://cdn.instructables.com/F5Y/6JQT/GLFUDNJW/F5Y6JQTGLFUDNJW.LARGE.jpg", "https://cdn.instructables.com/F3L/ZZOT/GLGCJLMW/F3LZZOTGLGCJLMW.LARGE.jpg", "https://cdn.instructables.com/F5E/W5BK/GLFUDNJX/F5EW5BKGLFUDNJX.LARGE.jpg", "https://cdn.instructables.com/FG6/5C7N/GLGCJZG6/FG65C7NGLGCJZG6.LARGE.jpg", "https://cdn.instructables.com/FDR/ZB5C/GLGCJLNF/FDRZB5CGLGCJLNF.LARGE.jpg", "https://cdn.instructables.com/FYD/93Z6/GLGCJZGN/FYD93Z6GLGCJZGN.LARGE.jpg", "https://cdn.instructables.com/FUP/UMDM/GLGCJZH2/FUPUMDMGLGCJZH2.LARGE.jpg", "https://cdn.instructables.com/FED/Q51Y/GLGCJM3F/FEDQ51YGLGCJM3F.LARGE.jpg", "https://cdn.instructables.com/FOO/37S6/GLGCJZHM/FOO37S6GLGCJZHM.LARGE.jpg", "https://cdn.instructables.com/FUQ/PP8R/GLGCJZH3/FUQPP8RGLGCJZH3.LARGE.jpg", "https://cdn.instructables.com/FWI/0IFL/GLFUDNK9/FWI0IFLGLFUDNK9.LARGE.jpg", "https://cdn.instructables.com/FBL/6CBB/GLGCJZF3/FBL6CBBGLGCJZF3.LARGE.jpg", "https://cdn.instructables.com/FCJ/B4QB/GLGCJZFG/FCJB4QBGLGCJZFG.LARGE.jpg", "https://cdn.instructables.com/F46/7B0R/GLGCJLMS/F467B0RGLGCJLMS.LARGE.jpg", "https://cdn.instructables.com/FL1/3VM0/GLFUDNVL/FL13VM0GLFUDNVL.LARGE.jpg"], "step_title": "Step 5: Build an SMD Vacuum Pick and Place Tool"}, {"step": 6, "steps_text": "This really was the most time consuming step; that is, designing and planning the entire device. The goal is to make a 5 LED microcontroller-based circuit with a small enough part count to fit on a 2\" by 3.5\" standard business card. It has to be a single sided board to reduce complexity, and it has to be built entirely with surface mount components to save on time drilling holes, keep the profile as thin as possible, and keep the end user from getting poked by leads sticking out of the bottom. Most importantly, it needs to be cheap and quick to make. Again, that means a reduced parts count and surface mount components.The Microcontroller _______________________________________________________________________    I ended up designing the whole thing around the Microchip PIC12F508 , the smallest, cheapest microcontroller I could find with the right number of pin outs. With no interrupts or PWM, the PIC12F508 is nothing fancy, but it definitely gets the job done. At the time of writing, they run around 46 cents apiece. Similar chips are available from ATMEL, under the AVR banner, and are more full featured, but cost about twice as much. And in the quantities I want, that matters.  The PICF508 runs nominally at 4MHz on its internal oscillator. It has only 750 bytes of program memory, and 25 bytes of RAM, but we don't need that much, anyway. It also does not have interrupts or PWM, but, again, we can get by without those. As far as I/O goes, it has exactly enough. There are 8 pins, two for power, and 6 I/O pins, one of which is input only. We already know what that means: It will have five LEDs and one sensor, and that's it. The most important feature is that it is programmable in-circuit (ICSP), meaning you  don't have to take it off the board to reprogram it; an important point when you are dealing with a soldered on SMD part.  When running a program, pins 2, 3, 5, 6, 7 of the PIC are configured as 3V LED ouputs, pin 4 as an input, and 1 and 8 are 3V dc power inputs.  In ICSP mode, the PIC is programmed over five pins:Pin           Function1              Vdd  2              (unused)  3              (unused)4               Vpp  5              (unused)6              ICSP CLOCK7              ICSP DATA8              VssThe Circuit _______________________________________________________________________    That decision made, the rest comes easy, up to a point. Aside from the five LEDs and their current limiting resistors, a tilt switch that pulls Pin 4 (GP3) low when the the board is tilted, a bypass capacitor across pin 1 and 8 (.1 uF C1) to prevent erratic CPU behavior, and a momentary power switch to prevent battery drain, there isn't much to it. It's simple, as promised. And with the right program, it can do anything! Anything at all. The only limit is yourself!  I spent a bit of time obsessing about the other components; I ordered about 20 different tactile switches from DigiKey to find the thinnest, nicest looking, softest feeling tactile switch possible. SInce the battery will overheat (and potentiall explode) if soldered to, I played around with conductive epoxy and conductive tape, with no luck. In the end I bit the bullet and paid the 26 cents apiece of nice, solid, SMD battery retaining clips. They ended up fitting into the design fairly well, too.  Now all there is to do is obsess about the artistry of the PCB layout, and we're done. Ironically, I put more time into proportion and layout than anything else on this project, and it gets three sentences of description.  Well, the thing does have be pretty, after all.Improvements _______________________________________________________________________    The final design does leave room for improvement. For one thing, it needs much brighter LEDs so it can be seen better in bright light. Also the tilt switch makes it seem kind of cheap, e.g. \"What is that thing rattling around? Is it broken?\" Other flaws, such as having to wave it to see anything, are intrinsic to the design and were accepted before I even began. Incidentally, it ends up being something of an intelligence test if you don't explain how it works, but there is a definite advantage of that; only the people who can figure it out will be giving me a call. :)  In order for ICSP to work there cannot be any interfering components on the pins it uses I had quite a bit of trouble with this. After modifying the original copper trace design, and rearranging the ICSP pads (but still matching the schematic exactly!), I found that I could not program boards anymore. The easy solution is to remove the capacitor connecting pin 1 and 8, and it works properly now. The component isn't integral to the design, anyway.ReferencesPIC12F508/509/16F505 DatasheetPartsPIC12F508CR2032 3V Lithium coin cellBattery retainer clipSMD tactile switchTilt switch (though a mercury tilt switch would work just as well :)   RED SMD LEDs, 20 mA (LTST-C930EKT is what I used, part listed is superior, cheaper substitute) x 5   100 ohm SMD resistor, 0805 1/8 W 5% x 5   47k ohm SMD resistor, 0805 1/8 W 5%.1 uf SMD capacitor, 1206", "step_imgs": ["https://cdn.instructables.com/F39/Z1DO/GLHRYD08/F39Z1DOGLHRYD08.LARGE.jpg", "https://cdn.instructables.com/FY7/K08J/GLFUDYRO/FY7K08JGLFUDYRO.LARGE.jpg", "https://cdn.instructables.com/FNW/XB35/GLFUDYRR/FNWXB35GLFUDYRR.LARGE.jpg", "https://cdn.instructables.com/FTZ/22IN/GLHRYVYB/FTZ22INGLHRYVYB.LARGE.jpg", "https://cdn.instructables.com/FY2/SDY7/GLHRYD0J/FY2SDY7GLHRYD0J.LARGE.jpg", "https://cdn.instructables.com/FAS/A4TI/GLFUDYRS/FASA4TIGLFUDYRS.LARGE.jpg", "https://cdn.instructables.com/FX0/SOPW/GLHRYW80/FX0SOPWGLHRYW80.LARGE.jpg", "https://cdn.instructables.com/FTQ/O4ZP/GLFUDYRN/FTQO4ZPGLFUDYRN.LARGE.jpg", "https://cdn.instructables.com/FPE/COVR/GLHRYW4U/FPECOVRGLHRYW4U.LARGE.jpg", "https://cdn.instructables.com/FTN/TK4G/GLOX6SPD/FTNTK4GGLOX6SPD.LARGE.jpg", "https://cdn.instructables.com/FPL/2J2C/GLHRYD17/FPL2J2CGLHRYD17.LARGE.jpg", "https://cdn.instructables.com/FN1/GFXU/GLHRYVZ7/FN1GFXUGLHRYVZ7.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 6: Design the Board"}, {"step": 7, "steps_text": "Laminator in hand, now we need to use it. This is the first step of actual PCB fabrication; everything else was just foreplay.Finding Suitable Transfer Paper _______________________________________________________________________    The first step is to print a transfer onto suitable paper. If you are sufficiently bankrolled, you could use the commercial product made by Pulsar Pro , at about 10 cents a sheet, or if you're feeling thrifty you can go the DIY Route, which is free. I don't know why I would even question that, though. Sorry.  Finding the right free paper can be tricky. The two key characteristics are its ability to hold on to the toner when printed on and its ability to release it when heated. One predictor of this is how glossy the paper is; more glossy, better release, less glossy, means better hold. We need a happy medium.  People on the internet will recommend all kinds of weird store brand glossy photo papers that are long discontinued, or have to be imported from overseas. Some people have had success using the waxy backing on shipping labels, suggesting you buy them and then peel off all the labels(or use all the labels and then save up the backing). Moreover, most papers are associated with the need to rub and peel and soak the boards just to get the paper off.  Forget that. If I am going to compromise it has to be actually free, not just less expensive than the real thing. I have tried many, many things. As it turns out, it was a piece of junk mail that did the trick; a Menard's coupon mailer gave me the best results out of everything. Eventually I stopped getting the junk mailings, and they only had a few strangely sized pages each, so I had to find a more consistently available paper. But I knew where to start. The best analogue so far are those glossy Apartments For Rent listings they have at the grocery store. Check out the free literature rack for something similar. It works remarkably well; it prints without toner loss, and when you run it under hot water, it releases instantly. Presto!  The paper is too thin to run through the Laser printer by itself, so you need to make a carrier out of regular white paper by folding over and creasing the top of one side.The Laser Printer _______________________________________________________________________    At this point I should mention the printer itself. For the most part, your final resolution, board quality, and minimum feature size is limited by the resolution of your printer. In all other respects, any black and white laser printer will work as well as any other. Toner density should be set to the maximum level, and hopefully you have a printer that has a single-page slot in it so you can just feed the page in by hand.  You could even use a photocopy using a regular inkjet as the source if you can figure out how to load your special paper; any toner based method will work.  One caveat, that I discovered too late: the standard Brother brand toner reputedly melts at a higher temperature than other kinds of printers, so I had to get an off brand refilled cartridge that uses a more common toner to get consistent results. So far so good, though. It was a cheap fix, given that I specifically had to buy the off-brand stuff.Transferring the Pattern to the PCB _______________________________________________________________________    To prepare the PCB, you will find that you need to have it very clean for the toner to stick to the copper. Even fingerprints will pose a problem in the final adhesion, so wear cotton gloves. Acetone or isopropyl alcoholor even just soapy water and a scouring pad work well,. When it's clean, wipe it down with a lint free cloth and let it dry.  The PCB i have available is thin as far as FR4 goes, at around .020 in (20 mil), and that is exactly what I want. Thinner PCB not only goes through the laminator, but can be translucent Standard PCB  Once the transfer is printed, you need to line up your precut PCB to your alignment marks on the transfer paper, toner side to the copper. Here it really helps to have a light table so you can see though the transfer paper. Fold over one edge of the transfer, crease it, make sure that it doesn't move, and feed the creased end into the preheated laminator. I have not noticed any differences in adhesion based on transfer paper on the bottom roller or the top roller, though I use very thin PCB. You may notice a difference for thicker PCBs.  The technique for double-side PCB is similar, but the alignment is tricky. Instead of leaving a margin on your design to be folded over, you print the patterns for both layers side by side, with a gap that is the thickness of the PCB. The two sides should then line up exactly opposite each other when folder over the PCB.  The board is pulled through about 1/4 \" per second. I usually run it though about three times, with no time for the board to cool between passes. Of course, the number of passes will vary quite a bit depending on board thickness, the kind of toner, type of paper, and laminator settings. Cotton gloves also help to remove the hot board from the laminator.  Now to the sink where a stream of hot water is ready and waiting. The paper should peel right off after about 10 seconds, though the finer details will need a quick rubdown to clean off the remaining pulp.  And it's ready to etch!Tools & Supplies   Modded laminator      Laser printer      Glossy junkmail or commerical transfer paperBlank FR4 PCB, single sided .020in (20 mil) ", "step_imgs": ["https://cdn.instructables.com/FKV/D3SX/GLFUDNGL/FKVD3SXGLFUDNGL.LARGE.jpg", "https://cdn.instructables.com/FSA/NCB4/GLFUDYXJ/FSANCB4GLFUDYXJ.LARGE.jpg", "https://cdn.instructables.com/FYY/A224/GLGCJYIK/FYYA224GLGCJYIK.LARGE.jpg", "https://cdn.instructables.com/FGI/8BUB/GLGCJLFJ/FGI8BUBGLGCJLFJ.LARGE.jpg", "https://cdn.instructables.com/FSP/2BW1/GLGCJLDC/FSP2BW1GLGCJLDC.LARGE.jpg", "https://cdn.instructables.com/FYA/PO5M/GLGCJLDD/FYAPO5MGLGCJLDD.LARGE.jpg", "https://cdn.instructables.com/FMV/QSEW/GLFUDNGD/FMVQSEWGLFUDNGD.LARGE.jpg", "https://cdn.instructables.com/FTP/8HD6/GLGCJLDE/FTP8HD6GLGCJLDE.LARGE.jpg", "https://cdn.instructables.com/FYC/FK5D/GLGCJLDF/FYCFK5DGLGCJLDF.LARGE.jpg", "https://cdn.instructables.com/FMJ/VNQC/GLGCJYJ0/FMJVNQCGLGCJYJ0.LARGE.jpg", "https://cdn.instructables.com/FC1/TK1R/GLGCJYJ1/FC1TK1RGLGCJYJ1.LARGE.jpg", "https://cdn.instructables.com/FN7/KEIF/GLFUDNGG/FN7KEIFGLFUDNGG.LARGE.jpg", "https://cdn.instructables.com/FNI/9X1T/GLFUDNGK/FNI9X1TGLFUDNGK.LARGE.jpg", "https://cdn.instructables.com/F23/75OV/GLFUDNGH/F2375OVGLFUDNGH.LARGE.jpg", "https://cdn.instructables.com/FOW/E59L/GLGCJLDX/FOWE59LGLGCJLDX.LARGE.jpg", "https://cdn.instructables.com/F26/MF5R/GLGCJLEW/F26MF5RGLGCJLEW.LARGE.jpg", "https://cdn.instructables.com/FUP/YJKR/GLGCJLEX/FUPYJKRGLGCJLEX.LARGE.jpg"], "step_title": "Step 7: The Toner Transfer Process"}, {"step": 8, "steps_text": "Ah, the most immediately hazardous step. This one involves a bit of chemistry, and if done without the proper precautions could be very dangerous. Be careful! You do this one at your own risk, so wear proper protective equipment (goggles, face shield, rubber gloves) and definitely don't do this anywhere near your kitchen.  It's time to make the magic happen! This is the part where we get to break out that badass etch tank we made earlier and pump out hundreds of circuit boards. The key ingredient for this to work is some kind of etchant. As I mentioned before, I decided on CuCl2 (Cupric Chloride). It is reusable, very cheap, and can be made from readily available chemicals. It is a very good alternative to Ferric Chloride, a common hobby etchant that is not easily regenerated and is quite expensive for a one time use product. Surprisingly, it is fairly commonly used in the PCB industry, as much or possibly even more so than Ferric Chloride.The Chemistry _______________________________________________________________________    Regrettably, There is just not enough space here to go into any major detail on the chemistry, and this is covered in far greater detail in the those two links so I will breeze over most of  it. Suffice it to say that the articles referenced at the bottom of this step should be your primary resources.  Simply put, given the right amounts of oxygen, HCl (Hydrochloric acid), copper, and water, we will have a perfect amount of etchant.  The reaction we want to happen is:  Cu + 2 HCl + H2O2  -->  CuCl2 + 2H2O  The copper comes, initially, from the circuit board itself. Hydrochloric acid is commonly available as a pool cleaner, sold as Muriatic Acid. Mine can as 31.45% (20 degree Baume, or 10.01 Molar). Hydrogen Peroxide can be found in higher concentrations at health food stores. You want 35% Food grade (11.6 Molar); the 3% kind you get in the first aid section just won't cut it. You also need a jug of distilled water, as tap water is just too impure.  For my 2 L tank, I only need 1.6 Liters of etchant. The ratios in the above formula, and assuming my etchant should be 3 Molar HCl at its final volume, I came up with .48L HCl, .92L H2O, and .20L H2O2 as my reagents. Add the water, then the Peroxide, then the HCl. Always add acid to water, and never the reverse (As the mnemonic goes, \"Do as you oughta, add acid to watah [water]\"). And do it outside, in a pyrex dish. It will produce heat and fume fairly violently at first, but as you begin to use the solution to etch boards, the fuming will decrease as it turns to Cupric Chloride. Note: Do not make the mistake of mixing your etchant in your homemade etch tank. Absolutely do not etch too many boards (side by side) or mix raw copper into your etchant, as i did, especially in an enclosed sealed tank. The reaction will be violently exothermic and fume viscously. It will melt, crack, or break open your etch tank from pressure and heat that is far beyond what is normally produced with a controlled stable etchant. With a sufficient air bubbler, you won't need to mix in the copper initially, anyway. The solution will effectively make itself. Etching _______________________________________________________________________    After mixing the etchant, it is time to etch! If you have built your etchtank carefully, all you need to do is slide the pcb into the clip on the lid and place it in the tank. The etch progress can be observed through the window in the side. The hanger I currently use needs some improvement as the boards need to be turned and replaced off halfway through to etch the part covered up by the clip.  -a  The boards will etch rapidly at first, in under a minute, and as the solution begins to become saturated, the etch times will increase to five minutes or more. Once it becomes unreasonably long, you simply need to add the right amount of acid and/ or run the bubbler for a period to regenerate the solution and decrease etch times. Again, consult the above paper for how to do this properly; it is a very good reference.  When you can see the board is fully etched, remove the lid and pull out the board with plastic tongs. Let the excess etchant drip into the tank, and place the board in a plastic tub to rinse it off. Then it's on to the Scotch Brite pad and some acetone to take off the layer of toner, and the copper traces should polish up to a bright shine.  When the tank is not in use, the etchant should be stored in an airtight glass vessel that will not be used for food, out of the light, and properly labeled. Under no circumstances should the etchant be poured down the drain, as it is both toxic (the high copper content) and corrosive to metals. If you do happen to spill any, or need to dispose of it, the solution can be neutralized with lime, and mixed with concrete for disposal. Be sure to dispose of it properly, according to your local hazardous waste policy! Where I live they have a facility will take in waste like this for free.   It is O.K. if some of the rinse water ends up in the sink, assuming you do not have copper pipes and that you leave the water running afterwards long enough to flush it all out of the system. I cover and resuse even my rinse water, treating everything that comes in contact with the acid as hazardous waste. So don't go pouring anything down the sink, seriously. ReferencesEtching with Air Regenerated Acid Cupric Chloride, Adam Seychell   Stop using Ferric Chloride etchant! (A better etching solution.) Tools & Supplies   Safety gear: (Goggles, long rubber gloves, apron, splash shield, etc.)      Etch Tank      Plastic spill tray      Plastic tub (for rinsing)      Non-metallic measuring cup or graduated cylinder      Acetone      Plastic tweezers or forceps ", "step_imgs": ["https://cdn.instructables.com/FV2/9B8I/GLFUDNG2/FV29B8IGLFUDNG2.LARGE.jpg", "https://cdn.instructables.com/F3E/NZQY/GLFUDNG0/F3ENZQYGLFUDNG0.LARGE.jpg", "https://cdn.instructables.com/F9L/G4QX/GLGCJYGR/F9LG4QXGLGCJYGR.LARGE.jpg", "https://cdn.instructables.com/FER/ZFXF/GLGCJLA6/FERZFXFGLGCJLA6.LARGE.jpg", "https://cdn.instructables.com/F7S/13YP/GLGCJYGW/F7S13YPGLGCJYGW.LARGE.jpg", "https://cdn.instructables.com/F71/1C9H/GLGCJYGX/F711C9HGLGCJYGX.LARGE.jpg", "https://cdn.instructables.com/F69/VE3H/GLFUDNG1/F69VE3HGLFUDNG1.LARGE.jpg", "https://cdn.instructables.com/F5Y/XQ6D/GLQCL9XT/F5YXQ6DGLQCL9XT.LARGE.jpg", "https://cdn.instructables.com/F0F/M3UV/GLGCJLA5/F0FM3UVGLGCJLA5.LARGE.jpg", "https://cdn.instructables.com/FJD/3JEL/GLGCJYH9/FJD3JELGLGCJYH9.LARGE.jpg", "https://cdn.instructables.com/FAE/MJKP/GLGCJYH3/FAEMJKPGLGCJYH3.LARGE.jpg", "https://cdn.instructables.com/FA7/GCRG/GLFUDNG3/FA7GCRGGLFUDNG3.LARGE.jpg", "https://cdn.instructables.com/FB5/4HSB/GLGCJLEY/FB54HSBGLGCJLEY.LARGE.jpg", "https://cdn.instructables.com/FCH/JE15/GLGCJYJI/FCHJE15GLGCJYJI.LARGE.jpg", "https://cdn.instructables.com/FIX/V9NC/GLGCJLFH/FIXV9NCGLGCJLFH.LARGE.jpg", "https://cdn.instructables.com/F8Q/H0RO/GLGCJYJJ/F8QH0ROGLGCJYJJ.LARGE.jpg", "https://cdn.instructables.com/F07/IS7P/GLGCJLFI/F07IS7PGLGCJLFI.LARGE.jpg"], "step_title": "Step 8: Etch Your PCB"}, {"step": 9, "steps_text": "If you so desire, it is a simple affair to chemically plate a thin layer of tin on the surface of the copper traces. Most commercial PCBs at least have tin plated solder pads in a addition to a soldermask to prevent short circuits over the traces (usually the distinctive green color, though sometimes other colors are used). In our case, however, to prevent corrosion and improve the solderability of joints a tin plating will do nicely.The Chemical Plating Solution _______________________________________________________________________    I have gotten very nice results using Tinnit, a powdered \"just-add-water\" plating solution. It is quite inexpensive at around $10 including shipping, has a 6+ month shelf life, and can plate many boards before needing to replaced (475 mL or 1 pint will plate up to 600 sq. inches of copper). It works by chemically depositing a very thin layer of tin on to the exposed copper of the circuit board. This produces the same result as an electroplating method, and is quite a bit simpler and cheaper.  The copper traces must be clean of oxidation or tarnish as well as etchant before you can plate it. If you just etched it, it should be clean from removing the toner. If not, first you will need to polish it up with a scotch brite pad and give it a quick rinse.  You will also need some way of heating the solution to 50\u00ba C and a container to do it in. I was able to come up with a stirring hotplate, which definitely gives me a head start. It's the kind that has both a heater and a magnet mounted to a motor underneath so the solution can be stirred by special glass coated-magnet simultaneously. If you can't find a good hotplate, a kitchen stove will work just as well.The Plating Vessel _______________________________________________________________________    The tricky part is finding a non-metallic container to do the plating in. A real lab would some kind of thermal-shock resistant borosilicate glass tray, also known as Pyrex. You'd think you could just use your casserole dish, but that is a very bad idea. What most people don't know is that kitchen \"Pyrex\" is not the same thing; the Pyrex name is actually licensed by Corning Glass to a company called World Kitchen. They use an entirely different kind of glass, called soda lime glass. It is known to shatter catastrophically when exposed to a temperature differential such as that on an uneven stovetop. So don't do that.  There is a cheap alternative, though. In my research I came across an early Corning product called pyroceram,  marketed as \"Corningware.\" It is not glass, but actually a glass-ceramic, and incredibly reistant to thermal-shock. Real hi-tech stuff, and Corning actually made casserole dishes out of it! You can get them at Savers or Goodwill for under $5.00, complete with lid. Look for the distinctive white color and the \"Corningware - Safe For Rangetop Use\" label on the bottom.  I also needed a little wire harness to suspend the board over the spinner stir magnet at the bottom of my dish.Plating the Board _______________________________________________________________________Safety Note: Tinnit contains Acidic tin salts, so wear gloves and goggles and don't reuse anything for eating. Follow the warnings on the package. Please!  Tinnit comes as a powder that first needs to be dissolved in hot water. Following the instructions on the back, heat 475mL (1 pint) of distilled water to 55\u00ba C (120\u00ba F). Once it's fully dissolved, it will be a milky white-yellow color with a few solids floating around. Immerse the board face-up in the solution and give it 10-30 minutes, stirring at 5 minute intervals. If everything has gone to plan, you should see the copper almost immediately start to turn a dull gray. The longer you leave it in, the thicker the plate. Just don't heat it over 140\u00ba F  or it will start to put off weird ammonia and sulfur dioxide fumes.  Once you're satisfied, pull the board out and rinse it off thoroughly. The instructions say to clean it off with ammonia to remove corrosive residues that would dull the board. Window cleaner with ammonia will do in a pinch. Then just shine it up with a scratch free Scotch Brite pad and it's ready to solder!Tools & SuppliesTinnit plating solutionLaboratory thermometer   Plastic tweezers      Rubber gloves, goggles      Borosilicate tray, or Rangetop-safe casserole dish ", "step_imgs": ["https://cdn.instructables.com/F09/YG25/GLL4ZCR4/F09YG25GLL4ZCR4.LARGE.jpg", "https://cdn.instructables.com/FMK/R3CB/GLQCL9ED/FMKR3CBGLQCL9ED.LARGE.jpg", "https://cdn.instructables.com/FTP/UP1L/GLL4ZCL7/FTPUP1LGLL4ZCL7.LARGE.jpg", "https://cdn.instructables.com/FH9/WGL4/GLL4ZCLB/FH9WGL4GLL4ZCLB.LARGE.jpg", "https://cdn.instructables.com/F3Q/SBNX/GLPH1IFB/F3QSBNXGLPH1IFB.LARGE.jpg", "https://cdn.instructables.com/FH1/X2FH/GLL4ZCND/FH1X2FHGLL4ZCND.LARGE.jpg", "https://cdn.instructables.com/FVV/2HTN/GLQCL9EE/FVV2HTNGLQCL9EE.LARGE.jpg", "https://cdn.instructables.com/FL1/0NBX/GLPH1IFT/FL10NBXGLPH1IFT.LARGE.jpg", "https://cdn.instructables.com/FR2/1CE9/GLQCL9EI/FR21CE9GLQCL9EI.LARGE.jpg", "https://cdn.instructables.com/FAL/AMQ6/GLQCL9EJ/FALAMQ6GLQCL9EJ.LARGE.jpg", "https://cdn.instructables.com/FKB/WB6S/GLL4ZCN0/FKBWB6SGLL4ZCN0.LARGE.jpg", "https://cdn.instructables.com/FRG/0K6E/GLPH1IFC/FRG0K6EGLPH1IFC.LARGE.jpg", "https://cdn.instructables.com/FE1/HZUM/GLQCL9EU/FE1HZUMGLQCL9EU.LARGE.jpg", "https://cdn.instructables.com/F47/H4PZ/GLQCL9EY/F47H4PZGLQCL9EY.LARGE.jpg", "https://cdn.instructables.com/FT9/V8SI/GLPH1IH9/FT9V8SIGLPH1IH9.LARGE.jpg", "https://cdn.instructables.com/FAY/MXID/GLQCL9F1/FAYMXIDGLQCL9F1.LARGE.jpg", "https://cdn.instructables.com/FBK/79OD/GLPH1IHA/FBK79ODGLPH1IHA.LARGE.jpg", "https://cdn.instructables.com/F7J/6AJK/GLPH1IHB/F7J6AJKGLPH1IHB.LARGE.jpg"], "step_title": "Step 9: Tin Plate the PCB"}, {"step": 10, "steps_text": "\n          At this point we have the hard part done; we have a circuit board. We just need to solder on the parts. With a properly made stencil, it is a simple matter of wiping a thin layer of solder paste over board over the stencil and placing the components.The Stencil _______________________________________________________________________   Commercial\u00a0PCB manufacturers use a metal solder stencil, etched out of stainless steel or aluminum for large runs of boards, but you can order them custom cut online out of thick mylar. If you have\u00a0access\u00a0to a laser cutter (laser cutter use number two) or vinyl cutter, you can cut your own out of acetate or transparency film. In a pinch, you can even print out your pattern onto a sheet of transparency \u00a0film and use an X-Acto knife to cut out the solder pads. Whatever works.  In my case, I had a friend \u00a0cut me a stencil out of thick acetate with his vinyl cutter. It took a bit of tweaking to get the settings right, as it is an unusually thick and brittle material to cut; thicker than most vinyls. Eventually we determined that the cutter needed to make at least four passes to cut all the way though.Applying the Solder Paste _______________________________________________________________________   For the actual screening, I made a jig out of a piece of thick silicone rubber. I cut out a piece the exact size of the PCB, then I stacked extra PCBs underneath the frame, thereby creating a cutout sunk exactly to the depth of the board. This gives a surface for the stencil to lay flay all the way across and also holds the board in place while the squeegee is dragged across.  Line up your stencil, then tape it down at the top with packing tape.Be sure to be wearing rubber gloves as the solder contains a lot of scary things, in my case, Lead. Scoop out a blob of solder paste and put it either on the squeegee, or at the top of the stencil, above the cutouts. The solder paste should be viscous, but not so viscous that it can't be spread. It's a non-newtonian material, meaning that it holds it flows more easily under pressure, and solidifies somewhat when the pressure is released.  Cheap decent-quality solderpaste and flux can be had from DealExtreme, though you should be prepared for slow (but free) shipping. If the solder paste is old, or simply too viscous, you may need to thin it with flux.  Hold the stencil tight at the bottom and run the squeegee across the stencil, taking care not to lift it off the surface. Repeat until all areas are filled and then carefully peel up the stencil.This part definitely takes practice and you will probably have to make several attempts before you get it right.  Now just place the board on a lazy susan and pick and place the appropriate parts with a tweezers or a vacuum pen. Then it's off to the reflow oven, where you hopefully don't bump the board and spill the parts you just meticulously placed all over the floor and have to pick hairs and dirt off the parts because it stuck into the paste still on them.Tools & Supplies   Solder paste stencil     metal or rubber squeegee     X-Acto Knife     Vacuum pickup tool     toothpick or other disposable mixing stick     rubber gloves  solder paste\u00a0$3.37, DealExtreme  Flux\u00a0$3.61, Deal Extreme     SIlicone rubber sheet     packing tape ", "step_imgs": ["https://cdn.instructables.com/FY7/K08J/GLFUDYRO/FY7K08JGLFUDYRO.LARGE.jpg", "https://cdn.instructables.com/FO0/YFRL/GLFUDNVE/FO0YFRLGLFUDNVE.LARGE.jpg", "https://cdn.instructables.com/FEY/S08L/GLGCK00K/FEYS08LGLGCK00K.LARGE.jpg", "https://cdn.instructables.com/F68/YYIG/GLFUDNVD/F68YYIGGLFUDNVD.LARGE.jpg", "https://cdn.instructables.com/FG3/SCQB/GLFUDNVH/FG3SCQBGLFUDNVH.LARGE.jpg", "https://cdn.instructables.com/FHA/EZVK/GLGCJRB3/FHAEZVKGLGCJRB3.LARGE.jpg", "https://cdn.instructables.com/F43/W21S/GLGCK00V/F43W21SGLGCK00V.LARGE.jpg", "https://cdn.instructables.com/FB7/75VK/GLFUDNVI/FB775VKGLFUDNVI.LARGE.jpg", "https://cdn.instructables.com/FJ4/8GPN/GLGCK00X/FJ48GPNGLGCK00X.LARGE.jpg", "https://cdn.instructables.com/FA0/J4SC/GLFUDNVG/FA0J4SCGLFUDNVG.LARGE.jpg", "https://cdn.instructables.com/F6D/78TY/GLGCJRB6/F6D78TYGLGCJRB6.LARGE.jpg", "https://cdn.instructables.com/FZT/HWN5/GLGCK00N/FZTHWN5GLGCK00N.LARGE.jpg", "https://cdn.instructables.com/F15/ZHRX/GLFUDNVJ/F15ZHRXGLFUDNVJ.LARGE.jpg", "https://cdn.instructables.com/FNM/LH7H/GLGCK00Y/FNMLH7HGLGCK00Y.LARGE.jpg", "https://cdn.instructables.com/F3C/NG9M/GLGCK00Z/F3CNG9MGLGCK00Z.LARGE.jpg", "https://cdn.instructables.com/FDT/LOTW/GLGCK00M/FDTLOTWGLGCK00M.LARGE.jpg", "https://cdn.instructables.com/FCJ/1NEO/GLFUDNVM/FCJ1NEOGLFUDNVM.LARGE.jpg", "https://cdn.instructables.com/FL1/3VM0/GLFUDNVL/FL13VM0GLFUDNVL.LARGE.jpg", "https://cdn.instructables.com/FIX/VI30/GLGCK010/FIXVI30GLGCK010.LARGE.jpg"], "step_title": "Step 10: Screen the Solder and Populate the PCB"}, {"step": 11, "steps_text": "\n          Now it is time to bake the PCB! I promise it will be fun.Programming the Reflow Controller _______________________________________________________________________   First things first: it is important that the reflow oven is properly configured, or this won't go well. It's all about the set point parameters here. The maximum temperature and time maintained should not be any longer than the most sensitive component can handle, and it is recommended that it actually be 5 degrees lower than that value. In this case, the most sensitive component is,\u00a0surprisingly\u00a0the LEDs. The microcontroller can take, based on it's volume, up to 260\u00ba C, and the resistors and capacitors have tolerances above that. The LEDs have a recommended max temperature of no more than 225\u00ba. The manufacturers were kind enough to provide a reflow slope, so I just used that one.  If your oven is slow to heat up, you may encounter problems near the peak of your reflow ramp. The idea is to bring the temperature up slowly, spike it to \"re-flow\" the solder, and then drop it off rapidly, but not instantly, to room temperature. So if getting that peak is a problem, you may have to step in and open the door of your oven to \u00a0speed of the rate of cooling from that peak temperature.\u00a0Baking the PCB _______________________________________________________________________   Once you have the oven programmed, place the board in the center of the rack, making sure the thermocouple is near the surface of the PCB so it can get a reading that close to\u00a0the\u00a0actual conditions of the\u00a0solder\u00a0joints. \u00a0Close the door, and start the program. Fire extinguisher nearby, of course.  Wait until the temperature drops to room temp.\u00a0to take the board out\u00a0, as it will embrittle the solder joints if they are denied\u00a0their\u00a0cooling cycle.\u00a0  I should note here that if you do not need to make many, many identical PCBs, you don't really need to go to the trouble of building a reflow oven or screening the solder; it is very possible to solder the parts by hand. You will need a soldering iron with a relatively fine point, however. The trick is to tin on pad on each component, hold it in place with a tweezers (or the vacuum tool) and flow the solder on that joint with the iron. Then it's secure and perfectly aligned to do the other side.  \u00a0Tools & Supplies   Reflow oven & controller     solder-screened and populated PCB ", "step_imgs": ["https://cdn.instructables.com/FC2/9G99/GLHRYWX7/FC29G99GLHRYWX7.LARGE.jpg", "https://cdn.instructables.com/FEJ/20BN/GLGCJZ67/FEJ20BNGLGCJZ67.LARGE.jpg", "https://cdn.instructables.com/FK3/86JG/GLFUDNIS/FK386JGGLFUDNIS.LARGE.jpg", "https://cdn.instructables.com/FIN/KX8Y/GLGCJZ1U/FINKX8YGLGCJZ1U.LARGE.jpg", "https://cdn.instructables.com/FEO/5ZZS/GLGCJLLY/FEO5ZZSGLGCJLLY.LARGE.jpg", "https://cdn.instructables.com/FTK/OPXL/GLFUE0IH/FTKOPXLGLFUE0IH.LARGE.jpg"], "step_title": "Step 11: Bake Your PCB"}, {"step": 12, "steps_text": "In-Circuit Serial Programming (ICSP) _______________________________________________________________________  Microcontrollers can be programmed a number of different ways. The traditional way of doing this is a Zero Insertion Force (ZIF) socket, where the chip must be removed from its it's circuit board in order to program it. Some chips are capable of In-Circuit Serial Programming, and, as you might gather from the name, the chip can actually be programmed while it is still on its board. This is very important for our little business card, considering it will be a tiny surface mount chip that can't be placed in any normal socket. Further, we will have the ability to\u00a0reprogram it at will without \u00a0the need to desolder it\u00a0every time.  With the PIC, the programmer puts the chip in a high voltage programming mode and it works surprisingly well assuming the rest of the circuit is relatively isolated from the programming pins.  For ICSP to work there needs to be some way of\u00a0connecting the programmer to the right pins on the PIC. Most through hole PCB designs use a connector soldered to the board, but in our case we need a cheap, flat solution that doesn't need a connector. That's where the programming jig comes in.The Programming Jig _______________________________________________________________________  I had to make several programming jigs over the course of the project, depending on what stage the prototype was in.The first one simply used a scrap prototype board with SMD pads for the IC and wires to the traces coming out of the appropriate pins. Then I just positioned the chip and hold it down with my finger while it is being programmed, taking care not to short out the leads. I also tried placing a magnet underneath the board to hold the chip in place.  The final solution relies on a clever little mechanical connector called a \"pogo pin.\" It is essentially just a spring-loaded pin that makes a good temporary contact against the circuit board. They are a little fragile, but they work very well. It helps if the circuit board was planned with this in mind, as you need contact pads connected to the proper pins. With ICSP it is important to have the programming pins isolated from the rest of the circuit and connected directly\u00a0to the PIC, since it could disrupt the programming signals.Building the Improved Jig _______________________________________________________________________  There are simpler ways of doing this, and certainly lazier ways, but nothing beats a dedicated jig. The one I built uses a hinged transparent lid with pogo pins mounted in the acrylic. The lid locks down with two rows of neodymium magnets and presses the pogo pins firmly down against the programming pads. It also presses the momentary power button, since the PCB layout was changed after the programmer was built; the switch needs to be pressed to connect pin 1 to the programming pad.  The base of the unit uses a scrap chunk of black acrylic and the cover is a a clear piece that helps in lining up the connections when a board is inserted. over the place it needs to bend. The PCB is held firmly in a\u00a0predictable\u00a0place with two PCB rails cut to the proper length, and there is a spacer insert that both raises the board up to the right height and stops the PCB in the proper position when it is pushed in. Using a hole saw, I cut a semicircle out of both the pacer and the black frame so that the card can be easily grasped for removal.  For the lid to line up parallel to the rest of the unit it needs to be bent at a slight angle. This is easy to do with a blowtorch. With the lid attached to the black frame on its hinge, run the torch back and forth from about 2 inches away. Take care not to heat it too long or get too close as it will scorch, so practice on a piece of scrap first. When it becomes malleable bend it down over the card guides and until it sits flush against the top of them. Hold it in place until it does not move back, then leave it to cool. Be sure to do this outside or near a window as the plexi will fume as it is heated.  The holes for mounting the pogo pins were drilled into the lid of the unit using a drill press. I made a template for the holes and printed it on transparency film. Slide them in one by one and make sure it lines up with the right pad on the board.\u00a0 With the lid shut,\u00a0 press the the pin down to a depth that will push the spring-loaded poker in a little more than halfway in. Then mark the depth with a sharpie and add a blob of solder to either side of the pin. It should not move up and down, add a dab of glue to keep it from wiggling in any direction.  Connect the ICSP wires to the pogo pins with the pogo holders counting from the marked red wire, to these pins on the PIC:ICSP\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PIC Pin   1 .............. 4  2 .............. 1  3 .............. 8  4 .............. 7  5 .............. 6  Once it's complete, connect the programmer, slide in a populated board, and snap the lid down. It's ready to program! Be sure to remove the coin cell battery from it's holder or the programmer is toast; there is no protection on its output pins so any external current will likely destroy it. A simple fix is to put a bumper in the lid of the programmer that would stop the lid from closing if it ran into a battery.PartsiCP01 USB In-Circuit Serial Programmer   Scrap acrylic or polycarbonate  Miniature Neodymium magnets\u00a0(2.5 x 1mm) (x 14)  Pogo Pin holder (x 5)Pogo Pin, round tipped (x 5)   2\" hinge     5-pin header connector     Circuit board slide-in mounting rails, left and right     Rubber feet (x 4)     Assorted screws & bolts Tools & Supplies   Soldering Iron & solder     Power drill or drill press     1 1/4\" holesaw     Blowtorch     #2 Screwdriver     Hacksaw     Superglue     Printable transparency paper     Tape ", "step_imgs": ["https://cdn.instructables.com/FR2/7K87/GLPH1QXY/FR27K87GLPH1QXY.LARGE.jpg", "https://cdn.instructables.com/FHM/SISQ/GLQCLF38/FHMSISQGLQCLF38.LARGE.jpg", "https://cdn.instructables.com/FC0/87WK/GLGCJLKA/FC087WKGLGCJLKA.LARGE.jpg", "https://cdn.instructables.com/F0S/50HO/GLGCJYUS/F0S50HOGLGCJYUS.LARGE.jpg", "https://cdn.instructables.com/FOO/OS2R/GLL4ZPFT/FOOOS2RGLL4ZPFT.LARGE.jpg", "https://cdn.instructables.com/FLW/V9YB/GLPH1QXG/FLWV9YBGLPH1QXG.LARGE.jpg", "https://cdn.instructables.com/FU2/WICE/GLPH1QXK/FU2WICEGLPH1QXK.LARGE.jpg", "https://cdn.instructables.com/F60/C2FI/GLQCLF2Y/F60C2FIGLQCLF2Y.LARGE.jpg", "https://cdn.instructables.com/FUK/1VQY/GLPH1QXM/FUK1VQYGLPH1QXM.LARGE.jpg", "https://cdn.instructables.com/FVG/I1TK/GLQCLF2W/FVGI1TKGLQCLF2W.LARGE.jpg", "https://cdn.instructables.com/FQP/C62S/GLPH1QXI/FQPC62SGLPH1QXI.LARGE.jpg", "https://cdn.instructables.com/FKO/RJW1/GLQCLF2X/FKORJW1GLQCLF2X.LARGE.jpg", "https://cdn.instructables.com/FYY/9IJ2/GLPH1QXJ/FYY9IJ2GLPH1QXJ.LARGE.jpg", "https://cdn.instructables.com/FPL/B8V1/GLQCLF2Z/FPLB8V1GLQCLF2Z.LARGE.jpg", "https://cdn.instructables.com/FUM/B524/GLQCLF2U/FUMB524GLQCLF2U.LARGE.jpg", "https://cdn.instructables.com/F75/1ZDE/GLQCLF30/F751ZDEGLQCLF30.LARGE.jpg", "https://cdn.instructables.com/F4I/1TIX/GLL4ZPJG/F4I1TIXGLL4ZPJG.LARGE.jpg", "https://cdn.instructables.com/FL5/CVWK/GLPH1QXN/FL5CVWKGLPH1QXN.LARGE.jpg", "https://cdn.instructables.com/F1N/0D16/GLPH1QXH/F1N0D16GLPH1QXH.LARGE.jpg", "https://cdn.instructables.com/F92/YN9E/GLPH1QXL/F92YN9EGLPH1QXL.LARGE.jpg", "https://cdn.instructables.com/F4Q/RZKK/GLL4ZPHX/F4QRZKKGLL4ZPHX.LARGE.jpg", "https://cdn.instructables.com/FK7/OJSI/GLQCLF2V/FK7OJSIGLQCLF2V.LARGE.jpg", "https://cdn.instructables.com/FP8/3E99/GLPH1QXO/FP83E99GLPH1QXO.LARGE.jpg", "https://cdn.instructables.com/FSP/WQNR/GLQCLF31/FSPWQNRGLQCLF31.LARGE.jpg", "https://cdn.instructables.com/F4Q/JCBC/GLQCLF2S/F4QJCBCGLQCLF2S.LARGE.jpg", "https://cdn.instructables.com/FGT/30KO/GLPH1QXF/FGT30KOGLPH1QXF.LARGE.jpg", "https://cdn.instructables.com/FBN/57MK/GLL4ZS4K/FBN57MKGLL4ZS4K.LARGE.jpg", "https://cdn.instructables.com/F57/DLIG/GLPH1QXP/F57DLIGGLPH1QXP.LARGE.jpg", "https://cdn.instructables.com/F21/B83Q/GLQCLF32/F21B83QGLQCLF32.LARGE.jpg", "https://cdn.instructables.com/FTM/6MT2/GLPH1QXQ/FTM6MT2GLPH1QXQ.LARGE.jpg", "https://cdn.instructables.com/FIJ/JOXQ/GLL4ZPQG/FIJJOXQGLL4ZPQG.LARGE.jpg", "https://cdn.instructables.com/FUE/ZTMU/GLPH1QXR/FUEZTMUGLPH1QXR.LARGE.jpg", "https://cdn.instructables.com/FBM/SD4Q/GLPH1QXT/FBMSD4QGLPH1QXT.LARGE.jpg", "https://cdn.instructables.com/FYA/LMR0/GLL4ZPVB/FYALMR0GLL4ZPVB.LARGE.jpg", "https://cdn.instructables.com/F6P/MB4D/GLL4ZPS6/F6PMB4DGLL4ZPS6.LARGE.jpg", "https://cdn.instructables.com/FGV/6R16/GLPH1QXS/FGV6R16GLPH1QXS.LARGE.jpg", "https://cdn.instructables.com/FDX/4GXW/GLQCLF34/FDX4GXWGLQCLF34.LARGE.jpg", "https://cdn.instructables.com/FNA/IBKC/GLL4ZPXB/FNAIBKCGLL4ZPXB.LARGE.jpg", "https://cdn.instructables.com/FSH/JTEH/GLPH1QXU/FSHJTEHGLPH1QXU.LARGE.jpg", "https://cdn.instructables.com/FKK/QFV2/GLL4ZPZG/FKKQFV2GLL4ZPZG.LARGE.jpg", "https://cdn.instructables.com/FAT/CQ2F/GLQCLF35/FATCQ2FGLQCLF35.LARGE.jpg", "https://cdn.instructables.com/FEF/1K99/GLPH1QXW/FEF1K99GLPH1QXW.LARGE.jpg", "https://cdn.instructables.com/FQV/IX7J/GLPH1QXV/FQVIX7JGLPH1QXV.LARGE.jpg", "https://cdn.instructables.com/FM3/2ANT/GLQCLF37/FM32ANTGLQCLF37.LARGE.jpg", "https://cdn.instructables.com/FNK/4L2X/GLL4ZQ41/FNK4L2XGLL4ZQ41.LARGE.jpg", "https://cdn.instructables.com/FKR/GVXW/GLPH1QXX/FKRGVXWGLPH1QXX.LARGE.jpg"], "step_title": "Step 12: Build a ICSP Jig"}, {"step": 13, "steps_text": "\n          The board now complete, we have only to give it a program to run, and we will be ready to set our creation free into the wild! The PIC can be programmed either in C++ or assembly language. I chose C++, to mostly to save time, but also because I didn't\u00a0necessarily\u00a0want to commit to this architecture, and admittedly, assembly languages are no fun!\u00a0For simplicity, I developed the board using the DIP PIC12F509, which is pin compatible with the 508. It is also larger and easier to manipulate for testing purposes, and I found that it had more memory than I needed, so I was able to downgrade the chip for the final product.How the POV Card works _______________________________________________________________________  The card is off until the momentary on switch is held down. On power up, the program simulates a little rolling ball with a binary counter that rolls in and out with the tilt of the card. After roughly four tilts back and forth, it then switches to Persistence Of Vision mode and cycles through a series of programmed patterns. Currently, it says my name, followed by a neat square wave pattern that acts as a separator, and then my phone number. When the tilt switch closes, the program recognizes that as the start of a wave, and plays the current pattern one time through, then waits until another wave starts. As long as the wave does not double back too soon, and the pattern is not too long, there will be no overlap as the pattern will be blank until it resets.The Patterns _______________________________________________________________________   Each pattern is an array of bytes, each byte a column in the sequence. The time that each column (frame) in the pattern is left on and the time between frames determines the speed of the display, and how close the frames are spaced when the card is waved. Basically, it changes the width of the\u00a0characters and the pattern as a whole.\u00a0Furthermore, the speed at which you wave the card also plays a part in the spacing, but not enough to make it illegible; since it changes frames at a constant rate, the variation is not enough to matter, but is enough to make it look dynamic. Neat, huh?  To create the patterns, I modified a script I found \u00a0written by Andrew Mason. My version\u00a0is\u00a0customized\u00a0to allow for alternate byte formatting and number of LEDS, but the LED placement is fixed, for the time being. You can make any pattern you want, provided it is small enough to fit in the PICs memory. The rate that the pattern plays back at can be changed in the code, as well.  \u00a0The Program  _______________________________________________________________________  The code is very simple. Without PWM or interrupts, there were not very many tricky things I could do, even if I wanted to. Conserving space and\u00a0optimizing\u00a0made it a little more interesting, though, given the tweaking\u00a0necessary\u00a0to make the code fit in the PICs tiny memory.  To play a pattern, the PIC simply checks for the tilt switch to be activated, then loops through a pattern. It sets the GPIO outputs to the current byte in the array, which represents a frame, waits a set period, then increments the array. Once the pattern has played all the way through, it blanks the display and waits until the tilt switch has been activated. This indicates another wave has started, and it goes through the pattern once more.\u00a0  The frame code looks like this, without quotes : \"0b00000000,\". The 0b delineates a byte and the comma separates each byte from the next. This is all placed inside an array of constants, since it won't be changing during the playback and that will save RAM. Five of the bits in the array indicate an LED output, while one is unused and one is a read-only bit used for the input pin. The bits used are:\u00a00bXX12X543, where the number indicates the pin.  \u00a0The Code  _______________________________________________________________________  #include <htc.h>  #include <stdlib.h>\n\t__CONFIG(MCLRE_OFF & WDT_OFF & CP_OFF & OSC_IntRC);\nconst char waveform[] = { /* 0bXX12X543 - sets pin at number, to output high, e.g.: \n0b00100111, complete array code omitted for space; see attached .c file for complete code */ };\nconst char binary[] = { /* code omitted */ };\nconst char name[] = {/* code omitted */};\nvoid init(void) {\n\tOPTION = 0b01000111;\n\t//sets pin 2,3,5,6,7 output, pin 4 input\n\tTRIS = 0b00001000;\n}\nvoid display_roll (const char p[], const char pattern_length) {\n\tchar i = 0;\n\tfor (unsigned int j = 0; j < 350; j++) {\n\t\t//plays pattern forwards or backwards depending on tilt\n\t\tif (GP3 == 0 && i < pattern_length) { i++; } else if (GP3 == 1 && i > 0) { i--; } \n\t\tGPIO = p[i]; //sets LED outputs to current frame in current pattern\n\t\t_delay(16000); //frame delay in number of cpu cycles\n\t}\n}\nvoid display_pattern (const char p[], const char pattern_length, const char loops, const char speed) { \n\tfor (char i = 0; i < loops; i++) {\n\t\t//exits display either at swing restart\n\t\tfor (char j = 0; j < pattern_length && GP3 == 1; j++) {\n\t\t\tGPIO = p[j];\n\t\t\t//frame delay in multiples of 10 microseconds :)\n\t\t\tfor (char k = 0; k < speed; k++) { _delay(40); }\n\t\t}\n\t\tGPIO = 0b00000000; //blank output so pattern doesn't overlap while swinging back to start\n\t\twhile (GP3 == 1); //if still waving, wait until swing restarts and switch contacts \n\t\t_delay(5000); //lazy debounce\n\t}\n}\nvoid main(void) {\n\tinit();\n\tdisplay_roll(binary, 31);\n\twhile (1) {\n\t/* function variables are: pattern name, length of pattern (in bytes/frames), \n\tnumber of loops, speed of display/framerate */\n\t\tdisplay_pattern(name, 69, 110, 25); \n\t\tdisplay_pattern(waveform, 71, 100, 25);\n\t\tdisplay_pattern(number, 61, 110, 25);\n\t}\n}Programming the Board _______________________________________________________________________   All code was written in Notepad++, an excellent free multi-language editor. You will also need the MPLAB IDE with a copy of the HI-TECH C Compiler. Both are available in free versions.  You will need a copy of Microchip's PICKit 2 programming software. With the chip connected and the iCP01 plugged in, set the device family to \"Baseline\" and select PIC12F508 from the device dropdown. Then load the hex file and press the write button.  \u00a0ReferencesPIC12F508/509/16F505 DatasheetHi-Tech C 9.81 Compiler User GuidePOVgen\u00a0online LED Pattern GeneratorHi-Tech C ComplilerMPLAB Integrated\u00a0Development\u00a0EnvironmentTools & SuppliesPIC12F508 I/SN\u00a0SOIC\u00a0or PIC12F508 I/P\u00a0DIP microcontroller  USB In-Circuit Serial Programmer (iCP01)   Breadboard     8-pin SMD IC breakout board, or extra unpopulated PCB ", "step_imgs": ["https://cdn.instructables.com/F39/2619/GLFUDYWT/F392619GLFUDYWT.LARGE.jpg", "https://cdn.instructables.com/FE8/2UFC/GLHRYX42/FE82UFCGLHRYX42.LARGE.jpg", "https://cdn.instructables.com/FHL/ZNN4/GLFUE0PF/FHLZNN4GLFUE0PF.LARGE.jpg", "https://cdn.instructables.com/FR2/7K87/GLPH1QXY/FR27K87GLPH1QXY.LARGE.jpg", "https://cdn.instructables.com/FR4/JX5X/GLQCL9WW/FR4JX5XGLQCL9WW.LARGE.jpg"], "step_title": "Step 13: Program the PIC"}], "channel": "LEDs"}, {"category": "technology", "description": "Electronic market is full of devices called pedometer and fitness tracker. They counts the number of steps you have taken, distance you have covered, whether you are walking or running and bunch of other stuff. Ever wondered, how these devices perform such measurements.I decided to make one on my own and share the knowledge of making it with guys. In this instructable we will develop accelerometer data accumulator and an algorithm, intelligent enough to identify whether you are walking or running.  I decided to go with machine learning. Machine learning is a sub-field of computer science which explores the study and construction of algorithms that can learn from data, and the derived algorithm is then used to make predictions on data. I am going to walk you through them step by step and believe me these things are easy to learn.Lets get started.", "title": "Distinguish Walking and Running Using Machine Learning ", "url": "https://www.instructables.com/id/Distinguish-Walking-and-Running-Using-Machine-Lear/", "section": "technology", "steps": [{"step": 1, "steps_text": "We need to develop an algorithm to identify walking and running. Machine learning approach says we need data to develop this algorithm. Which data? Data that we will be using to develop this algorithm is accelerometer data. What are these accelerometers? . These are electronic devices which can measure proper acceleration. Proper acceleration is not the same as coordinate acceleration which is \"rate of change of velocity\". For example, an accelerometer at rest on the surface of the Earth will measure an acceleration g=9.81m/s2 straight upwards. By contrast, accelerometers in free fall (falling towards the center of the Earth at the rate of about 9.81m/s2) will measure zero.We will proceed as follows.Design of electronics to accumulate data.      Collecting accelerometer data(detail of accelerometer, in following steps).       Develop algorithm.      Test algorithm.", "step_imgs": [], "step_title": "Step 1: Plan"}, {"step": 2, "steps_text": "First thing to consider in design of data accumulator is that, it should be a wearable device with data storing capability. Next, Where are we going to wear this wearable device?. Making wearable small enough to were on wrist is expensive, so I decided to make a wearable small and light enough to wear on ankle.I think this is a cost effective decision. Also accelerometer readings near ankle compared to wrist, will make our algorithm design easy.", "step_imgs": ["https://cdn.instructables.com/FC6/RFLA/IKJ8BLUG/FC6RFLAIKJ8BLUG.LARGE.jpg"], "step_title": "Step 2: Design of Electronics to Accumulate Data (step 1): Intro"}, {"step": 3, "steps_text": "Following is the list of things we will need to design data accumulator device.Arduino duemilanove/uno (This is what I used, I suggest you use Arduino Nano),       Accelerometer ADXL345 breakout board,       Micro SD card (1 GB will do),       Micro SD card reader module with level conversion chip,       Few Male berg strip,       General purpose circuit board,       4 AA battery holder,       4 AA batteries (This is what I used, I suggest you use smaller 5V Lipo battery),       Few small single core wires,     USB A to B cable (connecting arduino to PC),     Styrofoam for packing and     Tape for packing.Following is the list of software we will need.Arduino IDE (freeware) and     GNU Octave (freeware)If you have doubt regarding any component, just look at the Images or the video(its a \"timed\" video with starting point, where I discuss the required electronics component).", "step_imgs": ["https://cdn.instructables.com/F9S/N0PB/IKJ8BGZO/F9SN0PBIKJ8BGZO.LARGE.jpg", "https://cdn.instructables.com/FYR/DMFU/IKJ8BGZQ/FYRDMFUIKJ8BGZQ.LARGE.jpg", "https://cdn.instructables.com/FNC/ABEO/IKJ8BGZP/FNCABEOIKJ8BGZP.LARGE.jpg", "https://cdn.instructables.com/FR6/0AZG/IKJ8BGZV/FR60AZGIKJ8BGZV.LARGE.jpg", "https://cdn.instructables.com/FKK/1F5I/IKJ8BGZX/FKK1F5IIKJ8BGZX.LARGE.jpg", "https://cdn.instructables.com/FQC/OGUZ/IKJ8BGZY/FQCOGUZIKJ8BGZY.LARGE.jpg", "https://cdn.instructables.com/FS5/RR3B/IKJ8BGZZ/FS5RR3BIKJ8BGZZ.LARGE.jpg", "https://cdn.instructables.com/FXP/Z0T9/IKMXDW0G/FXPZ0T9IKMXDW0G.LARGE.jpg", "https://cdn.instructables.com/FKK/CJ76/IKMXDW0J/FKKCJ76IKMXDW0J.LARGE.jpg"], "step_title": "Step 3: Design of Electronics to Accumulate Data (step 2): Things Needed"}, {"step": 4, "steps_text": "In this step we will put all parts together. Connect as per the fritzing sketch image attached. Following is the description of the same.For ADXL345 breakout board.Connect SDA and SCL pins of breakout board to pin A4 and A5 on Arduino duomilenove/UNO.( Note:- if board that you are using has I2C pins of arduino board some where else, connect I2C pins of breakout board there.  )        Connect CS pin of breakout board to 5V pin of Arduino.        Connect Vcc and GND pins of breakout board to 5V and GND pins of Arduino. For Micro SD card reader board.Connect MOSI pin of SD card reader to pin no 11 of arduino duomilenove/UNO.        Connect MISO pin of SD card reader to pin no 12 of arduino duomilanove/UNO.        Connect SCK pin of SD card reader to pin no 13 of arduino duomilanove/UNO.        Connect CS pin of SD card reader to pin no 10 of arduino duomilanove/UNO.Connect Vcc and GND pins of SD card reader to pin 5V and GND  pins of arduino duomilanove/UNO.NOTE:- If you are using any other arduino board connect according to schematic of your arduino board.I have attached images of my data accumulator device.If still in doubt just look at attached video.", "step_imgs": ["https://cdn.instructables.com/F3C/XMSH/IKJ8BMLY/F3CXMSHIKJ8BMLY.LARGE.jpg", "https://cdn.instructables.com/FIV/1CNS/IKJ8BGZL/FIV1CNSIKJ8BGZL.LARGE.jpg", "https://cdn.instructables.com/F1W/NZDK/IKJ8BH00/F1WNZDKIKJ8BH00.LARGE.jpg", "https://cdn.instructables.com/FKI/TFPW/IKJ8BH03/FKITFPWIKJ8BH03.LARGE.jpg", "https://cdn.instructables.com/FZX/1VYN/IKJ8BH1D/FZX1VYNIKJ8BH1D.LARGE.jpg", "https://cdn.instructables.com/FJP/E72H/IKJ8BH01/FJPE72HIKJ8BH01.LARGE.jpg"], "step_title": "Step 4: Design of Electronics to Accumulate Data (step 3): Putting Things Together"}, {"step": 5, "steps_text": "Now as hardware is ready, lets code.I have attached data accumulation code, this code stores reading of 3 axis accelerometer ADXL345 in an SD card every 1 sec for 1 minute. I know this is way below the rate at which we will collect training data, this is just a test code. If you want you can change the rate by editing the 'delay' statement at the end of loop() code and change the duration of logging by changing 'measurements_to_take' variable at the beginning of the code. ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: Design of Electronics to Accumulate Data (step 4):Codeing"}, {"step": 6, "steps_text": "In this step we will place our data collecting device near ankle and collect the data. Small amount of preparation is needed to make sure that you don't hurt your self from edges of battery holder, sharp projections from arduino or breakout board.To avoid getting hurt, I stuffed some Styrofoam between my ankle and battery holder as you can see in attached images. For stacking up electronics and making sure that there is no short between them, I again used Styrofoam. I advice wearing sock while collecting data.Finally I wrapped up everything together with a tape as shown in images and stuck it to my ankle. Please note down the orientation of your accelerometer, so that each time you remove and stick it again accelerometer orientation remains the same. I mean we can develop an algorithm that takes care of random orientation but for beginning I suggest keeping the orientation fixed.PS: I know this is not the way to pack a thing, but box that I ordered could not accommodate this assembly, hence this tape method.", "step_imgs": ["https://cdn.instructables.com/FSA/1U3P/IKMXDTXA/FSA1U3PIKMXDTXA.LARGE.jpg", "https://cdn.instructables.com/F0I/Z54T/IKMXDTXD/F0IZ54TIKMXDTXD.LARGE.jpg", "https://cdn.instructables.com/FOA/JVR9/IKMXDU4K/FOAJVR9IKMXDU4K.LARGE.jpg", "https://cdn.instructables.com/F84/H813/IKMXDTXJ/F84H813IKMXDTXJ.LARGE.jpg", "https://cdn.instructables.com/F8O/9WLV/IKMXDTXK/F8O9WLVIKMXDTXK.LARGE.jpg", "https://cdn.instructables.com/F7S/2YF4/IKMXDTZM/F7S2YF4IKMXDTZM.LARGE.jpg"], "step_title": "Step 6: Collecting Accelerometer Data (step 1): Wearing the Accumulator"}, {"step": 7, "steps_text": "After wearing, roam around and collect walking and running data. If you want you can make changes in the code, in order to get desired rate of data and duration of data collection. I have added comments in the code for easy editing.I have attached the arduino code.For better understanding of code just download it and have a look,I have added comments to make it self explanatory, if still in doubt look at timed video attached.Make your friends wear it (though they will resist if you pack things like me ;) ) and collect data. I am attaching few readings that I have taken.In arduino code, I used serial monitor for debugging purpose you can disable it to get data at faster rate. ", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 7: Collecting Accelerometer Data (step 2): Roaming Arround"}, {"step": 8, "steps_text": "Now that we have some data, lets try to develop our algorithm that can distinguish running and walking.We will be using something called \"Logistic regression\" to distinguish walking and running, strictly speaking it will distinguish walking from the rest, but in out data set we only have running besides walking. Basic Idea behind Machine learning is to find a characteristics which can distinguish set of things, for example you want to distinguish banana form apple, which characteristic do you choose?. We can choose color and shape as their characteristics. So if you are given color and shape of some unknown thing you can identifying whether its a banana or an apple. Similarly we need a set of characteristics that can distinguish walking and running.To find these characteristics we need to visualize the data. I am attaching an octave( Install Octave first:  https://www.gnu.org/software/octave/download.html... ) script to visualize data that I have attached in previous step(PS: you need to make few changes before running this script, changes are mentioned in next line).In visualize.m script make sure that you change the path, and point to location of your data file.If you have any doubt regarding visualize.m just look up this attached video. In attached video I visualized the data that I have collected. On visualizing you can come out with characteristics that can distinguish walking and running, I decided to go with dominant frequency and average absolute peak value. Make sure that you look at the plots and agree with what I am saying.       ", "step_imgs": ["https://cdn.instructables.com/FLP/N1VR/IKOAPV5D/FLPN1VRIKOAPV5D.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Developing Algorithm (part 1 ): Finding Characteristics "}, {"step": 9, "steps_text": "As I have already mentioned, ML (Machine learning) is a kind of pattern recognition thing. It separates 2 or many groups depending on their characteristics. For example if I have bunch of paired numbers {(1,4),(6,3),(5,2)...(X,Y)}, I want to separate them in to two groups, one containing pair that has number of sum less then 6 and other group contain the rest. A simple line with equation X+Y < 6 will do our job. In our case X and Y will be Dominant frequency and average absolute peak values. In the visualize script, that I have attached in previous step, besides just visualizing data, It helps in computing these two parameters also.Dominant frequency is computed using FFT algorithm.(https://en.wikipedia.org/wiki/Fast_Fourier_transfo...)On running Visualize script you will get results for Dominant frequency and average absolute peak values. Copy them and paste in one text file, In following format. Dominant_frequency_1,average_absolute_peak_values_1,0/1 ...0/1 in the place after second comma tells the Logistic regression method whether the characteristics are of walking data or running data. 1 for walking and 0 for running. please look at the sample file that I have attached for proper formatting.What Logistic regression does is that, it tries to separate out this walking and running data with the help of a straight line. Shown in Image. How does it know that this line will separate these two data set?. Here jumps in the MATHEMATICS. It is a bit difficult to explain it in writing, but I am attaching a video tutorial on Logistic regression by Andrew Ng, who is an expert in this field.In next step I will talk about scripts, which you can use on your own data, to get the algorithm which is nothing but a straight line separating these 2 data sets.", "step_imgs": ["https://cdn.instructables.com/FP4/DNJM/IKOAQ7JO/FP4DNJMIKOAQ7JO.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 9: Developing Algorithm (part 2 ): Applying Logistic Regression"}, {"step": 10, "steps_text": "I am attaching scripts needed to develop a line that separate out 2 data sets. PS: Change the path to the data file(which you created in previous step) in script named ML_algo.m, by default the script will point to my sample data file. Put all the files attached in one folder and execute ML_algo.m file. Look up the attached video to see the explanation and execution the ML_algo.m file.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 10: Developing Algorithm (part 3 ): Coding "}, {"step": 11, "steps_text": "Execute following command in Octave to predict the probability of data belonging to walking set:prob = sigmoid([1 test_Dominant_frequency  test_average_peak_value] * theta); example:- prob = sigmoid([1 2.5656 423.5656] * theta);I did few trials, just have a look at video attached.So, This is how things are done using Machine learning, I encourage you guys to try and collect more data and try out various other stuff like separating cycling from walking etc. I hope this was a learning experience. I encourage you to post few data set in the comment part so that other people can use it for generalizing their algorithm.Thanks for your time.", "step_imgs": [], "step_title": "Step 11: Testing Algorithm "}], "channel": "Electronics"}, {"category": "technology", "description": "SssssssssssBOOM!!! You died. Respawn?Whoops. I suppose a diamond sword would have been a good idea. These torches have terrible attack damage, don't you think?I know sentries are nothing new. Neither are creepers. But the two combined? I haven't seen that yet, have you? Probably not. And that is the basis of this project.Background Story: I'm obsessed with LEDs, Arduino, and Robotic Stuff. And explosions are cool too. I don't actually play Minecraft that much, but I do see the merit it holds as an educational and creative stimulant. And it gives me an excuse to blow stuff up. Without blowing anything up. Which is cool. Anyway, I wanted to create something robotic that has LEDs and can explode without exploding. And then I saw the Minecraft Challenge here on Instructables, and knew I just HAD to make a creeper.So what is this thing anyway?We will be building a small robotic 'creeper' that acts as a sentry and will blink red and hiss when something gets too close.  I want to make it entirely open source, and I also want to make it cheap so anyone can build it (and because my ROB project was expensive).After starting the build, I decided to make it capable of operating in different 'modes', aside from just being a sentry. As of now, I have added a standby mode in which it essentially becomes an RGB \"breathing\" nightlight, two versions of the sentry mode, one where it hisses, and one where it just beeps, and an object following mode where it will follow the first object it sees within a pre-specified range. Whew! Did I get everything? Nope, wait, one more thing. Potential upgrades are an explosion sound effect (which is really hard to get right, I've been trying for months now), and a motor driver,  internal battery and wheels so it can have a fifth mode for obstacle  avoidance.But how do I build it?Well, follow along, and let's see how this one turns out.", "title": "Minecraft Creeper Sentry With Arduino Uno, Ultrasound and LEDs", "url": "https://www.instructables.com/id/Minecraft-Creeper-Sentry-With-Arduino-Uno-Ultrasou/", "section": "technology", "steps": [{"step": 1, "steps_text": "Always, always, always gather materials before starting a project. That way you never have to shelf it for later because you don't have something vital.You will need:CardboardPrinter Paper1x Arduino Uno1x 9-gram Servo and servo horn1x HC-SR04 or equivalent ultrasonic sensor1x Buzzer (passive)4x RGB LEDs (Common Cathode)7x LONG male-male jumper wires (the longest ones in the standard Dupont assortments will do)Lots of male-male jumper wires (any size will do)4x male-female jumper wires1x external power source (at least 5 volts and 1 amp)Acrylic Paint:Apple Barrel Plaid \"Leaf Green\" 20528Delta Ceramcoat \"Sunshine Pearl\" 02615Delta Ceramcoat \"Phythalo Green\" 02501Apple Barrel Plaid \"Black\" 20504Apple Barrel Plaid \"Pewter Grey\" 20580", "step_imgs": [], "step_title": "Step 1: Gathering Materials"}, {"step": 2, "steps_text": "So, we need to have somewhere to mount everything. And it needs to look like a creeper. I wish I could 3D print this, but alas, cardboard is all I've got. (I seem to mention this a lot, don't I?)Step 1: CuttingCut out:1x rectangle 2.5 inches x 5 inches  - Label this \"A1\"4x rectangles 2.75 inches x 2.5 inches - Label these \"B1\" through \"B4\"4x rectangles 2.75 inches x 5.75 inches - Label these \"C1\" through \"C4\"6x rectangles 2.25 inches x 4.75 inches - Label these \"D1\" through \"D6\"2x squares 2.75 inches x 2.75 inches - Label these \"E1\" and \"E2\"1x square 4.25 inches x 4.25 inches - Label this \"F1\"Step 2: GluingHeat up your glue gun, and use the schematics and pictures above to create the feet, head, and the main body.Step 3: Access HatchCut and glue small strips of cardboard about 1/2 inch wide around the perimeter of the last rectangle of cardboard. This piece will be our door. (Don't mind the electronics in the picture, I took it after I finished the creeper because all of my pictures from during the build are terrible.)Use a strip of printer paper and glue to create a hinge, and attach the door to the body so that it will close nicely, but requires a little force to open. (Again, ignore the paint.)Now you can move on to the circuitry!", "step_imgs": ["https://cdn.instructables.com/FA3/WQG3/JDOUV70C/FA3WQG3JDOUV70C.LARGE.jpg", "https://cdn.instructables.com/FBN/6OYB/JDOUV6ZZ/FBN6OYBJDOUV6ZZ.LARGE.jpg", "https://cdn.instructables.com/FWA/I82A/JDOUV70D/FWAI82AJDOUV70D.LARGE.jpg", "https://cdn.instructables.com/FTB/HOOI/JDOUV708/FTBHOOIJDOUV708.LARGE.jpg", "https://cdn.instructables.com/FZC/L8J6/JDOUV70B/FZCL8J6JDOUV70B.LARGE.jpg", "https://cdn.instructables.com/FRF/W0R6/JDOUV70E/FRFW0R6JDOUV70E.LARGE.jpg", "https://cdn.instructables.com/F6M/QFJ8/JDOUV78D/F6MQFJ8JDOUV78D.LARGE.jpg", "https://cdn.instructables.com/F0S/QPTD/JDOUV78E/F0SQPTDJDOUV78E.LARGE.jpg"], "step_title": "Step 2: The Frame"}, {"step": 3, "steps_text": "This part gets a bit tricky. I designed PCBs for this step, although I don't have a way of getting them manufactured myself. I'll attach them here, though, so you can use them if you like. (Sorry I don't have any circuit schematics this time around... Maybe I'll add them later if I have time.)Note: I have two pushbuttons, and tell you how to assemble it with both. However, the code only uses the one on A1, and the other one is a spare I originally intended to use to switch the colors in Standby Mode.Step 1: The ArduinoOn a mini breadboard, bread the two pushbuttons, the buzzer and the potentiometer.Connect one side of each button to one side pin on the potentiometer.Connect the same side pin I just mentioned to Ground on the Arduino and the negative side of the buzzer.Connect the other side of the potentiometer to 5V on the Arduino.Connect the center pin of the potentiometer to A0 on the Arduino.Connect the open sides of the pushbuttons to A1 and A2 on the Arduino.Connect the positive side of the buzzer to A5 on the Arduino.Connect a jumper from the 5V pin of the Servo to the positive side of the potentiometer.Connect a jumper from the negative pin of the Servo to Ground on the Arduino.Connect a jumper from the Signal pin of the Servo  to pin 9 on the Arduino.Step 2: the Lights and UltrasoundOn a second mini breadboard, bread 4 RGB LEDs in the corners. Connect the Red, Green, Blue, and Ground pins of the LEDs together to form a common Red, Green, Blue and Ground pins, respectively. Connect 4 male-female Dupont jumpers to the HC-SR04.Connect GND from the HC-SR04 to the common ground, and bread the other 3 pins in their own respective rows of the breadboard.Step 3: Two Square Holes and a BoxFrom a scrap piece of cardboard, cut out a rectangle about the same size as the mini breadboard. Cut out strips about 1/4 inch wide and glue these to the perimeter of the rectangle. Glue the box you just created in a the center of the head, over the servo horn.Rotate the head section to the center position, i.e. until it is looking forward (although it doesn't have eyes yet)Using a long blade on an X-Acto knife, cut a square hole next to the box, through the head and the top of the body simultaneously. In other words, cut through to the inside of the body of the creeper.Step 4: WiresFirst, peel off the waxy paper and stick the breadboard with the lights on top of the box we made in the last step.Now, get out 7 of the longest Dupont jumper cables you have. About 6 inches apiece should be fine, or you can solder two or three shorter ones together.Attach one of these each to the Red, Green, Blue, Trig, Echo, VCC, and Ground rows on the top mini breadboard.Thread these through the holes we made in the last step. Connect the VCC wire to the positive pin on the potentiometer on the second breadboard. Connect the Ground wire to one of the open Ground pins on the Arduino.Connect the Trig wire to pin 4 on the Arduino.Connect the Echo wire to pin 5 on the Arduino.Connect the Red wire to pin 6 on the Arduino.Connect the Green wire to pin 11 on the Arduino.Connect the Blue wire to pin 3 on the Arduino.Gently twist the head in both directions until the servo reaches its limit. With the arduino and the mini breadboard inside the body, the wires should never become pinched or taut. If they do you will need to make them longer (i.e. you will need to solder another small jumper wire to the end of the current one).Now you can attach the top of the head!", "step_imgs": ["https://cdn.instructables.com/FBJ/D6H3/JDOUV78F/FBJD6H3JDOUV78F.LARGE.jpg", "https://cdn.instructables.com/F7S/UE02/JDOUV73X/F7SUE02JDOUV73X.LARGE.jpg", "https://cdn.instructables.com/FF7/RT2C/JDOUV74F/FF7RT2CJDOUV74F.LARGE.jpg", "https://cdn.instructables.com/FZ1/VZ2H/JDOUV74P/FZ1VZ2HJDOUV74P.LARGE.jpg", "https://cdn.instructables.com/FUB/EPU9/JDOUV74G/FUBEPU9JDOUV74G.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: The Circuits!"}, {"step": 4, "steps_text": "So, the part I've been referring to as the head isn't really a head yet, just a platform. Here we will make the distinct creeper face come to life! Not really. We do that later when we paint it. But this is the baseline for that later step.Step 1: PaperUsing either printer paper or a heavier Bristol (which I prefer because it doesn't crumple as easily and won't wrinkle as bad when I paint it), cut out 5 squares 11 centimeters acrss, leaving tabs on the edges so we can glue them together.Using a glue of your choice, assemble the squares into a cube with one side missing.Step 2: More Cardboard (Seriously, what would I do without this stuff?)Print out the Creeper Template document I attached.Lay the template over the cardboard, and cut out the eyes and mouth, leaving the white areas intact. Do this as neatly as possible, we still need the shaded area.Lay the shaded area over one of the sides of the cube adjacent to the missing side, and lightly trace the eyes and mouth, keeping in mind the missing side of the cube is the bottom.Using a glue of your choice, carefully glue the cardboard eyes and mouth on the inside of the cube,aligned to the tracing on the outside.Carefully cut out the circles on the cube, using the cardboard as a guide.Step 3: Ultrasonic SensorSlot the HC-SR04 into the circles we just created, so the front is flush with the cube. The header pins should be pointing away from the missing side of the cube.Hot glue the sensor in place.Step 4: Gluing the HeadNOTE: You may want to test the code before doing this, to ensure your LEDs and HC-SR04 are wired correctlyCarefully fit the cube over the top of the base of the head, and hot glue the edges in place once you are satisfied. Make sure your sensor faces forward when the head is in the center position.Now you can move on to upload and test the code!", "step_imgs": ["https://cdn.instructables.com/F4B/4PLG/JDOUV75Z/F4B4PLGJDOUV75Z.LARGE.jpg", "https://cdn.instructables.com/FYV/ZYH7/JDOUV75Q/FYVZYH7JDOUV75Q.LARGE.jpg", "https://cdn.instructables.com/FKX/2IA4/JDOUV75P/FKX2IA4JDOUV75P.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: The Rest of the Head"}, {"step": 5, "steps_text": "The code for this project took me a while to write and is kind of all over the place. I originally intended to use a different code for the tracking and standby modes, but issues with libraries and timer pins forced me to write a whole new section for each of those. I also originally intended to have a sixth mode in which the creeper plays the Calm theme from Minecraft, but preliminary testing excluded that idea as the theme sounded terrible and conflicted with the Servo library.Anyway, have a read through to get an idea as to what I am doing with it, then upload the code to your Arduino./* --------------------------------------------------------------------------------------------\n\n This is a code for an Arduino sentry with ultrasound. \n The original design is intended to be a Creeper from Minecraft. \n There are several \"modes\" that can be selected through the use of pushbuttons \n and a potentiometer. The first pushbutton cycles through the modes, and the \n potentiometer adjusts the \"active range\".\n \n --------------------------------------\n \n The modes are as follows:\n \n 1 - Standby Mode    - 7-color \"breathing\" (basically a night light)\n \n 2 - Creeper Sentry  - Will blink and hiss when someone gets within the active range\n \n 3 - Standard Sentry - Will beep when someone gets within the active range\n \n 4 - Object Tracking - Will track the first object it \"sees\" while within range\n \n --------------------------------------\n \n Code written by Dangerously Explosive\n \n Not for commercial use.\n \n----------------------------------------------------------------------------------------------- */\n\n#include  //initialize the libraries\n\n//servo vars          \n\nServo sentryServo;         //init the servo\nint servoPosition = 0;         // the servo position\nconst int numReadings = 3;   // the number of readings to take, make this bigger for a slower, more accurate scan\nint index = 0;                // the index of the current reading\nint total; // the total value of the sum of all readings taken at one position.\nint angle = 1; //the number of degrees shifted during each scan while tracking an object\n\n//ultrasonic vars\n\nint echoPin = 5;              // the HCSR04's echo pin\nint trigPin = 4;              // the HCSR04's trig pin\nunsigned long pulseTime = 0;  // variable for timing the pulse\nunsigned long distance = 0;   // variable for distance\nint average;                  // for the avg. distance\nint minRange = 50;            // the max distance in centimeters something must be to set off the alarm\n\n//light vars\n\nint RED = 6;    // RED pin of the LEDs\nint GREEN = 11;  // GREEN pin of the LEDs \nint BLUE = 3;   // BLUE pin of the LEDs    \n// it doesn't really matter what pin you assign, you can always change it later.\n\n// debouncing vars\n\nconst int buttonPin = A1;    // the pushbutton pin\nconst int potPin = A0;       // the potentiometer pin\nint buttonState;             // the current reading from the input pin\nint buttonState1;\nint lastButtonState = LOW;\nint lastButtonState1 = LOW;// the previous reading from the input pin\nint mode = 0;                // the sentry mode\nint colorMode = 0;           // the LED mode in standby\nlong lastDebounceTime = 0; // the last time the output pin was toggled\nlong lastDebounceTime1 = 0;\nlong debounceDelay = 50;    // the debounce time; increase if the output flickers\n\n// Other vars\nint buzzerPin = A5;\n\n\n//debounce function \n\nvoid debounce(){\n  // read the state of the switch into a local variable:\n  int reading = digitalRead(buttonPin);\n\n  if (reading != lastButtonState) {\n    // reset the debouncing timer\n    lastDebounceTime = millis();\n  }\n\n  if ((millis() - lastDebounceTime) > debounceDelay) {\n\n    // if the button state has changed:\n    if (reading != buttonState) {\n      buttonState = reading;\n\n      // only toggle the mode if the new button state is LOW\n      if (buttonState == LOW) {\n        mode ++;\n        tone(buzzerPin, 500, 50); //beep so I know something happened\n        if (mode >= 5){\n          mode = 0;\n        }\n      }\n    }\n  }\n  \n    \n  // save the reading.  Next time through the loop,\n  // it'll be the lastButtonState:\n  lastButtonState = reading;\n}\n\nvoid getRange(){ // find the range at which the alarm should go off\n  int rawRange = analogRead(potPin);         // get the potentiometer readings\n  minRange = map(rawRange, 0, 1023, 0, 150); // mapped to a value between 0 and 1.5 meters  \n}\n\n\nvoid getAlert1 (){\n  getRange();\n  if (average <= minRange){\n    beep();\n    Alert();\n  };\n}\n\nvoid getAlert(){\n  getRange();\n  if (average <= minRange){\n    blinky();                 //blink red\n    hiss();                   // hiss \n        // good explosion sounds are really hard to make, so I just have it hiss\n  };\n}\n\nvoid blinky(){\n  digitalWrite(GREEN, LOW);\n  analogWrite(BLUE, 0);\n  int duration = 100;\n  for(int l = 0; l <= 10; l++){\n    analogWrite(RED, 255);\n    delay(duration);\n    analogWrite(RED, 0);\n    delay(duration);\n    duration = duration - 10; \n  }\n}\n\nint var1;\nint var2;\n\nvoid hiss(){\n  for (int j = 0; j <= 100; j++){\n    var1 = random(300, 700);\n    var2 = random(300, 700);\n    tone(buzzerPin, var1);\n    delay(2);\n    tone(buzzerPin, var2);\n    delay(2);\n  }\n  noTone(buzzerPin);\n  digitalWrite(GREEN, HIGH);\n}\n\n  int duration = 500;\n  int i = 0;\n  \nvoid beep(){\n  digitalWrite(GREEN, LOW);\n  analogWrite(BLUE, 0);\n  int frequency = 500;\n  duration = 200;\n  for(int i = 0; i <= 20; i++){\n    analogWrite(RED, 255);\n    digitalWrite(GREEN, LOW);\n    tone(buzzerPin, frequency);\n    delay(duration);\n    analogWrite(RED, 0);\n    digitalWrite(GREEN,HIGH);\n    delay(duration);\n    noTone(buzzerPin);\n    frequency = frequency + 10;\n    duration = duration - 10;\n    \n  }\n  tone(buzzerPin, frequency);\n  delay(500);\n  noTone(buzzerPin);\n}\nint q = 200;\nvoid Alert(){\n  digitalWrite(GREEN, LOW);\n  tone(buzzerPin, 500);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  delay(q);\n  tone(buzzerPin, 300);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  delay(q);\n  tone(buzzerPin, 200);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  delay(q);\n  tone(buzzerPin, 100);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  noTone(buzzerPin);\n  delay(q);\n  tone(buzzerPin, 100);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  noTone(buzzerPin);\n  delay(q);\n  tone(buzzerPin, 100);\n  analogWrite(RED, 255);\n  delay(q);\n  analogWrite(RED, 0);\n  noTone(buzzerPin);\n  digitalWrite(GREEN, HIGH);\n}\n\nint numReadings1 = 1;\n\nvoid getAverage(){\n  for (index = 0; index<=numReadings1; index++) {\n    digitalWrite(trigPin, LOW);\n    delayMicroseconds(50);\n    digitalWrite(trigPin, HIGH);                           // send signal\n    delayMicroseconds(50);                                 // wait 50 microseconds for it to return\n    digitalWrite(trigPin, LOW);                            // close signal\n    pulseTime = pulseIn(echoPin, HIGH);                    // calculate time for signal to return\n    distance = pulseTime/58;\n    total = distance + total;\n    delay(10);\n  }\n  average = total/numReadings; \n  total = 0;\n}\n\n/*\nThe tracking code is very simple. First, it determines if an object is in range.\nIf it is, then it turns until it doesn't see the object, i.e. it is looking just past it on one side.\nThen, turn left until it sees the object again, and repeat. In this way, we can keep track of the object.\nThis is basically using the old \"The missile knows where it is\" logic. If we know where the object is not, \nwe can reasonably determine where it is. The way I have it set up is rather jittery, and I'm really just \ntracking the edge of an object than the object itself. If you are planning on tracking larger objects, you \ncan increase the value of the variable \"angle\" so the servo will turn in larger increments, resulting in a\nfaster, less detailed scan where small objects are more likely to be missed.\n\nI should mention this is a very primitive, finicky and easy-to-fool system, so I don't reccomend using it \nas a security measure or a targeting system. It is also not necessarily accurate.\n*/\n\nvoid track(){\n  sentryServo.write(servoPosition); // first get the servo going\n  getAverage();                     // then find the distance to target\n  getRange();                       // find the range within which we will track an object\n  if (average <= minRange){               //if the object is in range, turn left\n    servoPosition = servoPosition + angle;\n  }\n  if (average >= minRange){                //otherwise turn right\n    servoPosition = servoPosition - angle;\n  }\n  if (servoPosition <= 10 || servoPosition >= 170){  // you can change these values so that your sentry makes a smaller sweep.   \n    angle = -angle;                                 // if we hit the edge of our sweep, go the other way        \n  }\n}\n\n\n\nvoid setup() {\n\n  sentryServo.attach(9); //servo is on pin 9\n  sentryServo.write(90);\n  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);\n  pinMode(buttonPin, INPUT_PULLUP); // active low\n\n  pinMode(RED, OUTPUT);\n  pinMode(BLUE, OUTPUT);\n  pinMode(GREEN, OUTPUT);\n  analogWrite(GREEN, 255); // color sequence to notify of reset and to test LEDs\n  delay(1000);\n  analogWrite(GREEN, 0);\n  delay(500);\n  analogWrite(RED, 255);\n  delay(1000);\n  analogWrite(RED, 0);\n  delay(500);\n  analogWrite(BLUE, 255);\n  delay(1000);\n  analogWrite(BLUE, 0);\n  delay(500);\n  pinMode(buzzerPin, OUTPUT);\n\n} \n\nint fade = 5;\nint state = 0;\nint count = 0;\nint h = 50;\n\nvoid loop() {\n  debounce();\n  while (mode == 0){\n    if (state == 0){\n      analogWrite(RED, colorMode);\n      analogWrite(GREEN, 0);\n      analogWrite(BLUE, 0);\n      debounce();\n      colorMode = colorMode + fade;\n      delay(h);\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 1){\n      analogWrite(RED, 0);\n      analogWrite(GREEN, colorMode);\n      analogWrite(BLUE, 0);\n      debounce();\n      colorMode = colorMode + fade;\n      delay(h);\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 2){\n      analogWrite(RED, 0);\n      analogWrite(GREEN, 0);\n      analogWrite(BLUE, colorMode);\n      debounce();\n      colorMode = colorMode + fade;\n      delay(h);\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 3){\n      analogWrite(RED, colorMode);\n      analogWrite(GREEN, colorMode);\n      analogWrite(BLUE, 0);\n      debounce();\n      colorMode = colorMode + fade;\n      delay(h);\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 4){\n      analogWrite(RED, colorMode);\n      analogWrite(GREEN, 0);\n      analogWrite(BLUE, colorMode);\n      debounce();\n      colorMode = colorMode + fade;\n      delay(h);\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 5){\n      analogWrite(RED, 0);\n      analogWrite(GREEN, colorMode);\n      analogWrite(BLUE, colorMode);\n      colorMode = colorMode + fade;\n      delay(h);\n      debounce();\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 6){\n      analogWrite(RED, colorMode);\n      analogWrite(GREEN, colorMode);\n      analogWrite(BLUE, colorMode);\n      colorMode = colorMode + fade;\n      delay(h);\n      debounce();\n      if (colorMode >= 255 || colorMode <= 0){\n        fade = -fade;\n        count ++;\n      }\n      if (count == 2){\n        count = 0;\n        state ++;\n      }\n    }\n    if (state == 7){\n      debounce();\n      state = 0;\n    }\n    debounce();\n  };\n  \n  while (mode == 1){\n    debounce();\n    analogWrite(GREEN, 255);\n    analogWrite(BLUE, 0);\n    analogWrite(RED, 0);\n    for(servoPosition = 0; servoPosition < 180; servoPosition++) {  \n      debounce();\n      sentryServo.write(servoPosition);\n\n      for (index = 0; index<=numReadings; index++) {            // take readings from the sensor and average them\n        \n        digitalWrite(trigPin, LOW);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, HIGH);                           // send signal\n\n        delayMicroseconds(50);                                 // wait 50 microseconds for it to return\n\n        digitalWrite(trigPin, LOW);                            // close signal\n\n        pulseTime = pulseIn(echoPin, HIGH);                    // calculate time for signal to return\n\n        distance = pulseTime/58;                               // convert to centimetres\n\n        total = distance + total;\n\n        delay(10);\n\n      }\n\n      average = total/numReadings;         // get our average\n\n      getAlert();                          // explode if too close\n\n      total = 0;                           // reset our totals\n    }\n    debounce();\n    // reverse direction when we get to either side\n\n    for(servoPosition = 180; servoPosition > 0; servoPosition--) {  // going right to left\n      debounce();\n      sentryServo.write(servoPosition);\n\n      for (index = 0; index<=numReadings;index++) {\n\n        digitalWrite(trigPin, LOW);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, HIGH);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, LOW);\n\n        pulseTime = pulseIn(echoPin, HIGH);\n\n        distance = pulseTime/58;\n\n        total = distance + total;\n\n        delay(10);\n      }\n\n      average = total/numReadings;\n\n      getAlert();\n\n      total = 0;\n    }\n  };\n\n  while (mode == 2){ // still acting as a sentry, but with different sounds\n    debounce();\n\n    for(servoPosition = 0; servoPosition < 180; servoPosition++) {  \n      debounce();\n      sentryServo.write(servoPosition);\n\n      for (index = 0; index<=numReadings;index++) {            // take readings from the sensor and average them\n\n        digitalWrite(trigPin, LOW);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, HIGH);                           // send signal\n\n        delayMicroseconds(50);                                 // wait 50 microseconds for it to return\n\n        digitalWrite(trigPin, LOW);                            // close signal\n\n        pulseTime = pulseIn(echoPin, HIGH);                    // calculate time for signal to return\n\n        distance = pulseTime/58;                               // convert to centimetres\n\n        total = distance + total;\n\n        delay(10);\n\n      }\n\n      average = total/numReadings;         // get our average\n\n      getAlert1();                          // explode if too close\n\n      total = 0;                           // reset our totals\n    }\n\n    // reverse direction when we get to either side\n    debounce();\n    for(servoPosition = 180; servoPosition > 0; servoPosition--) {  // going right to left\n      debounce();\n      sentryServo.write(servoPosition);\n\n      for (index = 0; index<=numReadings;index++) {\n\n        digitalWrite(trigPin, LOW);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, HIGH);\n\n        delayMicroseconds(50);\n\n        digitalWrite(trigPin, LOW);\n\n        pulseTime = pulseIn(echoPin, HIGH);\n\n        distance = pulseTime/58;\n\n        total = distance + total;\n\n        delay(10);\n      }\n\n      average = total/numReadings;\n\n      getAlert1();\n\n      total = 0;\n    }\n  };\n  \n  // re-center the servo for the track function\n  servoPosition = 90;\n\n  while (mode == 3){ \n    debounce();\n    analogWrite(BLUE, 255);\n    analogWrite(GREEN, 0);\n    track();\n  };\n  \n  while(mode == 4){\n    sentryServo.write(90);\n    debounce();\n  };\n  \n  analogWrite(BLUE, 0); // turn off the blue light for the next time thru.\n  delay(10); // let the processor rest a little\n}\n", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: The Code!"}, {"step": 6, "steps_text": "Okay, now your sentry should be functional. Let's make it pretty!Step 1: Mounting ThingsUsing an adhesive of your choice, mount the Arduino in an upright position along the \"back wall\" of the body.Peel the waxy paper off the bottom of the mini breadboard, and stick it as far back on the \"floor\" of the body as possible.Close the access door to make sure it all fits nicely.Step 2: PowerCut a hole in the bottom of the body of the creeper. The exit point should be somewhere between the feet.Connect a power jack of your choice (I used a standard barrel jack I harvested from a fried Arduino) to the Vin and GND pins of the Arduino, and then hot glue it in the hole you just created.Check to see that it works, then move on.Step 3: Paint!I think this part is pretty self-explanatory. You can use however much detail and whatever colors you like, or even not paint it at all. It all depends of how you want it.I only used one shade of green for the whole thing, and it looks darn good. My mixture is a 1:1 ratio of Delta Ceramcoat \"Sunshine Pearl\" yellow with Apple Barrel Plaid \"20528 Leaf Green\", and a teensy bit (1 drop to every 10 of yellow) of Delta Ceramcoat \"Phthalo Green\" for that blue-y tint that makes the whole thing glow nicely in sunlight.The black is Apple Barrel Plaid \"20504 Black\", and the grey is Apple Barrel Plaid \"20580 Pewter Grey\". I used a flat brush for the whole thing.Let it dry, and viola! One finished Creeper Sentry!", "step_imgs": ["https://cdn.instructables.com/FSP/OUPW/JDOUV771/FSPOUPWJDOUV771.LARGE.jpg", "https://cdn.instructables.com/FH9/KQDA/JDOUV76U/FH9KQDAJDOUV76U.LARGE.jpg"], "step_title": "Step 6: Mounting Things, Power, and Paint!"}, {"step": 7, "steps_text": "All in all, I like how this one turned out. Although I didn't plan it that way, it is actually to-scale with my furnace clock and almost to-scale with my glowing torch (which is just a little big). The code is a bit jittery, something I hope to fix in coming days, but the effect is still there. If I ever figure out how, I will come back and add a few lines of code for the symbolic explosion sound that creepers have to add that much more special-ness to it.I actually added the tracking code at the last minute on a whim, and I really like how it turned out, even if it doesn't work that well. It is really cool to walk into a room and have a creeper turn and look at you, and then have it keep looking at you as you walk past, just like in Minecraft. Well, except the part where it chases me and explodes. But that's a project for another time.As always, these are the projects of Dangerously Explosive, his lifelong mission, \"to boldly build what you want to build, and more.\"You can find the rest of my projects here.Please, please vote if you liked this project and want to see more like it. Be sure to comment if you have questions, comments (duh?), or suggestions, I want to hear all of it!", "step_imgs": ["https://cdn.instructables.com/FE0/CTA6/JDOUV76P/FE0CTA6JDOUV76P.LARGE.jpg", "https://cdn.instructables.com/FW4/ZOKW/JDOUV76T/FW4ZOKWJDOUV76T.LARGE.jpg", "https://cdn.instructables.com/FUJ/6P1T/JDOUV789/FUJ6P1TJDOUV789.LARGE.jpg", "https://cdn.instructables.com/FIY/S7DJ/JDOUV785/FIYS7DJJDOUV785.LARGE.jpg"], "step_title": "Step 7: The Results"}], "channel": "Arduino"}, {"category": "technology", "description": "This short project will use an 8x8 Red Led Matrix display with the V-USB ATtiny85 Project Board created in my first Instructable. The object of this exercise being to have an ATtiny85 control an 8x8 Led Matrix Display, and then try to find something useful to do with it.", "title": "V-USB ATtiny85 Project Board and an 8x8 Red LED Matrix Display", "url": "https://www.instructables.com/id/V-USB-ATtiny85-Project-Board-and-an-8x8-Red-LED-Ma/", "section": "technology", "steps": [{"step": 1, "steps_text": "Description, No. Required, Source, Unit Cost, Total Unit CostAssembled Custom PCB, 1 , PCBWay , $8.21 each , $8.21(when 10 units are produced, unit price drops when more boards are ordered for production)   8x8 Red LED Matrix, 1 , Amazon , $3.47 each , $3.47  Bread Board Wires , 1 set ,  Amazon , $6.67 , $6.67  Mini Bread Board, 1 , Amazon , $0.97 each , $0.97   Small tactile switch, 1 , Amazon , $0.05 each , $0.05   Photo Resistor, 1 , Amazon , $0.07 each , $0.07  10KOhm Resistor, 1 , Amazon , $0.05 each , $0.05100nF capacitor, 1 , Amazon , $0.07 each, $0.07Total cost of Project $19.56Note1: This cost assumes that you have no components on hand.Note2: You may substitute the custom PCB (V-USB ATtiny85 Project Board) with any Arduino compatible micro controller. For example the Arduino Uno.", "step_imgs": ["https://cdn.instructables.com/F53/8R9B/IKCX9OZE/F538R9BIKCX9OZE.LARGE.jpg", "https://cdn.instructables.com/F9T/I1IB/IKH7KHQF/F9TI1IBIKH7KHQF.LARGE.jpg"], "step_title": "Step 1: Parts List"}, {"step": 2, "steps_text": "The MaxMatrix Library should be installed first.Download the MaxMatrix Library from here.     Extract or unzip the compressed file.     Copy or move the extracted folder to the Libraries folder of your Arduino IDE.The MaxMatrix Usage wiki explains how to use the library.The example code that follows is based on this library work and also the work found here.", "step_imgs": [], "step_title": "Step 2: The MaxMatrix Library"}, {"step": 3, "steps_text": "Connect to the 8x8 LED Matrix Module to the Micro ControllerVCC to the 5V pin on the ATtiny85 microcontroller      GND to the GND pin on the ATtiny85 microcontroller      DIN to PB1 pin on the ATtiny85 microcontroller      CS to PB2 pin on the ATtiny85 microcontroller      CLK to PB3 pin on the ATtiny85 microcontroller", "step_imgs": ["https://cdn.instructables.com/FW7/XXE9/IKCX9P5X/FW7XXE9IKCX9P5X.LARGE.jpg", "https://cdn.instructables.com/FLL/HM31/IKCX9P4G/FLLHM31IKCX9P4G.LARGE.jpg", "https://cdn.instructables.com/FUY/QOSI/IKCX9P8E/FUYQOSIIKCX9P8E.LARGE.jpg"], "step_title": "Step 3: Make Some Connections"}, {"step": 4, "steps_text": "Specification for the ATtiny85 taken from the Atmel website.Parameter, Value               Flash (Kbytes),  8 Kbytes (8192 Bytes)                     Pin Count,  8                      Max. Operating Freq,  (MHz): 20 MHz                     CPU: 8-bit AVR       Max I/O Pins, 6       ADC Channels, 4                      ADC Resolution (bits), 10       Temp. Sensor, Yes       SRAM (Bytes), 512                      EEPROM (Bytes), 512               Self Program Memory, Yes       Temp. Range (deg C), -40 to 85       Operating Voltage (Vcc), 1.8 to 5.5 The EEPROM memory will hold 512 bytes. So we immediately have a problem with the example code. The character definitions are just too many, we will need to cut the definitions down in order to fit into the EEPROM space.Note1: Some of the pictures show lower case letters etc. I was using the code directly as written. It worked, however I found that it could break the Micronucleus, and make the ATtiny85 device unusable with the Arduino IDE/Micronucleus. I put this down to the original code, requiring around 882 bytes in the EEPROM for the character definitions. I decided to cut the character set down to a more manageable number. A set that would fit in the EEPROM memory.Note2: This does not preclude just removing the Micronucleus flashing the program to the ATtiny, using a micro controller programmer. For example the USBasp.Note3: The sketch code will work fine with a micro controller such as the Arduino Uno, without any modification. With more memory you are able to define a complete character set.", "step_imgs": ["https://cdn.instructables.com/FL0/EX68/IKFS6PU1/FL0EX68IKFS6PU1.LARGE.jpg"], "step_title": "Step 4: The Atmel ATtiny85 Micro Controller"}, {"step": 5, "steps_text": "Let us reduce the number of character definitions from the example code in order to fit easily into EEPROM memory. we will use the first 60 or so character definitions, \"space\" to \"_\". This will give us definitions for 65 characters. Each definition requires column count byte, a row count byte and 5 bytes for the character bits. So we now need (65 * 7) = 455 bytes to store the character definitions in EEPROM. This will fit within the 512 total memory space of the ATtiny85, so far so good.const unsigned char CH[] PROGMEM = {\n  3, 8, B00000000, B00000000, B00000000, B00000000, B00000000, // space\n  1, 8, B01011111, B00000000, B00000000, B00000000, B00000000, // !\n  3, 8, B00000011, B00000000, B00000011, B00000000, B00000000, // \"\n  5, 8, B00010100, B00111110, B00010100, B00111110, B00010100, // #\n  4, 8, B00100100, B01101010, B00101011, B00010010, B00000000, // $\n  5, 8, B01100011, B00010011, B00001000, B01100100, B01100011, // %\n  5, 8, B00110110, B01001001, B01010110, B00100000, B01010000, // &\n  1, 8, B00000011, B00000000, B00000000, B00000000, B00000000, // '\n  3, 8, B00011100, B00100010, B01000001, B00000000, B00000000, // (\n  3, 8, B01000001, B00100010, B00011100, B00000000, B00000000, // )\n  5, 8, B00101000, B00011000, B00001110, B00011000, B00101000, // *\n  5, 8, B00001000, B00001000, B00111110, B00001000, B00001000, // +\n  2, 8, B10110000, B01110000, B00000000, B00000000, B00000000, // ,\n  4, 8, B00001000, B00001000, B00001000, B00001000, B00000000, // -\n  2, 8, B01100000, B01100000, B00000000, B00000000, B00000000, // .\n  4, 8, B01100000, B00011000, B00000110, B00000001, B00000000, // /\n  4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // 0\n  3, 8, B01000010, B01111111, B01000000, B00000000, B00000000, // 1\n  4, 8, B01100010, B01010001, B01001001, B01000110, B00000000, // 2\n  4, 8, B00100010, B01000001, B01001001, B00110110, B00000000, // 3\n  4, 8, B00011000, B00010100, B00010010, B01111111, B00000000, // 4\n  4, 8, B00100111, B01000101, B01000101, B00111001, B00000000, // 5\n  4, 8, B00111110, B01001001, B01001001, B00110000, B00000000, // 6\n  4, 8, B01100001, B00010001, B00001001, B00000111, B00000000, // 7\n  4, 8, B00110110, B01001001, B01001001, B00110110, B00000000, // 8\n  4, 8, B00000110, B01001001, B01001001, B00111110, B00000000, // 9\n  2, 8, B01010000, B00000000, B00000000, B00000000, B00000000, // :\n  2, 8, B10000000, B01010000, B00000000, B00000000, B00000000, // ;\n  3, 8, B00010000, B00101000, B01000100, B00000000, B00000000, // <\n  3, 8, B00010100, B00010100, B00010100, B00000000, B00000000, // =\n  3, 8, B01000100, B00101000, B00010000, B00000000, B00000000, // >\n  4, 8, B00000010, B01011001, B00001001, B00000110, B00000000, // ?\n  5, 8, B00111110, B01001001, B01010101, B01011101, B00001110, // @\n  4, 8, B01111110, B00010001, B00010001, B01111110, B00000000, // A\n  4, 8, B01111111, B01001001, B01001001, B00110110, B00000000, // B\n  4, 8, B00111110, B01000001, B01000001, B00100010, B00000000, // C\n  4, 8, B01111111, B01000001, B01000001, B00111110, B00000000, // D\n  4, 8, B01111111, B01001001, B01001001, B01000001, B00000000, // E\n  4, 8, B01111111, B00001001, B00001001, B00000001, B00000000, // F\n  4, 8, B00111110, B01000001, B01001001, B01111010, B00000000, // G\n  4, 8, B01111111, B00001000, B00001000, B01111111, B00000000, // H\n  3, 8, B01000001, B01111111, B01000001, B00000000, B00000000, // I\n  4, 8, B00110000, B01000000, B01000001, B00111111, B00000000, // J\n  4, 8, B01111111, B00001000, B00010100, B01100011, B00000000, // K\n  4, 8, B01111111, B01000000, B01000000, B01000000, B00000000, // L\n  5, 8, B01111111, B00000010, B00001100, B00000010, B01111111, // M\n  5, 8, B01111111, B00000100, B00001000, B00010000, B01111111, // N\n  4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // O\n  4, 8, B01111111, B00001001, B00001001, B00000110, B00000000, // P\n  4, 8, B00111110, B01000001, B01000001, B10111110, B00000000, // Q\n  4, 8, B01111111, B00001001, B00001001, B01110110, B00000000, // R\n  4, 8, B01000110, B01001001, B01001001, B00110010, B00000000, // S\n  5, 8, B00000001, B00000001, B01111111, B00000001, B00000001, // T\n  4, 8, B00111111, B01000000, B01000000, B00111111, B00000000, // U\n  5, 8, B00001111, B00110000, B01000000, B00110000, B00001111, // V\n  5, 8, B00111111, B01000000, B00111000, B01000000, B00111111, // W\n  5, 8, B01100011, B00010100, B00001000, B00010100, B01100011, // X\n  5, 8, B00000111, B00001000, B01110000, B00001000, B00000111, // Y\n  4, 8, B01100001, B01010001, B01001001, B01000111, B00000000, // Z\n  2, 8, B01111111, B01000001, B00000000, B00000000, B00000000, // [\n  4, 8, B00000001, B00000110, B00011000, B01100000, B00000000, // \\ backslash\n  2, 8, B01000001, B01111111, B00000000, B00000000, B00000000, // ]\n}; Let us look at the sketch#include <MaxMatrix.h>\n#include <avr/pgmspace.h>Load the necessary libraries. MaxMatrix will manipulate the data in order to display it on the led matrix, and pgmspace will put the data into the EEPROM memory.MaxMatrix m(DIN, CS, CLK, MAXS);This sets up the library data, load and clock pins. It also indicates if there are more than one matrix on the data line and will \"spill\" the data over to it.m.shiftLeft(false, true);\nprintStringWithShift(string1, 100);Indicate the scrolling direction and call the display routine to scroll the text string across our led matrix. The number 100 is the scrolling speed of the text displayed. Try changing the value and see what happens.void printCharWithShift(char c, int shift_speed) {\n\n  if (c < 32) return;\n  c -= 32;\n  memcpy_P(buffer, CH + 7 * c, 7);\n  m.writeSprite(MAXS * 8, 0, buffer);\n  m.setColumn(MAXS * 8 + buffer[0], 0);\n  for (int i = 0; i < buffer[0] + 1; i++)\n  {\n    delay(shift_speed);\n    m.shiftLeft(false, false);\n  }\n}The scrolling display routine, called with the character array pointer c, and the scrolling speed of the characters displayed. // Extract characters from Scrolling text<br>void printStringWithShift(char* s, int shift_speed) {\n  while (*s != 0) {\n    printCharWithShift(*s, shift_speed);\n    s++;\n  }\n}The heart of the sketch, this routine pulls the character from the text to be displayed until it finds the end of the string text, denoted by 0.NowDownload the example sketch MatMatrixExample1.ino       Open the file in the Arduino IDE       Compile and load the sketch to the ATtiny85 micro-controller.Note1: these examples will also work with an Arduino Uno, nano etc. Either use the same pin assignments or change to your preference. It is all about experimentation.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: The Program"}, {"step": 6, "steps_text": "Now let us try and display some real world information, let us add a photo-resistor to the ATtiny85 device and display the analog readings on the 8x8 Led Matrix.Connect the photo-resistor as shown in the Fritzing diagram and schematic above.        Connect a 10K Ohm resistor from GND on the 8x8 led matrix to one side of the photo-resistor        Connect the other side of the photo-resistor to VCC on the 8x8 led matrix        Now connect PB4 (A2) from the ATtiny85 device to the point where the 10K Ohm resistor and the photo-resistor meet        Download the MatMatrixExample2.ino sketch        Load the MatMatrixExample2.ino sketch into the Arduino IDE        Compile the sketch and transfer it to the ATtiny85 deviceLet us look at the example sketch#include  <MatMatrix.h>\n#include  <avr/prgmspace.h>Load the libraries necessary . The character definitions have already been described above.#define DIN 1\n#define CS 2\n#define CLK 3\n#define MAXS 1\n#define PHOTO 2    // physical pin 4, PB4, A2 (pin definition for the ATtiny85)\n#define SPEED 100Let us try to keep memory usage to a minimum, we will define the values we need, we will not use integer variables if we do not need them.int photo;\nint strlength;\nString data;These integer variables we will need. photo will read the photo-resistor sensor value strlength and data will be used to convert the integer value read to a character string. The MaxMatrix library requires that the data is transferred as a character array, so these variables will help us do that.MaxMatrix m(DIN, CS, CLK, MAXS); // define Library\nbyte buffer[10];\nchar string1[] = \"THE V-USB ATTINY85 PROJECT BOARD --- ANALOG LIGHT INTENSITY\";  // Scrolling Text but ony upper case\nchar analogdata[6];\n// Try lower case and see what happens!! ... funThe character array analogdata[6] provides space for the data result. However should the length of the data result be longer that six characters, then we will have garbage displayed. The data is terminated with a \"/0\". Adjust the value and see what happens.// PB4 set for output\npinMode(PHOTO, OUTPUT);Set the I/O pin for analog reading on the photo-resistor. Note1: this is PB4, but analog A2.// Let us make a loop and measure the light intensity for say 20 cycles\n  for (int n = 0; n < 20; n++) {\n    photo = analogRead(PHOTO);\n    data = String(photo) + String(\" , \");\n    strlength = data.length() + 1;\n    data.toCharArray(analogdata , strlength);\n    printStringWithShift(analogdata, SPEED);\n    delay(SPEED);\n  }Now let us read the analog pin a few times and display the results. Try covering the photo-resistor with your hand, and shining a torch onto the sensor.", "step_imgs": ["https://cdn.instructables.com/F7I/R66K/IKFQ09R8/F7IR66KIKFQ09R8.LARGE.jpg", "https://cdn.instructables.com/FYT/8J9V/IKFQ09Y4/FYT8J9VIKFQ09Y4.LARGE.jpg", "https://cdn.instructables.com/FZH/E9SY/IKH7KK6G/FZHE9SYIKH7KK6G.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 6: Let's Add a Sensor"}, {"step": 7, "steps_text": "Now let us add a button and turn this device into a six digit die. Remove the photo-resistor        Add the push button to the circuit.        Connect the 10K Ohm resistor from the GND pin of the 8x8 led matrix module to one side of the push button.        Connect the VCC pin of the 8x8 led matrix to the same side rail of the push button.        Connect the opposite side rail of the push button to pin PB4 of the ATtiny85 device.Using the MatMatrixExample2.ino sketch downloaded in Step 6, try pressing the button you have just added to the circuit. What just happened?This is why we have to be sure we have enough space for our datachar analogdata[6];Try changing the size of this array, say 10 should be a good compromise. Compile the sketch and load it onto the ATtiny85 device, try pressing the button again.What happened this time?Now let us define some sprites to represent the die. Read the library wiki, this will give further details on the library usage.Note1: singular = die, plural = dice. Sprite definition for die face 18, 8, 0, 0, 0, 24, 24, 0, 0, 0\n\nbyte DIE_1[] = {8, 8, 0, 0, 0, 24, 24, 0, 0, 0};\n...\nm.writeSprite(0, 0, DIE_1);Sprite definition for die face 28, 8, 192, 192, 0, 0, 0, 3, 3\n\nbyte DIE_2[] = {8, 8, 192, 192, 0, 0, 0, 3, 3};\n...\nm.writeSprite(0, 0, DIE_2);Sprite definition for die face 38, 8, 192, 192, 0, 24, 24, 0, 3, 3\n\nbyte DIE_3[] = {8, 8, 192, 192, 0, 24, 24, 0, 3, 3};\n...\nm.writeSprite(0, 0, DIE_3);Now we will generate a random number to simulate a roll of the die.randomSeed(analogRead(0)); // randomize the seed\n\n...\n\nlong dieRoll = random(0, 7);\n\n...Now let us try the example sketch.Download the MaxmatrixExample3.ino file.  Open the file in the Arduino IDE.  Compile and load the sketch to the ATtiny85 micro controller  Press the button to roll the die.Well it works, sort of. Do you notice how the die may sometimes roll away with itself. The pin state does not always seem to return to the LOW state. It may float between HIGH and LOW, and keep on rolling.How should we fix that.?Let us try adding a 100nF capacitor across the switch rails.Play the game now, is the die more stable?Does it wait for the next button press?Well it should.Did you notice that this die has seven faces?The seventh face is the Joker, roll the Joker and lose. byte DIE_J[] = {8, 8, 0, 128, 224, 251, 251, 224, 128, 0};  // Joker !!!//byte DIE_J[] = {8, 8, 0, 136, 232, 59, 59, 232, 136, 0};  // alternative Joker !!!There are two choices in the sketch for the Joker sprite definition. Remove the comments to make the sprite active.", "step_imgs": ["https://cdn.instructables.com/FMV/WP7M/IKFQ0HJE/FMVWP7MIKFQ0HJE.LARGE.jpg", "https://cdn.instructables.com/FJ6/A46G/IKFQ0HMX/FJ6A46GIKFQ0HMX.LARGE.jpg", "https://cdn.instructables.com/FYG/V4BT/IKH7KH2C/FYGV4BTIKH7KH2C.LARGE.jpg", "https://cdn.instructables.com/FO7/QEUB/IKFRXZXH/FO7QEUBIKFRXZXH.LARGE.jpg", "https://cdn.instructables.com/FE3/DOLY/IKFRXZXG/FE3DOLYIKFRXZXG.LARGE.jpg", "https://cdn.instructables.com/FO5/OI8P/IKH7KK6B/FO5OI8PIKH7KK6B.LARGE.jpg", "https://cdn.instructables.com/FTW/SE4I/IKK0AQ9P/FTWSE4IIKK0AQ9P.LARGE.jpg", "https://cdn.instructables.com/FC8/M77Z/IKK0AQ9O/FC8M77ZIKK0AQ9O.LARGE.jpg", "https://cdn.instructables.com/FUC/G3M5/IKK0AQ9B/FUCG3M5IKK0AQ9B.LARGE.jpg", "https://cdn.instructables.com/FP3/HMR6/IKK0AQ9A/FP3HMR6IKK0AQ9A.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 7: Let's Make a Die"}, {"step": 8, "steps_text": "Here is a simple character designer, that will allow us to design a character or a sprite in Microsoft Excel (or just upload it to Google Drive, and use it with Google Sheets). Simply place a 1 where we require a pixel to be, the columns on the right of the matrix will indicate the decimal and hexadecimal value for the pixel row defined. Now we type these into the program definition, for display by MaxMatrix on the 8x8 led matrix.One thing to bear in mind with the creation of characters for this particular 8x8 led matrix using MaxMatrix libraries. The byte values are COLUMNS (notice the orientation from the photographs) when the matrix is plugged into a bread board with the MAX2719 chip to the bottom. If more than one matrix is going to be used then this needs to be considered in order to have a seamless scrolling display device.The Character Designer is generating byte values in ROWS. So rotate the graphic design accordingly, in order to generate values in the correct orientation. Note1: there are other free tools out there, a general web search should bring up a few popular ones.", "step_imgs": ["https://cdn.instructables.com/FSI/N45Z/IKFPY7P7/FSIN45ZIKFPY7P7.LARGE.jpg", "https://cdn.instructables.com/FHE/QPPC/IKH7KHGG/FHEQPPCIKH7KHGG.LARGE.jpg", "https://cdn.instructables.com/FP3/HMR6/IKK0AQ9A/FP3HMR6IKK0AQ9A.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: Character Designer"}, {"step": 9, "steps_text": "There is a lot of room for improvement. The sketch code additions I have made to these public domain examples are not the best solutions to the problem. There is plenty of room for expansion on this project idea. However the 8x8 led matrix will display real world data quite readily, as shown in Step 6 with the photo resistor. The die game developed for Step 7 is actually quite playable, once the capacitor is added to the circuit.Try adding another 8x8 led matrix.    Make the die game a dice game (two or three dice)How many 8x8 led devices can we chain together?I think we have clearly shown that the ATtin85 is quite a versatile little chip. The 8x8 led matrix adds some very simple display possibilities that may be leveraged for some quite powerful ideas. The memory constraints imposed by the micro controller itself do not necessarily mean that a project may not be completed. A little compromise and ingenuity could lead to some very interesting projects.", "step_imgs": [], "step_title": "Step 9: Conclusion: Make It Better"}, {"step": 10, "steps_text": "A short list of instructable projects and information that helped produce this project.16x8 LED dot matrix with MAX7219 module by BIGDOG1971Brainy-BitsSpidey Sense!Best Microcontroller Projects.Arduino Photo-Resistor TutorialArduino LED Matrix KitPJRCArduino Button Tutorial", "step_imgs": [], "step_title": "Step 10: Further Reading"}], "channel": "Arduino"}, {"category": "technology", "description": "This instructable walks you through programming and using the Boston Android Xmega evaluation board to work as a simple arbitrary waveform generator taking advantage of the integrated 12bit DAC and high speed DMA controller. I have provided precompiled firmware as well as source code which can be loaded onto the device and configured via a USB port on your PC or laptop. You will need a computer (mac, pc, linux all supported) with an available USB\u00a0port, free driver for the USB-Serial adapter, a Boston Android Xmega EVAL-USB-64 development board ($31.99) and an open source AVR chip programming utility called AVRDUDE. Once set up, you can generate sine, ramp, triangle, square or any waveform you define from 5 to 20KHz with amplitude of up to 3.3Vp-p. It is possible to generate faster waveforms with the arbitrary waveform feature (up to 500KHz).", "title": "Atmel Xmega USB/Serial Arbitrary Waveform Generator", "url": "https://www.instructables.com/id/Atmel-Xmega-USBSerial-Arbitrary-Waveform-Generato/", "section": "technology", "steps": [{"step": 1, "steps_text": "1) Boston Android Xmega EVAL-USB-64 (or comparable) Development Board 2) PC with USB\u00a0port 3) AVRDUDE (free AVR programing software)Also recommended: Oscilloscope (to view waveforms) Headphone or small speaker (to listen to waveforms) WINAVR and AVRSTUDIO to modify the source code and built your own version of the waveform generator software Although this example walks through programming and using the EVAL-USB-64 board, you can use any of the EVAL-USB boards from Boston Android. And if you're very experienced you can download the example source code and build for other target hardware such as the Atmel XPLAIN evaluation board, or the Xmega boards available from chips45 and Mattair, Megavore. The xmega family allows effortless migration of code from one chip to another.", "step_imgs": ["https://cdn.instructables.com/FET/WVPV/G76MFGAH/FETWVPVG76MFGAH.LARGE.jpg"], "step_title": "Step 1: What You Need"}, {"step": 2, "steps_text": "Although not necessary, it is helpful to solder lead wires to your board to make it easy to connect an oscilloscope or frequency counter to observe the waveform output. The waveform output is on PORTB pin 2 and pin1 is configured as GND.", "step_imgs": ["https://cdn.instructables.com/FS2/RSWN/G79D44VK/FS2RSWNG79D44VK.LARGE.jpg"], "step_title": "Step 2: Solder Lead Wires (optional)"}, {"step": 3, "steps_text": "AVRDUDE is available as a standalone source distribution which you can compile with the GCC compiler on a number of operating systems (namely Linux). However,\u00a0if you use a PC running Windows there is a complete\u00a0binary distribution (no compiling needed) called WINAVR which includes AVRDUDE, along with the AVR-GCC compiler which will allow you to modify and compile your own\u00a0version of the waveform generator.Download WINAVR (includes AVRDUDE) Then install it. \u00a0", "step_imgs": ["https://cdn.instructables.com/F8I/TWM9/G7844GI3/F8ITWM9G7844GI3.LARGE.jpg"], "step_title": "Step 3: Installing AVRDUDE"}, {"step": 4, "steps_text": "The EVAL-USB-64 board includes a built in usb/serial bridge IC which creates a virtual serial port on your PC. Most Windows, Linux (and probably Macs) include the necessary drivers and you don't need to do anything. However, if your system complains it needs drivers go here and download the VCP drivers for your platform:Download VCP Drivers", "step_imgs": ["https://cdn.instructables.com/FCV/ME9V/G7844GID/FCVME9VG7844GID.LARGE.jpg"], "step_title": "Step 4: Install USB/Serial Drivers"}, {"step": 5, "steps_text": "  If you are using the EVAL-USB-64, you can download the waveform generator .hex file and move on to the next stepAlternative Path:  If you are using an alternative platform you will need to download and compile the source code. All the code is in a single .c file which is written to be compiled with AVR-GCC. If you are running on a Windows PC you can download the following two packages and compile and program the application on to your board.  1) Download WINAVR  2) Download AVR Studio IDE  3) Create new avr-gcc project in AVR Studio and paste the source code into the initial .c file  4) Compile (creates .hex file to load onto target device)", "step_imgs": ["https://cdn.instructables.com/FB2/E5IP/G7844GJ0/FB2E5IPG7844GJ0.LARGE.jpg"], "step_title": "Step 5: Download Waveform Generator Application"}, {"step": 6, "steps_text": "The EVAL-USB-64 board contains a serial bootloader which allows your board to be programmed with avrdude.  1) Plug your board into the usb port of your PC.  2) Open a command line window.  3) Locate the hex file you downloaded xmega-waveform-serial.hex 4) Within 10 seconds of plugging in your board, execute the following command to load the program image.avrdude -p  x64a3 -c avr911 -P COM5 -b 57600 -e -U flash:w:xmega-waveform-serial.hex  Your com port may be different. To be sure, in windows go to the Device Manager and check \"com ports\" to see what port your board is connected to. It is almost always the highest numbered com port on your system since the builtin com ports are assigned COM1-4 typically. On my laptop it comes up as COM5 but your computer will likely be on another numbered port. Alternative Paths: If you have an Atmel AVRISP mkii or JTAGICE mkii or compatible device you can use Atmel's AVRStudio to program the .hex file you downloaded in the previous step. See Atmel's documentation for using this utility.", "step_imgs": [], "step_title": "Step 6: Program Board"}, {"step": 7, "steps_text": "Connect your board to your PC with a standard USB/miniB cable. Open a serial terminal to the board. Under Windows XP you can use Hyperterm and open a connection to the COM port your device is on (you should know your COM port number from the previous step). Under Vista/7 you can use TeraTerm. The serial port configuration is 9600 Baud, 8N1, no flow control. After you connect you should be able to type 'h' which will print out the usage instructions for the waveform generation utility.", "step_imgs": ["https://cdn.instructables.com/FAU/U3XS/G76MOAYE/FAUU3XSG76MOAYE.LARGE.jpg"], "step_title": "Step 7: Connect to Waveform Generator Over Serial Port"}, {"step": 8, "steps_text": "In your serial terminal enter the following command:s 1000 You should be able to measure 1KHz waveform on your oscilloscope or frequency counter. Alternatively you can hook up a speaker or headphone and hear a low constant tone.", "step_imgs": ["https://cdn.instructables.com/FEM/04GD/G79D44X2/FEM04GDG79D44X2.LARGE.jpg", "https://cdn.instructables.com/FK6/9B47/G79DHTO2/FK69B47G79DHTO2.LARGE.jpg"], "step_title": "Step 8: Generate 1KHz Sine Wave"}, {"step": 9, "steps_text": "Okay, Sine wave is easy to generate without a fancy 12bit DAC. Let's generate some other waveforms including Ramp, Triangle and Square waves:r 1000 t 1000 S 1000", "step_imgs": ["https://cdn.instructables.com/FLZ/18DM/G79D44XC/FLZ18DMG79D44XC.LARGE.jpg", "https://cdn.instructables.com/F4G/ADX8/G79D44XO/F4GADX8G79D44XO.LARGE.jpg", "https://cdn.instructables.com/FQX/SXPQ/G79D44XF/FQXSXPQG79D44XF.LARGE.jpg"], "step_title": "Step 9: Generate 1KHz Ramp, Triangle and Square Waves"}, {"step": 10, "steps_text": "Although you can enter any number you want, for the standard waveforms (sine, square, etc) you should limit the frequency to 5Hz-20KHz. For example 20KHz sine waveform is shown below. To go beyond 20KHz you can use the arbitrary waveform function in the next step to create your own waveform with fewer datapoints (the dac is limited by how fast you copy data to it, the fewer datapoints in your waveform the faster you can go).", "step_imgs": ["https://cdn.instructables.com/F1S/D2H3/G79D44YT/F1SD2H3G79D44YT.LARGE.jpg"], "step_title": "Step 10: Frequency Limits"}, {"step": 11, "steps_text": "Okay, let's generate our own waveform. To do this you use the \"w\" command and you will need to specify the number of datapoints, the frequency the waveform is output and then the data itself: w [freq] [num data points] [data1] [data2] ... [dataN]    Here is an example arbitrary waveform which is a square wave with a trapezoidal shape repeated at 1KHz and 20 data points:w 1000 20 0 0 0 0 0 0 0 0 4095 4050 4000 3950 3900 3850 3800 3750 3700 3650 3600 3550 Note the range of data point values is 0 - 4095 (12 bit resolution) Once the arbitrary waveform is loaded you can change the frequency without re-entering all the data. To keep the same waveform as above change the frequency:w 10000", "step_imgs": ["https://cdn.instructables.com/FAY/BIRA/G79D44ZG/FAYBIRAG79D44ZG.LARGE.jpg", "https://cdn.instructables.com/FSB/QJES/G79D4509/FSBQJESG79D4509.LARGE.jpg", "https://cdn.instructables.com/FW0/UXVR/G79D450N/FW0UXVRG79D450N.LARGE.jpg"], "step_title": "Step 11: Arbitrary Waveforms"}, {"step": 12, "steps_text": "By default when you configure a waveform it is played back indefinitely. But you can also specify a small number of cycles. Here's how you would generate two cycles of a sine wave at 10KHz.n 2 s 10000 This works for arbitrary waveforms as well. To go back to infinite cycles enter the following:n 0", "step_imgs": ["https://cdn.instructables.com/FHF/QO36/G79D450Z/FHFQO36G79D450Z.LARGE.jpg"], "step_title": "Step 12: Number of Cycles"}, {"step": 13, "steps_text": "You can connect a small speaker (or headphones) to the circuit in order to hear what your waveform sounds like (or determine your hearing range). You will want to put a blocking capacitor in series to prevent any DC current from the DAC and to create a bipolar (positive and negative swinging) signal. 1) Solder a 47uF(or whatever you have handy over 1uF) electrolytic capacitor between PORTB header pin 3 and one of the leads to your speaker. 2)\u00a0Solder the other speaker lead to PORTB header pin 2 (the Gnd pin) Electrolytic caps are polarized; make sure you connect the positive end of the cap toward the board (PORTB pin 3) Now set some outputs and listen to them: s 1000 s 2000 r 1000 S 100 s 100 t 100 s 16000 I\u00a0can hear 16KHz sine wave, but above that it's silent..  USE EAR PLUGS\u00a0WHEN\u00a0YOU\u00a0OPERATE\u00a0HEAVY\u00a0EQUIPMENT AND\u00a0POWER\u00a0TOOLS\u00a0KIDS! :-)", "step_imgs": ["https://cdn.instructables.com/FVV/YOJ4/G79DOUAO/FVVYOJ4G79DOUAO.LARGE.jpg"], "step_title": "Step 13: Connecting a Speaker"}], "channel": "Electronics"}, {"category": "technology", "description": "This project demonstrates the process of converting a video file into a format readable by the TI84 Silver Plus graphing calculator. A program is used to convert the data stored on the calculator into a smoothly playing video.You will need:  \u2022 TI Connect Software   \u2022 USB to Calculator wire   \u2022 TI-Coder Software(optional)", "title": "Running Videos on a TI84 Calculator", "url": "https://www.instructables.com/id/Running-Videos-on-a-TI84-Calculator/", "section": "technology", "steps": [{"step": 1, "steps_text": "For video conversion and processing I used Adobe Premiere Pro.Import the video and change the resolution to 95 pixels by 63 pixels. Then match the frame rate to the imported rate. Keep in mind you have a 10 frame limit for uploading to the calculator. I made mine 17 frames long so I could choose which frames would make the video smoother.If you use a green screen:Use a keying effect such as Ultra Key. The picture dictates the settings I used for my screen but yours may be different. Use either a solid white or solid black background as the replacement for the green.Exporting:File format: BMPWidth: 95 pixelsHeight: 63 pixelsFrame Rate: Compatible with input videoAspect: Square Pixels (1.0)Field Order: ProgressiveRender at Maximum DepthUse Maximum Render QualityThe output pictures show both a black and white background color replacing the green screen.", "step_imgs": ["https://cdn.instructables.com/FWK/8UHT/IAQMK8MA/FWK8UHTIAQMK8MA.LARGE.jpg", "https://cdn.instructables.com/FUZ/50DT/IAQMK8OO/FUZ50DTIAQMK8OO.LARGE.jpg", "https://cdn.instructables.com/F0L/ZCVP/IAQMK8N6/F0LZCVPIAQMK8N6.LARGE.jpg", "https://cdn.instructables.com/F9H/8LWQ/IAQMK8NV/F9H8LWQIAQMK8NV.LARGE.jpg", "https://cdn.instructables.com/FIX/2LZI/IAQMK8NY/FIX2LZIIAQMK8NY.LARGE.jpg", "https://cdn.instructables.com/FG9/L7YQ/IAQMK8PE/FG9L7YQIAQMK8PE.LARGE.jpg", "https://cdn.instructables.com/FUH/HV6Z/IAQMK8Q5/FUHHV6ZIAQMK8Q5.LARGE.jpg"], "step_title": "Step 1: Video Conversion and Processing"}, {"step": 2, "steps_text": "Since the calculator works based on turning pixels on and off, the only readable format is monochrome.In other words we need to convert the BMP files to a lower resolution based on pixels being filled or blank.To do this, first go to http://image.online-convert.com/convert-to-jpg and individually convert each picture using the settings shown in the reference picture.Save each file in the series you want them to appear on the calculator.", "step_imgs": ["https://cdn.instructables.com/FDJ/F7PF/IAQMK8SG/FDJF7PFIAQMK8SG.LARGE.jpg", "https://cdn.instructables.com/F5Z/L9QS/IAQMK8SH/F5ZL9QSIAQMK8SH.LARGE.jpg"], "step_title": "Step 2: Converting to Monochrome"}, {"step": 3, "steps_text": "1. Open TI Connect2. Click on TI ScreenCapture3. Allow the computer to find and connect to the calculator (make sure the calculator is on)4. Open each individual BMP file into the ScreenCapture window5. Send the pictures 1-by-1 to the calculator by using the Send Picture button (as shown in the reference image)-Note: Be sure to start at pic0 and continue to pic9           This process can take some time but once you get the rhythm things go much faster", "step_imgs": ["https://cdn.instructables.com/FOC/90GT/IAQMK8LK/FOC90GTIAQMK8LK.LARGE.jpg", "https://cdn.instructables.com/F1J/CGGM/IAQMK8U4/F1JCGGMIAQMK8U4.LARGE.jpg", "https://cdn.instructables.com/F1I/XDLI/IAQMKIW8/F1IXDLIIAQMKIW8.LARGE.jpg", "https://cdn.instructables.com/FSB/SXDD/IAQMKIWB/FSBSXDDIAQMKIWB.LARGE.jpg", "https://cdn.instructables.com/FKN/XXWB/IAQMKIWC/FKNXXWBIAQMKIWC.LARGE.jpg", "https://cdn.instructables.com/FEQ/X54N/IAQMKIX2/FEQX54NIAQMKIX2.LARGE.jpg", "https://cdn.instructables.com/FSV/5KWP/IAQMKIX3/FSV5KWPIAQMKIX3.LARGE.jpg", "https://cdn.instructables.com/F55/61L3/IAQMKIXR/F5561L3IAQMKIXR.LARGE.jpg", "https://cdn.instructables.com/FX8/TBHJ/IAQMKIVI/FX8TBHJIAQMKIVI.LARGE.jpg"], "step_title": "Step 3: Uploading to the Calculator"}, {"step": 4, "steps_text": "To get the frames to appear as a video, we need to create a program that cycles through the frames at a variable rate. To do this you can type the program directly on the calculator by pressing PRGM, NEW, naming the program, and typing the code (this is a very tedious process and is not recommended).The best way to do this is to visit http://www.ticalc.org/archives/files/fileinfo/396/39658.html and download the         TI-Coder application (this does not need to be installed to run). Unzip the file and open the application. Then paste the code found in the attached text document. -Note: If you are programming directly onto the calculator, use the same code but press the STO> key in replace of the \u00fc", "step_imgs": ["https://cdn.instructables.com/FDX/888Q/IAQMK8T7/FDX888QIAQMK8T7.LARGE.jpg", "https://cdn.instructables.com/FML/Q9RR/IAQMK8T9/FMLQ9RRIAQMK8T9.LARGE.jpg", "https://cdn.instructables.com/F47/PG3A/IAQMK8TC/F47PG3AIAQMK8TC.LARGE.jpg", "https://cdn.instructables.com/FLJ/7DPD/IAQMK8U1/FLJ7DPDIAQMK8U1.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Programming"}, {"step": 5, "steps_text": "To run the program,  simply navigate to PRGM, select the program, and press run. A menu prompting \"SPEED:\" will appear. Type a number to represent how fast the pictures should move between each other (faster is smaller numbers, slower is larger numbers). I've found that 5 seems to work well with most videos. Now if you are afraid that you will lose the program (clearing the calculator's RAM will delete the pictures and program) you can do the following:Perform the keystroke 2nd, +, 8Select Create NewName the GroupPress 2Select the program and each pic filePress the right arrow key and select DoneNow if you clear the calculator, you can retrieve the files by doing the following:Perform the keystroke 2nd, +, 8, Right Arrow KeySelect the GroupIf a there is a popup, press 3 (Overwrite All)The program and pictures should now be fully available.If you want to have multiple videos on your calculator, this grouping function can act as a way to switch between videos, with each video setup having its own group.IMPORTANT: To stop the program from playing the video, Press the \"ON\" key followed by \"1\". If the video starts drawing a graph in-between each frame, Press Y1, navigate to each equation in the plot, highlight the equals sign, and press Enter so that the equals sign is no longer highlighted.", "step_imgs": ["https://cdn.instructables.com/FZW/G1JM/IAQMK9J0/FZWG1JMIAQMK9J0.LARGE.gif"], "step_title": "Step 5: Running and \"Archiving\" the Program"}, {"step": 6, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F6L/8UP2/IAQMM382/F6L8UP2IAQMM382.LARGE.gif", "https://cdn.instructables.com/F33/RLKK/IAQMM37Z/F33RLKKIAQMM37Z.LARGE.gif", "https://cdn.instructables.com/F72/CKQU/IAQMM385/F72CKQUIAQMM385.LARGE.gif"], "step_title": "Step 6: Examples"}], "channel": "Electronics"}, {"category": "technology", "description": "This is a radar, designed to detect the distance and direction an object is from the ultrasonic sensor. With the ultrasonic sensor connected to a servo, it has the ability to rotate 180 degress, similar to a radar utilised to detect the position of planes. As the radar wasn't my original idea, I have also made improvements and adjustments to the original source of this project. This includes 3D printing an ultrasonic sensor bracket, laser cutting a box to make it look cleaner, and the inclusion of a buzzer. The original inspiration for this project can be viewed here: https://www.youtube.com/watch?v=JvmIutmQd9U as it gave me a good understanding into what the end result was going to look like, but also gave me ideas on improvements I could make to the overall aesthetics of the project.", "title": "How to Make an Arduino Radar", "url": "https://www.instructables.com/id/How-to-Make-an-Arduino-Radar/", "section": "technology", "steps": [{"step": 1, "steps_text": "The materials required for this build include:- 1 Servo- 1 Ultrasonic sensor- 1 Buzzer- 1 Bread board- 1 UNO R3 Arduino- Heaps of wiresPrograms required to make this radar:- Arduino IDE - Processing 3.4 To download the above programs onto your computer, follow the links below:-  https://www.arduino.cc/en/main/software-  https://processing.org/download/", "step_imgs": ["https://cdn.instructables.com/FAO/060W/JOONZ6T7/FAO060WJOONZ6T7.LARGE.jpg", "https://cdn.instructables.com/F1T/SMO4/JOONZ6TC/F1TSMO4JOONZ6TC.LARGE.jpg"], "step_title": "Step 1: Materials and Programs"}, {"step": 2, "steps_text": "This is the arduino code which basically controls the movement and input of the servo and sensor. This was copied from the youtube video https://www.youtube.com/watch?v=JvmIutmQd9U and seemed to work nicely with my arduino board and computer. // Includes the servo library\n#include <Servo.h>. \n// Defines Trig and Echo pins of the Ultrasonic Sensor\nconst int trigPin = 10;\nconst int echoPin = 11;\n#define buzzerPin A0 //Defines the pin A0 as an output to buzzerPin\n// Variables for the duration and the distance\nlong duration;\nint distance;\nServo myServo; // Creates a servo object for controlling the servo motor\nvoid setup() {\n  pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output\n  pinMode(echoPin, INPUT); // Sets the echoPin as an Input\n  Serial.begin(9600);\n  myServo.attach(12); // Defines on which pin is the servo motor attached\n}\nvoid loop() {\n  // rotates the servo motor from 15 to 165 degrees\n  for(int i=15;i<=165;i++){  \n  myServo.write(i);\n  delay(30);\n  distance = calculateDistance();// Calls a function for calculating the distance measured by the Ultrasonic sensor for each degree\n  \n  Serial.print(i); // Sends the current degree into the Serial Port\n  Serial.print(\",\"); // Sends addition character right next to the previous value needed later in the Processing IDE for indexing\n  Serial.print(distance); // Sends the distance value into the Serial Port\n  Serial.print(\".\"); // Sends addition character right next to the previous value needed later in the Processing IDE for indexing\n  tone(buzzerPin, 10000 / distance);\n  }\n  // Repeats the previous lines from 165 to 15 degrees\n  for(int i=165;i>15;i--){  \n  myServo.write(i);\n  delay(30);\n  distance = calculateDistance();\n  Serial.print(i);\n  Serial.print(\",\");\n  Serial.print(distance);\n  Serial.print(\".\");\n  tone(buzzerPin, 10000 / distance); //Produces a different tone according to the distance the object is from the sensor\n  }\n}\n// Function for calculating the distance measured by the Ultrasonic sensor\nint calculateDistance(){ \n  \n  digitalWrite(trigPin, LOW); \n  delayMicroseconds(2);\n  // Sets the trigPin on HIGH state for 10 micro seconds\n  digitalWrite(trigPin, HIGH); \n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n  duration = pulseIn(echoPin, HIGH); // Reads the echoPin, returns the sound wave travel time in microseconds\n  distance= duration*0.034/2;\n  return distance;\n}\n\n\n", "step_imgs": [], "step_title": "Step 2: Arduino Code"}, {"step": 3, "steps_text": "Here is the code I used for the processing program to take the information from the ultrasonic sensor, and turn it into the display that it creates. This was a code the I copied from the video https://www.youtube.com/watch?v=JvmIutmQd9U which worked really well, it only needed a few tweaks.<p>p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px 'Helvetica Neue'; color: #000000; -webkit-text-stroke: #000000}<br>p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px 'Helvetica Neue'; color: #000000; -webkit-text-stroke: #000000; min-height: 12.0px}\nspan.s1 {font-kerning: none}</p><p>import processing.serial.*; // imports library for serial communication</p><p>import java.awt.event.KeyEvent; // imports library for reading the data from the serial port</p><p>import java.io.IOException;</p><p>Serial myPort; // defines Object Serial</p><p>// defubes variables</p><p>String angle=\"\";</p><p>String distance=\"\";</p><p>String data=\"\";</p><p>String noObject;</p><p>float pixsDistance;</p><p>int iAngle, iDistance;</p><p>int index1=0;</p><p>int index2=0;</p><p>PFont orcFont;</p><p>void setup() {</p><p> size (1200, 700); // ***CHANGE THIS TO YOUR SCREEN RESOLUTION***</p><p> smooth();</p><p> myPort = new Serial(this,\"/dev/cu.usbmodem143401\", 9600); // starts the serial communication</p><p> myPort.bufferUntil('.'); // reads the data from the serial port up to the character '.'. So actually it reads this: angle,distance.</p><p>}</p><p>void draw() {</p><p>  fill(98,245,31);</p><p>  // simulating motion blur and slow fade of the moving line</p><p>  noStroke();</p><p>  fill(0,4); </p><p>  rect(0, 0, width, height-height*0.065); </p><p>  fill(98,245,31); // green color</p><p>  // calls the functions for drawing the radar</p><p>  drawRadar(); </p><p>  drawLine();</p><p>  drawObject();</p><p>  drawText();</p><p>}</p><p>void serialEvent (Serial myPort) { // starts reading data from the Serial Port</p><p>  // reads the data from the Serial Port up to the character '.' and puts it into the String variable \"data\".</p><p>  data = myPort.readStringUntil('.');</p><p>  data = data.substring(0,data.length()-1);</p><p>  index1 = data.indexOf(\",\"); // find the character ',' and puts it into the variable \"index1\"</p><p>  angle= data.substring(0, index1); // read the data from position \"0\" to position of the variable index1 or thats the value of the angle the Arduino Board sent into the Serial Port</p><p>  distance= data.substring(index1+1, data.length()); // read the data from position \"index1\" to the end of the data pr thats the value of the distance</p><p>  // converts the String variables into Integer</p><p>  iAngle = int(angle);</p><p>  iDistance = int(distance);</p><p>}</p><p>void drawRadar() {</p><p>  pushMatrix();</p><p>  translate(width/2,height-height*0.074); // moves the starting coordinats to new location</p><p>  noFill();</p><p>  strokeWeight(2);</p><p>  stroke(98,245,31);</p><p>  // draws the arc lines</p><p>  arc(0,0,(width-width*0.0625),(width-width*0.0625),PI,TWO_PI);</p><p>  arc(0,0,(width-width*0.27),(width-width*0.27),PI,TWO_PI);</p><p>  arc(0,0,(width-width*0.479),(width-width*0.479),PI,TWO_PI);</p><p>  arc(0,0,(width-width*0.687),(width-width*0.687),PI,TWO_PI);</p><p>  // draws the angle lines</p><p>  line(-width/2,0,width/2,0);</p><p>  line(0,0,(-width/2)*cos(radians(30)),(-width/2)*sin(radians(30)));</p><p>  line(0,0,(-width/2)*cos(radians(60)),(-width/2)*sin(radians(60)));</p><p>  line(0,0,(-width/2)*cos(radians(90)),(-width/2)*sin(radians(90)));</p><p>  line(0,0,(-width/2)*cos(radians(120)),(-width/2)*sin(radians(120)));</p><p>  line(0,0,(-width/2)*cos(radians(150)),(-width/2)*sin(radians(150)));</p><p>  line((-width/2)*cos(radians(30)),0,width/2,0);</p><p>  popMatrix();</p><p>}</p><p>void drawObject() {</p><p>  pushMatrix();</p><p>  translate(width/2,height-height*0.074); // moves the starting coordinats to new location</p><p>  strokeWeight(9);</p><p>  stroke(255,10,10); // red color</p><p>  pixsDistance = iDistance*((height-height*0.1666)*0.025); // covers the distance from the sensor from cm to pixels</p><p>  // limiting the range to 40 cms</p><p>  if(iDistance<40){</p><p>    // draws the object according to the angle and the distance</p><p>  line(pixsDistance*cos(radians(iAngle)),-pixsDistance*sin(radians(iAngle)),(width-width*0.505)*cos(radians(iAngle)),-(width-width*0.505)*sin(radians(iAngle)));</p><p>  }</p><p>  popMatrix();</p><p>}</p><p>void drawLine() {</p><p>  pushMatrix();</p><p>  strokeWeight(9);</p><p>  stroke(30,250,60);</p><p>  translate(width/2,height-height*0.074); // moves the starting coordinats to new location</p><p>  line(0,0,(height-height*0.12)*cos(radians(iAngle)),-(height-height*0.12)*sin(radians(iAngle))); // draws the line according to the angle</p><p>  popMatrix();</p><p>}</p><p>void drawText() { // draws the texts on the screen</p><p>  pushMatrix();</p><p>  if(iDistance>40) {</p><p>  noObject = \"Out of Range\";</p><p>  }</p><p>  else {</p><p>  noObject = \"In Range\";</p><p>  }</p><p>  fill(0,0,0);</p><p>  noStroke();</p><p>  rect(0, height-height*0.0648, width, height);</p><p>  fill(98,245,31);</p><p>  textSize(25);</p><p>  text(\"10cm\",width-width*0.3854,height-height*0.0833);</p><p>  text(\"20cm\",width-width*0.281,height-height*0.0833);</p><p>  text(\"30cm\",width-width*0.177,height-height*0.0833);</p><p>  text(\"40cm\",width-width*0.0729,height-height*0.0833);</p><p>  textSize(40);</p><p>  text(\"Ryan's Radar\", width-width*0.875, height-height*0.0277);</p><p>  text(\"Angle: \" + iAngle +\" \u00b0\", width-width*0.48, height-height*0.0277);</p><p>  text(\"Distance: \", width-width*0.26, height-height*0.0277);</p><p>  if(iDistance<40) {</p><p>  text(\"        \" + iDistance +\" cm\", width-width*0.225, height-height*0.0277);</p><p>  }</p><p>  textSize(25);</p><p>  fill(98,245,60);</p><p>  translate((width-width*0.4994)+width/2*cos(radians(30)),(height-height*0.0907)-width/2*sin(radians(30)));</p><p>  rotate(-radians(-60));</p><p>  text(\"30\u00b0\",0,0);</p><p>  resetMatrix();</p><p>  translate((width-width*0.503)+width/2*cos(radians(60)),(height-height*0.0888)-width/2*sin(radians(60)));</p><p>  rotate(-radians(-30));</p><p>  text(\"60\u00b0\",0,0);</p><p>  resetMatrix();</p><p>  translate((width-width*0.507)+width/2*cos(radians(90)),(height-height*0.0833)-width/2*sin(radians(90)));</p><p>  rotate(radians(0));</p><p>  text(\"90\u00b0\",0,0);</p><p>  resetMatrix();</p><p>  translate(width-width*0.513+width/2*cos(radians(120)),(height-height*0.07129)-width/2*sin(radians(120)));</p><p>  rotate(radians(-30));</p><p>  text(\"120\u00b0\",0,0);</p><p>  resetMatrix();</p><p>  translate((width-width*0.5104)+width/2*cos(radians(150)),(height-height*0.0574)-width/2*sin(radians(150)));</p><p>  rotate(radians(-60));</p><p>  text(\"150\u00b0\",0,0);</p><p>  popMatrix(); </p><p>}</p>", "step_imgs": [], "step_title": "Step 3: Processing Code"}, {"step": 4, "steps_text": "As my inspiration for this project hadn't included any sort of bracket to hold the ultrasonic sensor in place, I decided that it would be a good idea to 3D print this bracket to give the finished design a cleaner look, and make everything easier to put together. The section which holds the ultrasonic sensor ended up fitting relatively tightly around the ultrasonic sensor, doing a good job at keeping it in place. However, the hole cut out underneath for the servo arm to go in is slightly too big, so I needed to add a lot of glue to keep it in place. But overall, it works quite nicely and gives the design a good look.", "step_imgs": ["https://cdn.instructables.com/F2H/90EX/JOONZ6TA/F2H90EXJOONZ6TA.LARGE.jpg", "https://cdn.instructables.com/FPT/JAU1/JOONZ6TB/FPTJAU1JOONZ6TB.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Ultrasonic Sensor Bracket"}, {"step": 5, "steps_text": "This box was implemented to give the project a clean and professional look. It does a good job at concealing all of the wires and the arduino board itself. To create the actual box design, I used the website http://www.makercase.com/ to get the finger edges to join each side of the box together. This was a very useful website as it saves me heaps of time and is very easy to use. As you can see from the finished product of the radar, I cut out measured holes in the side and top of the design to allow for the parts of the project which needed to be on the outside. This included holes for the servo, which I stuck to the box from underneath, wires to the ultrasonic sensor, the buzzer, and to the arduino board itself from the computer. It is quite big (there is a lot of room in the box) but at least it gives you a lot of room to work with and nothing is ever cramped. If you were to make a box design yourself, you could definitely make ti smaller and everything would still fit. ", "step_imgs": ["https://cdn.instructables.com/FG4/MPI8/JOONZ6T6/FG4MPI8JOONZ6T6.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 5: Laser-Cut Box Design "}, {"step": 6, "steps_text": "As per the arduino code, the ultrasonic sensor has to be wired to pin 10 and 11. Though, as well as with all ultrasonic sensors, it also has to be wired to the ground and 5V pin. The servo has to be connected to the pin 12 (myServo.attach(12);) and it also has to be connected to the ground and 5V pins. As for the buzzer, it just connects to ground and the analog output pin A0. Once you have attached all the necessary items for the radar, your circuit should look somewhat like the diagram above. Also, try and keep everything neat! Once the circuit is in the box, it the wires are all extremely tangled, there is the chance a wire or two can slip out of place and cause your radar to malfunction. It happened to me, and I found keeping it neat from then on reduced these occurrences. ", "step_imgs": ["https://cdn.instructables.com/FIN/F4DU/JOMTIJ75/FINF4DUJOMTIJ75.LARGE.jpg", "https://cdn.instructables.com/F65/UISP/JOONZ6T9/F65UISPJOONZ6T9.LARGE.jpg"], "step_title": "Step 6: Wiring Construction"}, {"step": 7, "steps_text": "Assemble the laser cut box using strong super glue, so there is no chance that it will slip apart after you have finished the radar. I found it easier to use some books to hold up one of the sides of the box so I could then glue the adjacent side. After holding it there for 5 or so minutes, I would then continue to the next side and so on. Remember no to glue one of the ends on, as you will obviously need to put in and take out the radar. Once the glue on your box has hardened, you can continue with your assembly. Firstly, I glued the buzzer to the top of the case (shown above) and then when that was dry, I fed the wires through the relative hole and connected them to the buzzer. When it came to the servo, I glued the little wings of the servo underneath the box, so just the top part of the servo was showing. This allowed the whole thing to look aesthetic while also maintaining it's practicality, with the head of the servo readily available for easy access. Then with the ultrasonic sensor in the 3D printed bracket, attach the bracket to the servo using glue so that it is secure. Once this is done, your project is ready to test! ", "step_imgs": [], "step_title": "Step 7: Assembly"}, {"step": 8, "steps_text": "First start by connecting your computer to the arduino board. Next, open up both programs. Once the arduino code has loaded, upload it to the board. This should begin the servo and the buzzer, so noises will be produced and the servo will turn accordingly. Then, when the processing code has loaded, click run and if everything runs smoothly, the animation of the radar should appear. If this doesn't happen, check that the port name you are using is exactly the same as what it says in the code. For example if I am using the port \"/dev/cu.usbmodem143401\" , make sure the line of code in processing says \"myPort = new Serial(this,\"/dev/cu.usbmodem143401\", 9600);\". This should fix everything and it should all run smoothly. The process of getting it up and running can all be seen on the video link above of it working and detecting objects. ", "step_imgs": [], "step_title": "Step 8: Execution"}], "channel": "Arduino"}, {"category": "technology", "description": "Especially really appreciate Nicola Hoelzl (who is a translator) sent the great feedback and modified tutorials to make it better. Now the article is updated with Nicola's great suggestions, please enjoy reading. Thank you so much, Nicola!Tinkercad is amazing, but here is no one command to match an object (like text) to another object (such as a curved wall). However, the combination of hole and group commands can achieve these complicated shapes. In this tutorial, you are building curved text as an example. The matching video is at https://www.youtube.com/watch?v=VgVfIfT-Xso, but it will be easier to follow these steps.", "title": "Tinkercad: Easy to Create Curve Text", "url": "https://www.instructables.com/id/Tinkercad-Easy-to-create-Curve-Text/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, create the wave shape. Under Community shapes, find and edit the \u201cS Wall\u201d shape to match the wave in the screengrab.", "step_imgs": ["https://cdn.instructables.com/FHB/8OAH/ID4CTJT1/FHB8OAHID4CTJT1.LARGE.jpg", "https://cdn.instructables.com/F94/DX1S/ID4CTK6U/F94DX1SID4CTK6U.LARGE.jpg"], "step_title": "Step 1: Ready? Let\u2019s Start!"}, {"step": 2, "steps_text": "Drag the Text shape from right panel and enter your text.Rotate the Text to make it perpendicular to the S-Wall shape. Hold down the Shift-key while you rotate to make this more accurate. Stretch the depth of the Text (or raise the height in the inspector). Move the Text to cross the wave object, as on screengrabs above.", "step_imgs": ["https://cdn.instructables.com/FIE/TTMI/ID4CTJT2/FIETTMIID4CTJT2.LARGE.jpg", "https://cdn.instructables.com/FZW/1YTZ/ID4CTJT3/FZW1YTZID4CTJT3.LARGE.jpg", "https://cdn.instructables.com/FAH/9QJD/ID4CTJT4/FAH9QJDID4CTJT4.LARGE.jpg", "https://cdn.instructables.com/F42/3E7E/ID4CTJT5/F423E7EID4CTJT5.LARGE.jpg", "https://cdn.instructables.com/FGG/FHBG/ID4CTJT7/FGGFHBGID4CTJT7.LARGE.jpg", "https://cdn.instructables.com/F47/Y1MP/ID4CTJT9/F47Y1MPID4CTJT9.LARGE.jpg"], "step_title": "Step 2: Add Text"}, {"step": 3, "steps_text": "Cover the Wall shape with a Box shape, while letting the Text shape pop out in the front and back. Optionally, let the curved Wall shape stick out to easily select it later. (This might not work for other shapes, so learn to deselect using Shift-key.)Set the Text as hole. Group Text and Box. Set new group as hole. Now your design will look like the screengrab above.", "step_imgs": ["https://cdn.instructables.com/F11/U9GF/ID4CTJTB/F11U9GFID4CTJTB.LARGE.jpg", "https://cdn.instructables.com/F5G/HCM1/ID4CTJTC/F5GHCM1ID4CTJTC.LARGE.jpg", "https://cdn.instructables.com/F4K/SVIM/ID4CTJTD/F4KSVIMID4CTJTD.LARGE.jpg"], "step_title": "Step 3: Make Hole of the Negative Space"}, {"step": 4, "steps_text": "Select the wave shape, use Ctrl + D to duplicate the object in the same location.If you had the shape stick out, now change the height of its duplicate to less than the grouped Box-and-Text hole. While the duplicated shape is still selected, hold the Shift-key to additionally select the grouped Box-and-Text. Now group these two objects.Use the arrows on your keyboard to move the letters a bit out of the wave and change the color.", "step_imgs": ["https://cdn.instructables.com/FFI/ZDCS/ID4CTJTE/FFIZDCSID4CTJTE.LARGE.jpg", "https://cdn.instructables.com/FTA/N3BY/ID4CTJTF/FTAN3BYID4CTJTF.LARGE.jpg", "https://cdn.instructables.com/FWA/O3UW/ID4CTJTG/FWAO3UWID4CTJTG.LARGE.jpg", "https://cdn.instructables.com/FMX/MOSF/ID4CTJTH/FMXMOSFID4CTJTH.LARGE.jpg", "https://cdn.instructables.com/FSV/KW9O/ID4CTJTI/FSVKW9OID4CTJTI.LARGE.jpg"], "step_title": "Step 4: Conform Text to Wave Shape"}, {"step": 5, "steps_text": "Try this process on other shapes!", "step_imgs": ["https://cdn.instructables.com/FMQ/7ZYJ/ID4CTJT0/FMQ7ZYJID4CTJT0.LARGE.jpg"], "step_title": "Step 5: Try This Process on Other Shapes!"}, {"step": 6, "steps_text": "Using the same method, please practice to create text on the sphere surface.Or, you also can MAKE A TROPHY FOR THE ONE MILLIONTH TINKERER!! create your text on the trophy.", "step_imgs": ["https://cdn.instructables.com/F6R/4W61/ILCN5O2I/F6R4W61ILCN5O2I.LARGE.jpg"], "step_title": "Step 6: Practice: Create Text on Sphere"}], "channel": "Software"}, {"category": "technology", "description": "The purpose of this project was to make a scanner:1. That can scan pieces with maximun dimensions of 25cm in height and 10cm in width. 2. Cost-friendly 3. With the detail list of all materials usedThe end result was very successfull and hopefully this instructable will help more people try it and have fun while learning. YOUTUBE link of a scan:https://youtu.be/oZjiIRMD-Ho", "title": "DO YOUR OWN SCANNER 3D", "url": "https://www.instructables.com/id/DO-YOUR-OWN-SCANNER-3D/", "section": "technology", "steps": [{"step": 1, "steps_text": "The hardware of the scanner was made from scratch by machining each of the aluminum pieces used.Three pieces were also designed specially to be printed in 3D, taking into account the advantages that this process entails in the moment of rapid prototypes.List of materials in hardware for the Scanner structure:-Worm gear, Acme 8mm (30cm)-Bearings 608zz-4 Bearings Sc8uu-2 Linear rods (30cm)-Acrilic Base-30 Screws M4 15mm-Metal Screeds-Rivets and rivet gun", "step_imgs": ["https://cdn.instructables.com/FFC/UUXH/IVO5EE8I/FFCUUXHIVO5EE8I.LARGE.jpg"], "step_title": "Step 1: The Hardware"}, {"step": 2, "steps_text": "As mentioned before some of the pieces were made by using a 3D printer to facilitate the process of machining.We used the software of CAD NX 8.-The first piece (Top Left piece) was the base for the bearing 608zz. This piece is screwed to the top of the 3D scanner. (base_balero.stp)-The second piece (Top Right piece) was designed to hold the sensor that will read the object. This piece is screwed to the screw spindle and 4 bolts sc8uu from the rear while the front is screwed the sensor. Being the piece that more geometric constraints presented turned out to be the most complicated to design. Due to variations in the dimensions of the characteristics generated by the machining done to the base of the scanner, within the design of this piece had to counteract these inaccuracies, adding complexity to it. The resulting piece was able to meet all required geometric constraints as well as to place the sensor at a acceptable distance for its work. (base_sensor.stp)-The third piece (Buttom Left piece) is responsible for holding the rotating disk on which the desired scanned object is placed. This piece also fulfills the function of connecting the step motor with the disc, it was designed with nut holes that allowed it to better fit the piece to the engine shaft. (base_disco.stp)-The fourth piece (Buttom Right piece) was made in acrilic by a company called Finito Lab. This base is responsible for holding the piece to be scanned. It is 12cm in diameter and has the four holes designed for the step motor to be fitted.  (disco.stp)", "step_imgs": ["https://cdn.instructables.com/F9F/OOOG/IVO5EGOD/F9FOOOGIVO5EGOD.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: 3D Printing Pieces"}, {"step": 3, "steps_text": "For the assembly of the structure we need to join all of our hardware together. First we take our previously machined aluminum slabs. The two largest one will be top and bottom of a rectangular box that will be created once the rivet joins the other medium length slabs mechanically. Once we have the rectangular box and additional large slab should be joined standing just at the back. Now its time to set the 3D printed pieces in our assembly. First we take the worm and settle it through the spindle. Then the 3D printed piece which is the base for the sensor should be also included in the spindle and joined mechanically with bearing. Bearing will aswell be supporting the two lineal rods. At the top of the spindle another bearing should be set with the second 3D printed piece which is attatched to the aluminum slab. Once we have done the steps described above its turn to add the stepper motors with screws from the botom just leaving the shaft of the motor upside from the rectangular aluminum box. Then two couplers should be added to each of the stepper motors. One is fixed to the spindle and the other to the round rotating base. Its important to mention that this second couple was also a 3D printed part in order to get it fixed correctly to the rotating base.In this way there is no more to do other than settling the sensor through the 3D printed sensor base and making the corresponding electronic connections.", "step_imgs": ["https://cdn.instructables.com/F9G/A8GL/IVO4VK5R/F9GA8GLIVO4VK5R.LARGE.jpg"], "step_title": "Step 3: Assembly"}, {"step": 4, "steps_text": "Once the 3D scanner is assembled you are ready to add the electronic components.The ones used for this scanner are the following:- Arduino Uno - CNC Shield Arduino- 2 Stepper Motor NEMA 17 - Sharp sensor GP2Y0A41SK0F- 2 Pololu drivers A4988- Limit switch- Charger 12V (Power source)In the picture you can see how the electrical connections where made.Be careful while placing the drivers in the CNC Shield, make sure the pines are correctly place and located referring to the shield. Also, remember that is important to connect the motor terminals correctly because this is basic for the direction to where your motors supposed to move. ", "step_imgs": ["https://cdn.instructables.com/FA2/OA6H/IVO5EEZK/FA2OA6HIVO5EEZK.LARGE.jpg"], "step_title": "Step 4: Electronics"}, {"step": 5, "steps_text": "Now you are ready to scan your first piece. Through the Arduino platform the connection with the infrarred sensor and the stepper motors was made, data was printed in the Serial Monitor and saved in an text file. //Declare variablesint scannerValues;int csPin=10;int sensePin=A5;int tStep=2;int tDir=5;int tEnable=8;int push=13;int zStep=4;int zDir=7;int value;void setup() {   //Define stepper pins as digital output pins  pinMode(tStep,OUTPUT);  pinMode(tDir,OUTPUT);  pinMode(tEnable,OUTPUT);  pinMode(zStep,OUTPUT);  pinMode(zDir,OUTPUT);  pinMode(push,INPUT);  //Set rotation direction of motors  digitalWrite(tDir,HIGH);  digitalWrite(zDir,HIGH);  //delay(100);  //Enable motor controllers  digitalWrite(tEnable,LOW);  // Open serial communications  Serial.begin(9600);  Serial.println(value);}void loop() {  int vertDistance=10; //Total desired z-axis travel  int noZSteps=150; //No of z-steps per rotation.  Distance = noSteps*0.05mm/step  int zCounts=50; //Total number of zCounts until z-axis returns home 15  //int thetaCounts=400;  int thetaCounts=200;  // Scan object  digitalWrite(zDir,HIGH);   delay(5000);  for (int j=0; j  {    for (int i=0; i    {      rotateMotor(tStep, 1); //Rotate theta motor one step      delay(200);      //double senseDistance=0; //Reset senseDistanceVariable;      double senseDistance=readAnalogSensor(); //Read Sharp sensor, calculate distance    }    Serial.print('\\n');    rotateMotor(zStep, noZSteps); //Move z carriage up one step    delay(200);  }  // Scan complete.  Rotate z-axis back to home and pause.  digitalWrite(zDir,LOW);  delay(10);  for (int j=0; j  {    rotateMotor(zStep, noZSteps);    delay(10);  }  for (int k=0; k<3600; k++) //Pause for one hour (3600 seconds), i.e. freeze until power off because scan is complete.  {    delay(1000);   }  }//Rotation of platform void rotateMotor(int pinNo, int steps){  for (int i=0; i  {    digitalWrite(pinNo, LOW); //LOW to HIGH changes creates the    delay(1);    digitalWrite(pinNo, HIGH); //\"Rising Edge\" so that the EasyDriver knows when to step.    delay(1);    //delayMicroseconds(500); // Delay so that motor has time to move    //delay(100); // Delay so that motor has time to move  }}//Read sensor data, mean and displaydouble readAnalogSensor() {  //int noSamples=10;    int noSamples=100;  int sumOfSamples=0;  float senseValue=0;  float senseDistance=0;  for (int i=0; i  {    senseValue=analogRead(sensePin); //Perform analogRead    delay(2); //Delay to let analogPin settle -- not sure if necessary    sumOfSamples=sumOfSamples+senseValue; //Running sum of sensed distances  }  senseValue=sumOfSamples/noSamples; //Calculate mean  senseDistance=senseValue; //Convert to double  senseDistance=mapDouble(senseDistance,0.0,1023.0,0.0,5.0); //Convert analog pin reading to voltage  //Serial.print(\"Voltage: \");     //Debug  //Serial.println(senseDistance);   //Debug  //Serial.print(\" | \"); //Debug  //Sharp sensor GP2Y0A41SK0F calibration formulasenseDistance= -176.88*pow(senseDistance,6)+1154.3*pow(senseDistance,5)-3059.7*pow(senseDistance,4)+4197.3*pow(senseDistance,3)-3113.1*pow(senseDistance,2)+1149.8*senseDistance-139.8; //Convert voltage to distance in cm via cubic fit of Sharp sensor datasheet calibration  //Print to Serial - Debug  //Serial.print(\"Distance: \");    //Debug  //Serial.println(senseDistance); //Debug  //Serial.print(senseValue);  //Serial.print(\"   |   \");  Serial.print(senseDistance);  Serial.print(\"\\t\");  return senseDistance;}double mapDouble(double x, double in_min, double in_max, double out_min, double out_max){  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;}", "step_imgs": ["https://cdn.instructables.com/FCV/DDOF/IVO5EFZS/FCVDDOFIVO5EFZS.LARGE.jpg", "https://cdn.instructables.com/FKA/XB8L/IVO5EFZT/FKAXB8LIVO5EFZT.LARGE.jpg"], "step_title": "Step 5: Scanning the Piece"}, {"step": 6, "steps_text": "The data printed in the Serial Monitor has to be copy and paste in a text file that is going to be used in a Matlab program that take cares of plotting the 3D graph corresponding to the scanned piece.Remember to change the name of the .txt in the Matlab program in order for you to 3D plot the correct data.Here is the Matlab program://Declare variablesint scannerValues;int csPin=10;int sensePin=A5;int tStep=2;int tDir=5;int tEnable=8;int push=13;int zStep=4;int zDir=7;int value;void setup() {   //Define stepper pins as digital output pins  pinMode(tStep,OUTPUT);  pinMode(tDir,OUTPUT);  pinMode(tEnable,OUTPUT);  pinMode(zStep,OUTPUT);  pinMode(zDir,OUTPUT);  pinMode(push,INPUT);  //Set rotation direction of motors  digitalWrite(tDir,HIGH);  digitalWrite(zDir,HIGH);  //delay(100);  //Enable motor controllers  digitalWrite(tEnable,LOW);  // Open serial communications  Serial.begin(9600);  Serial.println(value);}void loop() {  int vertDistance=10; //Total desired z-axis travel  int noZSteps=150; //No of z-steps per rotation.  Distance = noSteps*0.05mm/step  int zCounts=50; //Total number of zCounts until z-axis returns home 15  //int thetaCounts=400;  int thetaCounts=200;  // Scan object  digitalWrite(zDir,HIGH);   delay(5000);  for (int j=0; j  {    for (int i=0; i     {      rotateMotor(tStep, 1); //Rotate theta motor one step      delay(200);      //double senseDistance=0; //Reset senseDistanceVariable;      double senseDistance=readAnalogSensor(); //Read Sharp sensor, calculate distance    }    Serial.print('\\n');    rotateMotor(zStep, noZSteps); //Move z carriage up one step    delay(200);  }  // Scan complete.  Rotate z-axis back to home and pause.  digitalWrite(zDir,LOW);  delay(10);  for (int j=0; j  {    rotateMotor(zStep, noZSteps);    delay(10);  }  for (int k=0; k<3600; k++) //Pause for one hour (3600 seconds), i.e. freeze until power off because scan is complete.  {    delay(1000);   }  }//Rotation of platform void rotateMotor(int pinNo, int steps){  for (int i=0; i  {    digitalWrite(pinNo, LOW); //LOW to HIGH changes creates the    delay(1);    digitalWrite(pinNo, HIGH); //\"Rising Edge\" so that the EasyDriver knows when to step.    delay(1);    //delayMicroseconds(500); // Delay so that motor has time to move    //delay(100); // Delay so that motor has time to move  }}//Read sensor data, mean and displaydouble readAnalogSensor() {  //int noSamples=10;    int noSamples=100;  int sumOfSamples=0;  float senseValue=0;  float senseDistance=0;  for (int i=0; i  {    senseValue=analogRead(sensePin); //Perform analogRead    delay(2); //Delay to let analogPin settle -- not sure if necessary    sumOfSamples=sumOfSamples+senseValue; //Running sum of sensed distances  }  senseValue=sumOfSamples/noSamples; //Calculate mean  senseDistance=senseValue; //Convert to double  senseDistance=mapDouble(senseDistance,0.0,1023.0,0.0,5.0); //Convert analog pin reading to voltage  //Serial.print(\"Voltage: \");     //Debug  //Serial.println(senseDistance);   //Debug  //Serial.print(\" | \"); //Debug  //Sharp sensor GP2Y0A41SK0F calibration formulasenseDistance= -176.88*pow(senseDistance,6)+1154.3*pow(senseDistance,5)-3059.7*pow(senseDistance,4)+4197.3*pow(senseDistance,3)-3113.1*pow(senseDistance,2)+1149.8*senseDistance-139.8; //Convert voltage to distance in cm via cubic fit of Sharp sensor datasheet calibration  //Print to Serial - Debug  //Serial.print(\"Distance: \");    //Debug  //Serial.println(senseDistance); //Debug  //Serial.print(senseValue);  //Serial.print(\"   |   \");  Serial.print(senseDistance);  Serial.print(\"\\t\");  return senseDistance;}double mapDouble(double x, double in_min, double in_max, double out_min, double out_max){  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;}El programa de Arduino es cargado, este se tarda aproximadamente 40 minutos para que termine de escanear una pieza para continuar a copiar los datos obtenidos del escaneo del monitor serial y guardarlos en un archivo de texto \u201cpositions#.txt\u201d para su pr\u00f3ximo despliegue en gr\u00e1fica con el programa de Matlab.Programaci\u00f3n Matlabclear all;clc;%% Processing variablesmaxDistance=18.5; %Upper limit -- raw scan value only scanning \"air\"minDistance=3.5; %Lower limit -- raw scan value error: reporting negative readingmidThreshUpper=0.001; %Offset radius threshold around 0midThreshLower=-midThreshUpper; %Offset radius threshold around 0windowSize=3; %Window size for average filter to clean up meshinterpRes=1; %Interpolation resolution, i.e. keep every interRes-th rowcenterDistance=11.5;%9.2; %[cm] - Distance from scanner to center of turntablezDelta=0.25;rawData=importdata('positions4.txt');num=numel(rawData);disp(num);rawData(rawData<0)=0; %Remove erroneous scans from raw data%rawData(rawData=='X')=[];%disp(rawData);indeces=numel(rawData);disp(indeces);%indeces1=200*40*20; %Find indeces of '9999' delimiter in text file, indicating end of z-height scan%disp(indeces1);% Arrange into matrix, where each row corresponds to one z-height.column=50;%cont=indeces/column;rawData(1,:)=[];r=reshape(rawData,[200,column]);r=r';disp(r);r(r>maxDistance)=NaN; %Remove scan values greater than maxDistance;r(rr=centerDistance-r; %Offset scan so that distance is with respect to turntable center of rotationr=abs(r);%disp('r');%disp(r);%Remove scan values around 0midThreshUpperIdx=r>midThreshLower;midThreshLowerIdx=rmidThreshIdx=midThreshUpperIdx.*midThreshLowerIdx;r(midThreshIdx==1)=NaN;% Create theta matrix with the same size as r -- each column in r corresponds to specific orientation%theta=0:360/size(r,2):360;theta=360:-360/size(r,2):0;theta(end)=[];theta=repmat(theta,[size(r,1) 1]);%disp('theta');%disp(theta);theta=theta*pi/180; %Convert to radians% Create z-height array where each row corresponds to one z-heightz=0:zDelta:size(r,1)*zDelta;z(end)=[];z=z';z=repmat(z,[1,size(r,2)]);%disp('r');%disp(r);[x,y,z]=pol2cart(theta,r,z); %Convert to cartesian coordinates%disp('x');%disp(x);%disp('y');%disp(y);%disp('z');%disp(z);%Replace NaN values in x, y with nearest neighbor at the same heightfor i=1:1:size(x,1)   if sum(isnan(x(i,:)))==size(x,2)      x(i:end,:)=[];      y(i:end,:)=[];      z(i:end,:)=[];    break;   endendfor i=1:1:size(x,1)   latestValueIdx=find(~isnan(x(i,:)),1,'first');   latestX=x(i,latestValueIdx);   latestY=y(i,latestValueIdx);   for j=1:1:size(x,2)       if isnan(x(i,j))==0          latestX=x(i,j);           latestY=y(i,j);       else           x(i,j)=latestX;           y(i,j)=latestY;      end   endend%Resample array based on desired mesh resolutioninterpIdx=1:interpRes:size(x,1);xInterp=x(interpIdx,:);yInterp=y(interpIdx,:);zInterp=z(interpIdx,:);%Smoothe data to eliminate more noiseh=fspecial('average',windowSize); %Define average filter%h=fspecial('gaussian',10,1.25); %Define gaussian filterxInterp=padarray(xInterp,[0, windowSize],'symmetric'); %Add symmetric duplicate padding along rows to correctly filter array edgesyInterp=padarray(yInterp,[0, windowSize],'symmetric'); %Add symmetric duplicate padding along rows to correctly filter array edges% xInterp=filter2(h,xInterp); %Filter x% yInterp=filter2(h,yInterp); %Filter yxInterp=xInterp(:,windowSize:end-windowSize-1); %Remove paddingyInterp=yInterp(:,windowSize:end-windowSize-1); %Remove padding%Force scan to wrap by duplicating first column values at end of arraysxInterp(:,end)=xInterp(:,1);yInterp(:,end)=yInterp(:,1);zInterp(:,end)=zInterp(:,1);%Add top to close shapexTop=mean(xInterp(end,:));yTop=mean(yInterp(end,:));xInterp(end+1,:)=xTop;yInterp(end+1,:)=yTop;zInterp(end+1,:)=zInterp(end,1)-zInterp(end-1,1)+zInterp(end,1);%surf(xInterp,yInterp,zInterp); %Plot point cloud as a mesh to verify that processing is correctplot3(xInterp,yInterp,zInterp,'.b'); %Plot point cloud as a mesh to verify that processing is correct", "step_imgs": ["https://cdn.instructables.com/FZW/PPH7/IVO5EFZC/FZWPPH7IVO5EFZC.LARGE.jpg"], "step_title": "Step 6: 3D Plotting"}], "channel": "Arduino"}, {"category": "technology", "description": "In this Instructable, I'll attempt to give an as-comprehensive-as-possible introduction to the world of drone racing and freestyle. Please note, however, that this is a huge, complex topic, with hundreds of websites dedicated to explaining it. I'll attempt to condense as much of this as possible into one Instructable that I'll maintain to the best of my ability.Before I continue, let me state now that this hobby is both expensive and time consuming. Don't let this deter you, but in all fairness, be warned that you may wind up dropping $700+ and many, many hours on this.So what is drone racing?Drone racing is a recently created sport where pilots fly FPV, or first person view, drones at speeds that can exceed 100 mph (If you needed to ask). Reaction times and technology are pushed to the limit as pilots weave through gates, tunnels, and between poles, while VR-like goggles let them see exactly what the drone sees. (Notable pilots: BanniUK, Nurk, Gab707, Wild Willy)OK cool, so then what's freestyle?Drone freestyle is a more relaxed, free way of flying, with no rules or boundaries imposed. Pilots \"float\" upside down in free fall, shoot narrow gaps, \"wallride\" vertical walls or trees, and perform flips, loops, rolls, and other maneuvers in smooth combos. Freestyle emphasizes the freedom of flight, as opposed to the human and technological limitations. (Notable pilots: Mr. Steele, Skitzo, StingerSwarm, Le Drib, Charpu)So now that it's defined, where in the world do I start?Hopefully, you'll know by the end, or at least halfway through. There are simulators, toy drones, simple FPV racing drones, high end FPV racing drones, and finally the custom build. My main focus will be on the custom build, as it's both the most difficult and most interesting part of the hobby, and will give you far better performance in the long run. I'll try to work through these in a logical order, please bear in mind that this is still a work in progress. **Disclaimer** None of the links included are affiliate links. These are direct links to the manufacturer only.Table of contents:Getting startedPicking equipmentSolderingBuilding your droneSoftware setupPIDs", "title": "Getting Started With Drone Freestyle", "url": "https://www.instructables.com/id/Getting-Started-With-Drone-Freestyle/", "section": "technology", "steps": [{"step": 1, "steps_text": "A simulator is nearly mandatory to learning to fly a drone. The easiest and cheapest way to start is with FPV Freerider (available here) which includes a free demo, or for $5 you can pick up the whole package. Other alternatives include Liftoff and the DRL simulator, but both of these are more advanced, and will be more difficult to learn on. These simulators will help you learn the basics of controlling the drone, and how to coordinate maneuvers. For the sake of this Instructable, I'll go with FPV Freerider as the demo simulator. You'll need at minimum a gamepad with two joysticks (Keyboard control is supported but nearly unflyable), but if you do have a RC radio with two gimbals and a USB cable, that'll work better.The basics of flightGenerally quadcopters (or quads) are flown in a Mode 2 configuration. This means that throttle is assigned to the left stick's vertical, or Y axis, Yaw is assigned to the left stick's horizontal X axis, Pitch is assigned to the right stick's vertical Y axis, and Roll is assigned to the right stick's horizontal X axis.There are two primary flight modes as well, self-level or horizon mode, and rate, or acro mode. Horizon mode returns the quad to a level position when the pitch/roll stick is released. Acro mode does not level itself, instead maintaining it's current angle when the pitch/roll stick is released. It's generally best to learn on horizon mode until you get a feel for controlling it, then switching to rate once you're comfortable. FPV Freerider also includes a rate switch, allowing you to determine the sensitivity of the input.Coordinated turnsAfter playing around with the simulator, you may notice that turning at speed is difficult. To fix this, combine roll and yaw in equal amounts to complete a banked turn, maintaining your speed and angle forwards. It may help to think of the quad as a thrust vector in a newtonian environment with very little air resistance: you need to cancel out your existing velocity in one direction, then accelerate in the desired direction (Think vector addition).Getting funky!Once you feel mostly confident with flying and turning and whatnot, try adding in some flips, loops and rolls (You'll need to be in acro mode for this to work). Remember that you'll want to zero the throttle any time you are upside down, otherwise you'll be accelerating downwards. Mess around with it, crash lots, just have fun! There's some neat structures on the map to play around with, just try things.", "step_imgs": ["https://cdn.instructables.com/FVG/XVJZ/J5MQKBYT/FVGXVJZJ5MQKBYT.LARGE.jpg", "https://cdn.instructables.com/F9S/LWWK/J6MGCJGW/F9SLWWKJ6MGCJGW.LARGE.jpg"], "step_title": "Step 1: Starting With a Simulator"}, {"step": 2, "steps_text": "Regardless of how psyched you are about drones, few people want to go drop $750+ on a racing drone right away. A cheap toy quad is an excellent place to start practicing your skills with a real quad without investing too much time or money. Personally I love the FQ777; it's small, charges quickly, is nearly indestructible, and is its own carrying case, so you can throw it in a bag and take it anywhere. Again, really just have fun with it, flying Line of Sight (or LOS) is hard, and trying to keep track of it's orientation can be difficult. With most small toy quads, flying indoors is probably recommended, outdoors the wind and gusts can play havoc with a less powerful drone. Practice on the simulator will still help, a lot of work is done just building muscle memory and coordination.Once you're comfortable, I would recommend looking into a \"real\" racing drone setup: there's a lot of options. I know I'm not able to cover everything here, but hopefully it's a pointer in the right direction.", "step_imgs": ["https://cdn.instructables.com/FLP/JQZZ/J5MQT7JO/FLPJQZZJ5MQT7JO.LARGE.jpg"], "step_title": "Step 2: Starting Cheap"}, {"step": 3, "steps_text": "There's really no simple answer. Your budget is the main determining factor at this point. You'll also have to consider whether you want to fly LOS (line of sight) or FPV. FPV is more expensive, but allows far greater freedom in the air. There are a huge and growing number of ready to fly (RTF) setups on the market, as well as bind and fly (BNF) which requires you to have your own radio (and goggles for FPV), and almost ready to fly (ARF) which require you to have your own radio, goggles, and flight controller board. Nearly every major RC distributor, such as HobbyKing, GetFPV, and HeliPal have their own line(s) of pre-setup racing/freestyle drones.Another factor to take into consideration is the size. A typical FPV racer is built to accept 5\" or 6\" propellers, and generally measures between 220mm to 250mm measured from rotor to rotor. However, recently smaller 3\" and 4\" racing drones have become more popular, as advances in the technology allow them to have the same features as larger drones, but in a lighter, cheaper, and more agile (although slower) package. At the higher end of the prebuilt racer spectrum are drones such as the ImmersionRC Vortex 250 and the TBS Vendetta. These offer high end racer specs, albeit at a premium price. The task of picking out a drone, radio transmitter, and FPV gear can be super daunting and intimidating. I personally started with an Eachine 250 Racer, a drone I would not recommend due to a history of electrical issues. However, it did give me the radio transmitter and an FPV screen, both of which I still use.Again, there's no one answer. The more common radio systems are Spektrum and Taranis, but nearly any RC radio system with 6+ channels can be used. One in particular you may want to consider is the new Taranis QX7, due to it's low price point and number of features. As far as FPV equipment goes, goggles are the best choice as they provide the most immersion and block out sun glare and distracting surroundings. The most commonly used system is the Fatshark FPV system which provides slim, compact goggles with high resolution display, but again at a premium. Personally, I've found the Eachine EV800 to be an excellent set, with a wide display that fills your field of view at a reasonable resolution.Finally, when it comes down to the drone itself, it's what you feel comfortable with. Building your own is not as complex as it sounds, but it will take a lot of time and effort. However, I personally enjoy building just as much as flying, it's all part of the process.", "step_imgs": ["https://cdn.instructables.com/F92/MUZB/J5MQT7MU/F92MUZBJ5MQT7MU.LARGE.jpg", "https://cdn.instructables.com/FYK/G1A9/J5MQT7L1/FYKG1A9J5MQT7L1.LARGE.jpg", "https://cdn.instructables.com/FUB/YWQP/J6MGCKC8/FUBYWQPJ6MGCKC8.LARGE.jpg", "https://cdn.instructables.com/FU4/51PP/J6MGCKXE/FU451PPJ6MGCKXE.LARGE.jpg"], "step_title": "Step 3: So What Do I Buy?"}, {"step": 4, "steps_text": "If you decide to build a custom drone, you're going to need a parts list first of all.At a minimum, you will need:Airframe     Radio transmitter and receiver     Flight controller     4x ESCs (electronic speed controllers)     4x Brushless motors     PDB (Power distribution board)     Lithium Polymer battery (LiPo)     A soldering iron with adjustable temperature     Small gauge rosin core solder     Solder fluxIf you plan on adding FPV equipment, you'll also need:FPV camera     Video transmitter     FPV goggles / screen", "step_imgs": ["https://cdn.instructables.com/FOO/7W5A/J63V2IQN/FOO7W5AJ63V2IQN.LARGE.jpg"], "step_title": "Step 4: So You Want to Build a Drone..."}, {"step": 5, "steps_text": "There are literally hundreds of offerings available for frames, ranging from $30 to $150. Things to note in your search are prop size, style (component placement and arm style), and carbon thickness. At this point you've likely already decided what prop size you'd like to fly with, so there's two main styles of frame to pick from: the H and the X.Main shapeH frames are literally shaped like a sideways H: a long body with arms at either end. Typically the motors are not spaced evenly, instead the sides are pushed closer together to allow for the longer body, which houses the main components. Variants on this style include the Lumenier QAV-R and the Shendrones Shrieker.X frames have evenly spaced motors and typically a compact vertical body containing all the primary electronics. Having the center of gravity and most of the weight in the center gives a more responsive quad with equal response on the roll and pitch axes, which is more desirable for racing. Examples of this style are the Shendrones Krieger and the XHover R5X.ExtrasA couple other factors you may want to keep an eye out for are carbon thickness, arm replacement, protection, and ability to carry an HD camera. Generally arms run from 3-4mm thick, while bodies are often made of 2mm carbon fibre to reduce weight. Thinner arms do mean reduced weight, but at the expense of durability. Adding to this, the removability of the arms is important as well: frames with separate, easily removable arms, such as the QAV-R and Krieger will be easier to fix, whereas unibody frames like the Shrieker require the entire base plate to be replaced in the event of a broken arm. Finally, a more enclosed frame will protect the fragile electronic components better.As far as ability to carry an HD camera goes, generally any quad with 4\" or larger propellers can carry as much as a GoPro session or equivalent. H frames typically have more room to mount the camera; it may get a bit tight on an X frame.Frames are largely subjective, and a balance of preference, usage, and of course aesthetics. After all, if you're already investing in this, it might as well look good right?", "step_imgs": ["https://cdn.instructables.com/FM6/BVIQ/J63V2IXU/FM6BVIQJ63V2IXU.LARGE.jpg"], "step_title": "Step 5: Airframe"}, {"step": 6, "steps_text": "I already touched on this briefly earlier, but here's a few more details on picking out a radio.I'm currently still flying with the FS-i6 that came with my Eachine Racer; you don't need all the bells and whistles to be able to fly well. However, features such as telemetry and audio feedback can be incredibly useful. Telemetry allows the radio not only to talk to the drone, but also allows the drone to talk back, giving information such as battery voltage, flight status, etc. Audio feedback allows you to receive this information without having to take your goggles off or turn your attention away from flying. Another bonus is the number of channels on your radio system. Quads require a minimum of 6 channels; one channel each for throttle, roll, pitch, yaw, arm, and an auxiliary channel. However, more channels allow you to remotely toggle more features, such as flight mode, rate modes, LEDs, and any other extras you may have.Typically the radio will come bundled with a receiver. Please note that not any receiver will work with any remote. Receivers are typically compatible with radios of the same make, but please check the specs! You'll also want to note the output signal from the receiver, more on that in the step on flight controllers.Some examples of popular radio systems include the Spektrum DX6 and DX9, as well as the Taranis and the new QX7. There's also the Turnigy 9XR, and numerous other radios by FRsky, FlySky, OrangeRX, and others.Again, budget is going to be one of the main determining factors here, you can pick a number between $60 and $2000.", "step_imgs": ["https://cdn.instructables.com/FVR/68G6/J5MQTU0W/FVR68G6J5MQTU0W.LARGE.jpg", "https://cdn.instructables.com/F10/FWIS/J654OL35/F10FWISJ654OL35.LARGE.jpg"], "step_title": "Step 6: Radio Transmitter"}, {"step": 7, "steps_text": "The flight controller is the \"brain\" of your quad. There are literally hundreds of options, primarily divided by the central processing chip, which is an STM32F1 - F4. The most common kinds are F1, F3, and F4 chips, with the big difference being the clock speed they can run at. Overall, a faster clock speed means a smoother, better flying quad that is easier to tune. This is not to say an F1 cannot be tuned as well as an F4, it will just require more time, and may not be quite as smooth. Another bonus of the higher end F4 chip is the ability to run more demanding software, which I'll cover later as well.Signal protocolsAs mentioned before, make sure that your receiver and flight controller are compatible. There are four main signal protocols: i-Bus, s-Bus, PPM, and serial. I-Bus, S-Bus, and PPM are supported by the majority of flight controllers, and are single wire communication protocols, meaning the data from all six channels sent by the radio is transmitted along one wire. S-Bus and i-Bus are the fastest of these, but the difference is slight. Serial is a one-channel-per-wire protocol, so your standard six channel radio will require you to run six wires from the radio receiver to the flight controller. Serial is not supported by many flight controllers, notable exceptions including the Naze32 rev5 and rev6. Additionally on flight controllers that do support serial input, more than six channels are generally not supported, limiting your number of aux channels.Extra featuresOther features you may want to look for on a flight controller are OSD (on screen display, basically HUD) and an integrated PDB (power distribution board). Obviously an OSD will only be necessary if you plan to fly FPV, but having it built into the flight controller directly allows you to display more information, giving you the ability to display a virtual horizon, flight modes, and more. Having a PDB integrated directly into the flight controller will save you precious space in your final build, and allows for neater wiring. Although a relatively uncommon feature, it will come in very handy, particularly on tighter, smaller builds, just note that it will generate more heat overall.Also look for extra UART (serial) ports if you plan on including telemetry (if supported by your radio and receiver). This will send data about the quad back to the radio. Please note that this is a slightly more advanced setup which I am not overly familiar with, so please excuse the rather brief explanation. :)Some examples of popular F1 flight controllers are the CC3D and Naze32. For F3 some of the best include the Lux V2, SP Racing F3 (includes OSD and PDB), and the Betaflight F3. For F4, some of the most common are the Revolt F4, F4 EVO, and the Matek F405 (available with OSD/PDB). Finally, there's also the KISS FC.*NOTE* From personal experience, I've found the MPU6050 gyroscope used in some boards (such as the Naze rev6) to be very noisy. This will make it harder to tune, and will add minor vibrations into your quad's flight. Don't make this a determining factor, just be warned. :)", "step_imgs": ["https://cdn.instructables.com/FNG/BXHH/J654OKU4/FNGBXHHJ654OKU4.LARGE.jpg"], "step_title": "Step 7: Flight Controller"}, {"step": 8, "steps_text": "I touched on the PDB briefly in the section on flight controllers. The PDB simple takes the power off the battery and divides it out to four traces, one for each motor. Many PDBs also have 5v and/or 12v takeoffs, which are useful for powering extra electronics that cannot be run off the flight controller or directly off the battery, such as LEDs and many FPV cameras. PDBs are usually designed to stack underneath the flight controller, and are usually pretty easy to pick out.ESC'sESCs, or electronic speed controllers, are what convert the digital signal from the flight controller into the actual output that goes straight to the motors. There's two main concerns when picking out ESCs; firmware and amp rating. The most widely used firmwares currently are BL-Heli and KISS. While many ESCs can run BL-Heli, only KISS ESCs can run the KISS firmware. The amp rating is by far the most important part of picking out a set of ESCs. This depends on the size of battery you intend to use: 3 cell, 4 cell, or even 6 cell, usually abbreviated as 3s, 4s, and 6s. I'll go more in depth in the next step, but essentially the more cells, the more power (Think acceleration and rate of climb). For a 3s battery, a 12a ESC should work fine, but you might be better off on a 20a. For 4s, a 20a ESC will work fine. Finally, for a 6s, you'll probably want to consider a 30a+ ESC, although I HIGHLY recommend building for a 4s and learning on a 3s. A 3s is predictable, a 4s is pretty insane, and a 6s is completely mental.Some common ESCs in the 4s range include the Aikon SEFM, DYS XSD series, Emax Bullet Series, FVT LittleBee, Kiss 18A, Lumenier 35A, Tattu 30A, and the TBS Bulletproof.Note that an ESC slightly larger than your requirements will work just as well. The numbers given here are rough guidelines; for a proper calculation, divide the maximum wattage of your motors by the voltage of your battery (14.8v for a 4s , 11.1v for a 3s). This will give you the minimum amperage of your ESCs.", "step_imgs": ["https://cdn.instructables.com/F5F/CH0G/J6FDZCYR/F5FCH0GJ6FDZCYR.LARGE.jpg", "https://cdn.instructables.com/F4I/CV1R/J654P27W/F4ICV1RJ654P27W.LARGE.jpg"], "step_title": "Step 8: PDB and ESC's"}, {"step": 9, "steps_text": "All drones run on lithium polymer (LiPo) rechargeable batteries. Racing and freestyle drones require vast amounts of power, so be warned that flight time per battery will usually run around the 2.5 - 3.5 minute mark. As mentioned earlier, the major determining factor in buying batteries is the cell count. I recommend starting on a 3s but building your quad so it can handle a 4s, which is what most pilots, such as Mr. Steele, Skitzo, and StingerSwarm fly. It is possible to learn on a 4s, but it is more difficult. If you'd like to see what a 6s looks like, check out MattyStuntz, who has some excellent flight videos. CapacityOnce you've figured out what cell count you want to start with, there's capacity. Capacity is typically measured in mAh, or milliamp hours. A common size is somewhere around 1300 to 1500 mAh, although some pilots do fly as large as a 2200 mAh LiPo. However, the weight of the battery becomes a major factor at that size, and it becomes a tradeoff of flight time, agility, and weight. C ratingFinally, there's discharge rating. This is measured in C, where the maximum output of the battery is mAh capacity * C rating = output in Amps. Note that this is not how to best determine your ESC rating, that should be calculated from the motor's max wattage. Practically, a high performance battery would run around 75-90C, while a trainer battery would be more along the lines of 30C. A lot of this depends on how bold you are with your new drone as well. :)I fly primarily 75C 1300 mAh 4s Tattu LiPos; they offer good performance and are fairly widely available. I learned on 30C 1500 mAh 3s Chinese LiPos, which, while slightly underpowered, were a great introduction to the basics of flight in the wild. Many companies sell their own rebranded LiPos; at least at the beginning, you'll be worrying more about the specs than the brand.", "step_imgs": ["https://cdn.instructables.com/FP9/K62B/J654OKZC/FP9K62BJ654OKZC.LARGE.jpg"], "step_title": "Step 9: Lithium Polymer Battery"}, {"step": 10, "steps_text": "Finally, motors! These are pretty subjective, as a wide range of specs are available from an even larger range of manufacturers. When choosing motors, there's two numbers in particular you'll want to look for; the size and kV rating.Assuming we're talking a 4-6\" quad running a 3-4s LiPo, the most common sizes of motors are 22XX range.(A brief explanation on sizes: the first two digits measure the diameter of the motor's stator in mm, and the second two measure the height of the stator in mm)SizingFor a 5\" specifically, 2204 is typically the starting size, and anything up to 2207 is common. Similar ranges can be used on a 4\" quad, and as low as an 1806, just be aware larger motors will respond more aggressively than on a 5\". For a 6\", you may want to consider 2205 as the starting size to ensure you have adequate power. Motor SpecsMore important than the size of the motor is the kV rating. Basically, RPM at max throttle = kV * battery voltage. Higher kV motors will draw more power, reducing flight time but amplifying thrust. Typically 22XX size motors range from 2300-2600 kV, do note that 2600 kV on any size motors will give a noticeable more aggressive flight.Efficiency and overall thrust generated will vary from motor to motor, check the manufacturer's specs for more information on thrust given varying types of propellers and efficiency rating.You'll want to do a lot of looking when it comes to motors, as they're one of the most important parts of your quad when it comes to performance. From experience, I've found the Emax 2306 2400 kv motors to be extremely efficient and high thrust, managing 4.5 minutes of aggressive flight on a 1300 MaH LiPo, while my lower powered Cobra 2205's only made 3.5 minutes.Another motor you may want to consider are the T-Motor F-40. Although I have not personally flown them, the specs are similar to the Emax motors, and they are highly reviewed by a number of pilots, including Johnny FPV. I myself fly Cobra 2205 2300 kV motors; they have decent \"punch\" but are relatively efficient given their performance. However, it's totally up to you to pick your own specs for your own style of flying.", "step_imgs": ["https://cdn.instructables.com/F78/62CW/J654OL1Z/F7862CWJ654OL1Z.LARGE.jpg"], "step_title": "Step 10: Brushless Motors"}, {"step": 11, "steps_text": "This may seem like a minor detail, but don't overlook your props. You should already know what size you plan on flying, but there's still blade count, angle, and manufacturer. Unlike many other components, the manufacturer is a key part here because they all use different materials and different constructionsYour typical prop is plastic or glass nylon; there are carbon fibre props that perform extremely well, but at a high price, and the brittle carbon breaks easily. Your standard racing or freestyle quad usually runs triblade propellers, which give it more lift and acceleration than a double bladed prop would. Some pilots run 4 blades or even more, but beyond four the efficiency of the prop begins to drop.Blade angle is another way to increase or decrease the aggressiveness of your flight. Again, generally speaking, between 30-45 are the most common angles, with 30 being reasonably calm and 45 being crazy. Recently RaceKraft has popularized a 51 degree blade angle, but these are intended for high performance racing. When picking out props, the prop diameter and angle are commonly abbreviated together, making a 5\" prop with a 45 degree angle a \"5045\".Finally, the manufacturer. This is again a subjective choice; you may want to try various manufacturer's materials to see how they feel in flight (you'll be going through a fair number of props at first). Two of the major competitors are Gemfan and Dalprop. Gemfan's propellers are more flexible, breaking more easily but they do not stay bent, meaning you won't have to worry too much about damaged props. Dalprop, on the other hand, uses a polycarbonate and glass material that is extremely durable and will survive many hard crashes. However, props can get slightly, unnoticeably bent, which will affect flight performance. Play around with this, try different manufacturers and angles and see what suits you best.", "step_imgs": ["https://cdn.instructables.com/F6I/3T8N/J654P38N/F6I3T8NJ654P38N.LARGE.jpg"], "step_title": "Step 11: Propellors"}, {"step": 12, "steps_text": "The FPV camera is what gives you the live video feed to fly by. They are specifically designed to be low latency and to adjust quickly to vary light conditions. Main factors to look for are resolution (TVL), OSD, and lens size.The resolution of FPV cameras is measured in TVL or TV lines, which is a measure of how many alternating black and white lines can be displayed horizontally. Most cameras run around 600 TVL, which isn't exactly HD, but completely fine to fly by.If your flight controller does not have an on-board OSD, you may want to look for a camera that has a built in on screen display. Without the data from the flight controller, the OSD included with the camera will typically only have a timer, voltage, and text display. However, this is plenty for regular flying; you don't even need an OSD if you keep a rough track of how long you've been flying. Lens size determines how wide angle your view is. The typical range is from 2.1mm (Super wide) - 2.8mm (closer to a regular camera). The sweet spot is around 2.5mm, which is what is included with most FPV cameras.A few notable cameras you may want to consider are the Foxeer Arrow V3 and the Runcam Swift 1 & 2. These are standard, commonly used daylight FPV cameras with up to date features.", "step_imgs": ["https://cdn.instructables.com/FNM/E7E2/J654OKWJ/FNME7E2J654OKWJ.LARGE.jpg"], "step_title": "Step 12: FPV Camera"}, {"step": 13, "steps_text": "The video transmitter is what broadcasts the video feed to your goggles or screen. The primary thing to look for here is the transmission power. This typically runs from 200 mW to 800 mW for outdoor quads. You may find 200 mW to be a little weak, shortening your range and giving you worse reception through obstacles. However, this range may be better for flying with others, either for fun or in a race, where you have multiple quads blasting video signals over a common area. From personal experience, I've found 400 mW to be fine for flying with others as well. From 600-800 mW would be used for longer range setups or for better transmission through and around obstacles.While there are a number of generic video transmitters, one you may want to consider is the TBS Unify. While at a premium price point, it offers channel and output power switching through a compatible radio (very handy in the field). The Immersion RC Tramp is similar in that it offers channel and output switching from a compatible radio, but only to a maximum of 600 mw. Finally, one video transmitter that has been growing in popularity is the Eachine VTX03; despite it's lower power (200 mw), at $14 it's hard to go wrong.The antennae included with your goggles or video transmitter is likely a linear \"stick\" antenna, which does not have great range or coverage. Usually quads are flown with a polarized cloverleaf antenna, such as this. This gives you better video transmission and reception because of the transmission pattern. A few you may want to consider are the TBS Triumph, which, although at a premium, offers better durability and performance; and the Lumenier Pagoda, which has a completely unique and durable design at a much lower cost. ", "step_imgs": ["https://cdn.instructables.com/F0N/I222/J654OL5A/F0NI222J654OL5A.LARGE.jpg", "https://cdn.instructables.com/F6R/21NM/J6FQLUYH/F6R21NMJ6FQLUYH.LARGE.jpg"], "step_title": "Step 13: FPV Video Transmitter & Antennae"}, {"step": 14, "steps_text": "Finally!Once you have all your parts ready to go, you can begin soldering. If you already know how to solder, skip this step. I'll try to give a concise introduction to it, you'll also want to check out lots of other resources, such as this. Don't be scared off by having to solder your own electronics, it's much easier than you might think, and will come in extremely useful in repairing and modifying your drone.What you're really doing Basically melting a soft metal in between two other metal joints so they stay together with good solid electrical contact. Solder joints are not intended to bear weight, just maintain a connection.Prep your surface In order for the solder to stick to the metal pad or wire you're soldering, you need to clean it first. Apply some flux paste to the surfaces you'll be soldering and heat up your iron to around 650\u00b0 for small joints and 700-750\u00b0 for larger joints. Briefly touch the tip of the iron to the fluxed surfaces to melt and boil the flux. You now have a clean \"sticky\" surface to solder to.A caution with electronics Soldering electronics has a reputation for being difficult due to the sensitive components. This means you can't hold the iron on the piece for very long without risk of damaging the sensitive circuits and chips onboard. A good rule of thumb for most pieces is that the iron should not be in contact with the piece for more than 2 seconds. For larger joints, using a wide chisel tip on the iron would be recommended, whereas a thin pointed tip will allow you to precisely solder smaller delicate joints.  Also, ensure that while your work surface is adequately ventilated to remove nasty solder fumes, that you don't have any breeze or wind blowing across the surfaces you are soldering, and that while blowing away solder fumes you don't blow on your work piece. this will unevenly cool it and create a bad solder joint.Pretinning Pretinning is one extra caution to make sure you get the best joint with as little work and contact time as possible. After you've fluxed your pieces, melt a bit of solder onto the tip of the iron and just touch it to the surface. On a wire, the solder should spread out on the immediate area and coat the wire strands in a silvery coating. You may need to get a bit more to ensure that there is solder on all parts of the wire, just make sure you put just enough on to thinly coat it. On a pad, such as a flight controller, ESC, or PDB, load up a bit more solder onto the tip and touch it to the fluxed pad. It should spread out to the corners of the pad and form a little silvery hump.  Make sure to clean the extra solder and flux off your iron frequently by wiping it on a damp sponge; many soldering stations have a holder for one. Never try to reuse old solder, and if there's any discolored or black solder or grunge on your tip, clean it off right away, dab it briefly in a bit of flux, and put some more solder on.Actually making the solder joints already Now that your surfaces are prepped, you can create the actual joint. Most of the soldering you'll be doing is wire-to-pad, which is by far the easiest. Arrange your pieces so that you can hold the surfaces together without getting your fingers too close (the board and wire will get very hot very quickly, I have many burned fingers to prove it). A \"helping hands\" solder workstation may be useful at this point. Get a bit of solder on the iron's tip, and using the tip, press down on the wire onto the solder pad. The solder on the pad from pretinning should melt and allow the wire to slip in, while the solder on the iron's tip should flow over the wire and meld with the liquid solder on the pad, create a smooth, shiny round blob. Remove the iron and hold the pieces without moving for a few seconds. Make sure you don't blow on the joint, or have air flowing around it, and that you don't move either piece until the solder has hardened (roughly 2 seconds). This will create a faulty, untrustworthy joint with stress cracks, which are visibly as a dullness in the surface. The joint should be a smooth round drop, evenly merged and shiny.Through-hole or pin soldering Depending on the style of your flight controller, ESCs, PDB, and radio receiver, you may need to mount some pins or wires through holes in the flight controller or PDB. This is super simple. If you're doing a wire, flux and tin it; if you're doing a pin, don't worry about fluxing or tinning it. Make sure you flux the top and bottom of the hole pad but don't tin it, you need to leave the hole as open as possible. Feed the tinned wire end (or un- fluxed pin) through the hole and fix it in such a way that you can hold it there for soldering. Now on the underside of the hole, where the wire or pin end is, drop a blip of solder from the iron. It should spread around the hole and flow onto the pin or wire smoothly. Again, this should be shiny and smooth. If there's wire sticking out of the solder joint after the solder has cooled, you can snip it with wire cutters to get it out of the way.I understand this is a very rough and brief introduction to soldering. Please don't take my word alone on all of this, there's many in depth tutorials out there, I didn't want to reinvent the wheel.", "step_imgs": ["https://cdn.instructables.com/FT9/1MGS/J7AQWTRB/FT91MGSJ7AQWTRB.LARGE.jpg", "https://cdn.instructables.com/F3P/H38S/J7AQWTRJ/F3PH38SJ7AQWTRJ.LARGE.jpg", "https://cdn.instructables.com/F9T/IBH9/J7AQWTRT/F9TIBH9J7AQWTRT.LARGE.jpg"], "step_title": "Step 14: Soldering"}, {"step": 15, "steps_text": "Now that all that's covered, there's the actual assembling of the main power system. The main flow is as follows:Battery -- PDB -- ESCs -- MotorsMain power supplyTo start with the battery - PDB connection: You'll need a female XT60 plug, some 12-14 gauge wire, and appropriately sized heatshrink (6mm will work fine). First, solder two equal lengths (around 12-15 cm, but this will vary greatly from frame to frame: it needs to reach comfortably from the PDB to the battery) of the wire to the \"bat\" pads on the PDB. Make sure that you use differently coloured pieces of wire for the positive and negative wires, this is super important because you really, really don't want to hook this up backwards. Slip a piece of 15-20mm onto each wire, and solder on the XT60 connector, ensuring that it is soldered on the right way. This is a bit of a complicated joint, it's best explained by this video.Once your XT60 plug is soldered, slip the heatshrink over the joint and shrink it. This can be done with just a hair dryer or even a lighter, just be cautious. ESCsNow that your battery and PDB are connected, you'll need to solder on your ESCs. One side of the ESC will have four wires coming from it: one equal sized set of red and black, and a smaller of white and black (often twisted together and frequently with a connector on the end). Solder the red and black wires to the PDB, paying attention to the positive and negative markings on the PDB (red wire is positive, black is negative). Repeat this for each ESC, and don't worry about the white and black wires; those are signal wires that will be connected to the flight controller.Before you solder on the motors, make sure to check on one detail. Most recent flight controllers are equipped with a feature called pass-through: this allows you to program and adjust the ESC's settings through the flight controller, instead of having to program the ESC directly. Don't worry if you don't have pass-through, just note whether you do or not.If you do, solder the motors straight onto the opposite end of the ESC, where the three pads are. If you do not, you can still solder the motor wires directly to the ESC, just know that you'll have to desolder a couple of them later. Once you have all your ESCs soldered to the PDB, the motors soldered to the ESCs, and the power lead soldered to the PDB, the next step is to wire up the control system. Don't plug the battery in just yet, we need to make sure there's a proper signal going to the ESCs so they don't flip out when they're powered on. ", "step_imgs": ["https://cdn.instructables.com/FOU/FRG2/J654P33T/FOUFRG2J654P33T.LARGE.jpg", "https://cdn.instructables.com/F1W/382D/J654P353/F1W382DJ654P353.LARGE.jpg"], "step_title": "Step 15: Assembling: Power Train"}, {"step": 16, "steps_text": "Now that the main power system is wired in, we can install the main flight controller and radio receiver. Before you begin, check the specs on both your flight controller and your radio receiver for the power requirements. A number of more recent systems can be run straight off the battery (14.8v), but some require a 5v power source. If your flight controller has a built in OSD, you'll want to run it straight off the battery power (if accepted) as this will allow the OSD to display the total remaining battery voltage. Generally PDBs have a 5v and/or a 12v stepdown built in; there may also be a 5v takeoff built into your flight controller.Also depending on your flight controller style, it may be wired with pins and connectors or by direct soldering to metal pads. If you plan on using pins, make sure to solder them on first, it'll be way harder afterwards.Main powerFirst, wire the power to your flight controller. Next, solder the signal wires from the ESCs to the flight controller. Check the documentation for the flight controller to determine where to solder the signal wires. If your ESCs have a built in BEC, there will be three thin wires instead of just the two. If you plan on using the built in BEC to power your flight controller, cut off the red wires on all but one ESC, you only need one. If you are using the BEC to power a flight controller with an onboard OSD, not that the voltage will not display correctly, as the BEC is a 5v stepdown regulator. ESCsIf you're not using a BEC, simply solder wires either directly from the battery leads or from a 5v takeoff to the \"BAT\" pads (or pins) on your flight controller. You can also solder the ESC signal wires (or hook up the pin connectors) so the signal and negative ESC pads, and if you're using BEC power, solder the one red power wire to the positive ESC pad.Make sure when you solder the ESC wires on that they're connected to the right pads. The standard layout for a quad is motor 1 at the bottom right, 2 at the top right, 3 at the bottom left, and 4 at the top left, if you're looking at the quad from behind.Radio ReceiverOk, so now that we have that complicated part over, we just need the radio receiver hooked up. Solder the positive and negative power wires to the appropriate pads on your PDB, and connect the signal wires. If your receiver supports PPM, S-Bus, or i-Bus, you should only have one signal wire (usually yellow) and one input pad on the flight controller. If you're using a receiver with serial output, you'll need to connect each channel's wire to the flight controller. Check the specs on your flight controller here, many have versatile pads that can be used as an auxiliary output or for serial input.Now that your receiver is powered and connected to your flight controller, you can go ahead and add in your FPV equipment (if you so choose), but I would recommend getting the software configured and working first. For the sake of organization I'll continue with the FPV equipment installation, but I would highly recommend getting your software configured and your quad flying at this point first to work out any bugs.", "step_imgs": ["https://cdn.instructables.com/F5G/BKBM/J654P39X/F5GBKBMJ654P39X.LARGE.jpg"], "step_title": "Step 16: Assembling: Control System"}, {"step": 17, "steps_text": "The FPV equipment is generally a very simple setup. Given that most FPV cameras can accept a wide range of voltages, they can be run off nearly any power source on your quad, so use whatever's convenient. Video transmitters are generally the same, which makes things a lot easier.Solder in your power wires for the transmitter and camera however you choose; I personally have one 12v power wire pair coming off my PDB (it was easily available) that splits in two, one for the camera and one for the transmitter. You'll likely have to do a wire-to-wire solder joint here; make sure you cover the joint afterwards with liquid electrical tape or heatshrink, carbon fibre IS CONDUCTIVE.If you have an OSD built into your flight controller that you'd like to use, run the video signal wire into the video in pad, and solder the video out pad to the transmitter. Also, if both your camera and transmitter support audio, solder those together as well. Once your power and video (and audio, if supported) wires are soldered, install the video transmitter antenna and you're set! DO NOT power the video transmitter on without the antenna connected; they get quite warm in normal usage, and without an antenna can overheat and fry. At this point, congratulations! All the electronics in your quad are ready to go.", "step_imgs": ["https://cdn.instructables.com/FSN/3A6N/J654P2V7/FSN3A6NJ654P2V7.LARGE.jpg"], "step_title": "Step 17: Assembling: FPV Equipment"}, {"step": 18, "steps_text": "Now that all the wiring is in place, we need to build our actual quad.Before we get to configuring software and whatnot, you'll want to mount everything to your frame. Although your build and positioning may vary with the style of your frame, the following layout works with 90% of frames.Main StackFirst, your PDB and flight controller are typically mounted in a stack in the center. Most PDBs and flight controllers have the standard 30.5mm hole mounting pattern. In this case, you can mount them on top of eachother: make sure to use some nylon standoffs to separate the two by at least a couple millimeters, as the PDB can get quite hot. If your standoffs are too tall, just sand them down to a good height. Use four long M3 (~12 mm) screws to mount the PDB and flight controller to the frame. If you're using an H frame, the longer body will give you more room to mount the other electronics. Typically the radio receiver and video transmitter are at the back, while you're determining where to put them, remember the video transmitter can get fairly hot. Mount your FPV camera (obviously) at the front, using either hardware included with the frame or the bracket included with the camera.BatteryOne final detail to arrange is battery placement. Depending on the size and style of your frame, you may not be able to put the battery on top, as is typical (H frames usually have plenty of room for a top mounted battery). If you do not have room, you can mount the battery suspended underneath, which will give you a better center of gravity, but will also risk damaging the battery in a crash. Make sure to leave room for an HD camera on the top plate as well!", "step_imgs": ["https://cdn.instructables.com/FI1/JCR1/J654P3HQ/FI1JCR1J654P3HQ.LARGE.jpg", "https://cdn.instructables.com/FUM/0PHH/J6MGD4UD/FUM0PHHJ6MGD4UD.LARGE.jpg", "https://cdn.instructables.com/FGV/CRM5/J6MGD552/FGVCRM5J6MGD552.LARGE.jpg"], "step_title": "Step 18: Mount All the Things: Main Stack"}, {"step": 19, "steps_text": "Now that you've got your power train in place, it's time to add the accessories.Most X and H frames have room at the rear for adding your radio receiver and video transmitter with the antennae coming out the back to avoid prop strikes. Any FPV frame will have a place for the camera (obviously) at the front of the quad, although positioning and protection may vary. CameraThis one's not that hard. Most frames have milled holes or side plates to attach the camera and/or it's bracket to. Fasten it nice and tight, making sure you leave room for it to angle 30-45 degrees. It's best to start with it around 25 or so, but as you get better, you'll want a steeper angle.ReceiverIn a perfect world, your build will have room at the back to mount both your radio receiver and video transmitter; however, sometimes you'll have to get creative. For sure, if you have a diversity receiver with two antennae, you'll want to mount them with a 90 degree offset to get the best range. This may be done either near the middle of the quad out the top in a V tail, at the back in a V tail, or in a number of other configurations I'll cover in the next section. For now, just mount it either with double sided tape, foam tape, or velcro with a zip tie on it as well.TransmitterThe video transmitter is often the hardest part to fit in. You need to leave room for a large bulky mushroom antenna out the back, but also try to avoid getting it too close to your other electronics, as it really heats up in use. Some alternatives to mounting include 90 degree elbow connectors (stick it straight out the top) and extension pig tails, allowing you more flexibility in where you mount the actual transmitter. Some frames are also designed to mount the transmitter vertically: if in doubt, look up some other people's builds.At any rate, you will want to make sure that you have some kind of connector between your video antenna and the video transmitter. This will ensure that in a hard crash, any damage is done to the cheap connector, instead of your expensive video transmitter.", "step_imgs": ["https://cdn.instructables.com/FGI/B22Z/J6MGD5PK/FGIB22ZJ6MGD5PK.LARGE.jpg", "https://cdn.instructables.com/F83/AGRH/J6MGD6WD/F83AGRHJ6MGD6WD.LARGE.jpg", "https://cdn.instructables.com/F79/BUYX/J6MGD6HK/F79BUYXJ6MGD6HK.LARGE.jpg", "https://cdn.instructables.com/F6X/D1OC/J6MGD3HK/F6XD1OCJ6MGD3HK.LARGE.jpg", "https://cdn.instructables.com/F9V/L9FR/J6MGD8DE/F9VL9FRJ6MGD8DE.LARGE.jpg"], "step_title": "Step 19: Mount All the Things: Receiver, Transmitter, and Camera"}, {"step": 20, "steps_text": "Unless you have a satellite receiver on your radio, you'll be left with one or two long wires, and you'll have the video antenna as well. These need to be mounted in such a way as to keep them out of props but still get good reception. Radio antennaeYou'll definitely want to mount your radio receiver antennas with a 90\u00b0 offset (if you have a diversity receiver with two antennae). The best way to do this is by heatshrinking them to zip ties off the back of the frame. Don't cut the antennae! The exposed wire is cut to a very specific length to get the best reception possible. Instead, put a tube of shrinkwrap around each of your back metal frame standoffs, and slide a zip tie inside it. Mount one zip tie going up and one going down. On the zip tie facing downwards, bend it to 90\u00b0 so it comes straight out the back; the other should be sticking straight up. Slip thin tubes of heatshrink along each zip ties and slide your antennae in, then heat them up to shrink them down (You may want to heat them up extra slowly to avoid damaging the wires).Video antennaThe video antenna is usually mounted out the middle of the back plate, or depending on your frame it may mount vertically, or with a vertical antenna. You'll probably want to add an adapter to the video transmitter before screwing on the antenna, so that in the case of a crash, the adapter takes the impact instead of your expensive video transmitter.However you wind up mount the video antenna, bend it so that it's at around a 45\u00b0 angle to the top frame plate. This will ensure that it's as close as possible to straight up while flying forward.", "step_imgs": ["https://cdn.instructables.com/F5X/13U7/J6MGD36C/F5X13U7J6MGD36C.LARGE.jpg", "https://cdn.instructables.com/F56/RY2O/J6MGD44I/F56RY2OJ6MGD44I.LARGE.jpg"], "step_title": "Step 20: A Brief Note on Antenna Management"}, {"step": 21, "steps_text": "Once you have your physical quad built, or at least the basics, it's time to get the software on your flight controller and ESC's configured. I'll run through how to set up your ESC's if you have pass through, and how to set up Betaflight on your flight controller. Betaflight is probably the most widely used software for freestyle and racing, particularly among F1-F3 flight controllers. FlashingFlashing is the process of putting the software on your flight controller. The process will vary among flight controllers, check the included manual or online for information about your specific flight controller. Typically there is a way to enable \"bootloader\" mode when you plug it into your computer. You'll also need the Betaflight configurator (Available as a chrome app). Go to the Firmware Flasher tab, and select your board type from the top pulldown, and the version from the second pulldown. At least at the beginning, ensure the \"Show Unstable Releases\" slider is off. Leave the rest of the settings as is, and click \"Load Firmware [Online]\". This will download the required hex file; once it's finished, hit flash and wait for the board to completely finish flashing before you do anything.Receiver configurationThe first thing you'll want to do with your newly flashed board is get it responding to your radio. Depending on your setup, you may need to connect the LiPo battery to power on the radio receiver, although many flight controllers power the receiver themselves. Plug your flight controller into the USB port, connect your battery, and open up the configurator. Hit connect, then move down to the \"Configuration\" tab on the left. Scroll down to the \"Receiver\" section, and select the protocol you used. PPM, SpekSat (Spektrum sattelite), Sbus, and SUMD are single wire inputs, while PWM requires one wire per channel. If you're using iBus, just select the serial based receiver option, iBus and Sbus are just different brand name protocols.Once you've selected your receiver type, hit \"Save and Reboot\" on the bottom right, and head to the main \"Receiver\" tab on the left hand side. Make sure your radio is on and bound to your receiver, and try wiggling the sticks a bit. You should see the corresponding Roll, Pitch, Yaw, and Throttle meters move. Also flicking the auxiliary switches on your radio should move a couple of the aux channels. If you see a bit of quivering in the values even when you're not touching the sticks, don't worry, it won't affect much in flight. If you're picky, turn up the RC Deadband clicker on the right just a few digits; this creates a deadzone around the center value that ignores any input within it's range. Also make sure that your sticks are in fact moving the right values: if not, adjust the layout in the \"Channel Map\" dropdown.", "step_imgs": ["https://cdn.instructables.com/FX0/EU5L/J6IF04UR/FX0EU5LJ6IF04UR.LARGE.jpg", "https://cdn.instructables.com/FJZ/EJLR/J6IFAD1U/FJZEJLRJ6IFAD1U.LARGE.jpg", "https://cdn.instructables.com/FIA/08N8/J6IF04V3/FIA08N8J6IF04V3.LARGE.jpg"], "step_title": "Step 21: Software: Flashing and Receiver"}, {"step": 22, "steps_text": "Once your receiver is configured and working with your flight controller in BetaFlight, you need to get your motors working. Make sure you have a charged LiPo ready for this part; you'll need the full battery power and you want to make sure you don't drain it dangerously low, so start with it charged. A very important note before you configure any of this: REMOVE YOUR PROPS! I can't stress this enough; you'll be spinning the motors up at this point and your quad is not predictable, no matter how \"right\" it seems. These motors spin incredibly fast (34,000 - 38,000 rpm at theoretical max throttle) and besides the risk of it taking off, props can easily slice skin deeply at a slight nick (speaking from experience).Updating ESC firmwareI'll walk through the setup process for using BLHeli ESCs with passthrough on the flight controller, as this is currently the most common setup. You'll need to get the BLHeli configurator for this (also a Chrome app). Make sure you hit disconnect on the BetaFlight configurator and shut it down first, as it can interfere with BLHeli. Hit connect on the BLHeli configurator, and wait until the screen goes mostly blank with only the two messages at the top. Plug in your battery, and hit read setup. After a few seconds, the configuration settings will pop up. First, hit Flash All at the bottom left corner, select your ESC type, MULTI as the mode (Stands for multishot, one of the most widely used modes), and the most recent version. Hit flash, and wait a few minutes for all the ESCs to finish flashing. Setting ESC parameters and calibrationTo calibrate the ESCs, we'll need to head back to the BetaFlight configurator. Disconnect from and shut down the BLHeli configurator, and open up and connect to the BetaFlight configurator again. At this point, please, Make Sure Your Props Are Removed! Unplug the LiPo, if you haven't already, and go to the motors tab. One quick explanation; the purpose of calibrating the ESCs is to make sure that they're properly adjusted to your setup. Not everything will be perfect in your build, which is why you need to calibrate the ESCs to your setup.Once in the motors tab, check the slider that enables motor control. Again, make sure your battery is NOT plugged in, and slide the master motor control slider all the way to max throttle. What we're doing is giving the ESCs a recognizable pattern to let them know we're calibrating. Now, plug in the battery.You should hear a series of three ascending bleeps. This tells you that the ESCs have recognized the max throttle value. Now, with the battery still plugged in, move the slider all the way to the bottom. Wait for a series of three descending bleeps, and your ESCs are configured! ", "step_imgs": ["https://cdn.instructables.com/FSR/54X2/J6IF09OY/FSR54X2J6IF09OY.LARGE.jpg", "https://cdn.instructables.com/FF0/3JC6/J6IF09NX/FF03JC6J6IF09NX.LARGE.jpg", "https://cdn.instructables.com/FF0/POWJ/J6IF09OV/FF0POWJJ6IF09OV.LARGE.jpg"], "step_title": "Step 22: Software: ESCs"}, {"step": 23, "steps_text": "Nope, you're not done with these after the ESCs.The only thing you need to check is to make sure that the motors are spinning in the right direction. As shown in the diagram at the top, the motors rotate in towards the front, and in towards the back, and are numbered as shown. Open up the BetaFlight configurator once again (don't worry, we're almost done with all the hopping back and forth) and drop down to the motors tab. Make sure your Props are Off, check the motor control slider, and very slowly increase the slider for motor 1. As soon as it starts to spin, leave it at its current position, and brush your finger against the side of the motor gently to figure out which way it's spinning. If you can't tell, simple bring the slider back down and watch the motor bell as it spins down. Repeat this for all the motors, making sure they're responding to the correct slider, and noting if the directions are correct (They almost certainly won't be). If your motors are responding to the wrong slider, you may have to revisit the wiring on your flight controller to make sure the ESC wires are connected properly. Write down which motors need to be reversed.Swapping motor directionsIf you don't have passthrough and your motors are spinning the wrong way, just unsolder and swap any two motor wires on the motors that need reversing. If you are using passthrough, its a little bit more complicated, although faster.Shutdown the BetaFlight configurator, open up BLHeli, read the setup, and under the ESCs that need to be reversed, just select reversed from the drop down. At this point also, under the \"Common Parameters\" box, make sure \"Brake on Stop\" is checked, and change the \"PWM Frequency / Damped\" to DampedLight if it isn't there already. This makes sure that active braking is enabled for the motors, giving cleaner flight. Disconnect, and we're done with BLHeli!", "step_imgs": ["https://cdn.instructables.com/FVA/4CNT/J6IF0A91/FVA4CNTJ6IF0A91.LARGE.jpg", "https://cdn.instructables.com/FF2/QBBE/J6IF0DQ3/FF2QBBEJ6IF0DQ3.LARGE.jpg", "https://cdn.instructables.com/F16/MX30/J6IF0DQ9/F16MX30J6IF0DQ9.LARGE.jpg"], "step_title": "Step 23: Software: Motors"}, {"step": 24, "steps_text": "And you thought we were finally done with this stuff.Head back to BetaFlight again, we're almost there. Head back over to the \"Configuration\" tab, and look under the \"ESC/Motor Features\" box. Set the ESC/Motor protocol to Multishot, and ensure that the third slider is checked (since you'll really want to arm and disarm your quad with an aux switch, NOT a stick position). For the last three values, plug in your battery with the props off. If your motors twitch at all by themselves, turn up the minimum throttle value, somewhere around 1050 - 1070 will usually do the trick. The other two values are typically fine at stock settings.Drop down to the \"System Configuration\" box now. Note that these settings will change wildly depending on the capabilities of your board (F1 - F4). Typically, BetaFlight knows what's a good update and loop frequency, you can try increasing these but at your own risk. At the very bottom of the window, check the CPU load percentage after you save and reboot with a given setting. It should be under 30% at idle to leave a safe window for flight. The very last thing in this tab is Airmode. What airmode does is it keeps the PID (control) loop running even at minimum throttle, and always keeps the motors spinning as soon as your quad is armed. This allows you to control the quad even in freefall, allowing you to pull off tricks like floating upside down, and various stalls. Airmode is actually probably the best known feature in BetaFlight, and one of the reasons it's so common.Mode SwitchesHomestretch, I promise.Pop over to the \"Modes\" tab on the left. This will allow you to set your aux switches to arm and disarm your quad and enable a whole bunch of other features. First, hit \"Add Range\" under ARM. Turn on your radio, and flip the aux switches until you see the orange tick under the slider move around in response to it. You may have to change the aux channel to get a response or to get the desired switch for arming. Drag the sliders around so that when the switch is in the disarmed position, it's in the grey, and when armed, in the orange. Give it a bit of space around it too to allow for imperfections.Here are some other modes you may want to add to your arm switch:Anti-Gravity - No, not that. BetaFlight's antigravity mode just smooths out common twitches and some vibrations on aggressive throttle maneuvers, it's worth enabling.   Angle: One of BetaFlights two self - levelling modes, and the best for beginners. Angle mode returns the quad to level when there is no user input, and will not allow the quad to rotate beyond a certain angle.  Horizon: The more aggresive of BetaFlight's self levelling modes. Horizon mode does not limit the angle of the quad, allowing you to do flips and rolls, but still levelling the quad when there is no user input.  HeadFree: Best for line of sight (LOS) flying, headfree effectively ignores the quad's current yaw angle; pitching forward always angles in the same direction regardless of the quad's orientation.  Failsafe: Engages failsafe mode. Depending on your settings, this disables a quad entirely, disarming and braking the props.  Beeper: If you have a beeper installed on your quad, this causes it to emit a series of beeps, very helpful for finding a lost quad.Don't worry about the rest of the settings right now, just make sure you have something set to arm, and if you want to fly self levelling, either Angle or Horizon set to the same setting as your arm switch.", "step_imgs": ["https://cdn.instructables.com/FGB/CM07/J6IF0MA9/FGBCM07J6IF0MA9.LARGE.jpg", "https://cdn.instructables.com/FJM/UFI7/J6IF0MBF/FJMUFI7J6IF0MBF.LARGE.jpg", "https://cdn.instructables.com/FWG/5GU9/J6IF0MBG/FWG5GU9J6IF0MBG.LARGE.jpg", "https://cdn.instructables.com/FVC/3OF5/J6IF0MCK/FVC3OF5J6IF0MCK.LARGE.jpg"], "step_title": "Step 24: Software: BetaFlight Modes and Configuration"}, {"step": 25, "steps_text": "You finally made it!Whether or not you have FPV equipment installed at this point, always do your first flight line of sight, no matter how comfortable you are with FPV. Put your props on, making sure that they're facing the right way and not upside down (easier to forget than it sounds). Grab your radio and a charged LiPo and find a nice wide open, grassy field.Two quick notes: Never try to fly a 4\" or larger quad in your house. Speaking from experience; I did once and my \"perfectly fine\" quad immediately took off backwards into my foot, leaving a deep cut. Never fly near people, except yourself, and always watch for people who may walk into your flying area.Secondly, whenever you plug your LiPo into your quad, make sure your radio is turned on first. This ensures that as soon as your receiver is powered, it is receiving a signal, so there's no chance of your flight controller somehow misreading a signal and flipping out.Once you're ready, step a safe distance away, ensure that your arm and airmode switch work correctly, (propellors should spin on arm), and try hovering! Play around with the roll, pitch, and yaw to see if any changes need to be made to the sensitivity. Another good test is to cut or reduce throttle briefly, then \"catch\" it with a burst of throttle. Watch and listen for any oscillations or vibrations. Also, unless you're using HeadFree mode for line of sight, don't use too much yaw right away; it's easy to lose orientation. If you feel confident enough and your FPV equipment is already installed, give it a try. It won't be easy at first; try sitting down and keeping your radio on your lap.If you haven't installed your FPV equipment, you can add it anytime now; you've verified that it flies, so you don't have to worry about getting both systems right at the same time. ", "step_imgs": ["https://cdn.instructables.com/FRZ/V3OK/J6MGD23P/FRZV3OKJ6MGD23P.LARGE.jpg", "https://cdn.instructables.com/F1I/6IU7/J6MGD1S6/F1I6IU7J6MGD1S6.LARGE.jpg"], "step_title": "Step 25: Maiden Flight"}, {"step": 26, "steps_text": "After you've flown around a little bit, FPV or line of sight, you'll notice that you're quad probably doesn't fly absolutely perfectly. It will likely oscillate or vibrate when you apply throttle, catch it from a fall, use a punch of throttle, or do a tight sharp maneuver. This is where the complex craziness of tuning comes in.A lot of tuning is just trial and error. Yes there are hundreds of articles all claiming to have the easy solution, and I'll attempt to give an explanation myself, but a lot of it is just learned by experience. Fortunately, the stock values on BetaFlight work very well, if not perfectly, on most quads.RatesRates are the most basic part of tuning. It simply controls how fast the quad rotates per how much you move the stick, typically measured in degrees/second at \"full stick\". If you head down to the \"PID Tuning\" tab in BetaFlight, you'll see your options. Don't worry about the PID tuning for now, it gets really complex. Just to the right of the PID tuning sections for Roll, Pitch, and Yaw, however, you'll find three adjustable sliders: RC rate, Super rate, and RC expo. What these do is change how the rate of rotation is affected by the sticks' movements.First, RC rate. This is your primary adjustment: the higher the value, the faster your quad rotates. This directly affects the \u00b0/s rating.Second, Super rate. This adds an exponential curve to the RC rate, increasing the \u00b0/s rating directly and bowing the curve in the middle, giving you the ability to make smaller adjustments near mid-stick, and super fast flips and maneuvers at full-stick.ExpoLast, RC expo. This is similar to Super rate in that it creates an exponential curve, but unlike Super rate, it leaves the endpoints of the curve alone, simply softening the middle of the curve. If you have your rates at a comfortable spot but need more fine control, try adjusting this.Always be sure to save your changes!Before I leave this section, two more things. As you scroll down, you'll find two more tabs on the right side; throttle adjustments and TPA. The throttle adjustments tab allows you to adjust the throttle response in a similar fashion to the rates. TPA is a different story, I'll cover that in the next section...", "step_imgs": ["https://cdn.instructables.com/F7U/HU5T/J6MG8JFI/F7UHU5TJ6MG8JFI.LARGE.jpg"], "step_title": "Step 26: Tuning: Rates and Expo"}, {"step": 27, "steps_text": "Ah, PIDs. For sure the most complex but most powerful part of tuning. PIDs are just numerical values in a calculation that determines how the quad responds to control input. In other words, they affect how the quad determines how its going to move from it's current orientation to the orientation it's supposed to be in, and how it responds to overcorrection.What they areP, I, and D stand for proportional, Integral, and Derivative. If you went to Wikipedia and looked up PID controllers, you'd be hit with an ugly equation that makes no sense. The math behind these isn't as complex as it seems, but you don't really need to know it. Really, all you need to remember are their basic functions:P: Effectively the strength of the correction when it needs to change angle; too high and it will continuously overcorrect, bouncing around; too low and the flight is extremely sloppy. Think of P as the twitch reaction that corrects the quad to its intended position.I: Effectively how the quad stays in position. This will be more noticeable in wind or freefall: too little I, and the quad hunts around, even when there is no input; too high, and you'll get more vibrations. Think of I as the measure of how well the quad holds its angle.D: Effectively a smoothing factor. D rounds out the response of P and I, giving smoother corrections: however, too high, and you can cause damage to your motors from excessive speed changes, and you controls will lag. Think of D as a rounding off of the correction value changes.What this meansOk, so math aside, BetaFlight has really good stock PIDs. However, I've found them to be typically a little low, so try roughly scaling all the numbers up a bit. I'm currently running my P and I around 60. Generally, P will be a bit higher than I, and D will be around half of either of those numbers.One thing I've found helpful is to move P and D together: if you're going to adjust your P value, try scaling D along with it. Say you do a quick flip, and notice at the end that your quad bounces a bit. That's too high a P. Move P and D both down a bit, and try flying again.If you're getting generally messy flight where the quad doesn't seem to track your flight path, increase I a bit.In summary...Really the best you can do is mess with it. Try stuff, guess at things, look up stuff online (PLEASE), whatever works for you. No set of PIDs work perfectly for two quads. TPAOne last super quick note: TPA. On higher throttle, you may notice some vibrations. TPA basically scales back the PID values at higher throttle to help get rid of these. It's that last setting on the right: TPA breakpoint sets at what throttle values (1000-2000) TPA kicks in, and the TPA value sets the gain, typically around 0.30 - 0.45 works well.", "step_imgs": ["https://cdn.instructables.com/F0A/MY9G/J6MG8QJ2/F0AMY9GJ6MG8QJ2.LARGE.jpg", "https://cdn.instructables.com/F6P/3M04/J6MG8QMF/F6P3M04J6MG8QMF.LARGE.jpg"], "step_title": "Step 27: Tuning: PIDs"}, {"step": 28, "steps_text": "I wanted to throw one more section in here with some hints and tips I've learned from my own flying. FreestyleBecause freestyle is easier and less risky, I've spent most of my time practicing it. Watching some of the best pilots on YouTube like Steele, Johnny, Skitzo, Willy, and others will help you get inspired and teach you some tricks. Try to move the sticks as smoothly as possible, and hold your rate of rotation whenever possible. This will help you get that silky smooth float many pilots have mastered. To some extent, also fly in a way that compensates for some of the issues with your quad. Even \"perfect\" tunes can have trouble with sharp throttle punches or hard flat catches, so try to avoid these. Anyway, freestyle is about fun, so really as long as you're having that, you're good. :)RacingOne confession; I've never actually flown a true race. I've booted around with friends and tried to do laps as fast as possible on my own, but I've never flown an actual race.That being said, the best advice I can give is start slow. Don't worry about speed at the beginning, focus on accuracy and maneuvers. Racing is about being in complete control of your quad and thinking ahead while moving at ridiculously high speeds, so if you can master the control part before adding speed, you're well on your way. Try to find a large, open, grassy field. Hitting anything at race speeds isn't going to be good, but grass is comparitively soft. In fact, most of the pictures in this instructable were taken in the middle of a big overhaul that happened after a high speed pass under a tree nicked a branch and flew into a concrete cinder block, at around 50 kmh. I cracked the top and bottom frame plates, damaged my GoPro, killed my FPV camera, 3 motors, and the flight controller had a close shave (literally). So yeah, practice at low speed, and just get comfortable with the maneuvers.Finally, please make sure to fly legally. With drones becoming more widespread, more rules are being put in place. If you're in the US, make sure to check this out; for Canadians, take a look at this.", "step_imgs": ["https://cdn.instructables.com/FRF/9R1G/J6MGCM4R/FRF9R1GJ6MGCM4R.LARGE.jpg"], "step_title": "Step 28: Flying Tips"}, {"step": 29, "steps_text": "Flying well takes a lot of skill and practice. Having an HD recording camera is a great bonus as it allows you to review your flight and critique yourself and your tune. You don't need to go straight to a GoPro: there's a number of cheaper cameras available in the $100 range, such as the Mobius and Foxeer Legend.However, if you do decide to go the GoPro route, I can say from experience that the footage will be considerably better quality. The GoPro session is also a very convenient size for a mini quad, and even the Session 4 has excellent image quality. Regardless of what HD camera you decide on, I would recommend a 3D printed mount. Although more expensive than a simple piece of foam, they will protect the camera far better, and will absorb more vibrations from the quad, giving you smoother video and avoiding \"jello\" (rolling shutter; jiggly, wavy video). As for the durability, the crash which destroyed my frame hit the GoPro mount head on without leaving so much as a mark: the only damage was on the unprotected side (a slight scratch).Most importantly, have fun, de-stress, and stay inspired. If you have any questions about your build or planned build, or if I didn't explain something clearly in the article, let me know in the comments. I'll do my best to keep this article updated as I learn and fly more, and I'm more than happy to hear any corrections! Also, if you enjoyed or learned anything from this article, please vote for me in the Make It Fly competition, it would be much appreciated :)", "step_imgs": ["https://cdn.instructables.com/F11/FAA3/J70QJU8E/F11FAA3J70QJU8E.LARGE.jpg"], "step_title": "Step 29: From Here"}], "channel": "Robots"}, {"category": "technology", "description": "The slide rules that took men to the Moon were made without computers, so these instructions are based on computerless production.  There are still books in existence that contain the log scales necessary without the use ot computers.I never used anything except circular slide rules, so this Instructable will give directions on how to make those kind.Numbers people do not always do crafts well, so for the sake of people who craft well, the numbers to make a Natural Log scale for a slide rule would be helpful and are included at Step 7.I don't do pictures well, and I speak too much math and too much verbose.  I will try to appreciate questions to help me clarify, if the questions are polite.  An internet search ought to produce plenty of pictures of \"circular slide rules\".The slide rule is based on logarithmic scales, and the accuracy of the slide rule is only as good as the precision of the markings.1.  Mark the uniform log scale.2.  Mark the C scale from the log scale.3.  Mark the Inverse, Square, Cube and / or identical D scales.4.  Mark the Natural Log scale, optional.", "title": "Slide Rule Using Common and Natural Log Scales", "url": "https://www.instructables.com/id/Slide-Rule-Using-Common-and-Natural-Log-Scales/", "section": "technology", "steps": [{"step": 1, "steps_text": "According to programming conventions, * means multiplication and ^ means exponents, so 2 * 3 = 6 and 3 ^ 2 = 9The slide rule is based entirely on the logarithmic scale.  Logarithms are not really intimidating because they are easily calculated with calculators or software.  For now.log(2) = .30103  10 ^ .30103 = 2     log(3) = .4771 10 ^ .4771  = 3     log(50) = 1.699 10 ^ 1.699   = 50A logarithm is defined as:   when     a ^ x = y then     x*log(a) = log(y)For example, because    2 ^ 3 = 8 then      3 * log(2) = log(8) and      3 = log(8) / log(2).Logarithms are usually only roughly equal, they usually require several places for accuracy.10 ^ .48 = 3.01995but 10 ^ .4771212 = 2.9999996", "step_imgs": [], "step_title": "Step 1: Quick Overview of the Math of Logarithms"}, {"step": 2, "steps_text": "Choose a precision of N from 1 to 9.  3 is convenient.   If N = 4 then     log(3) = .4771 when N = 2 then     log(3) = .48The circumference will be determined by the precision N you choose and the length of the scale or markings you choose.  If the precision N = 3 and the smallest unit is 1 mm, then the circumference will be     (10 ^ 3) * 1 mm = 1 meter  Because the circumference equates to PI * diameter, the diameter of the circle would be     (10 / PI)* 10 ^ (N - 1) = 3.183 * 10 ^ (N - 1) in whichever units are being used.  When N = 3 and the units are millimeters, the diameter will be     (10 / PI) * 10 ^ (N-1) = 3.183 * 10 ^ 2                                       = 318.3 mm which would be     318.3 / 25.4 inches = 12.53 inches  The diameter would then be 12.53 inches and the radius would be 6.265 inches.A circle can be formed accurately by fastening the measuring stick in the center of the circle and then marking the radius (half of the diameter) in many directions. There are 360 degrees in a circle.On the log scale, 360/10 = 36 degrees would be the size of each .1 increment on the log scale.360 / 100 = 3.6 for each .01 and360 / 100 = .36 for each .001.On the blank circle, measure 10 ^ N units for the circumference, using measuring tape or a yardstick. If it is too large, then evenly shave off some of the circumference, but be sure to keep it a perfect circle. If it is too small, then a new circle must be cut.Start marking the circumference and the face of the blank circle when the circumference is exactly 1,000 units. Paper is better for finding the perfect dimensions and for making patterns.It is convenient to mark all the .001 increments of the Log scale as 1 millimeter each.To make sure the slide rule is exactly the right diameter, it would be convenient to use a tape measure or a measuring stick to verify the circumference of the circle being used before beginning to make the markings. Using a tape measure would also be a convenient way to mark off the 1 millimeter increments around the outside of the circle for the Log Scale.", "step_imgs": ["https://cdn.instructables.com/F88/U6XR/IDR7SW1S/F88U6XRIDR7SW1S.LARGE.jpg"], "step_title": "Step 2: Calculations"}, {"step": 3, "steps_text": "There are 360 degrees in a circle.  On the log scale, 360/10 = 36 degrees would be the size of each .1 increment on the log scale.      360 / 100 = 3.6  for each .01 and     360 / 100 = .36  for each .001.On the blank circle, measure 10 ^ N units for the circumference, using measuring tape or a yardstick.  If it is too large, then evenly shave off some of the circumference, but be sure to keep it a perfect circle.  If it is too small, then a new circle must be cut.  Start marking the circumference and the face of the blank circle when the circumference is exactly 1,000 units.  Paper is better for finding the perfect dimensions and for making patterns.It is convenient to mark all the .001 increments of the Log scale as 1 millimeter each. To make sure the slide rule is exactly the right diameter, it would be convenient to use a tape measure or a measuring stick to verify the circumference of the circle being used before beginning to make the markings.  Using a tape measure would also be a convenient way to mark off the 1 millimeter increments around the outside of the circle for the Log Scale.", "step_imgs": ["https://cdn.instructables.com/FRW/1HQM/IDR7SW1Q/FRW1HQMIDR7SW1Q.LARGE.jpg", "https://cdn.instructables.com/F6R/R4F4/IDR7SW1T/F6RR4F4IDR7SW1T.LARGE.jpg"], "step_title": "Step 3: Mark the Circle"}, {"step": 4, "steps_text": "This is also a convenient way to make a protractor, which makes it a lot easier to make gears.  If we use 1 mm per each degree,360 millimeters / 3.141592654 = 114.6 mm  diameter, or 57.3 mm radius.pi = 3.141592654Millimeters are convenient units, but as long as they are all uniform, any unit would serve.", "step_imgs": ["https://cdn.instructables.com/FJR/4DGB/IDR7SW1M/FJR4DGBIDR7SW1M.LARGE.jpg"], "step_title": "Step 4: Protractors"}, {"step": 5, "steps_text": "I personally like the slide rules that have an inner turning dial somewhat better than the ones that have two clear cursors like clock hands.  Using two cursor hands requires that they be turned on the face of the slide rule without moving at all relative to the other cursor hand.If there is a rotating inner circle, then there would be a D scale on the outside (of the inner circle) to line up exactly with the C scale on the inside (of the outer ring).Fractions work much better with two dials that can rotate relative to each other.", "step_imgs": ["https://cdn.instructables.com/FKB/IQKM/IDR7SW1O/FKBIQKMIDR7SW1O.LARGE.jpg"], "step_title": "Step 5: Two Dials or Two Cursor Hands?"}, {"step": 6, "steps_text": "In my opinion, the log scale should be the scale on the outside of the largest outside ring of the slide rule, because it requires the highest precision and because it is the foundation on which all the other scales rest.It makes it easier to read the scales when the smallest increments are the shortest length of marking and the 5s are one length and the 10s are another length.The range of the C scale is 0 to 1 in increments of .1 and .01 (and .001 if large enough). The C scale is 10 raised to the log scale, so that 2 on the C scale would line up with .301 on the Log scale, and 7 on the C scale with .845.The D scale is exactly the same as the C scale and is only used on slide rules with two dials the rotate independently.The CI scale is the inverse of the C, so 5 on the C scale would line up with 2 on CI and 2 on the C scale would line up with 5 on CI.  Also, 3  would line up with 333, and 4 would line up with 25.The B scale is C ^ 2 and the K scale is C ^ 3.  With a LogLog scale, these scales are less necessary.Slide rules assume mental calculation of exponents.", "step_imgs": ["https://cdn.instructables.com/FJU/TVBA/IDR7SW1N/FJUTVBAIDR7SW1N.LARGE.jpg"], "step_title": "Step 6: Scales:  C (&D) B, K, CI"}, {"step": 7, "steps_text": "The Natural Log scale is especially useful to verify interest rates being charged.  The Natural Log scale can also calculate exponents directly.On the Natural Log Scale, e ^ .02, e ^ .2, e ^ 2, e ^ 20 all line up, one above the other, under 2 on the C scale.  Decimals and magnitudes are calculated mentally.  Attached are some tables of natural logs, but it would be a good idea to verify the numbers with an old book of mathematical tables.ln(LL scale) = C scaleThe Natural Log scale can be a spiral for the artistically adept.  It is also shown as nesting circles with steps up.  The characteristics (exponents) are left up to mental calculations, but it is easy to calculate 10 ^ 3.  To find the characteristic or  magnitude of the exponent of e only requires following the line down in  value to e ^ (10N) which is 1 on the C scale, 0 on log scale, to easily  see the exponent of e that applies.  For example,  e ^ .1 = 1.1052 and e ^ .04 = 1.0408.PRIME NUMBERSFrom the logs of primes, other values can be calculated.  There are about 200 prime numbers between 1 and 1,000. A slide rule can be created with only a table of the common and natural logs of prime numbers.  The other values can be calculated with each prime number and its common (base 10) or natural (base e) logarithm. For example: 4.2 = (2 x 3 x 7) / 10          = 10 ^ [log(2) + log(3) + log(7) - log(10)]          = 10 ^ [.30103 + .47712 +.8451 - 1]  4.2 = 10 ^ .62345 However, people who most need a slide rule may be more prone to make mistakes in calculating from prime numbers. ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 7: Natural Log Scale"}, {"step": 8, "steps_text": "To increase precision, measure out at a large scale, then scale down to a smaller scale.  Make a very large scale outer \"donut\" template from which to form the portable, personal slide rules.  In the center, have a pin to put the blank slugs on to make into more portable slide rules.", "step_imgs": ["https://cdn.instructables.com/FYI/A811/IDRP5U0U/FYIA811IDRP5U0U.LARGE.jpg"], "step_title": "Step 8: Master Model"}], "channel": "Tools"}, {"category": "technology", "description": "Hi All, welcome to another instructable! This time I wanted to make a really easy instructable you can do as an evening or weekend project. As part of my ongoing learning into spectrophotometry I have been experimenting with diffraction gratings and monochromators, and stumbled upon \"Young's double slit experiment\". This is a fascinating observation about how light travels (in waves) and reveals the effect of diffraction for different wavelengths of light.I decided to try and replicate the experiment to find out for myself how it worked with some laser pointers, and see if I could make the experiment work. ", "title": "Measuring Laser Wavelengths", "url": "https://www.instructables.com/id/Measuring-Laser-Wavelengths/", "section": "technology", "steps": [{"step": 1, "steps_text": "Lasers are really cool, but a warning before we continue! Looking into a laser or a strong collimated beam can blind you. Where possible I would recommend the use of colour filtered safety glasses to prevent stray beams damaging your eyes.Laser pointers are often sold as \"cat toys\" and granted I love to tease my cat with this, but I found the green one very strong (almost too bright to look at). They also profess to be less than 5 mW of power but I found a great disparity between the intensities of each colour (I may make an optical power meter to measure this in a separate instructable?). I doubt the label matches with reality, which we will soon discover when we measure the wavelengths.I bought the following materials for the experiment:x3 laser pointers (red, green, blue)A retort standA diffraction grating slide (500 lines per mm)Paper and pensBulldog gripsMeasuring rulerSafety glasses", "step_imgs": ["https://cdn.instructables.com/FCW/W8E5/JN0L5CA7/FCWW8E5JN0L5CA7.LARGE.jpg"], "step_title": "Step 1: Prerequisites and Safety!"}, {"step": 2, "steps_text": "The stand should be setup so that the laser pointer is aimed down towards the diffraction grating. The laser will pass through the grating and be projected onto a piece of paper at the bottom (the screen). To set this up follow these simple steps:Place a piece of paper at the bottom of the stand to make a screenPlace the lower arm of the retort stand about 10 cm above the standAttach the diffraction grating to the lower arm and secure it with a bulldog gripPlace the upper arm above the diffraction grating (the distance above the grating doesn't matter)Attach the laser to the upper arm so that it is aimed so the beam passes through the diffraction gratingPut your safety gear and, and then your ready to shoot some lasers!", "step_imgs": ["https://cdn.instructables.com/FGN/6LJB/JN0L5C8C/FGN6LJBJN0L5C8C.LARGE.jpg"], "step_title": "Step 2: Equipment Setup"}, {"step": 3, "steps_text": "To find the wavelength of the laser you need to measure the fringe separation. To do this follow this method:When the lasers hit the paper (screen) write down with a pen where the light spots occur (these are known as finges). Make sure you write down the middle one and the ones on both sides.Repeat step 1 for each colour, marking the fringes on the paperOnce you have done this for all lasers, measure the distance between the middle fringe and the 1st fringe next to it (this is known as the 1st order fringe).(You'll notice that there is a discrepancy between the picture and what I have recorded in my results later. This is because I did this a few times to determine uncertainty in the measurement).But how does this relate to wavelength? The equation is lambda = (a * x) / d, where 'lambda' is the wavelength in meters, 'a' is the distance between the slits in the diffraction grating, 'x' is the fringe separation, and 'd' is the distance between the screen and the grating. All of this is available for you to substitute into the equation to give you the wavelength.But you might ask \"how do I know what 'a' is?\". Well, if we know the grating has 500 'lines' per mm, that means there are 500,000 lines per m. If we divide 1m by 500,000 lines, we get the distance between them which is 2 \u00b5m. Together with x and d we can now calculate wavelength.Remember that all these distances are in meters. Wavelength is usually expressed nano meters (10^-9 m) so you will need to consider if you want to convert your answer to nano-meters or simply express is a something times 10^-9.", "step_imgs": ["https://cdn.instructables.com/FI4/GYTK/JN0L5C2T/FI4GYTKJN0L5C2T.LARGE.jpg"], "step_title": "Step 3: Experiment"}, {"step": 4, "steps_text": "I repeated this experiment for this instructable to produce the graph above. In the table you can see two rows (min and max). These are maximum and minimum wavelengths which are indicated on the lasers themselves, so I knew approximately what the wavelength should be to see if I got the right answer.Looking at the calculations, my measurements do not lie within the maximum and minimum bounds but they are at least consistent. The difference between the measured and expected was between 4% and 10%. I did not do a full uncertainty measurement but it is obvious there will be uncertainty introduced by the measurement techniques (i.e. measuring the distance to the screen not being perfectly perpendicular etc). Even with some unaccounted error I believe this is a fair representation of the actual wavelengths and perfectly demonstrates the double slit experiment.If you are interested to see the full set of results I have attached the excel file you can use to perform your own measurements. I am now in the process of playing with collimating lenses and reflectors, let me know if you would be interested in an instructable on this, and let me know what you thought about this quick instructable in the comments.", "step_imgs": ["https://cdn.instructables.com/FHX/NAZS/JN0L5C24/FHXNAZSJN0L5C24.LARGE.jpg", "https://cdn.instructables.com/FGY/QWST/JN0L5CAE/FGYQWSTJN0L5CAE.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Results"}], "channel": "Lasers"}, {"category": "technology", "description": "Star track is an Arduino based, GoTo-mount inspired star tracking system. It can point and track any object in the sky(Celestial coordinates are given as input) with 2 Arduinos, a gyro,RTC module,two low-cost stepper motors and a 3D printed structure.In the first step, I'm going to introduce you to the basics of Positional Astronomy. Next, I'll explain the idea behind this project. I'll give you the Tinkercad links for the 3d printed parts. So you can edit them to your preferences. Also, I'll include a troubleshooting guide based on the problems I encountered during this build. This way you don't have to build the same thing. Maybe you can find a better algorithm to track the stars. Or you can develop the structure and use bigger motors to drive a telescope? Your imagination (and resources of course :')) is the limit. Let me know about your build!EDIT:This instructables was featured on, HackadayArduino's official blogAdafruitIMPORTANT!:This project includes laser pointers thus needs safety measures before use. In many countries, it is illegal to point lasers to an Aircraft and to use them near airports. For more information please check:  http://www.laserpointersafety.com/IMPORTANT NOTE:You can use a cheap red dot sight instead of the laser. This will avoid all the issues with the laser (eye safety, legal issues, airplanes).( thanks for the feedback of Marty on Hackaday)", "title": "Star Track - Arduino Powered Star Pointer and Tracker", "url": "https://www.instructables.com/id/Star-Track-Arduino-Powered-Star-Pointer-and-Tracke/", "section": "technology", "steps": [{"step": 1, "steps_text": "In order to track the stars, you have to know the basics of the Celestial Coordinate System. Celestial coordinates define positions of objects in the sky. It's based on the observations of ancient astronomers. They believed that the earth was motionless and at the center of the universe. The sky, they thought , was a moving sphere surrounding Earth, a celestial sphere.[1] In its modern sense, as used in astronomy and navigation, the celestial sphere is an imaginary rotating sphere of undefined radius. All objects in the sky can be thought of as lying upon the sphere.[2] Unlike planets, since the distance between stars and Earth is gigantic, we can simplify the positions of the stars by projecting them on an imaginary sphere.There are differents ways to specify a objects location on the celestial sphere, These differ in their choice of fundamental plane, which divides the celestial sphere into two equal hemispheres along a great circle.Each coordinate system is named for its choice of fundamental plane:Horizontal systemEquatorial systemEcliptic systemGalactic systemSupergalactic systemEquatorial SystemI chose the Equatorial system for this project. Because the altitude and azimuth of a star are constantly changing, it is not possible to use the horizontal coordinate system in a catalogue of positions. And since this project will track the objects in the sky based on the coordinates given. we need a coordinate system for cataloguing purposes. One based on the celestial equator and the celestial poles and defined in a similar manner to latitude and longitude on the surface of the Earth. In this system, known as the equatorial coordinate system, the position of an object is defined by the declination and right ascension. And the coordinates of an object in the sky do not change relative to your position.[3]Equatorial Coordinates on Celestial sphereLike Earth, the celestial sphere also has an equator, north pole and a south pole called celestial equator, celestial north pole, and celestial south pole. These are just projections of Earths equator,north pole and a south pole on the celestial sphere.Like coordinates on earth (longitude and latitude), two coordinates define a point on the celestial sphere, Declination, and Right Ascension.DeclinationThe coordinate indicating where an object is between the celestial poles is declination. Measured from the celestial equator it ranges from 0\u00b0 to 90\u00b0 at the north celestial pole and to -90\u00b0 at the south celestial pole.[4]Right AscensionThe second coordinate Right Ascension(RA). It is like (but not the same as) longitude. It locates where a star is along the celestial equator. It has a zero reference point like green which, called the Vernal Equinox Point (we will get into locating that later).[4] Unlike Declination, Right Ascension changes with time(rotation of the earth) And the coordinate of Right Ascension is not in degrees but in hours minutes and seconds. The celestial sphere will make a full rotation in 24h sidereal time (ie if a stars coordinates are 20 dec, 5h RA. After 2 hours the coordinates will be 20dec,7hRA.) Since 360/24=15 1 hour of RA is 15 degrees.Sidereal TimeSidereal time is different than solar time. A sidereal day is about 4 minutes less than a solar day. Because of the Earths orbit around the sun. I'm not going into details on how to calculate Sidereal time. I will include some links below if you are interested. You can use a Sidereal calculator. Local Sidereal Time (LST) indicates the Right Ascension on the sky that is currently crossing the Local Meridian. So, if a star has a Right Ascension of 05h 32m 24s, it will be on your meridian at LST=05:32:24.[5] In other words, if you face the north at 0h Local Sidereal Time. the Vernal Equinox Point(0h Ra) will be right above you. to understand it more clearly open this animationhttp://astro.unl.edu/classaction/animations/coords...select your location and hit start animation, You will see a line rotating. when that line is above the stick figure it is 0h Local sidereal time.Here is a demonstration of Equatorial Coordinates on Celestial sphere by UNL Astronomy.Celestial-Equatorial (RA/Dec) DemonstratorHow to Locate the North Celestial PoleNow we know the coordinate system of the celestial sphere. But how do we locate a reference point to use our coordinate system? The North Celestial Pole will only change with your latitude. And can be located easily by the north star. Here is an interactive demonstration, you can change the latitude and hit the switch so you can see where the celestial sphere is located.Celestial and Horizon Systems ComparisonAlso here you can animate the movement of an object on the celestial sphere:Coordinate Systems ComparisonNote:I did not get into details since this is something like an introduction to positional astronomy. If you want to learn more I will include the links that were really helpful for me. There are also problems that you can solve to practice what you have learned. This way you will be able to calculate the coordinates of a star with a given latitude and time.Further Reading:History - http://csep10.phys.utk.edu/astr161/lect/retrograde...RA and DEC - http://www.physics.csbsju.edu/astro/sky/sky.11.htm...Celestial Sphere - http://www.astronomyforbeginners.com/astronomy/cel...Coordinate Systems - https://dept.astro.lsa.umich.edu/ugactivities/Labs...Celestial Coordinates - http://sbo.colorado.edu/SBO_OLD_SITE/sbo/astroinfo...Finding Astronomical Objects - https://www.saddleback.edu/faculty/mhaeri/document.. .Local Side Real Clock converter - http://www.jgiesen.de/astro/astroJS/siderealClock/How to Calculate Sidereal time - http://aa.usno.navy.mil/faq/docs/GAST.phpReferences:[1]http://www.skyandtelescope.com/astronomy-resources...[2]http://www.newworldencyclopedia.org/entry/Celestia...[3]http://www.jtwastronomy.com/tutorials/celestial_co...[4]http://astro.unl.edu/naap/motion1/cec_units.html[5]https://docs.kde.org/trunk5/en/kdeedu/kstars/ai-si...", "step_imgs": ["https://cdn.instructables.com/F91/5F5F/IR40FA0M/F915F5FIR40FA0M.LARGE.gif"], "step_title": "Step 1: A Little Bit of Positional Astronomy"}, {"step": 2, "steps_text": "Many computerized telescopes have a type of telescope mount and related software which can automatically point a telescope to astronomical objects that the user selects. Called GoTo mounts. Like a standard equatorial mount, equatorial GoTo mounts can track the night sky by driving the right-ascension axis[1]Since laser pointers are a perfect way to point stars, I thought a laser pointer with a GoTo mount would be a perfect tool for locating stars and to track them.First I had to design a 2-axis mount.360-degree rotating axis for RA  A up-down axis for DECAfter aligning the RA axis with the North Celestial Pole, an Arduino connected with an RTC should be able to calculate and track RA with sidereal time. And you can adjust the 2 axes to the user input from a computer via serial.But first I had to find a way to precisely point the mount to given degrees. The main idea was to use step motors and give them a specific step to take. But after a few tests I found out that the pointing was not accurate(a few degrees).Instead, I used a gyroscope placed on the laser pointer to track the degrees on the two axes, this way I was able to send a command to the step motor to start and stop the movement if necessary.", "step_imgs": ["https://cdn.instructables.com/F7M/RLBH/IR40FE1K/F7MRLBHIR40FE1K.LARGE.jpg"], "step_title": "Step 2: The Idea"}, {"step": 3, "steps_text": "I used two Arduino's in this project(due to the lack of digital pins).One to control the motors, the other to process the gyro data and send commands to the other Arduino(Master-slave) I had an Uno and nano lying around so I used them. You can use other Arduino's as well.Here are the main parts I used in this project:5v Stepper Motor(x2) - 3.68$Arduino Uno r3 clone - 5.80$Arduino nano clone- 2.18$3-Axis Gyro - 2.03$RTC - 1.07$______________________________________Total - 14,76$Also,Lots of jumper cables30x47x11mm thrust ball bearing(again you can use a bearing you like but have to change the dimension on the parts.)(10x) M3 bolts and nuts(4x) 623 2RS bearings (I had these bearings at the moment. You can use any bearing, but you have to adjust the pieces from tinkercad to your dimensions.X-acto knifeSuperglue A laser pointer(recommended)", "step_imgs": ["https://cdn.instructables.com/FR0/F839/IR40FRBC/FR0F839IR40FRBC.LARGE.jpg"], "step_title": "Step 3: Tools & Parts"}, {"step": 4, "steps_text": "The first part to design is the base. I thought of a delta type base plate so I can attach 3 legs and adjust them. Here is the Base plate You can edit it on tinkercad as you like. I will also include all .stl files in a zip folder.The BaseBase ScrewTripod Mount (Attached to the base)Pitch(DEC) MountGyro MountThe Base GearNote: I'm giving these tinkercad links so you can change the parts to your preferences. All the other files including these are in the Parts.zip folder.The GearsNow for the most important part, designing the gears. I tried to create the gears in Autodesk Inventor but later I found a gear generator tool that generates gears to a .stl file. This was a life-saver for me.http://joostn.github.io/OpenJsCad/I printed the parts with a prusa i3 3d printer. ", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 4: Designing the Parts"}, {"step": 5, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F5B/BC7C/IR40GRVU/F5BBC7CIR40GRVU.LARGE.jpg", "https://cdn.instructables.com/FXT/YWTC/IR40GSNI/FXTYWTCIR40GSNI.LARGE.jpg", "https://cdn.instructables.com/F83/WPM3/IR40GTLS/F83WPM3IR40GTLS.LARGE.jpg", "https://cdn.instructables.com/FYN/TMGJ/IR40GVB3/FYNTMGJIR40GVB3.LARGE.jpg", "https://cdn.instructables.com/F9F/NYLD/IR40GW35/F9FNYLDIR40GW35.LARGE.jpg", "https://cdn.instructables.com/FMX/34BM/IR40GWCB/FMX34BMIR40GWCB.LARGE.jpg", "https://cdn.instructables.com/FR7/OJBJ/IR40GWFD/FR7OJBJIR40GWFD.LARGE.jpg", "https://cdn.instructables.com/FIS/6EIL/IR40GVRP/FIS6EILIR40GVRP.LARGE.jpg"], "step_title": "Step 5: Assembly-Base Structure"}, {"step": 6, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F9H/8WOL/IR40GX8N/F9H8WOLIR40GX8N.LARGE.jpg", "https://cdn.instructables.com/FV7/VU67/IR40GW1E/FV7VU67IR40GW1E.LARGE.jpg"], "step_title": "Step 6: Assembly - Electronics"}, {"step": 7, "steps_text": "How Does it Work?There are two Arduino's working in order. Arduino Uno being master and nano being the slave.Master moduleThe master(Uno) module has two inputs,Gyro dataRTC(Real Time Clock) dataand 6 outputs,cw(base motor clockwise)ccw(base motor counter clockwise)stahp(base motor stop)cw2(DEC motor clockwise)ccw2(DEC motor counter clockwise)stahp2(DEC motor stop)The RTC is set to UTC time, a function calculates local sidereal time in degrees and rotates the mount to 0h RA position. The loop constantly checks if the gyro data is equal to the user input & sidereal time data. The default is 0,0. If there is a change and the equality breaks the master module send a command to the slave module.If the user value is higher than the gyro value a signal is sent through cw the motor turns clockwise.If the user value is less than the gyro value a signal is sent through ccw the motor turns counter clockwiseIf the user value is equal to the gyro value a signal is sent through stahp and the motor stopssame for cw2,ccw2,stahp2.This way the mount will turn to the user-specified coordinates. And update with sidereal time thus it will track the sky.Note: I could use serial communication between the two Arduino's but since the analog pins are used by the inputs I had to use digital pins.I uploaded the code to github so I can update it from one place:https://github.com/gocivici/Star-TrackMaster module code:/* This is the source code for the master-module of Star Track. Required Libraries: https://virtuabotix-virtuabotixllc.netdna-ssl.com... https://github.com/jrowberg/i2cdevlib/zipball/mas... Created 20 July 2016 by G\u00f6rkem Bozkurt */#include <virtuabotixRTC.h>#include <Wire.h>#include <MPU6050.h>MPU6050 mpu;//define RTC.virtuabotixRTC myRTC(A0, A1, A2);double M,Y,D,MN,H,S;double A,B;double location =32.88;//your longtitudedouble LST_degrees;//variable to store local side real time(LST) in degrees.double LST_hours;//variable to store local side real time(LST) in decimal hours.unsigned long timer = 0;float timeStep = 0.01;// Pitch and Yaw valuesdouble pitch = 0;double yaw = 0;double val = 0;//variable to store the user input DECdouble val2 = 0;//variable to store the user input RAdouble temp = val2;//temporary value to store val2const int stahp=7,stahp2=10;const int cw=8,cw2=11;const int ccw=6,ccw2=9;void setup() {    //set date-time according to (seconds, minutes, hours, day of the week, day of the month, month, year)     myRTC.setDS1302Time(00, 38, 23, 5, 27, 7, 2016);    Serial.begin(115200);    pinMode(stahp,OUTPUT);    pinMode(cw,OUTPUT);    pinMode(ccw,OUTPUT);    pinMode(stahp2,OUTPUT);    pinMode(cw2,OUTPUT);    pinMode(ccw2,OUTPUT);    delay(5000);//wait before starting    while(!mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G))    {    }    mpu.calibrateGyro();    mpu.setThreshold(3);}//--(end setup )---void loop(){    //this will update the RA degrees with sidereal time 1degree at a time    //this way the object or star on the sky is tracked.    if( floor(LST_degrees)==LST_degrees ){       if (LST_degrees>180){        val2 = temp+(360-LST_degrees);        }else{        val2 = temp-LST_degrees;        }    }    myRTC.updateTime();    LST_time();    recvdata();    pitch_check();    yaw_check();    timer = millis();    Vector norm = mpu.readNormalizeGyro();    //I've put the sensor with a 90 degree angle on the setup due to    //cable connection problems. Because of that the data values from the mpu6050 chip are    //different in this case:    //roll data(X-axis) is pitch.    //pitch data(Y-axis) is yaw.    yaw = yaw + norm.YAxis * timeStep;    pitch = pitch + norm.XAxis * timeStep;    Serial.print(\" Yaw = \");    Serial.print(yaw);    Serial.print(\" Pitch = \");    Serial.print(pitch);    Serial.print(\" LST_d = \");    Serial.print(LST_degrees);    Serial.print(\" LST_h = \");    Serial.println(LST_hours);//local sidereal time in decimal hours.    delay((timeStep*1000) - (millis() - timer));//timer for the gyro.}void recvdata(){  //This function receives data from serial as (0.00,0.00)  //splits it to strings by the comma \",\"  //than converts them to doubles     if (Serial.available() > 0){        String a= Serial.readString();        String value1, value2;        // For loop which will separate the String in parts        // and assign them the the variables we declare        for (int i = 0; i < a.length(); i++) {            if (a.substring(i, i+1) == \",\") {                value2 = a.substring(0, i);                value1= a.substring(i+1);                break;            }        }        val=90-value1.toFloat();        val2=value2.toFloat();        temp = val2;    }}void pitch_check(){    //check if pitch is high, low or equal to the user input    //send commands to slave-module to start and stop motors    if(floor(pitch*100)/100==floor(val*100)/100){        digitalWrite(stahp,HIGH);        }else{        digitalWrite(stahp,LOW);    }    if(floor(pitch*100)<floor(val*100)){        digitalWrite(cw,HIGH);        }else{        digitalWrite(cw,LOW);    }    if(floor(pitch*100)>floor(val*100)){        digitalWrite(ccw,HIGH);        }else{        digitalWrite(ccw,LOW);    }}void yaw_check(){    //check if yaw is high, low or equal to the user input    //send commands to slave-module to start and stop motors    if(floor(yaw*100)==floor(val2*100)){        digitalWrite(stahp2,HIGH);        }else{        digitalWrite(stahp2,LOW);    }    if(floor(yaw*100)<floor(val2*100)){        digitalWrite(cw2,HIGH);        }else{        digitalWrite(cw2,LOW);    }    if(floor(yaw*100)>floor(val2*100)){        digitalWrite(ccw2,HIGH);        }else{        digitalWrite(ccw2,LOW);    }}void LST_time(){    //Calculates local sidereal time based on this calculation,    //http://www.stargazing.net/kepler/altaz.html     M = (double) myRTC.month;    Y = (double) myRTC.year;    D = (double) myRTC.dayofmonth;    MN = (double) myRTC.minutes;    H = (double) myRTC.hours;    S = (double) myRTC.seconds;    A = (double)(Y-2000)*365.242199;    B = (double)(M-1)*30.4368499;    double JDN2000=A+B+(D-1)+myRTC.hours/24;    double decimal_time = H+(MN/60)+(S/3600) ;    double LST = 100.46 + 0.985647 * JDN2000 + location + 15*decimal_time;    LST_degrees = (LST-(floor(LST/360)*360));    LST_hours = LST_degrees/15;}Slave Module:/*this is the source code for the slave module of Star TrackRequired Libraries:http://www.airspayce.com/mikem/arduino/AccelStepper/AccelStepper-1.51.zipCreated 20 July 2016 by G\u00f6rkem Bozkurt */#include <AccelStepper.h>#define HALFSTEP 8#include <Wire.h>// Motor pin definitions#define motorPin1  2     // IN1 on the ULN2003 driver 1#define motorPin2  3     // IN2 on the ULN2003 driver 1#define motorPin3  4     // IN3 on the ULN2003 driver 1#define motorPin4  5     // IN4 on the ULN2003 driver 1#define motorPin5  A0     // IN1 on the ULN2003 driver 1#define motorPin6  A1     // IN2 on the ULN2003 driver 1#define motorPin7  A2     // IN3 on the ULN2003 driver 1#define motorPin8  A3     // IN4 on the ULN2003 driver 1// Initialize with pin sequence IN1-IN3-IN2-IN4 for using the AccelStepper with 28BYJ-48AccelStepper stepper1(HALFSTEP, motorPin1, motorPin3, motorPin2, motorPin4);AccelStepper stepper2(HALFSTEP, motorPin5, motorPin7, motorPin6, motorPin8);int stahp = 7,stahp2=10;int cw = 6,cw2 = 11;int ccw = 8,ccw2=9;boolean stopped = false;boolean stopped2 = false;void setup() {    stepper1.setMaxSpeed(1000.0);    stepper2.setMaxSpeed(1000.0);    pinMode(stahp2,INPUT);    pinMode(cw2,INPUT);    pinMode(ccw2,INPUT);    pinMode(stahp,INPUT);    pinMode(cw,INPUT);    pinMode(ccw,INPUT);}//--(end setup )---void loop(){    motor_pitch();    motor_roll();    if(stopped==false){        stepper1.run();    }    if(stopped2==false){        stepper2.run();    }}void motor_roll(){    if(digitalRead(stahp)==HIGH){        stopped = true;    }else{ if(digitalRead(cw)==HIGH){            stepper1.setSpeed(100);            stopped = false;        }        if(digitalRead(ccw)==HIGH){            stepper1.setSpeed(-100);            stopped = false;        }    }}void motor_pitch(){    if(digitalRead(stahp2)==HIGH){        stopped2 = true;    }else{ if(digitalRead(cw2)==HIGH){            stepper2.setSpeed(100);            stopped2 = false;        }        if(digitalRead(ccw2)==HIGH){            stepper2.setSpeed(-100);            stopped2 = false;        }    }}The slave module has 6 inputs from the master module with the same names. And drives the motors.Slave Module code:", "step_imgs": [], "step_title": "Step 7: Code "}, {"step": 8, "steps_text": "We assembled the base and connected the electronics, now for the first test(indoor),-Upload the master and slave codes to the Arduino's.master ==> unoslave ==> nano-Connect the Arduino Uno to the computer and open the serial monitor .You will see 4 values printed to the serial monitor,Yaw ==> RA value in degreesPitch ==> DEC value in degreesLST_d ==> Local Sidereal Time in degreesLST_h ==> Local Sidereal Time in decimal hoursWhen you first plug in the Arduino it will wait for 5 seconds. Then it will update the RA(yaw) value to your local sidereal time. After it is done it will continue to update the RA value 1 degree at a time.Let's input 0,0 to the serial monitor.When you try to move the mount, it will adjust itself to yaw=0, pitch=0.Now let's try an input like 5.00,5.00(5 degrees DEC,5 degrees RA). The motors should position the mount at 5,5. degrees. If you encounter any problems check the next step.", "step_imgs": ["https://cdn.instructables.com/F1P/82TZ/IR40GXP8/F1P82TZIR40GXP8.LARGE.jpg"], "step_title": "Step 8: First Test"}, {"step": 9, "steps_text": "-The steppers are just vibratingCheck the connections of your stepper to the Arduino, different steppers have different pin outputs.-The steppers start to wiggle when they arrive at the specified positionIf your stepper speed is too fast it will struggle to stop at the position specified. Edit the speed of the stepper on the slave module(slave.ino) to something like 50-75.-RA is not updatingCheck the coin-cell battery on the RTC or the connections between the Arduino.-RA-DEC values do not update(stuck at 0).The gyro is the main cause of his problem (in my case it was). this is why I put 5 seconds of delay, in the beginning, this way there was no problem. If y\u0131u find another way please let me know.If you encounter any problem during the build let me know(Even if you solved the problem). So I can put it here.", "step_imgs": [], "step_title": "Step 9: Troubleshooting"}, {"step": 10, "steps_text": "After assembling mount it to a tripod and go outside. The tripod will be a major tool because you will use it to align the setup with the north celestial pole.After going outside away from city lights, adjust the Laser to an upright position by turning the motor with your hand.Adjust the base gear so the RTC module is faced north.Adjust the tripod angle while the laser is on and at an upright position, it should point the north star. If you can not see the north star you can use a phone app like sky map.Plug in your Arduino to the setup. And wait while the RA degrees update.Now you are all set. The laser pointer is now pointing 90 DEC,0 RA on the celestial sphere.Tracking a starThere are huge star databases you can use. I will include the links below but for now, I will use Wikipedia for the coordinates of the star Arcturus. the coordinates of Arcturus are 14h 15m 39.7s , 19\u00b0 10\u2032 56\u2033 first we have to convert this data to degrees, so our setup can process it.I used https://www.swift.psu.edu/secure/toop/convert.htmthe result is: RA: 213.9167 DEC: 19.1822You can put this values into the serial monitor like this 213.9167,19.1822and the setup will start to point and track that object/star.Databases:http://www.stellar-database.com/http://simbad.u-strasbg.fr/simbad/", "step_imgs": ["https://cdn.instructables.com/FLU/Z78J/IR5MRV29/FLUZ78JIR5MRV29.LARGE.jpg", "https://cdn.instructables.com/FBQ/JC13/IR5MS4EW/FBQJC13IR5MS4EW.LARGE.jpg", "https://cdn.instructables.com/F4U/4BIL/IR5MRV3G/F4U4BILIR5MRV3G.LARGE.jpg", "https://cdn.instructables.com/F4N/10GX/IR5MRV3K/F4N10GXIR5MRV3K.LARGE.jpg", "https://cdn.instructables.com/FNT/TH0Q/IR5MRV3N/FNTTH0QIR5MRV3N.LARGE.jpg", "https://cdn.instructables.com/FBJ/3B94/IR5MRV3U/FBJ3B94IR5MRV3U.LARGE.jpg", "https://cdn.instructables.com/FW1/Z76Y/IR5MRV55/FW1Z76YIR5MRV55.LARGE.jpg", "https://cdn.instructables.com/FTH/HDKO/IR5MRV5D/FTHHDKOIR5MRV5D.LARGE.jpg", "https://cdn.instructables.com/F0P/0HOM/IR5MRV3V/F0P0HOMIR5MRV3V.LARGE.jpg"], "step_title": "Step 10: Final Assembly & Tracking"}, {"step": 11, "steps_text": "There are lots of things to improve on this project. My main goals for a later version are,Star database integrated into an android app. You will be able to choose a star. The data will be sent through Bluetooth to the Arduino as RA degrees, DEC degrees.  Laser on/off switch with a servo. After the user input, the laser will be turned on for 3-5 seconds to point the star(currently you have to press it manually)  more powerful motors and a bigger mount for a DSLR camera (maybe?)  Bigger gear ratios for precise locations.  Getting time and location data from a GPS module(currently, those are entered manually)I hope you enjoyed this project as I did and learned something from it. If you find a mistake in the code or wrong information of any kind please let me know. All questions are welcome!You can also contact me at: gocivici@gmail.com", "step_imgs": [], "step_title": "Step 11: What's Next"}], "channel": "Arduino"}, {"category": "technology", "description": "  I became interested in model railroading a few years ago. It's a hobby that requires skills in precision painting, model building, scenery design, wood working, electrical engineering and about a dozen other skills that I\u2019m forgetting right now. It is an excellent creative outlet.  Realism can be a part of the hobby, like laying out a train line complete with all the scenery with historical accuracy. You can also choose to just build a fantasy land complete with cities, realistic grass, unicorns and Godzilla-like monsters fighting Transformers for rule over the land. Regardless, you will be assembling and painting a variety of buildings to enhance the world you are creating.  I\u2019m writing about adding some realism to the town: lighting. You can light a building by just plugging in a bunch of little model light bulbs and light everything in a uniform way. Towns don\u2019t work like that though. People move from room to room, lights go on and off, street lights flicker, restaurants change the lighting through the night.  We\u2019re going to look at how to use an Arduino, a few TLC5940's and diorama skills to script the LEDs of a part of a town to create realistic lighting.", "title": "Creative Diorama Lighting With the Arduino and TLC5940", "url": "https://www.instructables.com/id/Creative-diorama-lighting-with-the-Arduino-and-TLC/", "section": "technology", "steps": [{"step": 1, "steps_text": "This looks like a long and expensive list of tools. You may have many of these tools already or those that can do the job just as easily.Tools you'll need:A hammar         A small nail         A multimeter         Needle nose pliers         Calipers like Neiko 01407A Stanless Steel 6-Inch Digital Caliper with Extra-Large LCD Screen and Instant SAE-Metric Conversion or be really good with a ruler.         A model file set, such as Tamiya Basic File Set or a tool to make very fine notches. Wire cutters work but easier to make a mistake. Modelers probably already have something like this.         Wire strippers. I use these: Irwin Industrial Tools 2078300 8-Inch Self-Adjusting Wire Stripper with ProTouch Grips Note: The description says it is good to 24 AWG, but it works well down to 28 AWG stranded.         Wire cutters similar to Xuron 170-II Micro-Shear Flush Cutter as you will want something with a small nose.         Soldering iron with temperature control         Ventilation         Table top vices like these:        PanaVise Model 201 \"Junior\" Miniature VisePanaVise 301 Standard PanaVisePanaVise 209 Vacuum Base Pv Jr. Note: I regret this and would rather have 2 of the model 201's. The vacuum base is not great on wood and it doesn't have the weight to keep it steady.Optional:A decade box when you need that one odd resistor that you don't have on hand: Elenco 1% 1 Watt Resistor Substitution BoxAn oscilloscope.         A circuit board holder such as: PanaVise 315 Circuit Board Holder You can remove the vice in the 301 and replace it with the board holder. You need a vice to crimp a few ribbon cables.         Helping hands or something similar. Bamboo skewers.", "step_imgs": ["https://cdn.instructables.com/F4Z/9ZP3/HUIS768L/F4Z9ZP3HUIS768L.LARGE.jpg", "https://cdn.instructables.com/F9I/7943/HUIS76A0/F9I7943HUIS76A0.LARGE.jpg"], "step_title": "Step 1: Tools"}, {"step": 2, "steps_text": "Some of these parts are optional and you have alternatives. I used three retailers: Amazon, Mouser and Jameco. All three delivered within 2 days thanks to Amazon Prime, Priority Mail and really fast customer fulfillment.The list is ordered by who fullfilled my order:Amazon:microtivity IL336 4.8mm Wide Angle White Straw Hat LED w/ Resistors (Pack of 100)microtivity IL614 5mm Diffused RGB Controllable LED, Common Anode (Kit, Pack of 30)microtivity IM414 Double-sided Prototyping Board (4x6cm, Pack of 5)POW3U PowerBoard-3U with Power Rails, 1 Sided PCB, 3.94 x 6.30 in (100 x 160 mm)A lot of male to male, male to female and female to female jumper wires. The Dupont connectors were the best since they are square and can mash up against each other. A note on Microtivity: Every part worked fine. The straw hats have a very wide angle and are great for building lighting. The RGB and white both draw 20mA according to their data sheets and that made it much easier to share the TLC5940's with both types. My regret was that I went with the prototyping board instead of a solder breadboard or strip board because of the time spent soldering bridges and buses. You will improve your soldering skills though.Mouser:2 or more TLC5940NT          10 10uF 25v radial caps cut tape          10 10K ohm 5% 1/4w resistor PN 660-CF1/4CT52R103J cut tape          10 2k OHM 5% 1/4w resistor PN 660-CFS1/4CT52r2027 cut tapeNote: The 2K resistor is based on a formula in the TLC5940NT's data sheetJameco:10 .1uF 25v cap 20% PN 151116          Several 16 pin female IDC sockets PN 119467.           Several 16 pin male header w/shroud straight PN 68180 mates with the above 16 pin female connector.          1 Cable Ribbon 16 Conductor Rainbow 28AWG 10 Feet Flat PN 28RC16-10VPA large solderless breadboard such as PN WBU-208-RA couple small breadboards such as PN WBU-301-R with power busSeveral Connector Unshrouded Header 40 Position 2.54mm Solder Straight Thru-Hole PN 7000-1X40SG-RPart 7 is just a 40 pin single row snappable header. You will need 64 pins per node board, which I'll describe in future step. You'll need two 40 pin headers per node board. Also, it is easy to miscount the number of pins you need when snapping them off so get a couple of extra headers for mistakes.Note: Some of the parts above say \"have 10 of this or that.\" Some vendors have minimum orders or parts like resistors and capacitors.Other stuff:Thick white paper or cardboard that can hold a little weight.          Common white glue          Evergreen Scale Models: Channel 5/16\" (7.9mm) PN 268 or something similar.         Various other parts to make your diorama look realistic.          Model buildings or similar structures, like lego.          Foam sheets, see picture. You can find them in most kid's craft stores.           An Arduino Uno R3", "step_imgs": ["https://cdn.instructables.com/F18/4VGK/HUIS7652/F184VGKHUIS7652.LARGE.jpg", "https://cdn.instructables.com/F4W/TG5R/HUIS765M/F4WTG5RHUIS765M.LARGE.jpg", "https://cdn.instructables.com/F2V/2221/HUIS766A/F2V2221HUIS766A.LARGE.jpg", "https://cdn.instructables.com/FPU/PSBZ/HUIS767J/FPUPSBZHUIS767J.LARGE.jpg", "https://cdn.instructables.com/F2P/KDLQ/HUIS767G/F2PKDLQHUIS767G.LARGE.jpg"], "step_title": "Step 2: Parts"}, {"step": 3, "steps_text": "The above ground setup will be just two buildings to demonstrate building lighting.Below ground is the controller board. A bridge will connect the controller board to each node via one or more ribbon cables. The nodes connect to the LEDs in the buildings. The LEDs are strung together on the channels to create a LED strip. Make a strip by measuring the windows you want to light. Draw lines on the strip to show room dividers and LED locations. Use the hammer and nail to punch holes for the LED leads. Create notches in the strip for the leads to bend into (see picture) using a file or something similar. Having LEDs off center from a window gives the effect of normal lighting.Test that the strip works before proceeding.Each LED on the strip is covered with a separate paper box. Use thick white paper or cardboard to make the box. Use the foam to cover the box to make it mostly light tight. Make sure to connect the LEDs to a Node before glueing the box to the windows. Test again that the LEDs work.Note: Light bleed can be a challenge. Your wrapper on the LEDs should be as light tight as you can make them so they only light the window. Also, the light can bleed through other windows too.Model makers use different manufacturing methods that impact lighting. First, some walls are very thin and the LED will bleed through the wall itself. Paint around the windows or better still, glue some white or black foam around the windows. Do not use other colored foam as it will change the color of the light. Some manufacturers make the models with walls that are not square. Foam and sandpaper works really well in these corners. I use a  bright flashlight to see all the places where light bleeds from my corners and other joints. It is easy to patch those locations using the foam or other materials.", "step_imgs": ["https://cdn.instructables.com/F6X/4W1Z/HUDEPC8A/F6X4W1ZHUDEPC8A.LARGE.jpg", "https://cdn.instructables.com/FFL/6GXX/HUIS767H/FFL6GXXHUIS767H.LARGE.jpg", "https://cdn.instructables.com/FV0/GEEH/HUIS768R/FV0GEEHHUIS768R.LARGE.jpg"], "step_title": "Step 3: Overview of Lighting the Buildings "}, {"step": 4, "steps_text": "The code manages LED clusters of either white or RGB. The bar or nightclub demonstrates a mix of both.The RGB LEDs follow a sine wave. The code originally calculated the value for the \"lead\" LED and then iterated it down to the other RGBs. The calculations were amazingly slow. Improving the speed required pre-calculating the entire sine wave and statically storing it in an array. The code runs significantly faster as a result and allows us to whip through all the LEDs.The LEDs are clustered in the code. The RGBs are one cluster. One set of windows are another and so on. Each LED has start and end time fields that indicate how many milliseconds to wait before performing an action such as changing the color, turn on or turn off.The loop() function will iterate through each LED cluster and you may notice slight delays as the code has to iterate through all the LEDs and then perform an update to set their state. A small delay is one of those bugs that's a feature. It adds some variability to the duration of the LEDs, making the lighting a little more realistic.Note that all times are hard-coded. You could change this so the lights run for a random period. Please be careful with the white LEDs and the brightness settings you choose. The TLC5940 has steps that go from 0 (off) to 4096 (leaves spots in your eyes). I have lowered the default LED brightness to something very low to see the LED work after foolishly setting the LEDs to their maximum and having a hard time seeing anything but spots afterwards. You will have to set the LEDs to a higher value once installed in the model because windows and other items may diffuse or block the light.", "step_imgs": [], "step_title": "Step 4: Overview of the Controller Code"}, {"step": 5, "steps_text": "First, you need the TLC5940 Aduino Library. The installation directions are out of date. Download the library and unzip into a temporary directory. Then open the Arduino editor and go to Sketch ->Import Library and add the library. The editor will do the rest.Edit the tlc_config.h file to modify the number of TLC5940's you are using. This project runs thee TLCs so the line reads#define NUM_TLCS    3The code is pretty straightforward from here and is commented. I have some comments at the end too.LEDController.ino#include \"Arduino.h\"\n#include <Tlc5940.h>\n#include <tlc_config.h>\n#include \"LedController.h\"\n\n// Root List for all LEDs\nList *lightList = NULL;\n// various values for iterating through the RGBs\nint rgbIndex = 0;\nint rgbLastStart = 0;\nboolean firstRGBIndex;\nint maxRGB = 252;\n\n// Handy for steping through all the LEDs\n// Each LED will flash, which helps find missing or incorrect connections\nvoid diag()\n{\n  for(uint8_t x= 0; x < 40; x++) \n  {\n    if ( x > 0) \n    {\n      Tlc.set(x-1,0);\n    }\n    Tlc.set(x,1000);\n    while(Tlc.update());\n    delay(500);\n  }\n}\n\n/*\nPause for 5 seconds so that you can pull up\nany diagnostic you may need.\nInitialize the TLC chain.\nCreate the complete light list\n*/\nvoid setup()\n{\n  delay(5000);\n  Tlc.init();\n  Tlc.clear();\n  lightList = createList();\n  \n  addNode(lightList, createRGBCluster1());\n  addNode(lightList, createLEDCluster1a());\n  addNode(lightList, createLEDCluster2());\n}\n\n/*\nIncrement the RGB value so it slowly moves through \nthe list of color transitions.\nKeep the current time so you know when to turn on and off lights.\nRun through the list.\n*/\nvoid loop()\n{ \n\n  //diag();\n  rgbIndex = rgbLastStart + 1;\n  firstRGBIndex = true;\n  long time = millis();\n  iterateList(time,lightList);\n\n  /* \n  The update finishes asynchronously on the TLC's.\n  You must wait till everything updates or your lights will\n  display incorrect values.\n  */\n  while(Tlc.update());\n}\n\n/* Single link list.\nMost of the following functions create a node of some type\nand attach it to the end of a list. This system creates lists of lists for each\nLED array. This exposed some memory challenges as the list is using some \nstatically allocated values and shares some of those values. Pointers \nwould have been a wiser choice.\n*/\nList* createList(void) \n{\n  List *list = (List*)malloc(sizeof(List));\n  list->head = NULL;\n  list->tail = NULL;\n  return list;\n}\n\nList* addNode(List* list, Node* node)\n{\n if (list != NULL && node != NULL)\n {\n   if (list->head == NULL)\n   {\n     list->head = node;\n     list->tail = list->head;\n   } else {\n     list->tail->next = node;\n     list->tail = node;\n   }\n }\n}\nNode* createNode(NodeType type, uint8_t pin)\n{\n  Node *result = (Node*)malloc(sizeof(Node));\n  result->next = NULL;\n  result->type = type;\n  \n  switch(type)\n  {\n    case LIST:\n      result->value = createList();\n      break;\n    case LED_RGB:\n      result->value = createRGB(pin);\n      break;\n    case LED_NORMAL:\n      result->value = createLED(pin);\n      break;\n  }\n  return result;\n}\n\nNode* createRGBNode(List* list, uint8_t pin, Runtimes runtimes, RGB *useSettings)\n{\n  Node *results = createNode(LED_RGB, pin);\n  RGB* rgb = (RGB*)results->value;\n  configureRGB(rgb, runtimes, useSettings);\n  addNode(list, results);\n  return results;\n}\n\nvoid configureRGB(RGB* rgb, Runtimes runtimes, RGB *useSettings)\n{  \n  if ( useSettings != NULL)\n  {\n    rgb->useSettings = useSettings;  \n    rgb->color = useSettings->color;\n    rgb->runtimes = useSettings->runtimes;\n  } else \n  {\n    rgb->runtimes = runtimes;\n  }\n}\n\nRGB* createRGB(uint8_t pin)\n{\n  RGB *result = (RGB*)malloc(sizeof(RGB));\n  result->pin = pin;\n  result->color.r = 0;\n  result->color.g = 0;\n  result->color.b = 0;\n  result->useSettings = NULL;\n  return result;\n}\n\nNode* createLEDNode(List* list, uint8_t pin, Runtimes runtimes, uint8_t level)\n{\n  Node *results = createNode(LED_NORMAL, pin);\n  LED* led = (LED*)results->value;\n  led->level = level;\n  led->runtimes = runtimes;\n  addNode(list, results);\n  return results;\n}\n\nLED* createLED(uint8_t pin)\n{\n  LED *result = (LED*)malloc(sizeof(LED));\n  result->pin = pin;\n  result->level=0;\n  result->runtimes.startTime=0;\n  result->runtimes.runTime=0;\n  result->runtimes.on=false;\n  return result;\n}\n\nvoid setRGBLed(RGB *led) \n{\n  Tlc.set(led->pin,led->color.r);\n  Tlc.set(led->pin+1,led->color.g);\n  Tlc.set(led->pin+2,led->color.b);\n}\n\n/*\niterate through the list and determine the correct \nway to execute each node.\n*/\nvoid iterateList(long time, List* list)\n{\n  if(list != NULL)\n  {\n    Node* node = list->head;\n    while(node != NULL)\n    {\n      executeNode(time, node);\n      node = node->next;\n    }\n  }\n}\n\nvoid executeNode(long time, Node* node)\n{\n  if(node != NULL)\n  {\n    switch(node->type)\n    {\n      case LIST:\n        iterateList(time, (List*)node->value);\n        break;\n      case LED_RGB:\n        setRGB(time,(RGB*)node->value);\n        break;\n      case LED_NORMAL:\n        setLED(time,(LED*)node->value);\n        break;\n      default:\n        Tlc.set(1,200);\n        Tlc.update();\n        break;\n    }\n  } else {\n  }   \n}\n\n/*\nHorrible cheating going on here.\nThere is only one RGB list so we're going to keep some extra state\nand apply it to just this rgb list. blech.\nHowever, this array runs much faster by iterating through precalculated\nvalues than trying to calculate and display those values.\n*/\nvoid setRGB(long time, RGB* rgb)\n{\n  if (rgb != NULL)\n  {\n    boolean cycle = time > rgb->runtimes.startTime + rgb->runtimes.wait;\n    if ( cycle )\n    {\n      if ( rgb->useSettings != NULL )\n      {\n        rgb->color = rgb->useSettings->color;\n        rgb->runtimes = rgb->useSettings->runtimes;\n      } else \n      {\n        if ( firstRGBIndex ) \n        {\n          firstRGBIndex = false;\n          rgbLastStart++;\n          if ( rgbLastStart > maxRGB) \n          {\n            rgbLastStart = 0;\n          }\n\n          rgbIndex = rgbLastStart;\n        }\n        rgb->color = rgbPattern[rgbIndex++];\n        \n        if ( rgbIndex > maxRGB) \n        {\n          rgbIndex = 0;\n        }\n        \n      }\n      rgb->runtimes.startTime = time;\n    }\n    setRGBLed(rgb);\n\n  }\n}\n\nvoid setLED(long time, LED* led) \n{\n  if (led != NULL)\n  {\n    long execWindow = led->runtimes.startTime + led->runtimes.runTime;\n    if(led->runtimes.runTime == -1 || (time > led->runtimes.startTime && time < execWindow))\n    {\n      led->runtimes.on = true;\n      Tlc.set(led->pin, led->level);\n    } else  if ( time > execWindow && led->runtimes.on == true ) {\n      led->runtimes.startTime = time + led->runtimes.wait;\n      led->runtimes.on = false;\n      Tlc.set(led->pin, 0);\n    }\n  }\n}\n\n\n/*\nThe various LED array factory methods\n*/\nNode* createRGBCluster1(void)\n{\n  int i = 0;\n  int wait = 50;\n  Runtimes rt = (Runtimes) { 0, 0, wait, false };\n  \n  Node* rgbList = createNode(LIST, 0);\n  List* rgbCluster1 = (List*)rgbList->value;\n  Node* a = createRGBNode( rgbCluster1, i, rt, NULL);\n  Node* b = createRGBNode( rgbCluster1, i+=3, rt, NULL);\n  Node* c = createRGBNode( rgbCluster1, i+=3, rt, NULL);\n  Node* d = createRGBNode( rgbCluster1, i+=3, rt, NULL);\n  Node* e = createRGBNode( rgbCluster1, i+=3, rt, NULL);\n  \n  // Let them share values which creates a kind of cool looking\n  // fountain effect.\n  createRGBNode( rgbCluster1, i+=3, rt, (RGB*)e->value);\n  createRGBNode( rgbCluster1, i+=3, rt, (RGB*)d->value);\n  createRGBNode( rgbCluster1, i+=3, rt, (RGB*)c->value);\n  createRGBNode( rgbCluster1, i+=3, rt, (RGB*)b->value);\n  createRGBNode( rgbCluster1, i+=3, rt, (RGB*)a->value);\n  \n  return rgbList;\n}\n\nNode* createLEDCluster1a(void)\n{\n  int i = 30;\n  Node* ledList = createNode(LIST, 0);\n  List* ledCluster = (List*)ledList->value;\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300);\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300);\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300);\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300);\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300);\n  createLEDNode( ledCluster, i++, (Runtimes) { -1, -1, -1, true }, 300); \n  return ledList;\n}\n\nNode* createLEDCluster2(void)\n{\n  int i = 36;\n  \n  Node* ledList = createNode(LIST, 0);\n  List* ledCluster = (List*)ledList->value;\n  createLEDNode( ledCluster, i++, (Runtimes) { 10000, 30000, 25000, true }, 3000);\n  createLEDNode( ledCluster, i++, (Runtimes) { 10000, 30000, 25000, true }, 3000);\n  createLEDNode( ledCluster, i++, (Runtimes) { 3000, 90000, 45000, true }, 3000);\n  createLEDNode( ledCluster, i++, (Runtimes) { 3000, 90000, 45000, true }, 3000);\n  \n  return ledList;\n}\n\n/*\nThis is some old code that did the sine wave calculation.\nIt works but is very slow. I wrote some code to capture the values \nand write them out the serial console instead and then copied the values \ninto the header\n\nvoid setRGBFreq(RGB *led, uint8_t i, uint8_t max) \n{\n    float frequency = .3;\n    led->r = sin(frequency*(i) + 0) * 127 + 128;\n    led->g = sin(frequency*(i) + 2) * 127 + 128;\n    led->b = sin(frequency*(i) + 4) * 127 + 128;\n      \n    uint8_t total = led->r + led->g + led->b;\n    if ( total > max ) \n    {\n      led->r -= led->r/total * 100.0;\n      led->g -= led->g/total * 100.0;\n      led->b -= led->b/total * 100.0;\n    }\n    //printList(led);\n}*/\n\n\n\n\nLEDController.h<code>\n#ifndef LEDController\n#define LEDController\n\n#define RGB_LEDS 10\n\n\ntypedef enum { LIST, LED_RGB, LED_NORMAL  } NodeType; \n\ntypedef struct  \n{\n  long startTime;\n  long runTime;\n  long wait;\n  boolean on;\n} Runtimes;\n\ntypedef struct \n{\n  uint8_t r;\n  uint8_t g;\n  uint8_t b;\n} Colors;\n\ntypedef struct rgb {\n  Colors color;\n  uint8_t pin;\n  Runtimes runtimes;\n  struct rgb *useSettings;\n} RGB;\n\ntypedef struct {\n  uint8_t pin;\n  uint8_t level;\n  Runtimes runtimes;\n} LED;\n\ntypedef struct node {\n  NodeType type;\n  void* value;\n  struct node* next;\n} Node;\n\ntypedef struct {  Node* head;\n  Node* tail;\n} List;\n\nstatic Colors rgbPattern[] = { \n{128, 243, 31},{165, 222, 11},{199, 193, 1},{227, 158, 3},\n{246, 120, 15},{254, 83, 38},{251, 50, 68},{237, 24, 104},\n{213, 7, 142},{182, 1, 179},{145, 6, 211},{107, 22, 236},\n{71, 47, 250},{40, 80, 254},{17, 117, 247},{3, 155, 229},\n{1, 190, 202},{10, 220, 168},{29, 242, 131},{58, 253, 93},\n{92, 253, 58},{130, 242, 30},{167, 221, 10},{201, 191, 1},\n{228, 156, 3},{247, 118, 16},{254, 81, 39},{251, 48, 70},\n{236, 22, 106},{212, 6, 144},{180, 1, 181},{143, 6, 213},\n{105, 23, 237},{69, 49, 251},{39, 82, 254},{16, 119, 246},\n{3, 157, 228},{1, 192, 200},{11, 222, 166},{31, 243, 129},\n{59, 253, 91},{94, 253, 57},{132, 241, 29},{169, 219, 10},\n{203, 189, 1},{230, 154, 4},{247, 116, 17},{254, 79, 41},\n{250, 46, 72},{235, 21, 109},{210, 5, 147},{178, 1, 183},\n{141, 7, 214},{103, 24, 238},{68, 51, 251},{37, 84, 254},\n{15, 121, 245},{3, 159, 226},{1, 194, 198},{12, 223, 164},\n{32, 243, 126},{61, 254, 89},{96, 252, 55},{134, 240, 27},\n{171, 218, 9},{204, 187, 1},{231, 152, 4},{248, 114, 18},\n{254, 77, 43},{250, 45, 74},{234, 20, 111},{208, 5, 149},\n{176, 1, 185},{139, 8, 216},{101, 25, 239},{66, 52, 252},\n{36, 86, 254},{14, 123, 245},{2, 161, 225},{2, 196, 196},\n{12, 224, 162},{34, 244, 124},{63, 254, 87},{98, 252, 53},\n{136, 239, 26},{173, 216, 8},{206, 186, 1},{232, 150, 5},\n{249, 112, 20},{254, 75, 44},{249, 43, 76},{233, 19, 113},\n{207, 4, 151},{174, 1, 187},{137, 8, 217},{99, 27, 240},\n{64, 54, 252},{34, 88, 254},{13, 125, 244},{2, 163, 224},\n{2, 198, 195},{13, 226, 160},{35, 245, 122},{65, 254, 85},\n{100, 252, 51},{138, 238, 25},{175, 215, 7},{208, 184, 1},\n{233, 147, 5},{249, 109, 21},{254, 73, 46},{248, 42, 78},\n{231, 18, 115},{205, 4, 153},{172, 1, 188},{135, 9, 219},\n{97, 28, 241},{62, 56, 253},{33, 90, 253},{12, 128, 243},\n{2, 165, 222},{2, 199, 193},{14, 227, 158},{36, 246, 120},\n{67, 254, 83},{102, 251, 50},{140, 237, 24},{177, 213, 7},\n{128, 243, 31},{165, 222, 11},{199, 193, 1},{227, 158, 3},\n{246, 120, 15},{254, 83, 38},{251, 50, 68},{237, 24, 104},\n{213, 7, 142},{182, 1, 179},{145, 6, 211},{107, 22, 236},\n{71, 47, 250},{40, 80, 254},{17, 117, 247},{3, 155, 229},\n{1, 190, 202},{10, 220, 168},{29, 242, 131},{58, 253, 93},\n{92, 253, 58},{130, 242, 30},{167, 221, 10},{201, 191, 1},\n{228, 156, 3},{247, 118, 16},{254, 81, 39},{251, 48, 70},\n{236, 22, 106},{212, 6, 144},{180, 1, 181},{143, 6, 213},\n{105, 23, 237},{69, 49, 251},{39, 82, 254},{16, 119, 246},\n{3, 157, 228},{1, 192, 200},{11, 222, 166},{31, 243, 129},\n{59, 253, 91},{94, 253, 57},{132, 241, 29},{169, 219, 10},\n{203, 189, 1},{230, 154, 4},{247, 116, 17},{254, 79, 41},\n{250, 46, 72},{235, 21, 109},{210, 5, 147},{178, 1, 183},\n{141, 7, 214},{103, 24, 238},{68, 51, 251},{37, 84, 254},\n{15, 121, 245},{3, 159, 226},{1, 194, 198},{12, 223, 164},\n{32, 243, 126},{61, 254, 89},{96, 252, 55},{134, 240, 27},\n{171, 218, 9},{204, 187, 1},{231, 152, 4},{248, 114, 18},\n{254, 77, 43},{250, 45, 74},{234, 20, 111},{208, 5, 149},\n{176, 1, 185},{139, 8, 216},{101, 25, 239},{66, 52, 252},\n{36, 86, 254},{14, 123, 245},{2, 161, 225},{2, 196, 196},\n{12, 224, 162},{34, 244, 124},{63, 254, 87},{98, 252, 53},\n{136, 239, 26},{173, 216, 8},{206, 186, 1},{232, 150, 5},\n{249, 112, 20},{254, 75, 44},{249, 43, 76},{233, 19, 113},\n{207, 4, 151},{174, 1, 187},{137, 8, 217},{99, 27, 240},\n{64, 54, 252},{34, 88, 254},{13, 125, 244},{2, 163, 224},\n{2, 198, 195},{13, 226, 160},{35, 245, 122},{65, 254, 85},\n{100, 252, 51},{138, 238, 25},{175, 215, 7},{208, 184, 1},\n{233, 147, 5},{249, 109, 21},{254, 73, 46},{248, 42, 78},\n{231, 18, 115},{205, 4, 153},{172, 1, 188},{135, 9, 219},\n{97, 28, 241},{62, 56, 253},{33, 90, 253},{12, 128, 243},\n{2, 165, 222},{2, 199, 193},{14, 227, 158},{36, 246, 120},\n{67, 254, 83},{102, 251, 50},{140, 237, 24},{177, 213, 7}\n};\n\n\n// Basic Double Linked-List functions for LEDs\nList* createList(void);\nList* addNode(List* list, Node* node);\nNode* createNode(NodeType type, uint8_t pin);\nRGB* createRGB(uint8_t pin);\nLED* createLED(uint8_t pin);\nNode* createRGB(List* list, uint8_t pin, Runtimes runtimes, RGB *useSettings);\nNode* createLEDNode(uint8_t pin, Runtimes runTimes, uint8_t level);\n\n\nvoid iterateList(long time, List* list);\nvoid setRGBLED(long time, RGB *led);\nvoid setLED(long time, LED* led);\n\n//Cluster factories\nNode* createRGBCluster1(void);\nNode* createRGBCluster1a(void);\nNode* createLEDCluster2(void);\n\nvoid configureRGB(RGB* rgb, Runtimes runtimes, RGB *useSettings);\n\n#endifThe code uses a several single Linked Lists to manage all the LEDs, their colors, brightness, durations and other settings. Using a linked list was a mistake and I would manage memory in a different way. Why?  The statically allocated rgbPattern uses a lot of memory, yet all the memory is contiguous. The linked lists are not contiguous by intention, rather by coincidence. The result is that you can have small blocks of memory being allocated for each node in the list. The allocator will grab the first block of memory that the node can fit in. This results in the allocator leaving small memory gaps between lists and nodes. These gaps are often not usable and the application can no longer allocate the maximum amount of memory. Running out of memory is a little odd: the Arduino reboots. You wait several seconds and then watch it reboot again, and again, and you get the idea. I wrote a quick function, not included in the code, that would write a number of bits with a set interval to a pin to give me an idea how far the application got. I hooked up an oscilloscope to the pin and watched the bits. Knowing that I was rebooting was the first trick. The pin writer wrote six bits inside the setup() function and then would write five bits in the loop() function. The five bits were never displayed. Just the six bits every 15 or so seconds.It was then just a question of playing around with a few things. I found out that commenting out a building's worth of LEDs let the application progress to the loop() and continue running. I reduced the number of colors the rgbPattern cycled through and then uncommented the building. The application ran normally again.Each Color object is only 24 bytes, yet there are 64 lines with 4 Color objects each. A little more than 6k spent on color rotation.The next thing would have been to allocate a simple array for all the nodes. Then it would have been one packed memory block for all the LEDs and freed up much more memory for the rest of the app. However, the solution most likely to work for a larger network of LEDs is a bigger board with more memory. A Mega would easily handle a large number of buildings.", "step_imgs": [], "step_title": "Step 5: Write the Code"}, {"step": 6, "steps_text": "Go to TLC5940 Wiring Guide and take a look at the diagram. Note, we use three TLC5940s. The third TLC5940 linked in the same way as the first to the second. My image shows only two TLC5940's, one ribbon cables and one node. You will need up to three ribbon cables and two nodes if you wire up everything as I have. It will also be a rats nest of cables as the next image shows. Blech! But that can happen when you are using jumper wires, headers and breadboards to wire everything up.An oscilloscope can be a bit eye opening. The pwm and sin pins show a lot of noise and jitter. The LEDs would flciker at times. The data sheet shows a 100nF capacitor (figure 22, page 21) between the VCC and GND. This does help. A decoupling circuit, such as the one described here reduces the jitter and noise. I used a 100nF and 10uF Electrolitic capacitor and the noise and jitter cleared up entirely. However, the choice of the electrolitic capacitor's value was based on what I had on hand, not the ripple. It still cleaned up a lot of jitter and noise and eliminated any LED flickering.I'm wiring this up for only two buildings and three LED Clusters. I have 14 more buildings to light and that will require migrating off the Arduino power supply to a separate power supply for both the Arduino and the hundred or so LEDs. It may also require upgrading to an Arduino with more memory too. A LED configuration file on an SD card would be an excellent improvement.", "step_imgs": ["https://cdn.instructables.com/FYH/O567/HUIS764Z/FYHO567HUIS764Z.LARGE.jpg", "https://cdn.instructables.com/FLX/DL65/HVR7UJSW/FLXDL65HVR7UJSW.LARGE.jpg"], "step_title": "Step 6: Wire Up the Controller Board"}, {"step": 7, "steps_text": "The bridges and nodes are nothing more than connectors for bridging jumper wires to ribbon cables. If you have soldering skills like mine, then grab your multimeter and set it to continuity test. Mine makes a steady beep if it finds can complete a circuit. Check each solder point against adjacent points to verify that you do not have any shorts. If you do have one, a pencil tipped soldering iron is small enough to swipe between the two contacts and break the connection. Well, usually. The point is that you should test the boards. It took far longer to solder everything together than it took to test everything. I didn't have any shorts, which was very surprising. If I can do it, you can too. The ribbon cables can be a breeze or a nightmare. I'm not sure which. I had accidentally created both cross-over and straight-through cables. Making the ribbon cable is easy. A vice is really handy for the type of connectors (16 pins over 2 rows) I am using. You just slip the ribbon wire into the connector, which has a bunch of teeth or vampire taps. Put the connector and ribbon wire in the vice making sure that the connector is flush with the jaws. Then just tighten the vice. You'll feel the taps cut into the ribbon cable and you are done. The connectors come with these little clip doodads. They lock into the base of the connector and lock it together. This is great when you know you made the cable right. It also helps disconnecting the cable from the male connector on the bridge and nodes. However, the clip really locks it together. If you make a mistake then you can only snip the connector off and use another connector. Leaving the clip off can cause the ribbon connector to fall apart if your cable is really jammed into the bridge or node, but you can correct a mistake like making a straight-through cable when you wanted a crossover. Buy extra connectors and it will save you a lot of time.The bridge boardThe Node", "step_imgs": ["https://cdn.instructables.com/FL2/B4SY/HUIS765P/FL2B4SYHUIS765P.LARGE.jpg", "https://cdn.instructables.com/F8L/P60S/HUIS765L/F8LP60SHUIS765L.LARGE.jpg", "https://cdn.instructables.com/FM2/SIBH/HUIS766W/FM2SIBHHUIS766W.LARGE.jpg", "https://cdn.instructables.com/F9W/4EXI/HUIS766B/F9W4EXIHUIS766B.LARGE.jpg", "https://cdn.instructables.com/FCP/GEZ1/HUIS768T/FCPGEZ1HUIS768T.LARGE.jpg"], "step_title": "Step 7: Build the Bridges, Nodes and Ribbon Cables"}, {"step": 8, "steps_text": "We need to create our first LED strip to light four windows. The lights will turn on and off at approximately regular intervals. Begin by laying a channel strip along the windows. Cut the strip using good scissors. User a permanent marker to show where the LEDs and a room divider should go. Take a nail and hammer and use it to punch two holes though the channel for each LED. Clear away the excess plastic with a file, sandpaper, x-acto knife or something sharp. Now use a file or similar tool to make notches for the LED's cathode and anode. Mark the anode (long lead) notch. I sort of goofed the following up a bit. First, the pictures show 2 LEDs. Turns out that the paper on the windows was much thicker than I thought. I cut the box down so the LEDs were physically closer to the window.  The box is consequently not square, it is only about 1/2 to 1/4 the depth of the box shown above. Also, I added one extra LED to each side because even shortening the distance was not enough for the light to shine through. I used a total of four LEDs to make the window bright enough to be seen with the room lights on. Now the hard part, make the box. Measure the space the box needs to fit in. Be accurate because we want as little light to bleed through as possible. Corrugated cardboard makes the task a little easier because you can cut across the back of the board, without cutting the front of the board, to make a nice square box.Punch four holes at the top of the box for the 4 LED cathodes to go through. Use something very small and hopefully the leads will be enough to go through what little cardboard remains. This will make a very light tight seal. Attach jumper wires, or some kind of crimp or solder wire to the anodes. Make two thin cuts at the bottom of the box and thread the wire through. Cardboard makes this very easy since it can be forced to wrap around the wire. You can also use foam or electrical tape to bend and cover the wire holes. Attach the cathode wires too.The room divider is the easy bit. Your channel should be either at the very top of the box or just a little lower. Cut a piece of cardboard that is the height and depth of the box. Cut a small rectangular hole at the back of the piece of cardboard using another channel as a guide. Test fit the cardboard to see if it fits the box and is a tight fit on the LED strip. Then glue it room divider in place.Now attach the box to the model. First try fitting it into place and see if you need to make any adjustments. Then use regular white glue to attache the box to the model. Trying to do this on an already assembled model can be challenging and have a lot of trial and error. I had to go through about five tries before I got the right size. I did manage to make the box tight enough on the shown model that it did not require glueing. I later noticed that one of the LEDs was not lighting and it was easy to pull the box and reattach the anode and cathode jumpers.The longer LED strips are for the bar. I just cut a hole through the cardboard that was just big enough for the LEDs to fit through. My LEDs don't even get warm after hours of continuos use so I am not worried about a possible fire hazard. Hook up the LEDs and verify that they all light up and work correctly. The LEDs on this strip are spaced so that you can solder the anodes together into a single bus. You only need one jumper wire to connect all the LEDs to the node.I mostly used a different colored jumper wire for each cathode. This helps debug wiring errors when the order of the LEDs matters. I also left them attached to each other which makes for something similar to a ribbon cable. ", "step_imgs": ["https://cdn.instructables.com/FUD/2PM4/HUPMWHHT/FUD2PM4HUPMWHHT.LARGE.jpg", "https://cdn.instructables.com/FCB/NB8O/HUPMWHNC/FCBNB8OHUPMWHNC.LARGE.jpg", "https://cdn.instructables.com/FOF/NZBG/HUPMWHBK/FOFNZBGHUPMWHBK.LARGE.jpg", "https://cdn.instructables.com/F2P/K2QV/HUPMWHFF/F2PK2QVHUPMWHFF.LARGE.jpg", "https://cdn.instructables.com/FIN/IS6L/HUPMWHDG/FINIS6LHUPMWHDG.LARGE.jpg", "https://cdn.instructables.com/FCZ/QOIX/HUIS765N/FCZQOIXHUIS765N.LARGE.jpg", "https://cdn.instructables.com/FBX/K7GU/HUPMWH4T/FBXK7GUHUPMWH4T.LARGE.jpg", "https://cdn.instructables.com/FL9/LMEU/HUPMWH8X/FL9LMEUHUPMWH8X.LARGE.jpg"], "step_title": "Step 8: Wire Up a LED Strip, Test, Box and Glue"}, {"step": 9, "steps_text": "I wanted to light the bar using RGB LEDs. I used balsa wood to make the floor and side walls. I used smaller strips to attach some translucent plastic cut from a lid I listed in the \"other stuff\" section of the parts list. You need some people in the bar, so attach some people that match the scale of the building. This bar is very quiet tonight. It's probably a Tuesday night.Measure the width of the building. The floor should run the entire width of the building. You do not need to run the entire depth. It should only represent a few feet of scale measurement. Cut using an x-acto knife or something similar. Next, measure out the walls so they are as tall as you want the ceiling to be. Note, the larger LED strip in the previous step will be used to light the room as well. The height of the walls has to be high enough so the ceiling clears any windows. Use wood or white glue to attach the walls to the floor. You need to get the walls to be 90 degrees to the floor. This can be hard. Use something square and tape the walls and floor to it while the glue dries. Remove the tape and hope the square thing isn't glued on too.Then cut two small strips of wood for the back wall edges. Repeat the process of glueing and squaring them. The back wall helps hide any cracks or jagged cuts on plastic. It gives the back wall a more \"finished\" look. I left out a tool from my list and you see it in the photo above. There are acrylic \"Rite-way\" clamps. They use two acrylic parts to make the clamp and the clamp locks tight because of some Neodymium magnets. I build everything model with them and the walls are always perfectly square. There are two versions of the clamps, one for N scale and the other for HO scale models. I have an HO scale model and use the appropriate clamps.Measure the full interior of the model and cut a piece of foam that as precisely as possible matches the interior measurements. Calipers are helpful for this. Insert the foam so that it is slightly higher than your \"ceiling\" height. Attach the cardboard LED strip from the previous step to the top of the bar using tape. Insert the bar area and RGB LED display into the building. The foam should cover the the LED strip and RGB display completely.You may have problems and answers are coming.", "step_imgs": ["https://cdn.instructables.com/FB1/WOWI/HUPMWHNH/FB1WOWIHUPMWHNH.LARGE.jpg"], "step_title": "Step 9: Add the RGB's (optional)"}, {"step": 10, "steps_text": "Making it all look clean and finished is the hardest part. Jumper wires are a little too inflexible to easily slip under the model. The nodes are big and take up a lot of space. The ribbon cables are pretty inflexible too. The easiest thing to do is to cut a hole under the model and then lace the wires through the holes. The nodes can be attached to the bottom of the table or whatever supports the scenery. Then attach the jumpers from the node to the LEDs or from the LEDs to the nodes (easier). You'll probably need to patch a few light bleed areas or yank the controller board and adjust light levels and timing to get everything just right later. The photos pretty much tell this tale too. Jumper wires are 24 AWG and you will get much better flexibility with 28 AWG. Using everyday jumpers to dry-fit everything is very important because it is very easy to make a mistake when you are working with 44 individual wires for just two buildings. It is much easier to crimp your own 28 AWG wire and d-sub connectors to get the flexibility. The ribbon wire shown above was done for a very short distance, about 2 feet. It looks messy. The real wires are much longer, 6 or more feet, and result in a voltage drop. You'll likely need to adjust the IREF resistor to a somewhat lower value. The bright side (haha, bright side....) is that you can have a different IREF resistor for each TLC so you can configure the TLC to operate more efficiently for each building or block of buildings.Finally, the RGB LEDs can be a pain to connect. Crimping your own wire and use 3 pin female d-subs make it much easier.", "step_imgs": ["https://cdn.instructables.com/FTU/4HAC/HVTWEKC8/FTU4HACHVTWEKC8.LARGE.jpg", "https://cdn.instructables.com/FDH/SP1X/HVTWEKCA/FDHSP1XHVTWEKCA.LARGE.jpg"], "step_title": "Step 10: Put It All Together"}, {"step": 11, "steps_text": "Like I said at the beginning, model railroading challenges you in nearly every way. A small setup can be done on the \"4x8 foot\" plywood sheet. Bigger layouts wrap around rooms, garages and basements. Making something that takes hours, days, weeks or months is almost nothing considering that some people spend years building their layout. For some, the train is just the excuse for building a really complicated model. It is like an art for just the artist and a few close friends. I hope this lighting system helps expand that world in some small way.There is plenty of room for improvement. One area is the nodes since they are not a really good design. They are adequate and easy to build. A better design would be to run some kind of shielded cable to a node and send updates to change the state of the LEDs. Alternatively, create a better node use angled connectors and a custom PCB. Add either female headers or screw connectors if you are using male jumpers or just regular wire.Another area for improvement is the RGB setup. Previous photographs show them attached to a small breadboard. The breadboard takes up too much space in the buildings. It would be better to use a PCB and set it vertically to take up less space.The biggest area is the controller board itself. An UNO has too little memory to manage  pre-calculated RGB displays and then dozens of LEDs that follow a script. A large memory system like a mega or a Due is more useful. Warning, the Due is not compatible with the library I used. There is a library just for the Due, but you are on your own. Or perhaps an industrious engineer will build a memory expander for the Uno or create a RAM drive. Thank you for your time and best wishes. I'd love to hear any suggestions or enhancements you may have.Thanks,Andy", "step_imgs": [], "step_title": "Step 11: The End"}], "channel": "Arduino"}, {"category": "technology", "description": "\n\t\u00a0\nOne of my favorite hobbies is making rolling ball sculptures.\u00a0 I usually make RBSs out of copper but being a geek I thought it would be cool to make a virtual sculpture and 3D print it on Shapeways.\u00a0\nI started first by trying to model an RBS with Blender.\u00a0 I quickly realized that doing anything in Blender takes quite a time commitment and has a steep learning curve.\u00a0 I tried evaluating some other 3D modeling programs but every package seemed too difficult to use to build an RBS for my apparently little brain.\nI realized quickly that whenever I made a virtual 3D model, I would need to be able to easily build it and modify it.\u00a0 Well, modifying a rolling ball sculpture has consequences such that any change made higher up will affect a portion of the track lower down.\u00a0 Being a computer programmer kind of guy, I thought it would be interesting to try to make a virtual model programmactically which would give me the freedom of making something which could be very accurate and forgiving as far as modifying the model.", "title": "Programmatic Creation of a 3D Model for 3D Printing", "url": "https://www.instructables.com/id/Programmatic-Creation-of-a-3D-Model-for-3D-Printin/", "section": "technology", "steps": [{"step": 1, "steps_text": "To start I decided to use VRML (Virtual Reality Modeling Language).\u00a0 VRML comes in a few flavors.\u00a0 There's VRML 1.0, 2.0 and then came X3D.\u00a0 X3D is sort of XML based and the latest and probably last version of VRML.\u00a0 I had already played with VRML 2.0 before so I went with that because I was too lazy to learn X3D.\u00a0 Looking at it, though, it's very similar to VRML so it really is that I'm just that I'm too lazy really to try to learn it.\nVRML allows you to describe a 3D scene by using primitives like cubes, spheres, extrusions, meshes, etc.\u00a0 There's options for placing an object or a group of objects in xyz space as well as the ability to scale and rotate them.\u00a0 VRML is fairly easy to learn and use.\u00a0 Since it has been around a while, there's plenty of example code on the web so google to your heart's content.\nTo create a VRML file, you simple create a file using notepad or your favorite text editor and create it with a \".wrl\" extension.\nOn the first line you put:\n#VRML V2.0 utf8\nThen you put your code for your shape or shapes.\u00a0 For an RBS I basically use Extrusions for everything.\u00a0 Here's an example of a RBS Rail:\nTransform {\n\u00a0 translation 0 0 0\n\u00a0 children Shape {\n\u00a0\u00a0\u00a0 appearance Appearance {\n\u00a0\u00a0\u00a0\u00a0\u00a0 material Material {\n\u00a0 diffuseColor 0.757827 0.771796 0.771797\n\u00a0 ambientIntensity 0.5\n\u00a0 specularColor 0.708205 0.708205 0.708205\n\u00a0 emissiveColor 0.000000 0.000000 0.000000\n\u00a0 shininess 1\n\u00a0 transparency 0.000000\n\u00a0\u00a0\u00a0\u00a0\u00a0 } # end material\n\u00a0\u00a0\u00a0 } # end appearance\n\u00a0\u00a0\u00a0 geometry Extrusion {\n\u00a0\u00a0\u00a0\u00a0\u00a0 beginCap TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0 endCap TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0 creaseAngle 0\n\u00a0\u00a0\u00a0\u00a0\u00a0 solid TRUE\n\u00a0\u00a0\u00a0\u00a0\u00a0 crossSection [\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00150000 0.00000000,\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00121353 0.00088168,\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00046353 0.00142658,\n\u00a0\u00a0\u00a0\u00a0\u00a0 -0.00046352 0.00142658,\n\u00a0\u00a0\u00a0\u00a0\u00a0 -0.00121353 0.00088168,\n\u00a0\u00a0\u00a0\u00a0\u00a0 -0.00150000 0.00000000,\n\u00a0\u00a0\u00a0\u00a0\u00a0 -0.00121353 -0.00088168,\n\u00a0\u00a0\u00a0\u00a0\u00a0 -0.00046353 -0.00142658,\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00046352 -0.00142659,\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00121352 -0.00088168,\n\u00a0\u00a0\u00a0\u00a0\u00a0 0.00150000 0.00000000\n\u00a0\u00a0\u00a0\u00a0\u00a0 ] # end cross section\n\u00a0\u00a0\u00a0\u00a0\u00a0 spine [\n0 0 0,\n0 0 -0.01,\n0 -0.01 -0.02,\n0 -0.02 -0.02\n\u00a0\u00a0\u00a0\u00a0\u00a0 ] # end spine\n\u00a0\u00a0\u00a0 } # end extrusion\n\u00a0 } # end shape\n}\nYou can end with this code but it's not really necessary usually:\nNavigationInfo{\n\u00a0 type \"EXAMINE\"\n} # end NavigationInfo\nSo what does it all mean?\nThe first line identifies a VRML file.\nThe \"geometry Extrusion\" section defines the extrusion with endcaps, a circular crosssection of xy points, which gets extruded across 4 xyz points.\nThe \"Shape\" section defines attributes about the shape which surrounds the geometry Extrusion section.\nThe \"Transform\" section defines either where to move the object xyz or scale or rotate the object.\u00a0 Several Transforms can surround other transforms.\u00a0 So, for example the inside transform can be for rotation, there could be another that surrounds that transform that could be for scale, and another transform which surrounds both of the others which could be for xyz translation.\nThe \"NavigationInfo\" section is for some VRML viewers to know what to do.\u00a0 You can go into examine mode, or go into flythrough mode, there may be other modes you could do, I don't know them all.", "step_imgs": ["https://cdn.instructables.com/FFT/J4EQ/H2CE6ED8/FFTJ4EQH2CE6ED8.LARGE.jpg"], "step_title": "Step 1: Use VRML to Create a Simple 3D Virtual Model"}, {"step": 2, "steps_text": "OK, it doesn't take a genius to realize that writing a bunch of VRML code by hand could get rather tedious and very hard to manage.\u00a0 So the next step would be to use some language where you could write functions that can output custom VRML code.\u00a0 What programming language you use is up to you.\u00a0 I actually use Tcl a lot but that's just a personal preference.\u00a0 You could just as easily use Perl, C, Java, C# or whatever can output plain text.\u00a0 Most Linux systems have Perl pre-installed or you can install it easily with yum or apt-get.\u00a0 You can download\u00a0 free community edition version of Perl for Windows from Activestate.com.\nHere's an example of a perl program that outputs a simple 3D model:\n#/usr/bin/perl\nopen FILEOUT, \">bot_part.wrl\" or die;\nprint FILEOUT \"#VRML V2.0 utf8\\r\\n\";\nprint FILEOUT \"\\r\\n\";\nprint FILEOUT \"# by Jim Brown\\r\\n\";\nprint FILEOUT \"\\r\\n\";\n$rad = 3.141592 / 180.0;\n$meter = 1;\n$cm = $meter / 100.0;\n$mm = $cm / 10.0;\n$back_plane_width = 24.0 * $mm;\n$back_plane_height = 40.0 * $mm;\nprint FILEOUT \"# part\\r\\n\";\nprint FILEOUT \"Transform \\{ \\r\\n\";\nprint FILEOUT \"\u00a0 translation 0 0 0\\r\\n\";\nprint FILEOUT \"\u00a0 children \\[\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 Shape \\{\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 appearance Appearance \\{\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 material Material \\{\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 diffuseColor 0.9 0.9 0.9\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 \\} # end material\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 \\} # end appearance\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 geometry Extrusion \\{\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 creaseAngle 0\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 beginCap TRUE\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 endCap TRUE\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 crossSection \\[\\r\\n\";\n\u00a0 $x_width = $back_plane_width;\n\u00a0 $y_width = 2 * $mm;\n\u00a0\u00a0 print FILEOUT \"\u00a0 \" . sprintf(\"%3.8f %3.8f\", 0 - ( $x_width / 2.0 ), 0 - ( $y_width / 2.0 )) . \"\\r\\n\" ;\n\u00a0\u00a0 print FILEOUT \"\u00a0 \" . sprintf(\"%3.8f %3.8f\", 0 + ( $x_width / 2.0 ), 0 - ( $y_width / 2.0 )). \"\\r\\n\" ;\n\u00a0\u00a0 print FILEOUT \"\u00a0 \" . sprintf(\"%3.8f %3.8f\", 0 + ( $x_width / 2.0 ), 0 + ( $y_width / 2.0 )). \"\\r\\n\" ;\n\u00a0\u00a0 print FILEOUT \"\u00a0 \" . sprintf(\"%3.8f %3.8f\", 0 - ( $x_width / 2.0 ), 0 + ( $y_width / 2.0 )). \"\\r\\n\" ;\n\u00a0\u00a0 print FILEOUT \"\u00a0 \" . sprintf(\"%3.8f %3.8f\", 0 - ( $x_width / 2.0 ), 0 - ( $y_width / 2.0 )). \"\\r\\n\" ;\nprint FILEOUT \"\u00a0\u00a0\u00a0 \\] # end cross section\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 spine \\[\\r\\n\";\n\u00a0 $x = $back_plane_width / 2.0;\n\u00a0 $y = 0;\n\u00a0 $z = 0;\n\u00a0 print FILEOUT \" \" . sprintf(\"%3.8f %3.8f %3.8f,\", $x, $y, $z) . \" \\r\\n\";\n\u00a0 $y = $y - $back_plane_height;\n\u00a0 print FILEOUT \" \" . sprintf(\"%3.8f %3.8f %3.8f,\", $x, $y, $z) . \" \\r\\n\";\n\u00a0 $x = $x + $back_plane_width / 2.0;\n\u00a0 $z = $z + $back_plane_width / 2.0;\n\u00a0 print FILEOUT \" \" . sprintf(\"%3.8f %3.8f %3.8f\", $x, $y, $z) . \" \\r\\n\";\n\u00a0 $x = $x + $back_plane_width / 2.0;\n\u00a0 print FILEOUT \" \" . sprintf(\"%3.8f %3.8f %3.8f\", $x, $y, $z) . \" \\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0\u00a0\u00a0 \\] # end spine\\r\\n\";\nprint FILEOUT \"\u00a0\u00a0\u00a0 \\} # end extrusion\\r\\n\";\nprint FILEOUT \"\u00a0 \\} # end shape\\r\\n\";\nprint FILEOUT \"\\]\\r\\n\";\nprint FILEOUT \"\\}\\r\\n\";\nprint FILEOUT \"\\r\\n\";\nclose FILEOUT;\nIn the example pics you can see that a 3D model is created.\u00a0 If you look at the wireframe image, you can tell that I have mitering turned on, or else the model would look squished.\u00a0 This is a feature of Accutrans3D.\nI figure that this step is enough to make many models in 3D.\u00a0 You can see in the example pics, I made a Raspberry Pi Case and had it printed in 3D using this method of creating a program that outputs vrml.\u00a0 I ended up with a nice box.\u00a0 I even added text and a Raspberry Pi logo on top of the box.\u00a0 You probably can see how using this method could be very powerful for making an exact object with exact measurements without any sort of modeling package other than pure code.", "step_imgs": ["https://cdn.instructables.com/F5T/EUOP/H1YONIKR/F5TEUOPH1YONIKR.LARGE.jpg", "https://cdn.instructables.com/F0E/DIT3/H21CGKHV/F0EDIT3H21CGKHV.LARGE.jpg", "https://cdn.instructables.com/FCT/PG6R/H27LRQB3/FCTPG6RH27LRQB3.LARGE.jpg", "https://cdn.instructables.com/FFC/SJ4X/H2BMNG98/FFCSJ4XH2BMNG98.LARGE.jpg", "https://cdn.instructables.com/FK7/MT3J/H1YONIKS/FK7MT3JH1YONIKS.LARGE.jpg", "https://cdn.instructables.com/F2E/3U6Q/H2BMNG99/F2E3U6QH2BMNG99.LARGE.jpg"], "step_title": "Step 2: Create a Perl Program That Outputs VRML"}, {"step": 3, "steps_text": "The previous step is usually far enough to build simple and even some complex 3D models with VRML.\u00a0 However, I wanted to build a Rolling Ball Sculpture.\u00a0 Trying to build a rolling ball sculpture using perl only seemed pretty tough to me.\u00a0 So I decided, it would be great to build a RBS scripting language that I could define an RBS then have a parser parse the scripting language and output the appropriate VRML code.\nMy RBS scripting code would have commands like:\u00a0 \"Create Start Bucket\", \"Go Straight some amount\", \"Turn Left some amount\", \"Turn Right some amount\", \"Create End Bucket\", etc and would have commands for building a frame and supports and such.\u00a0 For the track rungs I decided to make it automatic where every so often at a set distance it would automatically add a rung.\u00a0 For the Supports, I needed to be able to tell which rail, left or right, to have the support connect to and which side of the frame to connect to. For the turns, the parser would automatically figure out banking and smoothing.\u00a0 I can tell it where to place marbles.\u00a0\nFor the banking, if you can imagine, I have an invisible center rail on which I rotate the other two rails. So when I want to turn left, the right rail goes up and in a little and the left rail goes down and in a little according to a z rotation. The track is sort of built in short steps. So the parser sort of figures about 3 steps before the next turn and 3 steps into the next turn to incrementally start banking. After a curve the parser un-banks for about 3 steps before the end of the curve and 3 steps after the curve until it's back to normal no bank for straight track or banked to the next curve for curves.To figure the bank, at first I just guessed and manually set the bank based on the diameter of the curve and that worked. Later, I figured a formula to do the same thing. I figured that this incremental banking was not smoothing so a wrote a function that would smooth the entire track sort of in an Fast Fourier Transform (FFT) sort of and averaging over several steps fashion.\nFor the frame, I currently have a few choices.\u00a0 I can choose a rectangle cube frame which calculates its size from the extents of the track height, width and depth and puts the frame just a little larger than that so that the track fits inside those dimensions.\u00a0 I can choose a spherical frame like the Christmas Ornament sculpture which like the rectangle sculpture calculates its size from the extents of the track inside.\u00a0 I can choose a central spire frame like the two track rolling ball sculpture with the track going around the spire and the footprint being calculated by the extents of the track.\u00a0 For short track, I can choose no frame at all but instead just stilts for the track to be supported by.\u00a0 Each frame comes with its own set of challenges and its own algorithm for connecting the supports form the frame to the track.\u00a0 I will probably create a few more frame to chose from and perhaps try to make a few that are more artistic than a rectangle cube but that was a start.\nWhat's cool about making a scripting language is that changes are quick and easy.\u00a0 I can even do testing to make sure the track has the right distance from track passing over a track so that the marble has room to get through.\u00a0 I can build a sculpture, view it in a 3D modeling program, decide if it looks good, and if something needs to be changed I can change the script, re-parse it and then go back and view the change in the 3D modeling program.\u00a0", "step_imgs": ["https://cdn.instructables.com/FLR/VUCV/H2CE6DX9/FLRVUCVH2CE6DX9.LARGE.jpg", "https://cdn.instructables.com/F59/SE1P/H29XS7M6/F59SE1PH29XS7M6.LARGE.jpg", "https://cdn.instructables.com/FIM/JRPN/H29XS7M7/FIMJRPNH29XS7M7.LARGE.jpg", "https://cdn.instructables.com/FMI/COK3/H29XS7M9/FMICOK3H29XS7M9.LARGE.jpg", "https://cdn.instructables.com/FZ7/2UU0/H1YOINHB/FZ72UU0H1YOINHB.LARGE.jpg", "https://cdn.instructables.com/FMP/HVP7/H1ZG7FX0/FMPHVP7H1ZG7FX0.LARGE.jpg", "https://cdn.instructables.com/F8R/GAC4/H1YOINHC/F8RGAC4H1YOINHC.LARGE.jpg", "https://cdn.instructables.com/FMG/5Q1G/H1YOINI0/FMG5Q1GH1YOINI0.LARGE.jpg"], "step_title": "Step 3: Write a Scripting Language and Parser to Build 3D Models"}, {"step": 4, "steps_text": "OK, so I have a cool WRL file that I can upload to Shapways.\u00a0 Shapeways does accept VRML files for upload.\u00a0 OK, so I upload the file to Shapeways, and lo and behold, they won't accept it!\u00a0 Ugg.\u00a0 What's the deal!\nThere are several reasons why Shapeways won't accept a 3D model file.\u00a0 The main reason Shapeways won't accept a file is if a file is non-manifold.\u00a0 Non-Manifold basically means it's not water tight.\u00a0 This can happen when one beam crosses another beam at an intersection or when a beam bends at too tight an angle that causes weird inside out folding. There are probably more reasons that I can explain that can happen and I've probably encountered many of them.\u00a0 It's very frustrating. You must fix all non-manifold problems before Shapeways will accept the file.\u00a0 The good news is that Shapeways will allow you to modify and upload the file as many times as you wish until you get it right!\nI ran into a rather weird reason why Shapeways wouldn't allow me upload a WRL file.\u00a0 It appears that the Shapeways VRML renderer has a bug in it!\u00a0 I've told them about it but it appears to have fallen on deaf ears.\u00a0 After several emails back and forth they basically blew me off.\u00a0 It appears the the Shapeways renderer has an odd twisting behavior of extruded beams that curve around which my RBSs need to do.\u00a0 In addition, the bends are not very smooth as their VRML renderer doesn't do mitering.\u00a0 In their defense, mitering is not part of the VRML spec, but the twisting thing is definitely a bug.\nSo, I went looking for other VRML to STL renderers.\u00a0 MeshLab says it can render VRML but it apparently only does meshes and fails at extrusions.\u00a0 I had an old version of TurboCad 14, but it also has the weird twisting problem with extrusions.\u00a0 I tried Blender, but it doesn't like the multiple objects and also seems to have trouble with the extrusions.\u00a0 I tried NetFabb but it also has trouble with VRML extrusions.\u00a0 I tried several other packages but they all either couldn't render VRML at all or they failed at rendering extrusions correctly.\nI tried Accutrans3D and at first it couldn't render the VRML extrusions correctly either, but Wayne at Micromouse had pity on my plight and fixed the problem and gave me a working update!\u00a0 Yea!\u00a0 Go Wayne and Accutrans3D!\u00a0 Not only that, but Wayne implemented the mitering I was wanting and it works beautifully!\u00a0 No other 3D package works for this but Accutrans3D that I could find!\u00a0 So I was able to import my VRML file and output a STL file and upload that to Shapeways and that works perfectly!", "step_imgs": ["https://cdn.instructables.com/F6P/EZR6/H27LRQNH/F6PEZR6H27LRQNH.LARGE.jpg"], "step_title": "Step 4: Rendering VRML and Converting to STL"}, {"step": 5, "steps_text": "\n          OK, so getting to this point where I have a virtual 3D RBS model that I can upload to Shapeways doesn't mean anything if I can't print it or if it doesn't work after I print it.\u00a0 Well, I haven't written any physics testing software yet so all I can really do is to make it and try it.\u00a0 Of course this method is an expensive method because if it doesn't work, it's like $30 bucks down the drain for the 3D printing cost.\u00a0 I guess that's the price I pay for not having a physics testing program yet.\u00a0 But hey, most of these sculptures seem to work the first time and some don't. Anyway, check out these videos of some of the sculptures I've made so far:\n\t\t\u00a0", "step_imgs": ["https://cdn.instructables.com/F5H/F4TQ/H1YOINO2/F5HF4TQH1YOINO2.LARGE.jpg", "https://cdn.instructables.com/FXE/CT6F/H27LRQPA/FXECT6FH27LRQPA.LARGE.jpg", "https://cdn.instructables.com/FP3/GE9L/H29XS7V0/FP3GE9LH29XS7V0.LARGE.jpg", "https://cdn.instructables.com/FQC/T7R2/H2BMNGCC/FQCT7R2H2BMNGCC.LARGE.jpg"], "step_title": "Step 5: Videos and Next Steps Physics Testing Program?"}], "channel": "3D Printing"}, {"category": "technology", "description": "HiIn this Instructable I'll show you how I built a low-cost antenna analyser which can measure an antenna and display its VSWR over any or all of the HF frequency bands. It will find the minimum VSWR and corresponding frequency for each band but also will display a realtime VSWR for a user-selected frequency to facilitate antenna adjustment. If sweeping a single frequency band, it will display a graph of VSWR versus frequency. It also has a USB port on the back for outputting frequency and VSWR data, to allow more refined graph-plotting on a PC. The USB port can also be used to reflash the firmware if needed. I recently got into amateur radio (because I liked the idea of peer-to-peer communication over huge distances without infrastructure) and rapidly made the following observations:1. All of the worldwide communications that interested me take place on the HF bands (3-30 MHz)2. HF transceivers are very expensive and will break if you don't drive them into a reasonably well-matched antenna3. You are generally expected to rig up your own HF antenna from bits of wire strung across the garden (unless you want to spend even more money than you spent in 2).4. Your antenna might be a bad match but you won't know till you try it.Now a purist would probably say that one should first test the antenna on very low power at the frequency of interest and check the VSWR on the rig's meter to assess the quality of the match. I don't really have the time to muck about with that sort of thing for every frequency I might want to use. What I really wanted was an antenna analyser. These devices can test the quality of the antenna match at any frequency over the HF bands. Unfortunately they are also very expensive, so I set about considering whether I could make my own. I stumbled upon the excellent work carried out by K6BEZ (see http://www.hamstack.com/project_antenna_analyzer.html), who investigated the use of an Arduino to control a cheap direct digital synthesiser module (DDS). He soon abandoned the Arduino on cost grounds, preferring to use a PIC. Well, in 2017 you can buy an Arduino Nano for about \u00a33.50, so I thought it was time to revisit his work, pick up where he left off and see what I could come up with (note that I'm not the only one who has done this: there are some very nice examples to be found on the internet).Update (29/7/2018) - this work has been built upon considerably by bi3qwq, from China, who has made some really nice improvements to the user interface, which he has kindly shared. He's designed a very professional PCB (with a great calibration resistor feature) and done a really good looking build. To top it all he has prepared a schematic, which I know will delight many of those who have commented previously. Please see the comments section for more information.Update - I've been getting into 60 m recently, which the original sketch didn't cover. So now I've uploaded firmware version 7, which adds the 160 m and 60 m bands. These aren't add-ons; they are fully integrated into the operation of the analyser. It was fortunate that I could find an u8glib font that was still legible but allowed me to display ten bands simultaneously on that little screen (although it wasn't monospace, which caused some grief). I have estimated calibration values for the new bands, based on interpolation / extrapolation of the existing calibration values. I then checked these out with fixed resistors and they give pretty good results.Update - as several people have asked about schematics, the fundamental Arduino / DDS / VSWR bridge circuit is largely unaltered from K6BEZ's original work. Please check out the above URL for his original schematic on which I based this project. I've added an encoder, an OLED screen and fully developed firmware to make for an effortless user experience.Update - This system uses a very low voltage DDS signal source in conjunction with a resistive bridge containing diode detectors. Thus the diodes are operating in their non-linear regions and my first version of this system tended to under-read VSWR. As an example, a 16 ohm or 160 ohm impedance load should show a VSWR of about 3 in a 50 ohm system; this meter indicated a VSWR closer to 2 in this situation. I therefore carried out a software calibration using known loads which seems to be an effective fix for this problem. This is described in the penultimate step of this instructable and a revised sketch has been uploaded.Update - on-board graphing facility added to single sweeps as it was too useful to leave out, particularly when tuning antenna lengths for minimum VSWR : a graph gives you an instantly visible trend.", "title": "HF Antenna Analyser With Arduino and DDS Module", "url": "https://www.instructables.com/id/HF-Antenna-Analyser-With-Arduino-and-DDS-Module/", "section": "technology", "steps": [{"step": 1, "steps_text": "You will need the following items. Most of them can be obtained cheaply from Ebay. The most expensive single item was the box, at close on \u00a310! It might be possible to substitute some items (I used 47 Rs instead of 50 Rs, for example). The diodes were rather unusual (I had to buy 5 off from Italy) and would be worth substituting for more readily available items if you know what you are doing.Arduino Nano     DDS  module (DDS AD9850 Signal Generator Module HC-SR08 Signal Sine Square Wave 0-40MHz)    1.3\" i2c OLED display     MCP6002 op-amp (8 pin)     2 off AA143 diode     Ceramic capacitors: 2 off 100 nF, 3 off 10 nF     1 uF electrolytic capacitor     Resistors: 3 off 50 R, 2 off 10 K, 2 off 100 K, 2 off 5 K, 2 off 648 R     2.54 mm pitch screw terminal blocks: 3 off 2-pin, 2 off 4-pin     Single-core hook-up wire     702 or similar hook-up wire     Stripboard     Square header strip (female) for plugging the Arduino and DDS into - don't buy the round socket stuff by mistake!     SO-239 chassis-mount socket     Rotary encoder (15 pulse, 30 detent) with push switch and knob     Cheap rotary encoder 'module' (optional)      Project box     Toggle switch     Right-angle mini-usb to USB B bulkhead mount lead (50 cm)     PP3 and battery clip / holder     Self-adhesive PCB mounting posts / standoffsYou'll also need a soldering iron and electronics tools. A 3D printer and a pillar drill are helpful for the enclosure, although if you wanted you could probably assemble the whole thing on the stripboard and not bother with a box.Naturally you undertake this work and exploit the results generated at your own risk.", "step_imgs": [], "step_title": "Step 1: Buy Your Stuff"}, {"step": 2, "steps_text": "Plan out how you are going to arrange the components on the stripboard. You can either do it yourself, referring to K6BEZ's original schematic (which lacks an encoder or screen - see Page 7 of http://www.hamstack.com/hs_projects/antenna_analyzer_docs.pdf), or you can save a load of time and copy my layout.I do these layouts the simple way, using squared paper and a pencil. Every intersection represents a stripboard hole. The copper tracks go horizontally. A cross represents a broken track (use a 6 mm drill or the proper tool if you have one). Lines of circles with a box round them represent headers. Large boxes with screws denote the connector blocks. Note that in my diagram there is an extra line which runs horizontally through the middle of the board. Leave this out when you are putting it together (it's marked 'omit this line').Some of the components may appear to be laid out strangely. This is because the design evolved once I'd got the basic hardware working (particularly when I realised that the encoder needed hardware interrupts, for example).When soldering components onto the board, I use Blu-Tak to hold them in firmly in place while I turn the board over to solder the legs.I tried to minimise the amount of wire I used by aligning the Arduino and the DDS module and just using the stripboard to connect key pins. I didn't realise at the time that the hardware interrupts needed to read the encoder only work on pins D2 and D3, so I had to move DDS RESET from its original D3 connection with a bit of wire:DDS RESET - Arduino D7DDS SDAT - Arduino D4DDS FQ.UD - Arduino D5DDS SCLK - Arduino D6Arduino D2 & D3 are used for the encoder inputs A & B. D11 is used for the encoder switch input. D12 isn't used but I thought I'd make a screw terminal for it anyway, for future expansion.Arduino A4 & A5 provide the SDA & SCL (I2C) signals for the OLED screen.Arduino A0 & A1 take the inputs from the VSWR bridge (via the OPAMP).", "step_imgs": ["https://cdn.instructables.com/FT9/03WS/J08EBAYU/FT903WSJ08EBAYU.LARGE.jpg", "https://cdn.instructables.com/F63/TPTZ/J08EBA0O/F63TPTZJ08EBA0O.LARGE.jpg"], "step_title": "Step 2: Lay Out the Stripboard"}, {"step": 3, "steps_text": "It's worth testing the board before going to the trouble of mounting it into an enclosure. Attach the following components using flexible wire to the board using the screw terminal blocks:1.3\" OLED display (SDA and SCL are connected to Arduino pin A4 and A5 respectively; ground and Vcc go to Arduino GND and +5V, obviously)      Rotary encoder (this needs a ground, two signal lines and a switch line - you might need to flip the switch lines round if the encoder works the wrong way - connect these to Arduino ground, D2,D3 & D11 respectively). Note that for my prototyping work I mounted the 15/30 encoder onto a KH-XXX encoder module board, as the pins on the bare encoders are very flimsy. For the final job I soldered wires straight onto the encoder.     9V battery      SO-239 socket - solder the centre pin to the antenna signal line and use an M3 ring terminal and screw for the antenna groundFlash the following sketch onto the Arduino. Also make sure you have included the very good OLED driver library from Oli Kraus, or the complilation will crash and burn : https://github.com/olikraus/u8glib/If your OLED display is slightly different you may need a different configuration setting in u8glib; this is well documented in Oli's example code.", "step_imgs": ["https://cdn.instructables.com/FZZ/SIAC/J08EB9YQ/FZZSIACJ08EB9YQ.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Install the Modules, Attach the Peripherals and Flash the Code"}, {"step": 4, "steps_text": "I seriously considered leaving the analyser as a bare board, as it was only likely to be used occasionally. On reflection though, I thought that if I was doing a lot of work on a single antenna, it might end up getting damaged. So everything went in a box. There's no point going into details about how this was done, as your box will likely be different, but some key features are worth mentioning:1. Use self-adhesive PCB standoffs for mounting the stripboard. They make life really easy.2. Use a short USB adaptor lead to bring out the Arduino USB port to the rear of the enclosure. Then it's easy to access the serial port to obtain frequency vs. VSWR data and also to reflash the Arduino without taking the lid off.3. I developed a custom 3D-printed part to support the OLED display, as I couldn't find anything on the web. This has a recess to allow one to insert a 2 mm piece of acrylic to protect the fragile screen. It can either be mounted using double-sided tape or self tapping screws (with the tabs on either side). Once the display has been fitted, you can use a hot wire (think paperclip and blowlamp) to melt the PLA pins onto the back of the circuit board to secure everything. Here's the STL file for anyone who's interested:", "step_imgs": ["https://cdn.instructables.com/F3J/4WRS/J08EBB6P/F3J4WRSJ08EBB6P.LARGE.jpg", "https://cdn.instructables.com/FJM/F930/J08EBB35/FJMF930J08EBB35.LARGE.jpg", "https://cdn.instructables.com/FS2/2FD3/J08EBBAL/FS22FD3J08EBBAL.LARGE.jpg", "https://cdn.instructables.com/FF1/LQDK/J08EBB47/FF1LQDKJ08EBB47.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Put It All in a Nice Box (optional)"}, {"step": 5, "steps_text": "Originally I didn't do any calibration but discovered that the VSWR meter was consistently reading low. This meant that although an antenna appeared to be okay, my rig's autotuner wasn't able to match to it. This problem arises because the DDS module gives out a very low amplitude signal (about 0.5 Vpp at 3.5 MHz, rolling off as frequency increases). The detector diodes in the VSWR bridge are therefore operating in their non-linear region.There are two possible fixes for this. The first is to fit an broadband amplifier to the output of the DDS. Potentially suitable devices are available cheaply from China and they will boost the output to about 2 V pp. I have ordered one of these but have yet to try it. My feeling is that even this amplitude will be a bit marginal and some non-linearity will remain. The second method is to put known loads on the output of the existing meter and to record the displayed VSWR at each frequency band. This allows you to construct correction curves for actual versus reported VSWR, which can then be put into the Arduino sketch to apply correction on the fly. I adopted the second method as it was easy to do. Just get hold of the following resistors: 50, 100, 150 and 200 ohms. On this 50 ohm instrument these will correspond to VSWRs of 1,2,3 and 4 by definition. In the sketch there is a switch 'use_calibration'. Set this to LOW and upload the sketch (which will display a warning on the splash screen). Then carry out measurements at the centre of each frequency band for each resistor. Use a spreadsheet to plot expected versus displayed VSWR. You can then do a logarithmic curve fit for each frequency band, which gives a multiplier and intercept of the form TrueVSWR=m.ln(MeasuredVSWR)+c. These values should be loaded into the swr_results array in the last two columns (see the preceding comment statement in the sketch). This is an odd place to put them but I was in a hurry and as this array stores floats it seemed like a sensible choice at the time. Then put the use_calibration switch back to HIGH, reflash the Arduino and off you go.Note that when doing the spot frequency measurements, the calibration is applied for the initial choice of band. This won't be updated if you make gross changes in frequency.Now the meter reads as expected for the fixed loads and seems to make sense when measuring my antennas! I suspect I may not bother trying that broadband amp out when it arrives...", "step_imgs": ["https://cdn.instructables.com/FOO/F7RM/J1QP3L37/FOOF7RMJ1QP3L37.LARGE.jpg"], "step_title": "Step 5: Calibration"}, {"step": 6, "steps_text": "Attach an antenna via a PL-259 lead and switch the device on. It will display a splash screen then automatically perform a sweep of all the main HF bands. The display shows the frequency under test, the current VSWR reading, the minimum VSWR reading and the frequency at which it occurred. In order to reduce measurement noise, five measurements are taken of VSWR at every frequency point; the mean value of these five readings is then passed through a nine-point moving average filter with respect to frequency before the final value is displayed.If you want to stop this all-bands sweep, just press the encoder knob. The sweep will stop and a summary of all the band data gathered will be displayed (with nulls for those bands not yet swept). A second press will bring up the main menu. Choices are made by rotating the encoder and then pressing it at the appropriate point. There are three choices in the main menu:Sweep all bands will restart the sweep of all the main HF bands. When it finishes, it will display the summary screen described above. Write this down or take a photo if you want to keep it.Sweep single band will allow you to select a single band with the encoder then sweep it. Both the wavelength and frequency range are displayed while making the selection. When the sweep has finished, a second press of the encoder will display a simple VSWR versus frequency graph of the band just swept, with a numerical indication of minimum VSWR and the frequency that it occurred. This is very handy if you want to know whether to shorten or lengthen your dipole arms, as it shows the VSWR trend with frequency; this is lost with the simple numeric report.Single frequency allows you to choose a single fixed frequency and then continuously updates a live VSWR measurement, for antenna tuning purposes in real time. First select the relevant frequency band; the display will then show the centre frequency of the chosen band and a live VSWR reading. The relevant band calibration is applied at this point. One of the digits of the frequency will be underlined. This can be moved left and right with the encoder. Pressing the encoder emboldens the line; then rotating the encoder will reduce or increase the digit (0-9 with no wrap or carry). Press the encoder again to fix the digit, then go on to the next one. You can access pretty much any frequency across the entire HF spectrum using this facility - the band selection at the start just helps to get you close to where you probably want to be. There's a caveat though: the calibration for the selected band is loaded at the start. If you move too far away from the selected band by changing the digits the calibration will become less valid, so try to stay within the chosen band. When you have finished with this mode, move the underscore all the way to the right until it's under 'exit', then press the encoder to return to the main menu.If you connect your PC to the USB socket on the rear of the analyser (i.e. into the Arduino), you can use the Arduino serial monitor to collect frequency versus VSWR values during any sweep operation (it's currently set to 9600 but you can change that easily by editing my sketch). The values can then be put into a spreadsheet so you can plot more permanent graphs etc. The screenshot shows the VSWR summary for my 7.6 m fishing pole vertical antenna with 9:1 UNUN. My rig can accommodate a 3:1 max SWR with its internal auto-tuner unit. You can see that I will be able to tune it over all bands except 80 m and 17 m. So now I can relax in the knowledge that I've got a passable multi-band antenna and I'm not going to break anything expensive when transmitting on the majority of bands.Good luck and I hope you find this useful.", "step_imgs": ["https://cdn.instructables.com/F7R/2DKI/J08EDY8I/F7R2DKIJ08EDY8I.LARGE.jpg", "https://cdn.instructables.com/F3W/332S/J20PD0F7/F3W332SJ20PD0F7.LARGE.jpg"], "step_title": "Step 6: Using the Analyser"}], "channel": "Wireless"}, {"category": "technology", "description": "This instructable will explain step-by-step how to build a device that detects which note is played on an acoustic guitar. The device accomplishes this task by using a microphone to read in the sound wave, audio amplifier and DC offset circuits to adjust the signal, an algorithm to determine the frequency, and a seven segment display and LEDs to display the note. This instructable was developed while referencing the following Instructables: Arduino Audio Input, Arduino Frequency Detection, and Arduino Guitar Tuner.Parts List:  AmazonArduino Uno & USB Cable Part #: LYSB01KFD3F0I-CMPTRACCSJumper wires   Part #: 32JWKZNBreadboard  Part #: EBOOT-BREADBOARD-01  Radio Shack5mm Green LED  Catalog #: 2760022\u00bc-Inch Mono Inline Audio Jack  Catalog #: 2740340Heavy-Duty 9V Snap Connectors (2)  Catalog #: 2700324Uni-Directional Dynamic Microphone  Catalog #: 33030389V Batteries (2)  Catalog #: 2302211  Digi-KeyJ-FET Amplifier 2 CircuitPart #: 296-1780-5-ND10k Ohm Gang Linear Panel Mount Potentiometer  Part #: 987-1301-ND100 Ohm \u00b15% 0.25W Through Hole Resistor (3)  Part #: CF14JT100RTR-ND47 Ohm \u00b15% 0.25W Through Hole Resistor (3)  Part #: CF14JT47R0TR-ND390 Ohm \u00b15% 0.25W Through Hole Resistor (1)  Part #: CF14JT390RTR-ND100k Ohm \u00b15% 0.25W Through Hole Resistor (3)  Part #: CF14JT100KCT-ND10\u00b5F 16V Aluminum Capacitor  Part #: P5134-ND0.047\u00b5F -20%, +80% 25V Ceramic Capacitor  Part #: P4307-ND", "title": "Arduino Guitar Note Detector", "url": "https://www.instructables.com/id/Arduino-Guitar-Note-Detector/", "section": "technology", "steps": [{"step": 1, "steps_text": "Our design for the audio input circuit is based on the circuit design from the Arduino Audio Input Instructable. Our circuit diagram is shown above. This part of the circuit allows audio to be sampled and processed by the Arduino. The audio signal from the microphone goes into the circuit through an op amp circuit and DC offset circuit and then into the Arduino. Preparing the Audio Jack: In our circuit, we used the \u00bc-inch mono audio jack. Connect a wire to the ground pin of the mono jack, which is usually the larger pin on the jack. Then connect a wire to the one of the two signal pins of the mono jack, which are the smaller pins. In our own circuit, we used electrical tape, but you can solder the wires for a better connection.Building the Circuit: Refer to the circuit diagram above while constructing the circuit. The first step in the circuit is the amplifier. It increases the amplitude of the signal from around \u00b1200 mV to \u00b12.5 V. It also protects the audio source from the rest of the circuit. The 9 V batteries power the amplifier. Wire the +V and -V to the op amp. Wire the signal from the mono jack to the non-inverting input and connect the ground pin of the jack to the 0 V reference on your voltage supply (the junction between the two 9 V batteries in series). Wire a 100 kOhm resistor between the output and inverting input of the op amp. We used a 10 kOhm potentiometer as a variable resistor to adjust the gain of the op amp. The gain is the amplitude of the output voltage divided by the amplitude of the input voltage. Wire the potentiometer between the inverting input and the 0 V reference. You can adjust the potentiometer to adjust the gain of the amplifier based on the sensitivity of the microphone while keeping it in an acceptable range for the Arduino, which is 0 to 5 V.DC Offset: The +2.5 V DC offset causes the audio signal to oscillate around 2.5 V so that it stays within the acceptable range (0 - 5 V) for the Arduino\u2019s analog inputs. The DC offset circuit has two main components: a voltage divider and a capacitor. Our voltage divider is made from two 100k resistors wired in series from the Arduino\u2019s 5 V supply to ground. Because the resistors have the same resistance, the voltage at the junction between them equals 2.5 V. This 2.5 V node is tied to the output of the amplifier with a 10 \u03bcF capacitor. This causes the voltage at the 2.5 V node to center around 2.5 V. Connect the negative lead of the 10 \u03bcF to the output from the op amp. Connect the other side of the capacitor to the node between two 100k resistors in series between 5V and ground. Add the 47 nF capacitor from 2.5 V to ground. Now the output goes into an analog input pin A0 on the Arduino.", "step_imgs": ["https://cdn.instructables.com/F88/A1HT/J20P6CZS/F88A1HTJ20P6CZS.LARGE.jpg", "https://cdn.instructables.com/F3B/SBZI/J20P6DPR/F3BSBZIJ20P6DPR.LARGE.jpg", "https://cdn.instructables.com/F3S/YX71/J20P6DQN/F3SYX71J20P6DQN.LARGE.jpg", "https://cdn.instructables.com/FB3/G86W/J20P6DRV/FB3G86WJ20P6DRV.LARGE.jpg", "https://cdn.instructables.com/FHM/6EP2/J20P6DST/FHM6EP2J20P6DST.LARGE.jpg", "https://cdn.instructables.com/FER/CN95/J20P6DX5/FERCN95J20P6DX5.LARGE.jpg", "https://cdn.instructables.com/FHC/QXGD/J20P6DXZ/FHCQXGDJ20P6DXZ.LARGE.jpg"], "step_title": "Step 1: Step 1: Audio Input Circuit"}, {"step": 2, "steps_text": "Use a seven segment display and four LEDs to represent each of the following notes of a guitar: E2, A2, D3, G3, B3 and E4. Each segment and LED will be powered by the digital outputs from the Arduino. The digital pins 2-8 will be mapped to segments a, b, c, d, e, f and g of the seven segment display. The digital pin 10 will be used to power the seven segment. The digital pins 11-13 will provide the logic to the LEDs. The seven segment display will display the letter of the note and the LEDs will light up to represent the octave. Due to the limitations of the seven segment display, the notes will be presented in the following way: E2: \u201cE\u201d with two LEDs lit A2: \u201cA\u201d with two LEDs lit D3: \u201cd\u201d with three LEDs lit G3: \u201cg\u201d with three LEDs lit B3: \u201cb\u201d with three LEDs lit E4: \u201cE\u201d with four LEDs litRefer to the code in the \u2018Programing\u2019 section and \u2018Appendix\u2019 to program the LEDs and seven segment display. Refer to the circuit diagram above to wire the seven segment display and LEDs.", "step_imgs": ["https://cdn.instructables.com/FJD/3XT6/J20P8C3S/FJD3XT6J20P8C3S.LARGE.jpg"], "step_title": "Step 2: Step 2: 7 Segment Display"}, {"step": 3, "steps_text": "The code consists of two sections. The first section, written by Amanda Ghassaei, receives the audio input via the Arduino\u2019s Analog to Digital Converter.  From void setup();  cli();//disable interrupts\n  //set up continuous sampling of analog pin 0 at 38.5kHz\n \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA = 0;\n  ADCSRB = 0;\n  \n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enable auto trigger\n  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n  sei();//enable interruptsIn addition, this section deals with frequency detection. It does so by internally forming a graph. It then processes this graph, detecting the frequency of the oscillation formed. ISR(ADC_vect) {//when new ADC value ready  \n  prevData = newData;//store previous value\n  newData = ADCH;//get value from A0\n  if (prevData < 127 && newData >=127){//if increasing and crossing midpoint\n    newSlope = newData - prevData;//calculate slope\n    if (abs(newSlope-maxSlope) 9){\n          reset();\n        }\n      }\n    }\n    else if (newSlope>maxSlope){//if new slope is much larger than max slope\n      maxSlope = newSlope;\n      time = 0;//reset clock\n      noMatch = 0;\n      index = 0;//reset index\n    }\n    else{//slope not steep enough\n      noMatch++;//increment no match counter\n      if (noMatch>9){\n        reset();\n      }\n    }\n  }\n    \n  time++;//increment timer at rate of 38.5kHz\n  \n  ampTimer++;//increment amplitude timer\n  if (abs(127-ADCH)>maxAmp){\n    maxAmp = abs(127-ADCH);\n  }\n  if (ampTimer==1000){\n    ampTimer = 0;\n    checkMaxAmp = maxAmp;\n    maxAmp = 0;\n  }\n}void reset(){//clear out some variables\n  index = 0;//reset index\n  noMatch = 0;//reset match counter\n  maxSlope = 0;//reset slope\n}The second section decides what to do upon receiving the frequency, and was written by the Diracakteers. In this section, the frequency from above was used to determine the note by comparing the frequency to the frequency of the desired note. Once, the frequency is determined, the code then drives the seven segment display and LEDs appropriately.void frequencyCheck(){  \n  if(frequency>70&&frequency<90){ // Displays E on the seven segment display and turns on two LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n  }\n  else if(frequency>100&&frequency<120){ // Displays A on the seven segment display and turns on two LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n  }\n  else if(frequency>135&&frequency<155){ // Displays D on the seven segment display and turns on three LEDs\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>186&&frequency<205){ // Displays G on the seven segment display and turns on three LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>235&&frequency<255){ // Displays B on the seven segment display and turns on three LEDs\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>320&&frequency<340){ // Displays E on the seven segment display and turns on four LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n    digitalWrite(13,HIGH);\n  }\n  else{\n    digitalWrite(8,HIGH);\n  }\n}\n//\nvoid allOff(){ // turn off each segment of the seven segment display and all of the LEDs\n  digitalWrite(2,LOW);\n  digitalWrite(3,LOW);\n  digitalWrite(4,LOW);\n  digitalWrite(5,LOW);\n  digitalWrite(6,LOW);\n  digitalWrite(7,LOW);\n  digitalWrite(8,LOW);\n  digitalWrite(9,LOW);\n  digitalWrite(10,LOW);\n  digitalWrite(11,LOW);\n  digitalWrite(12,LOW);\n  digitalWrite(13,LOW);\n}The code can be viewed in full in the Appendix.", "step_imgs": [], "step_title": "Step 3: Step 3: Programming"}, {"step": 4, "steps_text": "Test your pitch detector in three phases. Complete Test 1 and Test 2 after you have constructed the audio input circuit and uploaded the code to your Arduino. Complete Test 3 after you have constructed the seven segment display and LED circuit.  1. Test that the microphone is reading any sound and that the code is printing the corresponding frequencies to the serial monitor in the Arduino programming environment. Use your voice as a sound source for this phase of testing by speaking into the microphone. In our project, we ran into some trouble when wiring the microphone. Make sure you are using the proper channels on the microphone.2. Test that your device is detecting specific frequencies properly. Hold the microphone 4 - 6 inches from the acoustic guitar strings and check that the displayed frequency in the serial monitor matches the expected frequency by playing each note.Above are sample tests from determining what ampThreshold value to use. If you are running into problems detecting certain frequencies, try changing some of the threshold values. Two tests were recorded with the threshold value of 20 and one test was recorded with the Threshold value of 25. As you can see from the diagrams above, the circuit struggled to detect notes at higher frequencies. To eliminate some of the static, make sure you are testing in a quiet room with little to no surrounding noise.  3. Test that the seven segment display and associated LEDs are displaying the correct note. Repeat Test 2, but this time look at the seven segment display for feedback, as opposed to the serial monitor. The project can be pretty touchy though, as certain notes (especially E4) can be noisy or hard to pick up.", "step_imgs": ["https://cdn.instructables.com/F04/JJWA/J20P9MP2/F04JJWAJ20P9MP2.LARGE.jpg", "https://cdn.instructables.com/FA5/P8UI/J20P9MUF/FA5P8UIJ20P9MUF.LARGE.jpg"], "step_title": "Step 4: Step 4: Testing"}, {"step": 5, "steps_text": "Our group is comprised of five University of Kentucky students studying electrical and computer engineering. We developed this project for a Signals and Systems (EE 421) course. Refer to our WordPress website, Diracakteers' Response to Pitch Detection, which includes a blog of our progress while developing this device and a description of pitch versus frequency.Sources:Arduino Audio Input by Amanda Ghassaei (amandaghassaei)Arduino Frequency Detection by Amanda Ghassaei (amandaghassaei)Arduino Guitar Tuner by nikoala3Appendix: <p>//Modified and used by Dirackteers<br>//\n//generalized wave freq detection with 38.5kHz sampling rate and interrupts\n//by Amanda Ghassaei\n//https://www.instructables.com/id/Arduino-Frequency-Detection/\n//Sept 2012</p><p>/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n*</p><p>/data storage variables\nbyte newData = 0;\nbyte prevData = 0;\nunsigned int time = 0;//keeps time and sends values to store in timer[] occasionally\nint timer[10];//storage for timing of events\nint slope[10];//storage for slope of events\nunsigned int totalTimer;//used to calculate period\nunsigned int period;//storage for period of wave\nbyte index = 0;//current storage index\nfloat frequency;//storage for frequency calculations\nint maxSlope = 0;//used to calculate max slope as trigger point\nint newSlope;//storage for incoming slope data</p><p>//variables for decided whether you have a match\nbyte noMatch = 0;//counts how many non-matches you've received to reset variables if it's been too long\nbyte slopeTol = 3;//slope tolerance- adjust this if you need\nint timerTol = 10;//timer tolerance- adjust this if you need</p><p>//variables for amp detection\nunsigned int ampTimer = 0;\nbyte maxAmp = 0;\nbyte checkMaxAmp;\nbyte ampThreshold = 30;//raise if you have a very noisy signal</p><p>void setup(){\n  \n  Serial.begin(9600);</p><p>  pinMode(2,OUTPUT); // segment a\n  pinMode(3,OUTPUT); // segment b\n  pinMode(4,OUTPUT); // segment c\n  pinMode(5,OUTPUT); // segment d\n  pinMode(6,OUTPUT); // segment e\n  pinMode(7,OUTPUT); // segment f\n  pinMode(8,OUTPUT); // segment g\n  pinMode(9,OUTPUT); // decimal point of the seven segment display\n  pinMode(10,OUTPUT); // common\n  pinMode(11,OUTPUT); // LED 2\n  pinMode(12,OUTPUT); // LED 3\n  pinMode(13,OUTPUT); // LED 4\n  \n  /*                                       BEGIN AMANDA\u2019s CODE \t\t\t*/\n  cli();//disable interrupts\n  \n  //set up continuous sampling of analog pin 0 at 38.5kHz\n \n  //clear ADCSRA and ADCSRB registers\n  ADCSRA = 0;\n  ADCSRB = 0;\n  \n  ADMUX |= (1 << REFS0); //set reference voltage\n  ADMUX |= (1 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only\n  \n  ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //set ADC clock with 32 prescaler- 16mHz/32=500kHz\n  ADCSRA |= (1 << ADATE); //enable auto trigger\n  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete\n  ADCSRA |= (1 << ADEN); //enable ADC\n  ADCSRA |= (1 << ADSC); //start ADC measurements\n  \n  sei();//enable interrupts\n}</p><p>ISR(ADC_vect) {//when new ADC value ready\n  \n  prevData = newData;//store previous value\n  newData = ADCH;//get value from A0\n  if (prevData < 127 && newData >=127){//if increasing and crossing midpoint\n    newSlope = newData - prevData;//calculate slope\n    if (abs(newSlope-maxSlope) 9){\n          reset();\n        }\n      }\n    }\n    else if (newSlope>maxSlope){//if new slope is much larger than max slope\n      maxSlope = newSlope;\n      time = 0;//reset clock\n      noMatch = 0;\n      index = 0;//reset index\n    }\n    else{//slope not steep enough\n      noMatch++;//increment no match counter\n      if (noMatch>9){\n        reset();\n      }\n    }\n  }\n    \n  time++;//increment timer at rate of 38.5kHz\n  \n  ampTimer++;//increment amplitude timer\n  if (abs(127-ADCH)>maxAmp){\n    maxAmp = abs(127-ADCH);\n  }\n  if (ampTimer==1000){\n    ampTimer = 0;\n    checkMaxAmp = maxAmp;\n    maxAmp = 0;\n  }\n}</p><p>void reset(){//clear out some variables\n  index = 0;//reset index\n  noMatch = 0;//reset match counter\n  maxSlope = 0;//reset slope\n}</p><p>/*\t\t\t\tEND AMANDA\u2019s CODE \t\t\t\t\t*/</p><p>void frequencyCheck(){\n  \n  if(frequency>70&&frequency<90){ // Displays E on the seven segment display and turns on two LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n  }\n  else if(frequency>100&&frequency<120){ // Displays A on the seven segment display and turns on two LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n  }\n  else if(frequency>135&&frequency<155){ // Displays D on the seven segment display and turns on three LEDs\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>186&&frequency<205){ // Displays G on the seven segment display and turns on three LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(3,HIGH);\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>235&&frequency<255){ // Displays B on the seven segment display and turns on three LEDs\n    digitalWrite(4,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n  }\n  else if(frequency>320&&frequency<340){ // Displays E on the seven segment display and turns on four LEDs\n    digitalWrite(2,HIGH);\n    digitalWrite(5,HIGH);\n    digitalWrite(6,HIGH);\n    digitalWrite(7,HIGH);\n    digitalWrite(8,HIGH);\n    digitalWrite(10,LOW);\n    digitalWrite(11,HIGH);\n    digitalWrite(12,HIGH);\n    digitalWrite(13,HIGH);\n  }\n  else{\n    digitalWrite(8,HIGH);\n  }\n}\n//\nvoid allOff(){ // turn off each segment of the seven segment display and all of the LEDs\n  digitalWrite(2,LOW);\n  digitalWrite(3,LOW);\n  digitalWrite(4,LOW);\n  digitalWrite(5,LOW);\n  digitalWrite(6,LOW);\n  digitalWrite(7,LOW);\n  digitalWrite(8,LOW);\n  digitalWrite(9,LOW);\n  digitalWrite(10,LOW);\n  digitalWrite(11,LOW);\n  digitalWrite(12,LOW);\n  digitalWrite(13,LOW);\n}\nvoid loop(){</p><p>  allOff();\n  \n  if (checkMaxAmp>ampThreshold){\n    frequency = 38462/float(period); //calculate frequency by using the timer rate over period\n  \n    Serial.print(frequency); //  print results to the serial display\n    Serial.println(\" hz\");\n  }\n  \n  frequencyCheck();\n  \n  delay(1000);// One second delay \n  \n}</p>", "step_imgs": [], "step_title": "Step 5: Conclusion, Sources, and Appendix"}], "channel": "Arduino"}, {"category": "technology", "description": "An electrocardiogram,or ECG, is a very old method of measuring and analyzing heart health. The signal that is read from an ECG can indicate a healthy heart or a range of problems. A reliable and accurate design is important because if the ECG signal shows a deformed waveform or incorrect heartbeat, a person may be misdiagnosed. The goal is to design an ECG circuit that is able to acquire, amplify and filter the ECG signal. Then, convert that signal through an A/D converter into Labview to produce a real-time graph and heartbeat in BPM of the ECG signal. The output waveform should look like this image.\"This is not a medical device. This is for educational purposes only using simulated signals. If using this circuit for real ECG measurements, please ensure the circuit and the circuit-to-instrument connections are utilizing proper isolation techniques.\"", "title": "ECG and Heart Rate Digital Monitor", "url": "https://www.instructables.com/id/ECG-and-Heart-Rate-Digital-Monitor/", "section": "technology", "steps": [{"step": 1, "steps_text": "The circuit needs to be capable of acquiring and amplifying an ECG signal. In order to do that, we will combine three active filters;  an Instrumentation Amplifier, a Second Order Butterworth Low-Pass filter and a Notch Filter. The design of these circuits can be seen in the images. We will go though them one at a time, then put them together to complete the full circuit.", "step_imgs": ["https://cdn.instructables.com/FHY/ULTW/JB2S0ABG/FHYULTWJB2S0ABG.LARGE.jpg", "https://cdn.instructables.com/FJU/6L9T/JB2S0ABI/FJU6L9TJB2S0ABI.LARGE.jpg", "https://cdn.instructables.com/FXX/PPKB/JB2S0ADD/FXXPPKBJB2S0ADD.LARGE.jpg"], "step_title": "Step 1: Designing the Circuit"}, {"step": 2, "steps_text": "The gain of the instrumentation amplifier needs to be 1000 V/V in order to get a good signal. Amplification through the instrumentation amplifier happens in two stages.  The first stage consists of the two op amps on the left and resistor R1 and R2 and the second stage of amplification consists of the op amp on the right and resistors R3 and R4.  The gain (amplification) for stage 1 and stage 2 are given in equation (1) and (2).Stage 1 Gain:  K1 = 1 + (2R2/R1)               (1)Stage 2 Gain: K2 = R4/R3                          (2)An important note about gain in circuits is that is multiplicative; e.g. the gain of the overall circuit in Figure 2 is K1*K2. These equations produce the values shown in the schematic. The materials needed for this filter are three LM741 op amps, three 1k ohm resistors, two 24.7 kohm resistors and two 20 kohm resistors.", "step_imgs": ["https://cdn.instructables.com/FLS/W9LN/JB2S08GQ/FLSW9LNJB2S08GQ.LARGE.jpg"], "step_title": "Step 2: Instrumentation Amplifier"}, {"step": 3, "steps_text": "The next stage is a Notch Filter to cut out noise at 60 Hz. This frequency needs to be cut out because there is lots of extra noise at 60 Hz due to power line interference, but it will not take out anything significant from the ECG signal. The values for the components used in the circuit are based on the frequency you want filtered out, in this case 60 Hz (377 rad/s).  The component equations are as followsR1= 1/ (6032*C)R2= 16 / (377*C)R3 = (R1R2)/ (R1 + R2)The materials required for this were one LM741 op amp, three resistors with values 1658 ohm, 424.4 kohm and 1651 ohms and 3 capacitors, two at 100 nF and one at 200 nF.", "step_imgs": ["https://cdn.instructables.com/FCV/YFEO/JB2S08HD/FCVYFEOJB2S08HD.LARGE.jpg"], "step_title": "Step 3: Notch Filter"}, {"step": 4, "steps_text": "The final stage is a Second Order Butterworth Low-pass filter with a cutoff frequency of 250 Hz. This the the cutoff frequency because a ECG signal only ranges to a max of 250 Hz. The equations for the values of the components in the filter are defined in the following equations:R1 = 2/ (1571(1.4C2 + sort(1.4^2 * C2^2 - 4C1C2)))R2 = 1 / (1571*C1*C2*R1)C1 < (C2 *1.4^2) / 4The materials required for this filter were one LM741 op amp, two resistors of 15.3 kohm and 25.6 kohm, and two capacitors of 47 nF and 22 nF.Once all three stages are designed and built, the final circuit should look like the photo.", "step_imgs": ["https://cdn.instructables.com/FRG/1C9B/JB2S08HY/FRG1C9BJB2S08HY.LARGE.jpg", "https://cdn.instructables.com/FKI/C9L4/JB2S0GLC/FKIC9L4JB2S0GLC.LARGE.jpg"], "step_title": "Step 4: Low Pass Filter"}, {"step": 5, "steps_text": "After the circuit is built, it needs to be tested to ensure it is working properly. An AC sweep needs to be run on each filter using a cardiac input signal at 1 Hz from a voltage generator. The magnitude response in dB should look like the images. If the results from the AC sweep are correct, the circuit is finished and ready to be used. If the responses are not correct, the circuit needs to be debugged. Start by checking all connections and power inputs to ensure everything has a good connection. If this does not solve the problem, use the equations for the components of the filters to adjust the values of resists and capacitors as needed until the output is where it should be. ", "step_imgs": ["https://cdn.instructables.com/FGO/C10T/JB2S0HX6/FGOC10TJB2S0HX6.LARGE.jpg", "https://cdn.instructables.com/FYE/BVI9/JB2S0HX8/FYEBVI9JB2S0HX8.LARGE.jpg", "https://cdn.instructables.com/FOZ/36KY/JB2S0HX9/FOZ36KYJB2S0HX9.LARGE.jpg"], "step_title": "Step 5: Testing the Circuit"}, {"step": 6, "steps_text": "Labview is a digital data acquisition software that lets a user design a VUI, or virtual user interface. A DAQ board is an A/D converter that can convert and transmit the ECG signal into Labview. Using this software, the ECG signal can be plotted on an amplitude vs. time graph to clearly read the signal and then convert the signal into a heartbeat in BPM. The first thing required for this is a DAQ board which acquires data and converts it to a digital signal to send to Labview on the computer. The first thing that needed to be added to the Labview design was DAQ Assistant, which acquires the signal from the DAQ board and defines the sampling parameters. The next step is connecting a waveform graph to the output of the DAQ assistant on the VUI design which plots the ECG signal showing the ECG waveform. Now that the waveform graph is complete, the data also needs to be converted to produce a numerical output of the heart rate. The first step in this calculation was finding the maximum of the ECG data by connecting the max/min element to the output of the DAQ data in the VUI, and then outputting this to another element called peak detection and to an element which would find the change in time called dt. The peak detection element also needed a threshold from the max/min which was calculated by taking the maximum from the max min element and multiplying it by .8, to find 80% of the maximum value, then inputted into the peak detect element. This threshold allowed the peak detect element to find the maximum of the R wave and the location the max occurred at while ignoring the other peaks of the signal. The locations of the peaks were then sent to an index array element added next on the VUI. The index array element was set to store on array with and index starting at 0, and then another starting with an index of 1. Then, these were subtracted from each other to find the difference of the two peak locations, which corresponds to the number of points between each peak. The number of points multiplied by the time difference between each point provides the time it takes for each beat to occur. This was accomplished by multiplied the output from the dt element and the output from the subtraction of the two arrays. This number was then divided by 60, to find the beats per minute, and then outputted using a numerical indicator element on the VUI. The setup of the VUI design in Labview is shown in in the Figure. ", "step_imgs": ["https://cdn.instructables.com/F0T/IL7M/JB2S08GT/F0TIL7MJB2S08GT.LARGE.jpg"], "step_title": "Step 6: Building a VUI in Labview"}, {"step": 7, "steps_text": "Once the VUI is finished on Labview, the final step is to connect the circuit to the DAQ board, so the signal runs through the circuit, into the board, then to Labview. If everything works properly, a 1 Hz signal should produce the waveform shown in the figure and a heartbeat of 60 beats per minute. Now you have a functioning ECG and Heart Rate Digital Monitor. ", "step_imgs": ["https://cdn.instructables.com/FOP/IF9Y/JB2S0NCV/FOPIF9YJB2S0NCV.LARGE.jpg"], "step_title": "Step 7: Put It All Together"}], "channel": "Electronics"}, {"category": "technology", "description": "Nowadays water tank has been widely used to store water for department. But there is one problem, how can we know there is no water or the bumping water overflows in time? It\u2019s real inconvenient to check the state again and again. With some programming knowledge, I decide make this alarm to inform with beeping and light indicator. This can be applied to some water level invisible tank or tower.Have a try!", "title": "How to Make a Water Level Alarm With Nano Board", "url": "https://www.instructables.com/id/How-to-Make-a-Water-Level-Alarm-With-Nano-Board/", "section": "technology", "steps": [{"step": 1, "steps_text": "SunFounder Nano board - http://bit.ly/2fwJNnjUSB cableSome jumper wires - http://bit.ly/2tXqPZN4 LEDs (white, green, yellow, red)Passive buzzerPlastic bottleFoam boardDrinking strawDielectric stickScissorsElectrical TapeColor Pen", "step_imgs": ["https://cdn.instructables.com/FIQ/BURZ/J6MGEOF3/FIQBURZJ6MGEOF3.LARGE.jpg"], "step_title": "Step 1: Prepare Materials"}, {"step": 2, "steps_text": "Stab at the bottom of the bottle to get a hole, then thread the drinking stick across the hole, and seal with glue.", "step_imgs": ["https://cdn.instructables.com/F7F/VURB/J6MGEOFT/F7FVURBJ6MGEOFT.LARGE.jpg"], "step_title": "Step 2: Make a Water Tank"}, {"step": 3, "steps_text": "Fasten a jumper wire\u2019s one end to the bottom of the stick and the other end to +5V power. Fasten the four other wires evenly on the stick in the same way. (Adjust the interval distance according to your actual needs)", "step_imgs": ["https://cdn.instructables.com/F4X/DM4S/J6MGEOP2/F4XDM4SJ6MGEOP2.LARGE.jpg"], "step_title": "Step 3: Make Water Level Probe"}, {"step": 4, "steps_text": "Draw a whale (whatever other image you like) on a paper and paint with color, then paste this paper on the foam board. Insert the buzzer to the whale\u2019s eye position, and four LED to the spout position in order. (Insert those components\u2019 pins across the foam board, thus the wiring in later part will be easier.)", "step_imgs": ["https://cdn.instructables.com/F3M/34Z8/J6MGEOUT/F3M34Z8J6MGEOUT.LARGE.jpg"], "step_title": "Step 4: Insert the LEDs and Buzzer"}, {"step": 5, "steps_text": "Complete the wiring as shown:", "step_imgs": ["https://cdn.instructables.com/FOV/WMGL/J6MGEOZL/FOVWMGLJ6MGEOZL.LARGE.jpg"], "step_title": "Step 5: Wiring"}, {"step": 6, "steps_text": "#define uchar unsigned char\nuchar flag = 4;\nvoid setup()\n{\n  Serial.begin(9600);  // start serial port at 9600 bps:\n  pinMode(2, OUTPUT);\n  pinMode(3, OUTPUT);\n  pinMode(4, OUTPUT);\n  pinMode(5, OUTPUT);\n}\nvoid loop()\n{\n  int w = analogRead(A0); //read the value from analog pin AO\n  int g = analogRead(A1);\n  int y = analogRead(A2); \n  int r = analogRead(A3);\n  Serial.println(\"w:\");\n  Serial.println(w);\n  Serial.println(\"g:\");\n  Serial.println(g);\n  Serial.println(\"y:\");\n  Serial.println(y);\n  Serial.println(\"r:\");\n  Serial.println(r);\n  if((w< 1000) && (g > 1000) && (y > 1000) && (r > 1000))                      //Stop when the car is picked up\n   flag = 0; \n    else if ((w< 1000) && (g < 1000) && (y > 1000) && (r > 1000))                            //if read the value of the Tracking module data[0] is more than 100\n    flag = 1;        \n      else if((w< 1000) && (g < 1000) && (y < 1000) && (r > 1000))                              //if read the value of the Tracking module data[2] is more than 100\n      flag = 2; \n        else if((w< 1000) && (g < 1000) && (y > 1000) && r< 1000)                           //if read the value of the Tracking module data[4] is more than 100\n        flag = 3; \n        else \n        flag = 4;\n  switch(flag)   //According to the relative position of the line and the car, adjust the front wheel steering angle to change the direction of the car to achieve inspection line.\n  {\n    case 0:\n    digitalWrite(2,HIGH);\n    digitalWrite(3, LOW);\n    digitalWrite(4, LOW);\n    digitalWrite(5, LOW);\n    break;\n    case 1: \n    digitalWrite(3,HIGH);\n    digitalWrite(2, LOW);\n    digitalWrite(4, LOW);\n    digitalWrite(5, LOW);\n    break;\n    case 2: \n    digitalWrite(4,HIGH);//turn the LED on\n    digitalWrite(2, LOW);\n    digitalWrite(3, LOW);\n    digitalWrite(5, LOW);\n    pinMode(9, OUTPUT); //set the pin 9 as an output\n    tone(9, 3000, 100);\n    delay(400);\n    tone(9, 0, 10);\n    delay(400);\n    pinMode(9, INPUT); //set the pin 9 as an input\n    break;\n    case 3: \n      digitalWrite(5,HIGH);\n      digitalWrite(2, LOW);\n      digitalWrite(4, LOW);\n      digitalWrite(3, LOW);\n      pinMode(9, OUTPUT);\n    tone(9, 3000, 100);\n    delay(80);\n    tone(9, 0, 10);\n    delay(80);\n    pinMode(9, INPUT); \n    break;\n    case 4: \n    digitalWrite(3, LOW);\n    digitalWrite(2, LOW);\n    digitalWrite(4, LOW);\n    digitalWrite(5, LOW); \n    break;\n  }\n}\n", "step_imgs": [], "step_title": "Step 6: Upload the Code"}, {"step": 7, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FHT/WV3M/J6MGEPQO/FHTWV3MJ6MGEPQO.LARGE.jpg"], "step_title": "Step 7: Put the Stick in Water Tank"}, {"step": 8, "steps_text": "Clog the drinking straw on the tank, and add water to the tank until the water reaches the topmost probe.Release the clogging, then observe the water level and the LED.", "step_imgs": ["https://cdn.instructables.com/FQH/JT57/J6MGEQ85/FQHJT57J6MGEQ85.LARGE.jpg"], "step_title": "Step 8: Water Level Indicator Done!"}], "channel": "Arduino"}, {"category": "technology", "description": "a.articles {\n\tcolor: white;\n\tbackground: red;\n\tfont-weight: bold;\n\tfont-style: italic;\n\ttext-decoration: none;\n}\na.articles:hover {\n\tcolor: white;\n\tbackground: black;\n}\np strong {\n\tfont-weight: bold;\n}\nThis instructable explains how photos may be printed on a CNC plotter with the help of \"Processing 3\" freeware available from https://processing.org/download/The finished plots make unique gifts ... especially when framed.", "title": "Make Your Own CNC Plotter Image", "url": "https://www.instructables.com/id/Make-Your-Own-CNC-Plotter-Image/", "section": "technology", "steps": [{"step": 1, "steps_text": " The monochrome image, shown in photo 1,  comprises rows and rows of tiny \"pixels\" (picture elements). Each \"pixel\" has a value between 0 (black) and 255 (white) ... a total of 256 shades.It is not possible to plot a monochrome image directly as  a plotter can only create two colors ... black (ink) and white (no ink).Theshold imagesPlotting each pixel with a value greater than 128 results in an image similar to that in the second photo.Much of the detail has been lost and the face is barely recognizable.The Processing 3 code used to create this image is shown below:// ----- simple threshold      int threshold = 128;         for (int y = 0; y < height; y++){           for (int x = 0; x < width; x++){             int location = x + y*width;             float value = brightness(pixels[location]);            if (value > threshold){               stroke(255);                  //draw white pixel               point(x, y);             } else {               stroke(0);                      //draw black pixel              point(x, y);            }          }           }DitheringAnother approach is to use dithering where each pixel is compared with 128 and the error term added to the next pixel before it in turn is compared with 128.The resulting image is shown in photo 3 and at first glance looks identical to photo 1. The difference between these two photos, however, is that each pixel in photo 1 contains one of 256 shades of gray whereas photo 3 only contains pure black and white pixels. If you examine this image closely you will see that the average number of \"black\" pixels, per unit area, is zero for white and 256 for solid black. Our eyes are averaging the number of \"black\" pixels across the image ....The code for this dithered image is similar to that for the threshold image and is shown below:// ----- one-dimensional dither       int threshold = 128;         for (int y = 0; y < height; y++) {           float error = 0;           for (int x = 0; x < width; x++) {            int location = x + y*width;             float value = brightness(pixels[location])+error;             if (value > threshold) {                      stroke(255);     //draw white pixel               point(x, y);              error = value - 255;             } else {               stroke(0);      //draw black pixel               point(x, y);               error = value;             }          }         }The following step describes the averaging method used to create the images in this instructable.", "step_imgs": ["https://cdn.instructables.com/FX4/124P/J6WGOCDD/FX4124PJ6WGOCDD.LARGE.jpg", "https://cdn.instructables.com/FHY/ZGZA/J6WGOCET/FHYZGZAJ6WGOCET.LARGE.jpg", "https://cdn.instructables.com/FUP/TM3B/J6WGOCDY/FUPTM3BJ6WGOCDY.LARGE.jpg"], "step_title": "Step 1: Theory"}, {"step": 2, "steps_text": "A problem with dithered images is that there can be upwards of a 100,000 black pixels each of which will wear the pen-lift mechanism and damage the pen.The number of pen-lift operations can be significantly reduced if we turn the image into an electronic \"jigsaw\" with different shades of gray associated with each block.  The resulting image, for a 5x5 pixel sample size, is shown in photo 1 above. Each of the electronic \"jigsaw\" pieces has been shaded using \"sinewaves\" of different amplitudes and frequencies as shown in the second photo. The beauty of this method is that the \"entry\" and \"exit\" points for each of the electronic \"jigsaw\" pieces lie on the same horizontal line which means that a pen-lift is not required until the end-of-line. The plotter is continuously laying ink ...  Bi-directional plotting, with no pen-lift, was considered but rejected as any mechanical play in the plotter would be noticeable.Generating the grayscaleThe required grayscale is generated by a drawSinewave (x, y, cycles, amplitude) function. Where:x=horizontal screen location in pixels y=vertical screen location in pixels cycles=number of complete cycles amplitude= the sinewave amplitudeTo see how this works, compare the sinewaves in photo2 with each of the step numbers shown in the following code.// ------------------------------------ // drawPattern // ------------------------------------ void drawPattern(int column, int row, int value) { /*     A grayscale is a bit like a staircase ... 16 steps requires 17 risers     */ // ----- locals int x=column*cellWidth;       //horizontal pixel co-ordinate int y=row*cellHeight;    //vertical pixel co-ordinate switch (value) { case 0:     drawSinewave(x, y, 1, 0.0); break;  //step0 (white) case 1:     drawSinewave(x, y, 1, 0.0); break; //step1 case 2:         drawSinewave(x, y, 1, 0.05); break; //step2 case 3:     drawSinewave(x, y, 1, 0.2); break;   //step3 case 4:     drawSinewave(x, y, 1, 0.3);  break; //step4 case 5:     drawSinewave(x, y, 1, 0.4); break; //step5 case 6:     drawSinewave(x, y, 1, 0.6); break; //step6 case 7:     drawSinewave(x, y, 1, 0.8); break; //step7 case 8:     drawSinewave(x, y, 1, 1.0); break; //step8 (mid-gray) case 9:     drawSinewave(x, y, 2, 1.0; break; //step9 case 10:         drawSinewave(x, y, 3, 1.0); break; //step10 case 11:     drawSinewave(x, y, 4, 1.0); break; //step11 case 12:     drawSinewave(x, y, 5, 1.0); break; //step12 case 13:     drawSinewave(x, y, 6, 1.0); break; //step13 case 14:     drawSinewave(x, y, 7, 1.0); break; //step14 case 15:     drawSinewave(x, y, 8, 1.0); break; //step15 (black) case 16:                         drawSinewave(x, y, 8, 1.0); break; } }I chose to use sinewaves of differing amplitudes and frequencies for my grayscale but there is no reason why other patterns can't be used. All we are trying to do is fool the eye ...A minor downsideAn A4 drawing can take up to 10 hours (overnight) to print.The reason for this is that each sinewave comprises  a series of straight lines at 30 degree intervals, or 12 co-ordinates per cycle. Dark screen \"cells\" tend to have more cycles than light colored screen \"cells\".For example black, with 8 cycles, generates 96 co-ordinates per screen \"cell\" ... hence the slow plot speed.", "step_imgs": ["https://cdn.instructables.com/FV8/PUKX/J6WGPIG5/FV8PUKXJ6WGPIG5.LARGE.jpg", "https://cdn.instructables.com/FVU/EV7J/J6WGOM2N/FVUEV7JJ6WGOM2N.LARGE.jpg"], "step_title": "Step 2: Grayscale Images"}, {"step": 3, "steps_text": "The following software must be installed in this sequence before you can plot an image:Processing 3Download and install a copy of \"Processing 3\" from https://processing.org/download/. This software allows us to create the image g-code.\"Processing 3\" is almost identical to the arduino IDE (integrated development environment) except that the function \"loop()\" has been replaced by \"draw()\". A few drawing \"primitives\" have also been thrown in for good measure, two of which are:point() ... for plotting specific screen pointsline() ... for drawing lines between two sets of screen co-ordinates.These drawing primitives allow us to preview our g-code image prior to plotting.processing3_terminal.pdeDownload a copy of \"processing3_terminal.pde\" from Step 2 of instructable  https://www.instructables.com/id/CNC-Gcode-SenderCopy the contents of this file into a new \"processing3.exe\" sketch and save the sketch as \"processing3_terminal\". The action of saving the sketch creates a \"../Documents/Processing/processing3_terminal/\" folder that contains the file \"processing3_terminal.pde\".draw_image_gcode.pdeDownload the attached file \"draw_image_gcode.pde\".Copy the contents of \"draw_image_gcode.pde\" into a new \"processing3.exe\" sketch and save it as \"draw_image_gcode\" without the quotes.The action of saving the sketch creates a \"../Documents/Processing/draw_image_gcode/\" folder that contains the file \"draw_image_gcode.pde\".images.zipDownload, and unpack, the attached \"images.zip\" file.  This zip file contains two essential  test images.Copy the two image files, \"image.jpg\" and \"grayscale.jpg\" into the \"../documents/Processing/draw_image_gcode\" folder that was created in the above step.Creating the image g-codeOpen, and run, the \"draw_image_gcode\" sketch using \"processing3..exe\".To run a sketch using \"processing3.exe\" you simply left-click the top-left on-screen button.All going well a grayscale image should appear on your screen and an \"image.ngc\" g-code file will appear in your \"../documents/Processing/draw_image_gcode\" folder.We now have everything we need to plot our first image ...", "step_imgs": ["https://cdn.instructables.com/F4N/YCBI/J6WGT2A2/F4NYCBIJ6WGT2A2.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Software"}, {"step": 4, "steps_text": "The following instructions assume that you have an Inkscape compatible plotter attached to your PC. Inkscape compatible plotters assume that the (0,0) co-ordinate is at the bottom-left corner. If your image comes out upside down and reversed then search \"draw_image_gcode.pde\" code for any lines that contain \"output.print()\" and delete any reference to \"height\".Suitable Inkscape plotters include:https://www.instructables.com/id/CNC-Drawing-Arm/https://www.instructables.com/id/CNC-Dual-Arm-Plot...https://www.instructables.com/id/CNC-Drum-Plotter/https://www.instructables.com/id/CNC-HANGING-PLOTT...Step 1Copy the file \"image.ngc\" from your \",,/Documents/Processing/draw_image_gcode/\" folder to your \"../Documents/Processing/processing3_terminal/\" folder.Step 2Open \"processing3.exe\" and run the sketch \"processing3_terminal.pde\" that is in a folder of the same name. The menu shown in photo 1 should appear on your screen. If not left-click the gray instruction box. Instructions for fixing communication port errors are detailed in https://www.instructables.com/id/CNC-Gcode-Sender/Step 3Follow EXACTLY the instructions shown in the screenshot shown in photo 1.T1 allows you to position the pen over the (0,0) co-ordinate using the 'A', 'S', 'K', and 'L'  keys. Press the 'E' key once the pen is correctly positioned.T2 S0.4 scales your image such that it fits on a sheet of A4 paper. The original \"image,jpg\" file dimensions were 467 pixels x 620 pixels. Scaling these dimensions by 40% produces a finished image that is  186 mm x 248 mm which will fit on a sheet of 290 mm x 210 mm A4 paper. Step 4Right-click the gray instruction box [1] then type \"image.ngc\" without the quotation marks. Press the enter key and your plotter should start working. As mentioned large images take a long time to plot ... I do mine overnight.[1]  there is no cursor", "step_imgs": ["https://cdn.instructables.com/FIM/MP5Z/J6WGUGB9/FIMMP5ZJ6WGUGB9.LARGE.jpg"], "step_title": "Step 4: Plotting Your Image"}, {"step": 5, "steps_text": "To plot another image, say  \"grayscale.jpg\", we need to change a few lines of code.  These code changes are shown below in bold highlight.It is essential that the dimensions within \"size\" match your image dimensions.The \"cellWidth\",  and \"output\" filename, are not critical.// -------------------------------------     // declarations     // -------------------------------------     PImage src;                                               //declare variables of type PImage     PrintWriter output;                                     //instantiate \"output\" for printing files     int   cellWidth = 64,                                 //cell width in pixels ... determines the detail     //int cellWidth = 5, //cell width in pixels ... determines the detail     cellHeight = cellWidth,                              //make cell square     columns,     rows;     boolean   penUp=true;                              //flag     // -------------------------------------     // setup     // -------------------------------------     void setup() {     size(1024, 512);                                        //grayscale.jpg dimensions (cellWidth=64)     //size(467, 620);                                        //image.jpg dimensions (cellWidth=5)     background(255);                                      //screen image background white     rows=height/cellHeight;                             //number of cell rows     columns=width/cellWidth;                          //number of cell columns     src = loadImage(\"grayscale.jpg\");           //get grayscale.jpg     //src = loadImage(\"image.jpg\");                   //get image.jpg     src.filter(GRAY);                                        //convert image to monochrome     output = createWriter(\"grayscale.ngc\");   //open a file for storing the g-code     //output = createWriter(\"image.ngc\"); //open a file for storing the g-code     noLoop();                                                   //main loop only runs once     }\u00a0\u00a0Click here\u00a0\u00a0 to view my other instructables.", "step_imgs": [], "step_title": "Step 5: Plotting Your Second Image"}], "channel": "CNC"}, {"category": "technology", "description": "CodeEN :As part of an Embedded System project at Polytech Paris-UPMC, we are in charge of creating an instrument.This  instrument must be autonomous, powered by a battery, and  must be able to determine the frequency of a signal and convert it autonomusly. We decided that our input signal will be a vibration. In order to generate this vibration we opted for a  string instrument. To summarize, our project breaks down as  follows: By plucking a string, a vibration is generated and sensed by an accelerometer. This  vibration is digitized with an analog-to-digital converter and then  analyzed with a Fourier transform to determine the frequency.From this  frequency we generate a sound that will be sent to the audio card of the  Raspberry Pi. Our application is coded in C language.FR :Dans le cadre d'un projet  \u00e0 Polytech Paris-UPMC, nous sommes charg\u00e9s de r\u00e9aliser un instrument. Cet instrument devra \u00eatre autonome, aliment\u00e9 par des piles ou une  batterie, et devra \u00eatre capable d'analyser un signal en fr\u00e9quence et la  convertir en totale autonomie. Nous avons choisi de r\u00e9aliser un  instrument qui produit diff\u00e9rent son en fonction d'une vibration. Afin  de g\u00e9n\u00e9rer cette vibration nous avons opt\u00e9 pour le choix d'un instrument  \u00e0 cordes. Pour r\u00e9sumer de fa\u00e7on concise, notre projet se d\u00e9compose de  la mani\u00e8re suivante : En excitant une corde, une vibration est g\u00e9n\u00e9r\u00e9e et capt\u00e9e par un  acc\u00e9l\u00e9rom\u00e8tre. Cette vibration est num\u00e9ris\u00e9e avec un convertisseur  analogique-num\u00e9rique, puis analys\u00e9e avec une transformer de Fourrier  pour en d\u00e9terminer la fr\u00e9quence. A partir de cette fr\u00e9quence nous  g\u00e9n\u00e9rons un son qui sera envoy\u00e9 \u00e0 la carte audio de la Raspberry Pi. Afin de cr\u00e9er diff\u00e9rentes fr\u00e9quences de vibration nous avons opt\u00e9 de  placer plusieurs cordes de tension et de longueurs diff\u00e9rentes afin de  cr\u00e9er plusieurs fr\u00e9quences et donc g\u00e9n\u00e9rer plusieurs sons. Notre  application est cod\u00e9e en langage C.", "title": "Raspberry Pi Thumb Harp (EN/FR)", "url": "https://www.instructables.com/id/Raspberry-Pi-Thumb-Harp-ENFR/", "section": "technology", "steps": [{"step": 1, "steps_text": "EN :- Raspberry Pi 2  - MCP 3008 Analog-to-digital converter- Polulu 5V Voltage regulator- OP Amp TL082 - 5V & 2,5V Voltage references- ICL7660 Voltage converter ( converts  5V to -5V for the op amp )-  ADXL335 Accelerometer - R\u00e9gulateur 5V S7V7F5  - 6 AA batteries 1,2V 2000mAh - Resistors ,capacitors & cables (see the analog portion for more details )- Rubber bands- Soft plastic(not the stuff from the picture)FR :- Raspberry Pi 2  - Convertisseur analogique num\u00e9rique MCP 3008- R\u00e9gulateur de tension 5V Polulu- Amplificateur TL082- R\u00e9f\u00e9rence de tension 5V et 2,5V- Convertisseur de tension ICL7660 qui transforme 5V en -5V (Pour le TL082)- Acc\u00e9l\u00e9rom\u00e8tre  ADXL335- R\u00e9gulateur 5V S7V7F5 - 6 piles AA de 1,2V 2000mAh - R\u00e9sistances & capacit\u00e9s- Connecteurs, nappe, etc..- \u00c9lastiques (ou cordes)- Plastique souple", "step_imgs": ["https://cdn.instructables.com/FP3/HM59/IXUSC1CH/FP3HM59IXUSC1CH.LARGE.jpg"], "step_title": "Step 1: What You'll Need / Mat\u00e9riel "}, {"step": 2, "steps_text": "EN:      Our strings are simple rubber bands. For them to vibrate at different frequencies, we play on the size of the strings as well as on their tension. To simplify, the longer a string is, the lower its frequency, and the more tense a string is, the higher its frequency is. In reality it  is more complex than that, because the material of the  string has an impact on its vibration, and the strings can vibrate in  several modes. To tune the instrument, we use a printf () in C code to display the frequency on the terminal. We then change the tension of the strings until the frequency gap between each string is sufficient to avoid confusion.We use a piece of flexible plastic on which is attached the sensor and the strings. Because we wanted to use only one sensor, that was the solution we developed. Between each string there is a binding. These  allow us to isolate the strings between them and prevent the vibration  of one string from vibrating another and gives us a false result. The whole is suspended on a plate of wood with hinges.FR:Nos cordes sont de simples \u00e9lastiques. Pour qu'elles vibrent \u00e0 des fr\u00e9quences diff\u00e9rentes, nous jouons sur la taille des  cordes ainsi que sur leur tension. Pour simplifier, plus une corde est  grande, plus sa fr\u00e9quence de vibration sera basse, et plus une corde est  tendu, plus sa fr\u00e9quence est haute. C'est en r\u00e9alit\u00e9 plus compliqu\u00e9 que  sa, car la mati\u00e8re de la corde \u00e0 un impact sur sa vibration, et les  cordes peuvent vibrer selon plusieurs modes. Pour accorder l'instrument,  nous utilisons un printf() dans le code C pour afficher la fr\u00e9quence  sur le terminal. Nous changeons ensuite la tension des cordes jusqu\u2019\u00e0 ce  que l'\u00e9cart entre chaque corde soit suffisant afin d\u2019\u00e9viter toute  confusion. Nous utilisons un support plastique souple sur lequel sont fix\u00e9s le  capteur et les cordes. \u00c9tant donn\u00e9 que nous ne voulions utiliser qu'un  seul capteur, c'est la solution que nous avons \u00e9labor\u00e9e. Entre chaque  fixation de corde sur notre support plastique, il y a une isolation  m\u00e9tallique verticale. Celle-ci nous permet d'isoler les cordes entre  elles et \u00e9viter que la vibration d'une corde en fasse vibrer une autre  et nous donne de faux r\u00e9sultat \u00e0 l\u2019acquisition. Le tout est suspendu sur  un support en bois avec des charni\u00e8res.", "step_imgs": ["https://cdn.instructables.com/FHU/8JA8/IXUSC0X2/FHU8JA8IXUSC0X2.LARGE.jpg"], "step_title": "Step 2: Mecanical Part / Partie M\u00e9canique"}, {"step": 3, "steps_text": "EN:The ADXL335 accelerometer allows us to capture the dynamic acceleration produced by the vibration  of the strings on its support, represented by the voltage at its  terminals, or rather by the voltage difference with its rest value.The sensor's output has a continuous voltage component and we don't want to amplify it. A high-pass filter (which may be a simple capacitance) is then used, and then the sinusoidal component is amplified.In addition, the MCP3008 can digitalize an analog input between 0 and 5V. We therefore use an adder circuit with our voltage reference 2.5V so that it is centered before sending it to the converter. A  5V voltage reference is used for the Vref input of the MCP3008 as it  must be as stable as possible to ensure proper conversion. We use batteries and the voltage regulator to supply power to our circuit. The 2,5V voltage reference can be used to supply the power needed by the sensor since it does not uses much. We also use a negative voltage converter circuit around the ICL7660 because our op amps need a -5V input. There is also an anti-aliasing filter at 1KHz upstream of the converter.FR :L'acc\u00e9l\u00e9rom\u00e8tre ADXL335 nous permet de capter l'acc\u00e9l\u00e9ration dynamique que produit la vibration des cordes sur son  support. Cette vibration est repr\u00e9sent\u00e9e par la tension aux bornes de  l\u2019acc\u00e9l\u00e9rom\u00e8tre, ou plut\u00f4t par la diff\u00e9rence de tension par rapport \u00e0 sa  tension de repos. La sortie du capteur a donc une composante continue (offset de repos)  qu'on ne souhaite pas amplifier.On utilise donc un filtre passe-haut  (qui peut \u00eatre une simple capacit\u00e9), puis on amplifie la composante  sinuso\u00efdale. De plus, le MCP3008 peut num\u00e9riser une entr\u00e9e analogique comprise entre 0  et 5V. On utilise alors un montage additionneur avec notre r\u00e9f\u00e9rence de  tension 2,5V pour rehausser le signal avant de le transmettre au  convertisseur. On utilise une r\u00e9f\u00e9rence de tension 5V pour l'entr\u00e9e Vref  du MCP3008 car elle doit \u00eatre la plus stable possible pour assurer une  conversion correcte. Nous utilisons des piles suivis d\u2019un r\u00e9gulateur de  tension pour alimenter notre circuit. La r\u00e9f\u00e9rence de tension 2,5V peut  servir \u00e0 alimenter notre capteur car celui-ci consomme tr\u00e8s peu de  courant. Nous utilisons aussi un montage de conversion de tension autour  du ICL7660. Il y a aussi un filtre anti-repliement \u00e0 1KHz en amont du convertisseur.", "step_imgs": ["https://cdn.instructables.com/FWE/0BV7/IXUSCWCG/FWE0BV7IXUSCWCG.LARGE.jpg"], "step_title": "Step 3: Electronic Circuit / Partie \u00c9lectronique Analogique "}, {"step": 4, "steps_text": "MCP3008 Datasheet EN:We use the analog-to-digital converter MCP3008 to digitize the signal received by the sensor.Port correspondence : MOSI (19) -> DIN ; MISO(21) -> DOUT SCLK(23) -> CLK ; CEO(24) -> CS-SHDN The ADC and the RPi communicate via the SPI bus (Serial Peripheral Interface). We use the WiringPi library, a GPIO interface library for Raspberry PI. For more details on how to use this library, click on this link. SPI  Transmission: The master generates the clock. At each clockstroke the  master and the slave exchange one bit. For more information, see the  MCP3008 datasheet (page 21). To enable the SPI bus on the Raspberry, use the raspi-config command.FR :Nous utilisons le convertisseur analogique-num\u00e9rique MCP3008 pour num\u00e9riser le signal re\u00e7u par le capteur. Correspondance des ports :  MOSI (19) -> DIN ; MISO(21) -> DOUT SCLK(23) -> CLK ; CEO(24) -> CS-SHDNLa communication entre le CAN et la RPi ce fait gr\u00e2ce au bus SPI (Serial Peripheral Interface).Pour la communication SPI, nous utilisons la biblioth\u00e8que WiringPi, une biblioth\u00e8que d'interface GPIO pour la Raspberry PI. Pour plus de d\u00e9tails  sur l'utilisation de cette biblioth\u00e8que, voir ce lien (en anglais).Transmission SPI : Le ma\u00eetre g\u00e9n\u00e8re l'horloge. A chaque coup d'horloge le ma\u00eetre et l'esclave s'\u00e9changent un bit. Pour plus d'informations, voir la datasheet du MCP3008 (page 21).Pour activer le bus SPI sur la Raspberry, utilisez la commande raspi-config.", "step_imgs": ["https://cdn.instructables.com/F87/DKOR/IWH3HRY9/F87DKORIWH3HRY9.LARGE.jpg"], "step_title": "Step 4: Signal Acquisition / Acquisition Du Signal"}, {"step": 5, "steps_text": "EN:To determine which string has been pinched, we use a discrete Fourier transform on the digitized signal. We thus obtain the spectral representation (the unit is no longer the time  but the frequency) of the signal, and as the strings vibrate  differently, they will have different spectrum. We use the GNU scientific library for the FFT (Fast Fourier Transform) algorithm. However, the function gsl_fft which performs the transformation on an  array has no information on the time interval between two values and  by extension on the frequency interval between two output values.To  ensure the coherence of this transform, we must absolutely control the  time interval between two acquisition (which corresponds to the inverse  of the sampling frequency Fe), and for this we use a posix timer. Moreover, only half of the result table is of interest to us, and the index of the medium corresponds to the frequency Fe / 2. To find the frequency corresponding to the amplitude of result [i], result [i] x (Fe / 2)) / result_size []. Finally,  we look for the index of the maximum value of the result table, to  which we apply the above formula to determine the dominant frequency of  the signal.FR:Pour d\u00e9terminer quelle corde \u00e0 \u00e9t\u00e9 pinc\u00e9e, nous utilisons une transform\u00e9e de Fourier discr\u00e8te sur le signal num\u00e9ris\u00e9. On obtient ainsi la repr\u00e9sentation spectrale (l'unit\u00e9 n'est plus le temps mais la fr\u00e9quence) du signal, et comme les cordes vibrent diff\u00e9remment, elles auront des spectres diff\u00e9rents. Nous utilisons la biblioth\u00e8que scientifique GNU(en anglais) pour l'algorithme de FFT (Fast Fourier Transform). Cependant, la fonction gsl_fft qui r\u00e9alise la transformation sur un tableau, n'a pas d'information sur l'intervalle de temps entre deux valeurs, et par extension sur l'intervalle de fr\u00e9quence entre deux valeurs en sortie.Pour assurer la coh\u00e9rence de cette transform\u00e9e, il faut donc absolument maitriser l'intervalle de temps entre deux acquisition (qui correspond \u00e0 l'inverse de la fr\u00e9quence d\u2019\u00e9chantillonnage Fe), et pour cela  nous utilisons un posix timer. De plus, seulement la moiti\u00e9 du tableau r\u00e9sultat nous int\u00e9resse, et l'indice du milieu correspond \u00e0 la fr\u00e9quence Fe/2. Pour retrouver la fr\u00e9quence correspondant \u00e0 l'amplitude de r\u00e9sultat[i], il faut faire (r\u00e9sultat[i] x (Fe/2)) / taille_resultat[]. Finalement, nous recherchons l'indice de la valeur maximale du tableau r\u00e9sultat, auquel nous appliquons la formule si dessus pour d\u00e9terminer la fr\u00e9quence dominante du signal.", "step_imgs": ["https://cdn.instructables.com/FO0/754O/IXUSC1T0/FO0754OIXUSC1T0.LARGE.jpg"], "step_title": "Step 5: FFT "}, {"step": 6, "steps_text": "EN :At the C code level, we use pthreads and a posix timer to parallelize our application. The pthreads are execution threads which are processed in \"pseudo-parallel\". We control the time interval between acquisitions with the posix timer, and the Fast Fourier Transform is made in a different thread. For the fourier transform, we use a big array, that we constantly filled by the posix timer function, and when it is at least half full, the function calls the FFT threads on this half of the array.FR :Au niveau du code C, nous utilisons des pthreads et un posix timer pour parall\u00e9liser notre application. Les pthreads sont des fils d\u2019ex\u00e9cutions qui sont trait\u00e9s en  \"parall\u00e8le\". Nous contr\u00f4lons l'intervalle de temps entre chaque acquisition du signal avec un posix timer, et la transform\u00e9e de Fourier se fait dans un fil d'ex\u00e9cution diff\u00e9rent.", "step_imgs": ["https://cdn.instructables.com/F0Y/JNDA/IXUSCG0M/F0YJNDAIXUSCG0M.LARGE.jpg"], "step_title": "Step 6: Pthreads & Timers"}, {"step": 7, "steps_text": "EN:To generate a sound, we use ALSA (Advanced Linux Sound Architecture). This architecture provides audio and MIDI functionality for Linux. After initializing the sound card, we fill a buffer with sinusoids of  different frequencies according to the string that was plucked, then we  send this buffer to the sound card, with the snd_pcm_writei () function. You can also use ALSA to play pre-recorded sound; We  chose to generate sound from sinus because we wanted to study later the  mathematical part of sound design (sum of cos, harmonics of  different amplitudes etc ...).FR:Pour g\u00e9n\u00e9rer un son, nous utilisons ALSA (Advanced Linux Sound Architecture). Cette architecture procure des fonctionnalit\u00e9s audio et MIDI pour Linux. Apr\u00e8s avoir initialis\u00e9 la carte son, nous remplissons un buffer avec des sinuso\u00efdes de fr\u00e9quences diff\u00e9rentes en fonction de la corde qui \u00e0 \u00e9t\u00e9 pinc\u00e9e,puis nous envoyons ce buffer \u00e0 la carte son, avec la fonction snd_pcm_writei(). Vous pouvez aussi utiliser ALSA pour jouer des sons pr\u00e9enregistr\u00e9s; Nous avons choisi de g\u00e9n\u00e9rer du son \u00e0 partir de sinus car nous voulions nous pencher plus tard sur la partie math\u00e9matique du  design d'un son (sommes de cosinus pour faire des accords, harmoniques  d'amplitudes diff\u00e9rentes etc...).", "step_imgs": ["https://cdn.instructables.com/FTM/D4SO/IXUSC0O2/FTMD4SOIXUSC0O2.LARGE.jpg"], "step_title": "Step 7: Sound Generation / G\u00e9n\u00e9ration Du Son "}, {"step": 8, "steps_text": "EN:We had a lot of fun doing this project, and a video is coming soon. Do not hesitate to take and improve our little project.Do not spend too much time on the mechanical part, the heart of the  project was to pick up and use a vibration, and the strings are just one way  to do it, but it can be a lot more things! For  example, you can use the sensor as a kind of musical stethoscope that  will play different sound by hitting the surface on which it's on. Be Creative!If you made it this far, thank you very much!FR:Nous nous sommes bien amusez en r\u00e9alisant ce projet, et une vid\u00e9o arrive bient\u00f4t. N\u2019h\u00e9sitez pas \u00e0 reprendre et \u00e0 am\u00e9liorer notre petit projet. Ne passez pas trop de temps sur la partie m\u00e9canique, le c\u0153ur du projet \u00e9tait de capter et traiter une vibration, et les cordes sont un moyen de faire vibrer le capteur, mais son utilisation n'est pas limit\u00e9e aux cordes. Par exemple, vous pouvez utiliser le capteur comme une sorte de st\u00e9thoscope musical qui jouerait diff\u00e9rents sons en frappant la surface sur laquelle il est. Soyez cr\u00e9atifs !Si vous \u00eates arrivez jusqu'ici, merci beaucoup !", "step_imgs": [], "step_title": "Step 8: Conclusion"}, {"step": 9, "steps_text": "", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 9: Demo"}], "channel": "Raspberry Pi"}, {"category": "technology", "description": "  Sometimes you get a chance to combine helping out your family with a nice hobby project..  In this case my father in law was looking for a lighting system for his bird breeding cages. A daylight simulation system to be exact. He asked me to take a look at a website which sells such systems, since he wanted to know what he needed to order. After a quick look at those websites and seeing their pricing.. I convinced my father in-law I would develop and install the system myself.. He would get his lighting, I would have a new hobby project!  \u00a0Daylight-simulation systems  The requirements for a daylight simulation system are simple: lights should gradually (say in 20 minutes) increase to a set high intensity in the morning, stay at that intensity during the day, gradually decrease to a set lower intensity in the evening, and stay at the low intensity during the night.  Other 'non-functional' requirements of such systems: the light should not flicker (this is stressful for the birds), the dimming should be smooth (again related to stress), the system should be reliable..  This instructable describes how I built this system based on an Arduino, some N-channel NPN transistors, a real time clock, a character LCD and some cheap LEDs from eBay.A sidenote: The birds are only in the cages for breeding, the remainder of the year they are in an outside bird sanctuary. So no animals were harmed for making this instructable!  I've submitted this project to the\u00a0123D Circuits Contest and the 2014 makerlympics (both pending approval). So if you like this project: please vote for it! Thanks!", "title": "Bird Cage LED Daylight Simulation System", "url": "https://www.instructables.com/id/Bird-cage-LED-daylight-simulation-system/", "section": "technology", "steps": [{"step": 1, "steps_text": "The base of the system is an Arduino Duemillenova. I think a Uno should work just fine. If you are considering to use a Leonardo or Mega: the code sets special registers in the Arduino.. these might be different for these boards!furthermore the system uses:an Arduino experimenting capea 16x4 character LCD (HD44780)an I2C serial display adapter (or just get a serial LCD)BD135 transistors (any NPN N-channel will do. Power MosFets would be even better)a 7809 9v voltage regulator (12v to 9v for the Arduino)A ds1302 RTC modulesome capacitors and resistorsCool white LED modules (12v led strips will also do)an auto-reset fuse ( or normal fuse if you like)Some switches (if you want to switch off unused cages). I used: http://www.conrad.nl/ce/nl/product/701011/a 12v power supply (over dimensions). I used a 3.5A supply for 18 x 4 LEDs (total +- 18 watts)A case: I used a Fibox TAM201610 http://www.conrad.nl/ce/nl/product/533259/I think everything combined including shipping cost about 85 euro'sAll items were sourced online from dealextreme, eBay, Conrad etc..  but any electronics store would do.A note on 'daylight' LEDsAccording to bird breeder forums and stores: birds need special daylight LEDs. Maybe this is true (I do not want to start a religious discussion), but to me such definitions feel a bit like high-end audio discussions...I've seen special birdkeeper websites showing off  'home developed' LED units for which the CE marking is of the 'China Export' type.  A quick search on eBay revealed that the advertised LEDs (which are sold at special discount prices of 5 EUR per unit) very much resemble 'Cool White store lighting' LED chains sold for around 10USD / 20 units. Therefore I feel that at least some of the advise is a sneaky way to overprice the LEDs.", "step_imgs": ["https://cdn.instructables.com/FRO/EZ68/HQPQXIJJ/FROEZ68HQPQXIJJ.LARGE.jpg", "https://cdn.instructables.com/F5P/UE3Q/HQPQXIJI/F5PUE3QHQPQXIJI.LARGE.jpg", "https://cdn.instructables.com/FRN/6LMW/HQOJ9A84/FRN6LMWHQOJ9A84.LARGE.jpg", "https://cdn.instructables.com/F4D/7Y8U/HQOJ9A8I/F4D7Y8UHQOJ9A8I.LARGE.jpg", "https://cdn.instructables.com/FCQ/3SWS/HQOJ9A8L/FCQ3SWSHQOJ9A8L.LARGE.jpg", "https://cdn.instructables.com/FX5/9MJV/HQQ5EQXI/FX59MJVHQQ5EQXI.LARGE.jpg", "https://cdn.instructables.com/FQH/VJ9G/HQOJ9A85/FQHVJ9GHQOJ9A85.LARGE.jpg"], "step_title": "Step 1: Bill of Materials"}, {"step": 2, "steps_text": "A schematic of supplying power to the arduino via a voltage regulator IC. Note that the same power supply can directly be used to power the LEDs without a voltage regulator.Note that since the number of available components is still a bit limited, the 9v battery represents a power supply ( > 9v) and the PNP transistor represents a 7809 voltage regulator IC. The schematic view gives the clearest representation. Be sure to use a power supply which can easily supply the the current you need to drive all your LEDs. I started out with a 12V / 2A power supply from some equipment that I no longer had. This seemed OK in the beginning, but resulted in a lower brightness and an unreadable LCD after about a day of testing!", "step_imgs": ["https://cdn.instructables.com/FRL/O648/HQQ5EQXM/FRLO648HQQ5EQXM.LARGE.jpg"], "step_title": "Step 2: Power the Arduino and LEDs"}, {"step": 3, "steps_text": "Dimming/fading of leds is the key part of the daylight simulation system. Leds can be faded by supplying a PWM signal instead of a DC signal. An example of this is known to most arduino owners: The 'fade' example. The only thing you need for this is a simple LED and a resistor to limit the current through the circuit.The same code can be used for fading a LED strip instead of a single LED. When powering or fading a LED strip, the voltage or the current that can be supplied by an Arduino pin are no longer sufficient. Therefore an n-channel NPN transistor is introduced. A very common transistor for this is the BD135. The current that can be supplied by this LED is limited (the TO220 type I used for this can supply a maximum of 1A). If more power is needed, a Power MOSFET can be used.An example circuit is shown below: Here a 9V battery is used to power a led which is controlled by an Arduino. Here, the 9v battery represents any type of external power supply. Note that a 10k external puldown resistor is used to keep the signal low until the arduino supplies a signal on Pin 9. Also, in case you are powering a LED strip, the current limiting resistors are already integrated in the strip itself and can be left out.The above example does not take into account two things:The relation between the pulse width and the (perceived) LED brightness is not linear, but logarithmic (or at least: logarithmic is a good enough approximation)The default PWM frequency is rather low, this might disturb the birds if they're in this light all dayGoogle is your friend, and there are a lot of topics covering fast PWM and logarithmic LUTs for arduino, so you don't have to re-invent the wheel. My main source of inspiration: http://forum.arduino.cc/index.php/topic,130736.0.h...So here's some example code which uses a logarithmic LUT and fast PWM on pin 9:Note that this works on my duemillanova clone, and might not work on Arduino mega, due, leonardo etc.<p>/* BirdLight</p><p>Example of a 12bit logarithmic LUT & Fast PWM for gently increasing\n/ decreasing brightness during day to night and night to day transitions. </p><p>Code mostly retrieved from: <a href=\"http://forum.arduino.cc/index.php/topic,130736.0.html\"> http://forum.arduino.cc/index.php/topic,130736.0....</a> </p><p>Copyright 2013 - Patrick Bronneberg \n*/\n/*-----( Configuration )-----*/\nconst double Night_Level = 5.0;\nconst double Day_Level = 99.0;\nconst int LED_PWM_PIN = 9;     // the pin that the fading LEDs are attached to</p><p>/*-----( Declare Constants )-----*/\nconst int PWMMax = 4095;     // Set maximum brightness for PWM\n// Define a logarithmic LUT for PWM dimming\nconst int PWMLut[] = {0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,9,9,9,10,11,\n  13,15,16,17,19,21,23,25,26,27,29,31,32,33,35,37,39,41,43,45,47,49,51,53,55,57,\n  60,63,66,69,71,74,77,80,84,88,91,94,98,102,106,110,114,118,123,128,133,138,143,\n  148,154,160,166,172,179,185,192,199,207,214,222,230,239,248,257,266,276,286,296,\n  306,317,329,341,353,366,379,392,406,421,436,451,466,483,500,518,536,555,574,595,\n  616,638,661,684,707,732,757,784,811,840,869,900,931,964,997,1032,1067,1105,1144,\n  1184,1224,1267,1311,1357,1404,1453,1503,1555,1609,1665,1722,1782,1843,1907,1973,\n  2042,2112,2185,2260,2339,2419,2503,2589,2679,2771,2867,2965,3069,3174,3284,3397,\n  3514,3629,3761,3905,4024,4079,4094};\n//Define the size of the lut: note that integers are 16bits so 2 bytes\nconst int lutSize = sizeof(PWMLut)/2;</p><p>/*-----( Declare global variables )-----*/  \nint ledBrightnessLevel = 0;\nint dayLevel = 0;\nint nightLevel = 0;\nboolean isDay = true;</p><p>void setup()\n{  \n  //Initialize the LED PWM\n  pinMode(LED_PWM_PIN,OUTPUT); \n  TCCR1A = (1 << COM1A1) | (1 << WGM11);                // Enable Fast PWM on OC1A (Pin 9)\n  TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);   // Mode 14 Fast PWM/ (TOP = ICR1), pre-scale = 1\n  ICR1 = PWMMax;     //Set the TOP value for 12-bit PWM\n  \n  // Calculate levels from configured percentages\n  dayLevel = LutPercentageToLevel(Day_Level);\n  nightLevel = LutPercentageToLevel(Night_Level);\n}</p><p>void loop()\n{\n  if (isDay)\n  {\n    //Decrease led brightness until we reach night level\n    if (ChangeLedBrightness(nightLevel, -1))\n    {\n      isDay = false;\n    }\n  }\n  else\n  {\n    //Increase led brightness until we reach day level\n    if (ChangeLedBrightness(dayLevel, -1))\n    {\n      isDay = true;\n    }\n  }\n}</p><p>double LutLevelToPercentage(int lutLevel)\n{\n  return lutLevel*100.0/lutSize;\n}</p><p>int LutPercentageToLevel(double lutPercentage)\n{\n  return (int)((lutSize/100.0)*lutPercentage);\n}</p><p>boolean ChangeLedBrightness(int finishedLevel, int ledFadeAmount)\n{\n \n  // set the current brightness\n  analogWrite(LED_PWM_PIN, PWMLut[ledBrightnessLevel]);    </p><p>  // change the brightness for next time through the loop:\n  ledBrightnessLevel = ledBrightnessLevel + ledFadeAmount;</p><p>  //Check if dimming is finished\n  if ((ledFadeAmount > 0 && ledBrightnessLevel >= finishedLevel) \n      || (ledFadeAmount < 0 && ledBrightnessLevel <= finishedLevel)  )\n  {\n    //Finished!\n    return true; \n  }\n  //Not yet finished\n  return false;\n}</p>", "step_imgs": ["https://cdn.instructables.com/FEO/ZKL3/HQPQVVCD/FEOZKL3HQPQVVCD.LARGE.jpg", "https://cdn.instructables.com/FPJ/1ZOM/HQQ5EQXK/FPJ1ZOMHQQ5EQXK.LARGE.jpg"], "step_title": "Step 3: LED Dimming"}, {"step": 4, "steps_text": "I had a 20x4 HD44780 character display lying around which I bought for less than 1 Euro on a clearance. I wanted to use this in this project, but did not want to lose 10pins of my arduino just for driving the LCD.To overcome this issue, I used an I2C backpack for the display. This is basically an adapter which drives all pins of the LCD but only costs you 2 pins + 5V & ground on your arduino. As stated in the Bill of Materials, these backpacks can be bought for less than 3 dollars on the internet.The downside of using such a device is that the standard Arduino character LCD library doesn't work, and you have to browse on the internet for a while until you find a suiting replacement. The replacement I used is:F Malpartida's NewLiquidCrystal library. which works great, so many thanks to F Malpartida of electroFUN LTD!Unfortunately it took me 2 evenings to get the display up & running with the backpack. So watch out for the following issuesIssues encounteredThe I2C address was different than indicated in the documentation: should be 0x20, but was 0x27.HINT: In case nothing happens when interfacing with the LCD you probably have the wrong address :)My backpack was wired differently from all the example libraries, so a had to figure out which LCD pin was driven by which pin of the I2C chip (required using the datasheet of the I2C chip for the pinout, and a voltage meter to figure out the connections to the LCD) --> When I used the correct address, the backlight started flickering, but no text was shown on screen.. which indicated the different wiring!", "step_imgs": ["https://cdn.instructables.com/FWU/R3BW/HQP02HYK/FWUR3BWHQP02HYK.LARGE.jpg", "https://cdn.instructables.com/FCQ/3SWS/HQOJ9A8L/FCQ3SWSHQOJ9A8L.LARGE.jpg", "https://cdn.instructables.com/F4D/7Y8U/HQOJ9A8I/F4D7Y8UHQOJ9A8I.LARGE.jpg"], "step_title": "Step 4: Adding the Display"}, {"step": 5, "steps_text": "The arduino does not feature a real-time-clock (RTC). Since this project is a daylight simulation system, we need to know what time it is in order to start dimming the LEDs.The most common & affordable RTC's are the DS1302 (SPI) and DS1307 (I2C). For this project I used the DS1302 connected via SPI. Connecting to this RTC is well explained on the arduino playground website I used the DS1302 library by Henning Karlsen. Which is easy to use, and very well documented. So thanks Henning for the hard work & for sharing the code!Example code to get the time, and check it against a set time:boolean CheckIsDay(){\n  //If called the second time, transit to the correct state\n    Time time = rtc.getTime();\n    if ((time.hour > Day_Start_Hour && time.hour < Day_End_Hour) ||\n        (time.hour == Day_Start_Hour && time.min >= Day_Start_Min) ||\n        (time.hour == Day_End_Hour && time.min < Day_End_Min))\n    {\n       return true; \n    }\n    {\n      return false;\n    }\n}Example code for setting the time / date:// Set the clock to run-mode, and disable the write protection  rtc.halt(false);\n  rtc.writeProtect(false);\n  \n  // The following lines can be commented out to use the values already stored in the DS1302\n  rtc.setDOW(SATURDAY);        // Set Day-of-Week (ENUM capital english full name of the day)\n  rtc.setTime(16, 12, 0);     // Set the time  (24hr format)\n  rtc.setDate(4, 1, 2014);   // Set the date dd mm yyyy", "step_imgs": ["https://cdn.instructables.com/FAX/CYEN/HQPQXIOK/FAXCYENHQPQXIOK.LARGE.jpg"], "step_title": "Step 5: Keeping Time"}, {"step": 6, "steps_text": "I'm used to programming in higher level languages, with large supporting frameworks.. because of this I felt a need for some additional structure in my code.Soft TimerIn order to program like there are multiple tasks running in the same time, I used the Soft Timer library. Using this library prevents having a 'god' loop method which controls everything, and in which the control flow becomes unreadable. Or as the creator explains it:SoftTimer enable a higher level Arduino programing, jet easy to use, and lightweight. You often face with the problem that you need to do multiply tasks in the same time. In SoftTimer manner programmer creates Tasks that runs periodically.When you use SoftTimer you do not implement the \"loop\" function of the Arduino. All your code will run event driven, all processes running asynchronous, no more blocking code (like delay()) is needed.Note that you sacrifice predictability in your timing, in my project this doesn't matter.. but if hard real-time is needed, don't use libraries like this!State machine: Another thing I added for structure is a state machine.Since the device can only be in one state at a single time, and the code for entering and exiting the states is in the same function, this really helps to improve the predictability of your device!/*-----( Declare State enum )-----*/#define STARTUP_STATE          1\n#define CONFIGURATION_STATE    2\n#define DAY_STATE              3\n#define NIGHT_STATE            4\n#define DAY_NIGHT_TRANSITION   5\n#define NIGHT_DAY_TRANSITION   6void ChangeState(int newState)\n{\n  SoftTimer.add(&backlightTask);\n      \n  //Leave current state\n  switch (currentState)\n  {\n     case STARTUP_STATE:\n       SoftTimer.remove(&startupTask);\n      break;\n    case CONFIGURATION_STATE:\n      break;\n    case DAY_STATE:\n      SoftTimer.remove(&timerTask);\n      SoftTimer.remove(&defaultDisplayTask);\n      break;\n    case NIGHT_STATE:\n      SoftTimer.remove(&timerTask);\n      SoftTimer.remove(&defaultDisplayTask);\n      break;\n    case DAY_NIGHT_TRANSITION:\n      SoftTimer.remove(&dayToNightTask);\n      break;\n    case NIGHT_DAY_TRANSITION:\n      SoftTimer.remove(&nightToDayTask);\n      break;\n  }\n  \n  //Enter new state\n  switch (newState)\n  {\n    case STARTUP_STATE:\n      SoftTimer.add(&startupTask);\n      break;\n    case CONFIGURATION_STATE:\n      DrawSettingsUI();\n      break;\n    case DAY_STATE:\n      SoftTimer.add(&timerTask);\n      SoftTimer.add(&defaultDisplayTask);\n      DrawSettingsUI();\n      break;\n    case NIGHT_STATE:\n      SoftTimer.add(&timerTask);\n      SoftTimer.add(&defaultDisplayTask);\n      break;\n    case DAY_NIGHT_TRANSITION:\n      ledBrightnessLevel = dayLevel;\n      SoftTimer.add(&dayToNightTask);\n      break;\n    case NIGHT_DAY_TRANSITION:\n      ledBrightnessLevel = nightLevel;\n      SoftTimer.add(&nightToDayTask);\n      break;\n  }\n  //Save current state\n  currentState = newState;\n}", "step_imgs": [], "step_title": "Step 6: Structuring Code: State Machine & Tasks"}, {"step": 7, "steps_text": "After breadboarding fun, it's time to create the circuit using the experimentation shield. The voltage regulators, transistors for powering the LEDs, and circuits for driving the display and rotary encoder are combined into one very crowded shield.In order to be able to control the light for each individual bird cage, one switch was added for each cage.I used a Dremel to create a window for the LCD, and a standard 7mm drill to create the holes for the switches and the rotary encoder. Note: I used painters tape to cover the places where I was to drill the holes so that the drill doesn't slip away from the surface and damage the casing. Unfortunately I did not take the large circuit board into account when marking the edges of the LCD display to cut out of the case. This resulted in the ugly stripe above the LCD..All in all, the device turned out quite nice. Judge for yourself based on the pictures :)", "step_imgs": ["https://cdn.instructables.com/F8Y/DOIV/HQOJ9C67/F8YDOIVHQOJ9C67.LARGE.jpg", "https://cdn.instructables.com/FMT/2V6F/HQOJ9C62/FMT2V6FHQOJ9C62.LARGE.jpg", "https://cdn.instructables.com/FWC/6ONC/HQOJ9C5T/FWC6ONCHQOJ9C5T.LARGE.jpg", "https://cdn.instructables.com/FC8/8L3O/HQOJ9C5U/FC88L3OHQOJ9C5U.LARGE.jpg"], "step_title": "Step 7: Combining Everything"}, {"step": 8, "steps_text": "In any project that has a little complexity I recommend: test, test, test!And don't test for a short while, keep the device running for days, find the boundary scenario's until you're sure enough that it won't fail when it's in use.In my project, timekeeping and dimming the lights are the parts I focused on.. This resulted in the following issues:Buffer overflows when writing to the LCD (I'm a spoiled programmer.. forgot about those things)The power supply failed after a day of operationThe LUT contained a typo, which caused the light to flickerProgramming errors caused a situation that if the device was first powered on at night, it would never transfer to 'day' mode..The RTC did not keep time longer than 5 minutes without power (the battery was dead)All in all.. it was well worth the effort!", "step_imgs": ["https://cdn.instructables.com/FTC/Y563/HQOJ9C05/FTCY563HQOJ9C05.LARGE.jpg"], "step_title": "Step 8: Testing"}, {"step": 9, "steps_text": "Installing the lights was a bit of a pain, since all cages needed to be fitted with LED modules and wiring, and the wiring of all 14 cages had to nicely routed to the controlling unit.. But after a day's work, and quite a lot of solder the birds could be moved to their newly lit cages!This was about 3 months ago. And I'm happy to say that the system has worked without issues! In the meanwhile the birds have started breeding --> which means they're actually happy with the lighting :)So: if you like this instructable, have questions or comments: let me know what you think! If I failed to credit someone: this was unintentional.. so let me know!And have fun creating!PatrickThe full code for the bird lighting system (also supplied as an attachment)/* BirdLight\nDaytime simulation for Bird cagesHardware: Arduino + I2C 16x4 LCD + SPI DS1302 + BD509 TransistorsUses a 12bit logarithmic LUT for gently increasing / decreasing brightness during\nDay to night and night to day transitions. Copyright 2013 - Patrick BronnebergThis sketch is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.This sketch is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.*/\n/*-----( Import needed libraries )-----*/ \n#include <wire.h>\n#include <lcd.h>\n#include \n<liquidcrystal_i2c.h>  // F Malpartida's NewLiquidCrystal library\n#include <ds1302.h>\n#include <softtimer.h>\n#include <softpwmtask.h>\n#include \n<pcimanager.h></pcimanager.h></softpwmtask.h></softtimer.h></ds1302.h></liquidcrystal_i2c.h></lcd.h></wire.h></p><p>/*-----( Configuration )-----*/\nconst double Night_Level = 5.0;\nconst double Day_Level = 99.0;\nconst unsigned int Day_Start_Hour = 7;\nconst unsigned int Day_Start_Min = 0;\nconst unsigned int Day_End_Hour = 21;\nconst unsigned int Day_End_Min = 40;</p><p>/*-----( Declare Constants )-----*/\n#define OFF  0\n#define ON  1\n#define RTC_MULTIPLIER 4 // 4 changes received for each step on the encoder</p><p>#define LCD_I2C_ADDR    0x27  // Define I2C Address for the PCF8574A \n#define LCD_BACKLIGHT_PIN  3 // The pin to use to control the LCD backlight (from i2c expander)</p><p>const int LED_PWM_PIN = 9;     // the pin that the PWM LEDs are attached to\n#define LEDValue OCR1A       // Use 12 bit timer1 for PWM Dimming</p><p>const int PWMMax = 4095;     // Set maximum brightness for PWM\n// Define a logarithmic LUT for PWM dimming\nconst int PWMLut[] = {0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,9,9,9,10,11,\n  13,15,16,17,19,21,23,25,26,27,29,31,32,33,35,37,39,41,43,45,47,49,51,53,55,57,\n  60,63,66,69,71,74,77,80,84,88,91,94,98,102,106,110,114,118,123,128,133,138,143,\n  148,154,160,166,172,179,185,192,199,207,214,222,230,239,248,257,266,276,286,296,\n  306,317,329,341,353,366,379,392,406,421,436,451,466,483,500,518,536,555,574,595,\n  616,638,661,684,707,732,757,784,811,840,869,900,931,964,997,1032,1067,1105,1144,\n  1184,1224,1267,1311,1357,1404,1453,1503,1555,1609,1665,1722,1782,1843,1907,1973,\n  2042,2112,2185,2260,2339,2419,2503,2589,2679,2771,2867,2965,3069,3174,3284,3397,\n  3514,3629,3761,3905,4024,4079,4094};\n//Define the size of the lut: note that integers are 16bits so 2 bytes\nconst int lutSize = sizeof(PWMLut)/2;</p><p>/*-----( Declare State enum )-----*/\n#define STARTUP_STATE          1\n#define CONFIGURATION_STATE    2\n#define DAY_STATE              3\n#define NIGHT_STATE            4\n#define DAY_NIGHT_TRANSITION   5\n#define NIGHT_DAY_TRANSITION   6</p><p>/*-----( Declare objects )-----*/  \nLiquidCrystal_I2C  lcd(LCD_I2C_ADDR,2,1,0,4,5,6,7);\nDS1302 rtc(3, 4, 5); //Real Time Clock on pins 3,4,5 (SPI)</p><p>// 20 minutes, 70% transition, 168 LUT steps --> (20 * 60 * 1000) / (0.7 * 168)\nTask dayToNightTask(10000, dayToNightTransition);\nTask nightToDayTask(10000, nightToDayTransition);\nTask defaultDisplayTask(10000, displayDefault);\nTask timerTask(20000, checkTimer);\nTask displayTask(30000, display);\nTask backlightTask(30000, toggleBacklight);\nTask startupTask(10000, startup);\n//Task configurationTask(200, configuration);</p><p>/*-----( Declare global variables )-----*/  \nint ledBrightnessLevel = 0;\nboolean isBacklightEnabled = false;\nboolean isConfigDisplayed = false;\nboolean startupCalled = false;\nint currentState = 0;\nint dayLevel = 0;\nint nightLevel = 0;\nint lastPosition = 0;\nint sleepRuns = 0;</p><p>void setup()\n{  \n  //Initialize the LED PWM\n  pinMode(LED_PWM_PIN,OUTPUT); \n  TCCR1A = (1 << COM1A1) | (1 << WGM11);                // Enable Fast PWM on OC1A (Pin 9)\n  TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);   // Mode 14 Fast PWM/ (TOP = ICR1), pre-scale = 1\n  ICR1 = PWMMax;     //Set the TOP value for 12-bit PWM\n  \n  // Set the clock to run-mode, and disable the write protection\n  rtc.halt(false);\n  rtc.writeProtect(false);\n  \n  // The following lines can be commented out to use the values already stored in the DS1302\n  rtc.setDOW(SATURDAY);        // Set Day-of-Week (ENUM capital english full name of the day)\n  rtc.setTime(16, 12, 0);     // Set the time  (24hr format)\n  rtc.setDate(4, 1, 2014);   // Set the date dd mm yyyy\n  \n  lcd.begin (16,4);  // initialize the lcd \n  // Set the backlight pin, start disabled\n  lcd.setBacklightPin(LCD_BACKLIGHT_PIN,POSITIVE);</p><p>  // Reset the display  \n  lcd.clear();\n  \n  // Calculate levels from configured percentages\n  dayLevel = LutPercentageToLevel(Day_Level);\n  nightLevel = LutPercentageToLevel(Night_Level);\n  \n  // Start displaying the current time\n  SoftTimer.add(&displayTask);\n  \n  // Startup the device\n  ChangeState(STARTUP_STATE);\n  \n  Serial.begin(9600);\n  Serial.println(\"Wim's Vogelparadijs\");\n}</p><p>void ChangeState(int newState)\n{\n  SoftTimer.add(&backlightTask);\n      \n  //Leave current state\n  switch (currentState)\n  {\n     case STARTUP_STATE:\n       SoftTimer.remove(&startupTask);\n      break;\n    case CONFIGURATION_STATE:\n      break;\n    case DAY_STATE:\n      SoftTimer.remove(&timerTask);\n      SoftTimer.remove(&defaultDisplayTask);\n      break;\n    case NIGHT_STATE:\n      SoftTimer.remove(&timerTask);\n      SoftTimer.remove(&defaultDisplayTask);\n      break;\n    case DAY_NIGHT_TRANSITION:\n      SoftTimer.remove(&dayToNightTask);\n      break;\n    case NIGHT_DAY_TRANSITION:\n      SoftTimer.remove(&nightToDayTask);\n      break;\n  }\n  \n  //Enter new state\n  switch (newState)\n  {\n    case STARTUP_STATE:\n      SoftTimer.add(&startupTask);\n      break;\n    case CONFIGURATION_STATE:\n      DrawSettingsUI();\n      break;\n    case DAY_STATE:\n      SoftTimer.add(&timerTask);\n      SoftTimer.add(&defaultDisplayTask);\n      DrawSettingsUI();\n      break;\n    case NIGHT_STATE:\n      SoftTimer.add(&timerTask);\n      SoftTimer.add(&defaultDisplayTask);\n      break;\n    case DAY_NIGHT_TRANSITION:\n      ledBrightnessLevel = dayLevel;\n      SoftTimer.add(&dayToNightTask);\n      break;\n    case NIGHT_DAY_TRANSITION:\n      ledBrightnessLevel = nightLevel;\n      SoftTimer.add(&nightToDayTask);\n      break;\n  }\n  //Save current state\n  currentState = newState;\n}</p><p>double LutLevelToPercentage(int lutLevel)\n{\n  return lutLevel*100.0/lutSize;\n}</p><p>int LutPercentageToLevel(double lutPercentage)\n{\n  return (int)((lutSize/100.0)*lutPercentage);\n}</p><p>void display(Task* me)\n{\n  lcd.setCursor(1,0); //Start at character 0 on line 0\n  lcd.print(rtc.getDateStr(FORMAT_SHORT,FORMAT_LITTLEENDIAN,'/'));\n  lcd.setCursor(10,0); //Start at character 0 on line 0\n  lcd.print(rtc.getTimeStr(FORMAT_SHORT));\n}</p><p>void toggleBacklight(Task* me)\n{\n   if (isBacklightEnabled)\n   {\n     lcd.setBacklight(OFF);\n     isBacklightEnabled = false;\n     //Remove the task after running once\n     SoftTimer.remove(me);\n   }\n   else\n   {\n     lcd.setBacklight(ON);\n     isBacklightEnabled = true;\n   }\n}</p><p>void displayDefault(Task* me)\n{\n   if (isConfigDisplayed)\n   {\n      DrawDayNightUI();\n      isConfigDisplayed = false;\n   }\n   else\n   {\n      DrawSettingsUI();\n      isConfigDisplayed = true;\n   }\n}</p><p>void checkTimer(Task* me)\n{ \n  Time time = rtc.getTime();\n  int currentLevel = 0;\n  switch (currentState)\n  {\n    case DAY_STATE:\n      currentLevel = dayLevel;\n      if (time.hour == Day_End_Hour && time.min == Day_End_Min)\n      {\n        //Start decreasing brightness\n        ChangeState(DAY_NIGHT_TRANSITION);\n      }\n      break;\n    case NIGHT_STATE:\n      currentLevel = nightLevel;\n      if (time.hour == Day_Start_Hour && time.min == Day_Start_Min)\n      {\n        //Start increasing brightness\n        ChangeState(NIGHT_DAY_TRANSITION);\n      }\n      break;\n  }\n  //Set the current brightness on the leds\n  analogWrite(LED_PWM_PIN, PWMLut[currentLevel]); \n}</p><p>void DrawSettingsUI()\n{\n  lcd.home();\n  \n  // Print our menu on the LCD\n  lcd.setCursor(0,1); //Start at character 0 on line 1\n  lcd.print(\"  DAG  -- NACHT \");\n  \n  char timerString[20];\n  sprintf(timerString, \" %02d:%02d || %02d:%02d \",Day_Start_Hour, Day_Start_Min, Day_End_Hour,Day_End_Min);\n  lcd.setCursor(0,2); //Start at character 0 on line 1\n  lcd.print(timerString);\n  \n  char levelString[20];\n  sprintf(levelString, \"  %02d%%  ||  %02d%%  \",(int)Day_Level, (int)Night_Level);\n  lcd.setCursor(0,3); //Start at character 0 on line 1\n  lcd.print(levelString);\n}</p><p>void DrawDayNightUI()\n{\n  // Print the dimming information on the lcd\n  lcd.setCursor(0,1); //Start at character 0 on line 1\n  lcd.print(\"---- STATUS ----\");\n  \n  lcd.setCursor(0,2); //Start at character 0 on line 2\n  int brightness = 0;\n  switch (currentState)\n  {\n    case DAY_STATE:\n      lcd.print(\"MODUS:       DAG\");  \n      brightness = Day_Level;\n      break;\n    case NIGHT_STATE:\n      lcd.print(\"MODUS:     NACHT\");  \n      brightness = Night_Level;\n      break;\n  }\n  \n  lcd.setCursor(0,3); //Start at character 0 on line 3\n  char levelString[17];\n  sprintf(levelString, \"Intensiteit: %02d%%\",brightness);\n  lcd.print(levelString);\n}</p><p>void DrawDimmingUI(int level)\n{\n  int brightness = (int)LutLevelToPercentage(level);\n  \n  // Print the dimming information on the lcd\n  lcd.setCursor(0,1); //Start at character 0 on line 1\n  lcd.print(\"---- DIMMEN ----\");\n  lcd.setCursor(0,2); //Start at character 0 on line 2\n  lcd.print(\"                \");  \n  lcd.setCursor(0,3); //Start at character 0 on line 3\n  char levelString[17];\n  sprintf(levelString, \"Intensiteit: %02d%%\",brightness);\n  lcd.print(levelString);\n}</p><p>void DrawStartupUI()\n{ \n  // Print the dimming information on the lcd\n  lcd.setCursor(0,1); //Start at character 0 on line 1\n  lcd.print(\"     Wim's     \");\n  lcd.setCursor(0,2); //Start at character 0 on line 2\n  lcd.print(\" Vogelparadijs \");  \n  lcd.setCursor(0,3); //Start at character 0 on line 3\n  lcd.print(\" Versie: v1.0b \");\n}</p><p>boolean CheckIsDay()\n{\n  //If called the second time, transit to the correct state\n    Time time = rtc.getTime();\n    if ((time.hour > Day_Start_Hour && time.hour < Day_End_Hour) ||\n        (time.hour == Day_Start_Hour && time.min >= Day_Start_Min) ||\n        (time.hour == Day_End_Hour && time.min < Day_End_Min))\n    {\n       return true; \n    }\n    {\n      return false;\n    }\n}</p><p>void startup(Task* me)\n{\n  if (startupCalled)\n  {\n    //If called the second time, transit to the correct state\n    Time time = rtc.getTime();\n    if (CheckIsDay())\n    {\n      ChangeState(DAY_STATE);\n    }\n    else\n    {\n      ChangeState(NIGHT_STATE);\n    }\n  }\n  else\n  {\n    startupCalled = true;\n    DrawStartupUI();\n  }\n}</p><p>void dayToNightTransition(Task* me)\n{\n  boolean finished = ChangeLedBrightness(nightLevel, -1);\n  if (finished)\n  {\n    ChangeState(NIGHT_STATE);\n  }\n}</p><p>void nightToDayTransition(Task* me)\n{\n  boolean finished = ChangeLedBrightness(dayLevel, 1);\n  if (finished)\n  {\n    ChangeState(DAY_STATE);\n  }\n}</p><p>boolean ChangeLedBrightness(int finishedLevel, int ledFadeAmount)\n{\n  DrawDimmingUI(ledBrightnessLevel);\n  \n  // set the current brightness\n  analogWrite(LED_PWM_PIN, PWMLut[ledBrightnessLevel]);    </p><p>  // change the brightness for next time through the loop:\n  ledBrightnessLevel = ledBrightnessLevel + ledFadeAmount;</p><p>  //Check if dimming is finished\n  if ((ledFadeAmount > 0 && ledBrightnessLevel >= finishedLevel) \n      || (ledFadeAmount < 0 && ledBrightnessLevel <= finishedLevel)  )\n  {\n    //Finished!\n    return true; \n  }\n  //Not yet finished\n  return false;\n}</p>", "step_imgs": ["https://cdn.instructables.com/FU4/7Q4K/HQPQVVD5/FU47Q4KHQPQVVD5.LARGE.jpg", "https://cdn.instructables.com/FH5/F93Z/HQQ5ER1S/FH5F93ZHQQ5ER1S.LARGE.jpg", "https://cdn.instructables.com/FO9/GASX/HQPQVVD2/FO9GASXHQPQVVD2.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 9: Results"}, {"step": 10, "steps_text": "Like with most projects, there are some items left on the TODO list:The rotary encoder does not control anything yet It is connected, but I did not yet have time to write a menu structure to allow changing the configuration.I want to replace the experimentation board with a nice PCB All the wiring and the many solder points makes me a bit nervous about the reliabilityAnd I never designed or ordered a PCB before, so it will be a nice new experiment!In case of any updates, I'll post them on this instructable.", "step_imgs": [], "step_title": "Step 10: TODO"}], "channel": "Arduino"}, {"category": "technology", "description": "Over the years I've had to measure some unusual processes in systems, and one of the most common 'tough' problems has been the measurement of displacement. For mm-scale motion I've used mice (mechanical and optical) to record movement, but I once found myself needing to record nanometric scale displacements and so I was led to interferometry.\nAn interferometer is not something that interferes with meters, nor a method for measuring between iron things. Instead, it is the use of phase differences (which cannot be easily measured) and the wave-like properties of light to form measurable changes in intensity (which can be easily measured).\nHere I'll describe how I\u00a0built a Michelson-Morley interferometer.\nIs it useful? Maybe.\nIs it awesome in that you can watch nanometer-scale phenomena? Ooh yes.", "title": "Desktop Michelson-Morely Interferometer", "url": "https://www.instructables.com/id/Desktop-Michelson-Morely-Interferometer/", "section": "technology", "steps": [{"step": 1, "steps_text": "You'll need;\n1)\u00a0A cheap laser diode - red is good, green is better.\nI\u00a0used a 5mW\u00a0diode that I\u00a0had bought from Roithner Lasertechnik in Austria many years ago - but I\u00a0have no reason to believe that a cheapy 3 dollar laser pointer from the local dollar store wouldn't work as well. Actually, there will be reasons, but they lie outside the scope of this article and you can have a dig around with the keywords of 'spatial coherence' and 'astigmatism'.\n2)\u00a0Some single-surface mirrors - I bought half a dozen on eBay for a few US\u00a0dollars.\nThese are fancy mirrors that have a highly reflective aluminium coating on one face of a glass slip. They prevent multiple internal reflections, which would occur with normal glass-faced mirrors.\n3)\u00a0A beam-splitter\nI bought some de-lasered blue-ray drive heads on eBay, and found a pair of beam-splitter cubes among the teeny tiny spangly bits inside.\nIn the image you can see the parts.\nThe two single-surface mirrors are each glued to a piece of aluminium right-angle extrusion that hjave been spruced up with a black permanent marker.\nThe laser and beam-splitter are glued to two lengths of scrap aluminium, to make positioning a little easier and to ensure that the laser and beam-splitter are at the same height.", "step_imgs": ["https://cdn.instructables.com/FSL/OWD0/G43EBKX5/FSLOWD0G43EBKX5.LARGE.jpg"], "step_title": "Step 1: The Parts List"}, {"step": 2, "steps_text": "The idea behind all of this is that the laser light is split into two separate paths. The beams travel along these paths and then recombine.\nIn most situations, when you add one thing to another, well you simply add the amplitude of the 'things'.\nPut a cheese infront of a cheese-o-meter, and it would read '1'.\nPut two cheeses infront of a cheese-o-meter, and it should read '2'. \n(yeah yeah - squish the two cheeses together and you have one cheese - it's a bad analogy but it makes me smile)\nBut, critically, with two cheeses infront of it, the cheese-o-meter never should display zero. It doesn't matter how you arrange them, side-by-side, one on another, the meter should read '2'.\nBut light can demonstrate wave-like properties. And anything that oscillates can, at any given time, can be said to have a phase with respect to some other thing. I'll explain.\nThe phase simply describes how far the oscillating thing is along its path, with respect to some other point. Consider two perfectly bouncy balls.\nA bouncing ball may be said to be 'in phase' with another similarly excited ball if the two both reach the apex of their bounces at the same time. A fancy way of saying that is that their phase difference is zero.\nIf the two balls are dropped from the same height at different times, then they will strike the ground at different times, but that difference will not change for subsequent bounces. One might say that their phase difference will be a constant.\nClearly, the balls could be dropped so that one is at the top of its path when the other hits the ground. The balls' motions are then in anti-phase:\u00a0when one is doing one thing, the other is doing its opposite.\nSo - back to the two light beams alluded to earlier. If one light beam takes a slightly longer path than another light beam, then when the two are brought back to the same point, there will be a phase difference between the two. If it helps to think of something associated with each beam wiggling back and forth while it travels, well, good for you, but don't imagine that it's the full truth.\nBecause the wavelength (ie, distance between wiggles)\u00a0is very very small for light, it doesn't take very much displacement for two beams to end up completely in anti-phase with each other.\nAnd that's where the cheese come in.\nSee, because cheese hasn't got a phase, it always adds in a simple way. \n1+1 = 2\nBut the electromagnetic fields that make up light have a phase (with respect to other light fields). So if one light beam is in anti-phase with another, when I\u00a0add them the sum is zero.\nSo two light particles can be combined to give '0', and '2', and any number in between when shone into a light-o-meter (such as an eye, or a camera). \nThe fields in a light beam are always oscillating - they wiggle back and forth while the light propagates forward. \nThus, if one light beam is split into two rays, and if the rays cover different distances before recombining, the two rays will have different phases. And unlike cheese, they can cancel each other out, or they can add together.\n(phew!)", "step_imgs": [], "step_title": "Step 2: A Little Theory"}, {"step": 3, "steps_text": "So here's a theoretical picture of how it should all work.\nThe laser's ray is split into two paths. One goes north to Mirror 1, one goes east to Mirror 2.\nIf the path taken by the northbound ray is of a different length to that of the eastbound ray, then when the two rays recombine at the eye / camera / screen, they will have different phases and will display an interference pattern.\nNo optical rig is perfect, so the rays won't precisely cancel each other out, nor will they exactly boost their amplitude. Instead one should see a fringe pattern of light and dark bands, and the position of those bands will move according to how the 'legs' of the interferometer are changed.", "step_imgs": ["https://cdn.instructables.com/F5L/MXAL/GD2JCAF8/F5LMXALGD2JCAF8.LARGE.jpg"], "step_title": "Step 3: "}, {"step": 4, "steps_text": "I\u00a0used a sheet of 6mm thick polycarbonate plastic as the 'optical bench'. It fails quite well in that role, and in a sense, that's a good thing - as it allows one to observe the effect of *tiny* deformations on the intereference pattern produced.\nHere's the arrangement.\nNow, this all looks very pretty, but the point to observe is the striped pattern at the bottom of the picture. \nThis is the interference pattern generated by the two rays, and it is an incredibly finicky thing to establish - expect a good half hour of gently poking and tilting the elements till you glimpse this faint but unmistakable banding.\nThat is being projected onto an almost-horizontal piece of white card. I tilted the card so that the interference pattern would be broadened out and the fringe motion would be more readily observed.\nThe second picture is a contrast boosted view of the image on the white card.\nIn the movie you can see the effect of gently poking the polycarbonate 'bench' with a bit of heat-shrink sleeving (I'd have used a feather, but I'm fresh out of them).\nWhat you're seeing is the weak and feeble tubing bending the 6mm polycarbonate. You can't see it actually deflect, but you're altering the relative path lengths of the two legs of the interferometer.", "step_imgs": ["https://cdn.instructables.com/FQQ/IYSG/G2HDXPGV/FQQIYSGG2HDXPGV.LARGE.jpg", "https://cdn.instructables.com/FS9/7L2G/G2HE094D/FS97L2GG2HE094D.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: The Arrangement"}, {"step": 5, "steps_text": "So, there you have it.\nA way of measuring nanometric disturbances.\nEvery time that a bright band is swapped for a dark band, the path lengths of the two rays in the interferometer will have been changed by exactly 1/4 of a wavelength. For red light that's a shade over 100nm.\nNow the question is how to engineer a way of generating controlled disturbances at that scale - and for that we'll need a feedback loop and a transducer! But that's another project - enjoy!", "step_imgs": [], "step_title": "Step 5: "}], "channel": "Science"}, {"category": "technology", "description": "a.articles {\n\tcolor: white;\n\tbackground: red;\n\tfont-weight: bold;\n\tfont-style: italic;\n\ttext-decoration: none;\n}\na.articles:hover {\n\tcolor: white;\n\tbackground: black;\n}\np strong {\n\tfont-weight: bold;\n}\nThis instructable shows how to improve the accuracy and resolution of the plotter described in https://www.instructables.com/id/CNC-Dual-Arm-Plot...The accuracy was improved by using: thick aluminium shoulder arms to prevent sideways flexing.    metal sleeves at each joint to eliminate sideways movement due to the 3mm bolt threads.    a light-weight gel-tipped ink cartridge (optional).The resolution was improved by a factor of 8 by:using a 4:1 step down belt drive to achieve more motor steps.    using a controller that supports 16 times microstepping.", "title": "CNC Dual Arm Plotter Version 2", "url": "https://www.instructables.com/id/CNC-Dual-Arm-Plotter-Version-2/", "section": "technology", "steps": [{"step": 1, "steps_text": "The above circuit shows two 12 volt stepper motors [1] connected to Big EasyDriver controllers set to 16 times microstepping. Adjust each motor current, in turn, to 400mA by rotating the Big EasyDriver potentiometer  while monitoring the current drain shown on the CPS-3205 power supply.[1]An alternate circuit using 6 volt stepper motors and EasyDriver controllers set to 8 times microstepping is shown in instructable https://www.instructables.com/id/CNC-Dual-Arm-Plot...If you choose to use 6 volt steppers, the supply voltage must be reduced to 6 volts.  You will also need to adjust the motor currents to 600mA and the following code definitions to:#define STEPS_PER_DEG 6400/360DELAY_MIN = 5000,", "step_imgs": ["https://cdn.instructables.com/FHQ/OTKF/J5V3SE10/FHQOTKFJ5V3SE10.LARGE.jpg"], "step_title": "Step 1: Circuit"}, {"step": 2, "steps_text": "A parts list is attached.All items were obtained from http://aliexpress.com", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: Parts List"}, {"step": 3, "steps_text": "The code for this plotter is attached.The code is identical to that used in https://www.instructables.com/id/CNC-Dual-Arm-Plot... apart from the following definitions: #define STEPS_PER_DEG 12800/360#define NUDGE STEPS_PER_DEG/4DELAY_MIN = 2500,", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 3: Code"}, {"step": 4, "steps_text": "The shoulder armReplace each of the plastic shoulder rulers with 6mm x 30mm flat aluminium bar. Drill two holes 285mm apart. Use the holes in one arm as a template for the second.One hole should have a diameter of 3/16 inches (4.76mm). The diameter of the other hole should be 6mm.The elbow armReplace the plastic elbow rulers with 1mm x 30mm flat aluminium bar. Thin aluminium allows the pen-lift to raise the arm assembly.Drill two holes 285mm apart. Use the holes in one arm as a template for the second.One hole should have a diameter of 3/16inches (4.76mm).  Custom-fit the other hole to fit the pen-holder.The elbow jointTrim 4mm from the end of a 3/16 inch tubular radio spacer. A simple method of doing this is to insert 4mm of the spacer into an electric drill then hold the spacer against a hacksaw blade while the drill rotates.Fit the shoulder and elbow arms over this spacer then sandwich the spacer between two 3mm washers using a 3mm nut and bolt.The elbow joint should now spin freely without wobble or unwanted sideways movement.", "step_imgs": [], "step_title": "Step 4: The Arms"}, {"step": 5, "steps_text": "Place a 6mm bolt through a GT2-80 6mm bore pulley [1]. Add a 6mm nut and washer then, using the existing 6mm motor clearance hole, sandwich the baseboard between another 6mm washer and nut.Fit a GT2-20 5mm bore pulley to a motor and place it on top of the base board. Now loop a GT2-200 timing belt around the pulleys and mark the outside edges of the motor while the belt is tight.  Remove the bolt and motor.Slot the existing 6mm motor clearance hole. The slot allows the timing belt to be tensioned.Make a pencil rubbing of the motor and use it as a template to drill four 3mm corner holes for mounting the motor and a 6mm clearance hole for the motor shaft. Mount the motor and attach the GT2-20 pulley to the motor shaft.Hack-saw the top off the bolt. The bolt may now be fitted to the base board (last photo).[1] The bore diameter of 6mm pulleys is actually 6.35mm (1/4 inch). The three center-punch marks around the hole (first photo) reduce the effective hole-size to 6mm to eliminate wobble. Next time I will purchase pulleys with a 5mm bore diameter and drill them to fit the bolt. ", "step_imgs": ["https://cdn.instructables.com/FXU/QVJZ/J5K6PRL5/FXUQVJZJ5K6PRL5.LARGE.jpg", "https://cdn.instructables.com/FFK/2DQG/J5K6PRL8/FFK2DQGJ5K6PRL8.LARGE.jpg", "https://cdn.instructables.com/F6U/IOCG/J5K6PRLD/F6UIOCGJ5K6PRLD.LARGE.jpg"], "step_title": "Step 5: Positioning the Motors and Spindles"}, {"step": 6, "steps_text": "Clamp a shoulder arm to the GT2-80 pulley as shown above and drill a 3mm diameter hole.Fit a 3mm nut and bolt to prevent the arm slipping while you drill a second 3mm hole on the opposite side.The temporary 6mm lock bolt may now be removed.", "step_imgs": ["https://cdn.instructables.com/FO0/7NK1/J5KWJ0BN/FO07NK1J5KWJ0BN.LARGE.jpg"], "step_title": "Step 6: Attaching the Shoulder Arms"}, {"step": 7, "steps_text": "Place the GT2-200 timing belt over the 6mm spindle.With the shoulder-arm attached, place the GT2-80 pulley over the spindle and lock in place using a 6mm drill-collet. Do not tighten the GT2-80 grub-screws ... the pulley must be free to rotate about the spindle.Loosen the under-neath nut and slide the spindle towards the motor.Fit the timing belt around the GT2-80 pulley and GT2-20 pulleys.Slide the spindle away from the motor until the belt is taut then tighten the 6mm spindle nut.", "step_imgs": ["https://cdn.instructables.com/FAI/5KZM/J5K5VR5E/FAI5KZMJ5K5VR5E.LARGE.jpg"], "step_title": "Step 7: Tensioning the Timing Belt"}, {"step": 8, "steps_text": "The above photos track the improvements made to the original \"CNC Dual Arm Plotter\" described in instructable https://www.instructables.com/id/CNC-Dual-Arm-Plot...Photo 1Plot of on-board \"target\" using software version 1. Notice how all lines are curved much like a vertical plotter. Photo 2Plot of \"target\" using software version 2. This software calculates the motor settings for EACH motor step.The lines are now straight but the image leaves much to be desired due to unwanted joint movement. Notice how much the center of the cross has been moved upwards.Photo 3Plot of \"target\" from this belt-drive plotter using the same software. The horizontal and vertical line are virtually straight due to the increased resolution and better joints.  The original plotter had a theoretical half-step error of 0.513mm. The \"wiggles\" for this plotter approach the pen-width which is 0.4mm. Photo 4\"Radial line\" test using the original plotter.Photo 5The same \"radial line\" test using this plotter. Notice how the horizontal, vertical and diagonal lines are all straight. The stepped nature of the lines in-between are due to the stepping ratio needed to correct the inherent line distortions. This probably accounts for why the circle in photo 3 is not smooth ... the line angle is continuously changing. While noticeable in these photos the \"wiggles\" are really quite small.Photo 6Some text output from this plotter, Again the horizontal and vertical line portions are relatively smooth.ConclusionsThe addition of belt drives, better elbow joints, and rigid  arms, improve the plotter resolution and accuracy.The accuracy is significantly improved by using stiffer shoulder-arms and better shoulder joints. The expected improvement in resolution through the use of gearing isn't as great as expected. The horizontal, vertical, and diagonal lines all show an improvement, Other angles. however, still show tiny \"wiggles\".\u00a0\u00a0Click here\u00a0\u00a0 to view my other instructables.", "step_imgs": ["https://cdn.instructables.com/FX2/L319/J5UA3XEO/FX2L319J5UA3XEO.LARGE.jpg", "https://cdn.instructables.com/F35/04PY/J5UA3XER/F3504PYJ5UA3XER.LARGE.jpg", "https://cdn.instructables.com/F95/ETGQ/J5UA3XGW/F95ETGQJ5UA3XGW.LARGE.jpg", "https://cdn.instructables.com/F1H/ZRET/J5UA3XJ0/F1HZRETJ5UA3XJ0.LARGE.jpg", "https://cdn.instructables.com/FNQ/3J8J/J5UA3XL9/FNQ3J8JJ5UA3XL9.LARGE.jpg", "https://cdn.instructables.com/FZC/5555/J5UA3XN6/FZC5555J5UA3XN6.LARGE.jpg"], "step_title": "Step 8: Results"}], "channel": "CNC"}, {"category": "technology", "description": "CNC-machining makes it easy to cut out shapes very precise and consistent. But often it stays limited to cutting out 2D shapes, for obvious reasons. While learning how to use the CNC myself a while ago, I dug deeper into creating inspiring 3D geometry with the help of programming. This gave me the knowledge to be able to create quicker and more efficient custom toolpaths that would have been harder or impossible to setup with standard CAM-software.In this instructable I'll guide you through the process of creating advanced mathematical geometry using programming in combination with cnc-machining. The knowledge you will gain from it will make you able to set up more sophisticated and more efficient toolpaths and will prevent being restricted by the limits of your CAM software.Quite some of the knowledge in this instructable builds upon Jens Dyvik's research. A lot of the examples that will be given were made using the Colinbus at Fablab Genk but some were also made on a Shopbot. The machines I've used were set up in the metric system so don't get confused with the numbers if you normally work in imperial units.If there's anything that is not clear or wrong, let me know so I can edit the instructable.", "title": "Make Awesome 3D Geometry by Programming CNC-code", "url": "https://www.instructables.com/id/Make-Awesome-3D-Geometry-by-Programming-CNC-code/", "section": "technology", "steps": [{"step": 1, "steps_text": "If you've never used a CNC before, some of the terms used in this instructable might sound weird. I therefore recommend getting familiar with a cnc before trying similar things like in this instructable. Use the CAM-software that comes with the machine you have access to as it will provide an idea on the workflow for starting a milling job.CAM-software is unfortunately not a plug and play thing. You need to know about feedrates, rpm, milling bits and so on. And even though the software makes it easy to set up the toolpaths, you still need to work within the capabilities of what the program is capable off. Having full control over what the machine will do, as we will learn in a later step, gives us the opportunity to change every part of the toolpath setup which is not always possible in CAM-software.", "step_imgs": ["https://cdn.instructables.com/FI9/3L9E/IXLA6CJU/FI93L9EIXLA6CJU.LARGE.jpg"], "step_title": "Step 1: Get Familiar With CNC"}, {"step": 2, "steps_text": "G-code is the language that makes your computer communicate with the CNC-machine. Inside your CAM-software you convert your CAD-files (3D or 2D) with the post-processor to a file which your machine will understand. This is a code made or used by the machine manufacturer for their machines. It's a set of commands that tells the machine where to go and what to do and in a simplified way it says something like this:- Put spindle speed to 18000 rotations per minute- Set move speed to 35 mm per second- Move to co\u00f6rdinate x100, y100 above the material- Move 25 mm in z-direction down and back up- Turn off spindle- Go to origin / 0-point on the machine... The differences between these g-code are for example how they define the command to move, or in which units they work, or if negative numbers in the z-direction are above or below the 0-point, etc. In the next step we'll have a look at dissecting this code to be able to write your own code for the machine you use.", "step_imgs": [], "step_title": "Step 2: What Is G-code"}, {"step": 3, "steps_text": "To understand which parts of the code does what you can create a simple example file using your cam-software. The post-processor converts the information into the right code for the machine. We can then analyze this file and reverse engineer how it works. You can just open it in notepad and read the lines of code. If you have a look at the example of the shopbot code, you'll see that a lot of the code is just co\u00f6rdinates which tell the machine where to move the spindle  to.And then depending on which machine you use, the rest of the code can be quite straight forward (e.g. in the example of the shopbot code M3 means to Move to a specific co\u00f6rdinate in 3 dimensions). Sometimes you can also find information online for a clear explanation. Some manufacturers might give the details themselves, like Shopbot for instance:http://www.opensbp.com/files/QuickReference_bothpa...We need to know what these different commands do as in a later step we will create this kind of code ourselves using programming.", "step_imgs": ["https://cdn.instructables.com/FSV/N0GQ/IXAQ4MBZ/FSVN0GQIXAQ4MBZ.LARGE.jpg", "https://cdn.instructables.com/FQN/H5FD/IXAQ4MBX/FQNH5FDIXAQ4MBX.LARGE.jpg"], "step_title": "Step 3: Understanding the Code From the Machine You Have Access To"}, {"step": 4, "steps_text": "So now we have a better idea on how the code for the machine works, we can use this information to create our own post processor. I've been using Rhino with its versatile plugin Grasshopper for this. Rhino is a CAD software which combines a 2D drawing and 3D modeling environment in one. Grasshopper is a plugin for doing node-based programming inside Rhino and it widely extends its capabilities. I think there's other programming languages or software that might be able to do similar things, but I find this combo of programming and a 3D environment the easiest to do this kind of stuff because you get a visual representation of what is happening in your code.What we'll be doing in this instructable will allow us to draw lines in 3D and make a toolpath file that will tell the machine to follow those lines. In the previous step we saw that the toolpath consists of co\u00f6rdinates. Which means we need to convert our lines into points, extract the co\u00f6rdinates from those points and turn that into the right format. We also need to keep in mind that between the lines we will want to move above the material because we don't want to cut in the material when it goes from one line to another one. So that means we need to copy the first and last point from each line and insert a z-height above our material.Or if I would simplify the process it would become like this:- Input lines- Optional: Sort lines to make sure the lines are milled in the right order, if necessary. (can also be used to speed things up a lot)- Convert lines to a list of points- Copy first point and last point from a curve, extract co\u00f6rdinates, replace the z-co\u00f6rdinate with one that is above the material, make new point from those co\u00f6rdinates and insert that point in the list on the right place (before the start point and behind the last point of each line inside the material).- Extract co\u00f6rdinates from each point- Convert these co\u00f6rdinates to the right syntax (the g-code that works specifically on your machine)- Combine this with the start and end-code of the file- Turn into gcode file. ", "step_imgs": ["https://cdn.instructables.com/FNW/M14B/IXAQ4LDV/FNWM14BIXAQ4LDV.LARGE.jpg", "https://cdn.instructables.com/FLV/W45L/IX6FXGMF/FLVW45LIX6FXGMF.LARGE.jpg", "https://cdn.instructables.com/FYC/6K5A/IXAQ4L4E/FYC6K5AIXAQ4L4E.LARGE.jpg", "https://cdn.instructables.com/FQ1/PKZB/IXAQ4L5Q/FQ1PKZBIXAQ4L5Q.LARGE.jpg"], "step_title": "Step 4: Programming - Grasshopper"}, {"step": 5, "steps_text": "I made a basic grasshopper definition which I added as an example. It does the steps I described in the previous step and converts 3D lines into  shopbot or colinbus code. I think it can be quite useful to better understand how it's done.Saving  the gcode file from the grasshopper file you do by right-clicking the  yellow panel with the code (on the right in the file) and choose a  stream destination, meaning where you will save the file. When you name  the file make sure you chose the extension that your gcode uses. For  Shopbot it's .sbp, for colinbus it's .c3d, etc... You can find out what  this is by looking at the toolpath file exported from the cam-software,  as we've seen in step 3.Before you're trying your self-made code out for the first time, make sure you read through the code and see if everything looks like it should. Then run the file in the air and look what the machine does. If everything looks like it should, run the file into the material and feel the satisfaction of milling your self-programmed code.From here the exploring in Grasshopper can start. The possibilities of combining Grasshopper with cnc-machining are endless. In the next steps I'll describe how I created some examples using these tools.", "step_imgs": ["https://cdn.instructables.com/F14/4OQN/IXLA9TWZ/F144OQNIXLA9TWZ.LARGE.jpg", "https://cdn.instructables.com/F5K/HUDF/IXLA9THW/F5KHUDFIXLA9THW.LARGE.jpg", "https://cdn.instructables.com/FQ1/B3B4/IXGFLIR0/FQ1B3B4IXGFLIR0.LARGE.jpg", "https://cdn.instructables.com/FEE/A9VU/IXGFLIQC/FEEA9VUIXGFLIQC.LARGE.jpg", "https://cdn.instructables.com/FHF/VQ2G/IXGFLI0K/FHFVQ2GIXGFLI0K.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 5: Generate Toolpaths & Test"}, {"step": 6, "steps_text": "Inside grasshopper there's an image sampler which can read the black and white value of an image and maps that to a number between 0 and 1. With 0 being black and 1 being white. So what we can do is remap that value to a different domain that will control how deep our v-bit goes. That way we can create different line thickness inside the material as if we're pushing harder and softer with a pencil on a paper.Since the image sampler needs points as an input we can quickly move those point to the z-depth we want. If we then sort our points into groups we can't create 3D polylines from those points and use a postprocessor like in one of the previous steps to turn this into gcode. When you're milling it out it is advisable to paint the top surface to get a nice colour contrast.I added the original file I used, to be able to learn from it. Be aware that the postprocessor used in this example file is for a Colinbus and  not a Shopbot.You could also convert the postprocessor to take points as an input and just drill every time to a different depth with the v-bit. In that way you can create halftone images on the CNC like I did the first time I tried my own code (see previous step images).", "step_imgs": ["https://cdn.instructables.com/FOG/7W9T/IXAQ4L30/FOG7W9TIXAQ4L30.LARGE.jpg", "https://cdn.instructables.com/FS5/UQ09/IXLADIJY/FS5UQ09IXLADIJY.LARGE.jpg", "https://cdn.instructables.com/FKJ/BOSM/IXLADIIT/FKJBOSMIXLADIIT.LARGE.jpg", "https://cdn.instructables.com/FB1/VR8O/IXAQ4L1O/FB1VR8OIXAQ4L1O.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 6: Example 1: Convert Image to 3D-milling Using a V-bit"}, {"step": 7, "steps_text": "This example is partially manual drawing and partially grasshopper. So what I did was creating 4 lines, of which the most top and most bottom one are basic arcs from a circle and the two lines in the middle are random curly waves I drew. I then used grasshopper to create transition lines between them; so-called \"Tween curves\". I wanted to create a line surface where these tween curves are the top of the surface. So what I then did was making lines in between those transition curves which the v-bit will follow. Now we end up with the curves in 2D, but we want to make them 3D so the edges end up at the same level. So what I did was dividing the v-bit curves up into points and for each point I calculate the distance to the closest curve. Since I am using a 90 degree bit I know that the distance to the closest transition curve is also our v-bit depth (see v-bit image). If you don't understand why you can search on trigonometry. So moving the division points in the z-direction down using the distance to the closest curve, we get a 3D curve that we can use with the post-processor again.I also sorted the curves and flipped every other curve. This increases the milling time as it makes sure that the machine doesn't move to the other side above the material with every curve.I added the rhino and grasshopper file so you can dissect how it's made. It's an old definition so I'm pretty sure there's stuff that can be done faster or in a different way.", "step_imgs": ["https://cdn.instructables.com/F7S/8VNS/IXLA5LGS/F7S8VNSIXLA5LGS.LARGE.jpg", "https://cdn.instructables.com/F96/WJ1T/IXLA5LH6/F96WJ1TIXLA5LH6.LARGE.jpg", "https://cdn.instructables.com/F09/VSRA/IXLA5LHF/F09VSRAIXLA5LHF.LARGE.jpg", "https://cdn.instructables.com/FAK/6PWM/IXAQ4L72/FAK6PWMIXAQ4L72.LARGE.jpg", "https://cdn.instructables.com/FYN/VSYM/IXAQ4L9E/FYNVSYMIXAQ4L9E.LARGE.jpg", "https://cdn.instructables.com/F9I/EF44/IXLA5UBJ/F9IEF44IXLA5UBJ.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 7: Example 2: Curvy Lines"}, {"step": 8, "steps_text": "This one I made while I was doing some exercises on learning Python inside Grasshopper. There's quite some steps involved before the final milling and I'm sure there are quicker ways to do this then how I did at the time, but here it goes. Inside the python component I created the code to generate points for creating a 100x100 mm square sinus wave surface. (I think I learned this from some tutorial but can't remember wherefrom. If anybody knows, tell me so I can add it) To create a smooth transition going from a flat surface to this sin wave surface I remap the numbers using a graph mapper. These will generate the scale factor we will use. It's not the cleanest way to generate this surface but it works for this application. So I scale each point in the z-direction from the highest point of our sin-surface and the pieces that will be flat are scaled with a value of 0.001 creating a flat looking surface (even though it's not perfectly flat).I then calculated the distance between the center of the square and each of the points from the sin surface we created. I sort the list of points according to that distance and move an optional number of the list of scaled points down to create the dome shape. (Because we calculated the distance from the center it creates this circular shape).I then order those points into lists of points to form polylines. I created these polylines add different heights so I could do a roughing in steps. So I used them with the postprocessor we've used before to do the roughing on the oak. But for the finishing path I wanted to use a spiral toolpath and had to do a workaround to achieve that:So from the final polylines I create a 3D surface. Then I baked the 3D surface into Rhino and drew a 2d spiral above the surface. I then did an offset (with the radius of the ball nose bit) on the surface and projected the spiral onto that surface, to match the edge of the ballnose with the surface that I actually want to create. Then when setting the z-height on the machine, I move the zero point down with a distance that matches the radius of the bit. So the 0-point in z-direction is now in the center of the bit. I then use the postprocessor on that projected spiral curve and that's it!Now a lot of this will be hard to follow by reading my text so I suggest having a look at my files to get a better understanding. You will need the python component which you can find on the food4rhino website: HereAnd then it's up to you! I hope you learned something from this instructable and in case you use it to make something I'd love to see the results!", "step_imgs": ["https://cdn.instructables.com/FP6/DB3G/IX6FXGDG/FP6DB3GIX6FXGDG.LARGE.jpg", "https://cdn.instructables.com/F7D/L32T/IXLA9XWV/F7DL32TIXLA9XWV.LARGE.jpg", "https://cdn.instructables.com/FLO/ONP9/IXLA9XZD/FLOONP9IXLA9XZD.LARGE.jpg", "https://cdn.instructables.com/F28/C7KA/IXLA9XZE/F28C7KAIXLA9XZE.LARGE.jpg", "https://cdn.instructables.com/FZT/142E/IXAQ4MCA/FZT142EIXAQ4MCA.LARGE.jpg", "https://cdn.instructables.com/F10/7K3C/IX6FXGBO/F107K3CIX6FXGBO.LARGE.jpg", "https://cdn.instructables.com/FYM/OV9B/IX6FXGGO/FYMOV9BIX6FXGGO.LARGE.jpg", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 8: Example 3: Sinus Bowl"}], "channel": "CNC"}, {"category": "technology", "description": "I was make a analog modeling synthesizer by nucleo F401RE.\u79cb\u6708\u96fb\u5b50\u901a\u5546\u3067\u3082\u8ca9\u58f2\u3055\u308c\u3066\u3044\u308bNucleoF401RE\u3092\u4f7f\u3063\u3066\u30a2\u30ca\u30ed\u30b0\u30e2\u30c7\u30ea\u30f3\u30b0\u30b7\u30f3\u30bb\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002PC_3 and GND of F401RE connect to headphone(L-CH only).\u4eca\u56de\u306f\u3067\u304d\u308b\u3060\u3051\u7c21\u5358\u306b\u4f5c\u308b\u305f\u3081\u306b\u97f3\u306f\u30a4\u30e4\u30db\u30f3\u304b\u3089\u3060\u3057\u3001PWM\u3067\u97f3\u3092\u9cf4\u3089\u3057\u3066\u307e\u3059\u3002L-CH\u306e\u307f\u3092F40RE\u306ePC_3\uff08\u4e00\u756a\u53f3\u4e0a\u306e\u30d4\u30f3\uff09\u306b\u3064\u306a\u304e\u3001comon\u3092GND\u306b\u7e4b\u304e\u307e\u3057\u305f\u3002I was make a headphone dupont adapter.\u30a4\u30e4\u30db\u30f3\u30b8\u30e3\u30c3\u30af\u3092\u30d6\u30ec\u30c3\u30c9\u30dc\u30fc\u30c9\u306b\u633f\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u3084\u3064\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\u3053\u308c\u3067\u30a4\u30e4\u30db\u30f3\u3068\u30dc\u30fc\u30c9\u3092\u63a5\u7d9a\u3057\u3066\u3044\u307e\u3059\u3002\u30b3\u30cd\u30af\u30bf\u306f\u5343\u77f3\u96fb\u5546\u3084\u5171\u7acb\u30a8\u30ec\u30b7\u30e7\u30c3\u30d7\u3067\u8cfc\u5165\u53ef\u80fd\u304b\u3068\u601d\u3044\u307e\u3059\u30022550\u30b3\u30cd\u30af\u30bf\u3068\u3044\u3063\u305f\u540d\u524d\u3067\u58f2\u3089\u308c\u3066\u307e\u3059\u3002\u79c1\u306faliex\u306egreatElectronics\u304b\u3089\u8cfc\u5165\u3057\u3066\u307e\u3059\u3002\u3053\u3053\u306e\u30b3\u30cd\u30af\u30bf\u306f\u5b89\u304f\u3066\u826f\u3044\u306e\u3067\u3059\u304c\u3001\u30aa\u30b9\u30d4\u30f3\u306f\u534a\u7530\u3067\u88dc\u5f37\u3057\u306a\u3044\u3068\u6298\u308c\u307e\u3059\u3002I use hardware  F401RE , headphone, headphone adapter only.output is interrupt per sample late.\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3054\u3068\u306b\u5272\u308a\u8fbc\u307f\u3092\u3057\u307e\u3057\u3066\u3001\u8a08\u7b97\u3068\u51fa\u529b\u3092\u884c\u3063\u3066\u307e\u3059\u3002\u6b63\u78ba\u306b\u306f\u5272\u308a\u8fbc\u307f\u3067\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u3066\u3001\u30d5\u30e9\u30b0\u3092\u691c\u51fa\u3057\u305f\u6642\u306b\u51e6\u7406\u3057\u3066\u307e\u3059\u3002all function easy Control . can not calc.\u6b63\u5f26\u6ce2\u3001\u4e09\u89d2\u6ce2\u3001\u77e9\u5f62\u6ce2\u306e\u95a2\u6570\u3092\u7528\u610f\u3057\u3066\u307e\u3059\u3002\u6bce\u56de\u3001\u95a2\u6570\u5916\u3067\u8a08\u7b97\u884c\u3063\u305f\u3053\u3068\u306f\u4e0d\u8981\u3067\u3059\u3002\u305d\u308c\u305e\u308c\u306e\u95a2\u6570\u306f\u5f15\u6570\u306b\u5468\u6ce2\u6570\u3001DUTY\u3001\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3068\u4f4d\u76f8\u3092\u4fdd\u6301\u3059\u308b\u5909\u6570\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u5165\u308c\u308b\u3060\u3051\u3067\u3059\u3002develop by mbed online compiler.MBED\u306b\u3066\u958b\u767a\u3057\u3066\u307e\u3059\u3002\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306f\u4e0b\u8a18\u30a2\u30c9\u30ec\u30b9\u3088\u308a\u3054\u89a7\u306b\u306a\u308c\u307e\u3059\u3002this Mbed site can see all source.https://developer.mbed.org/users/gitakichi/code/An...\u4eca\u56de\u306f\u30b7\u30f3\u30bb\u3063\u307d\u304f\u30ea\u30f3\u30b0\u30e2\u30b8\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u3084\u3063\u3066\u307e\u3059\u3002\u4eca\u5f8c\u3001\u697d\u5668\u3068\u3057\u3066\u4f7f\u3048\u305d\u3046\u306a\u30e2\u30ce\u3092\u88fd\u4f5c\u3057\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002", "title": "How to Make a Analog Modeling  Synthesizer", "url": "https://www.instructables.com/id/How-to-Make-a-Analog-Modeling-Synthesizer/", "section": "technology", "steps": [{"step": 1, "steps_text": "E = sin(\u03c9t+\u03b8) mean sin wave at electric circuit.\u4e0a\u8a18\u306e\u5f0f\u3067\u6b63\u5f26\u6ce2\u3092\u8868\u3059\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\u03c9 is angular velocity.\u03c9 = 2\u03c0f\u03c9\u306f\u89d2\u5468\u6ce2\u6570\u3067\u4e00\u822c\u306b\u306f2\u03c0f\u3068\u3055\u308c\u307e\u3059\u3002f is freq.f\u306f\u5468\u6ce2\u6570t is time.t\u306f\u6642\u9593\u3067\u3059\u03b8 is firstest phase.\u03b8\u306f\u521d\u671f\u4f4d\u76f8\u3067\u3059\u3002I use under formura.\u4eca\u56de\u306f\u521d\u671f\u4f4d\u76f8\u306f\u4e0d\u8981\u3067\u3059\u306e\u3067\u4e0b\u8a18\u306e\u5f0f\u3067E = sin(2 * 3.14 * f * t).under is Program.\u4e0b\u8a18\u306b\u6b63\u5f26\u6ce2\u306e\u30bd\u30fc\u30b9\u3092\u793a\u3057\u307e\u3059\u3002double sin_osc(double late,double freq_out,double &ift){     double data;    data = sin(6.28 * ift);    ift += late * freq_out;     if(ift > 1)    ift--;    return data; }", "step_imgs": [], "step_title": "Step 1: Sin-wave"}, {"step": 2, "steps_text": "under is square-wave Program.\u4e0b\u8a18\u306b\u77e9\u5f62\u6ce2\u306e\u30bd\u30fc\u30b9\u3092\u793a\u3057\u307e\u3059\u3002\u5168\u90e8\u306e\u95a2\u6570\u3067\u4f4d\u76f8\u3092\u4fdd\u6301\u3059\u308b\u5909\u6570\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u5f15\u6570\u306b\u6e21\u3057\u3066\u307e\u3059\u306e\u3067\u3053\u306e\u95a2\u6570\u306b\u540c\u3058\u5f15\u6570\u3092\u5165\u308c\u3066\u5b9f\u884c\u3059\u308b\u3060\u3051\u3067\u6ce2\u5f62\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002double square_osc(double late,double freq_out,double duty,double &ift){     double data;    if(duty > ift)  data = 1;     else data = -1;    ift += late * freq_out;     if(ift > 1)    ift--;    return data; }", "step_imgs": [], "step_title": "Step 2: Square-wave"}, {"step": 3, "steps_text": "under is triangle wave Program.\u4e09\u89d2\u6ce2\u3067\u3059duty\u306f0.1\u304b\u30890.9\u3067\u5165\u308c\u3066\u304f\u3060\u3055\u3044\u3002duty\u306b\uff11\u3092\u5165\u308c\u308b\u3068\u6b63\u5e38\u306b\u52d5\u4f5c\u3057\u306a\u3044\u53ef\u80fd\u6027\u304c\u6709\u308a\u307e\u3059\u3002duty\u306e0.1\u4ed8\u8fd1\u30680.9\u4ed8\u8fd1\u3067\u306f\u306e\u3053\u304e\u308a\u6ce2\u306b\u8fd1\u3044\u3082\u306e\u306b\u306a\u308a\u307e\u3059\u3002double triangle_osc(double late,double freq_out,double duty,double &ift){     double data;          if(ift < duty)    data = 2 * (ift * (1 / ift) - 0.5);     else    data = 2 *( (1 / (1 - duty)) * (1 - ift) - 0.5);    ift += late * freq_out;     if(ift > 1)    ift--;    return data; }", "step_imgs": [], "step_title": "Step 3: Triangle-wave"}, {"step": 4, "steps_text": "#include \"mbed.h\"Ticker flipper; PwmOut mypwm(PC_8); DigitalIn sw(USER_BUTTON);//duty must input 0.1-0.9 bool flip_flag;void flip() {     flip_flag = 1; }double sin_osc(double late,double freq_out,double &ift) {     double data;    data = sin(6.28 * ift);    ift += late * freq_out;     if(ift > 1)    ift--;    return data; } double square_osc(double late,double freq_out,double duty,double &ift) {     double data;    if(duty > ift)  data = 1;     else data = -1;    ift += late * freq_out;     if(ift > 1)    ift--;    return data; } double triangle_osc(double late,double freq_out,double duty,double &ift) {     double data;          if(ift < duty)    data = 2 * (ift * (1 / ift) - 0.5);     else    data = 2 *( (1 / (1 - duty)) * (1 - ift) - 0.5);    ift += late * freq_out;     if(ift > 1)    ift--;    return data; }int main() {     double data,late,ift_1,ift_2;     late = 20 * 0.001 * 0.001;    mypwm.period_us(20);     flipper.attach_us(&flip,20);    while(1) {        if(flip_flag == 1) {            data = (sin_osc(late,1200,ift_1) * sin_osc(late,1210,ift_2)) + 1;             mypwm.write( data / 20 );            flip_flag = 0;         }     } }", "step_imgs": [], "step_title": "Step 4: All Source Code"}, {"step": 5, "steps_text": "Mbed hardwere platformhttps://developer.mbed.org/platforms/ST-Nucleo-F40...", "step_imgs": [], "step_title": "Step 5: Reference"}], "channel": "Audio"}, {"category": "technology", "description": "IntroThis tutorial shows a way of designing a Heart Diseases Detector using Nexys Video board. This project combines electronics and medicine in order to obtain a product that detects hearth diseases. The results of this project don't compare with an examination and therefore the resuls cannot be considered valid - this is a project made for a contest and not for medical purposes. The aim of the project is to compare signals from MIT-BIT database with the signals acquired from the patients and returns a response to the tested person. ", "title": "FPGA Based Heart Diseases Detector", "url": "https://www.instructables.com/id/FPGA-Based-Heart-Diseases-Detector/", "section": "technology", "steps": [{"step": 1, "steps_text": "The patterns are Matlab files which include 3 types of files: .atr, .dat, .hea. After you've downloaded the files, you need to add their name in the code. The code will be atached down here :-) .On the first part, you need to add the path and the files for every signal. Remember that MIT-BIH data base has sampling frequency = 360 Hz, so you need to obtain this frequency from FPGA. On the specific data, you also have a variable called SAMPLES2READ which shows the number of periods to be displayed.The files for database must be downloaded from here: MIT-BIT data base.", "step_imgs": ["https://cdn.instructables.com/FFL/09GV/J16YL4N3/FFL09GVJ16YL4N3.LARGE.jpg"], "step_title": "Step 1: Dowload the Patterns"}, {"step": 2, "steps_text": "The TOP module consist of 4 important blocks: ADC   RAM  RX   TXIt is necessary to reduce the standard frequency of 100 MHz to 360 Hz, due to the sampling frequency of the MIT-BIH database; that's why the ADC block has multiple components: PLL, XADC, Frequency Divider.The RAM :2048 memory locationsone memory location = 12bBecause the control for writing and reading from the memory needs to be easily done, this block is controlled from an input port : we (write enable). When the memory is full, a pulse is generated on the pin pulseMem to inform the transmission block to start the transfer to the PC.", "step_imgs": ["https://cdn.instructables.com/FZJ/KKYQ/J1GOVZ2O/FZJKKYQJ1GOVZ2O.LARGE.jpg", "https://cdn.instructables.com/FMW/2WBO/J1GOW8A0/FMW2WBOJ1GOW8A0.LARGE.jpg"], "step_title": "Step 2: Blocks(ADC and RAM)"}, {"step": 3, "steps_text": "The transmission block waits for the memory to be full and after that it sends information to the PC. Because our signal has 12b - we chose to transmit 2 packages of 8 bits:the first package [b7 b6 b5 b4 b3 b2 b1 b0]the second package [0 0 0 0 b11 b10 b9 b8]The state machine has a counter for transmissions and only if this counter is even, and the program goes to the next address.In this case it is needed an PC application which knows to wait the second package before plotting the signal.", "step_imgs": ["https://cdn.instructables.com/FCP/ARFV/J1GOVX4O/FCPARFVJ1GOVX4O.LARGE.jpg"], "step_title": "Step 3: Transmission"}, {"step": 4, "steps_text": "", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Codes"}], "channel": "Electronics"}, {"category": "technology", "description": "Data Acquisition (DAQ) hardware provides simple interface to bring Analog/Digital signals in to your computer and the LabVIEW software is used to process the acquired signal. For example you can connect a thermocouple sensor to the DAQ module via analog input channel and with the help of LabVIEW VI read / display the current temperature. In this tutorial I will construct a data acquisition virtual instrument (VI) in LabVIEW for MiniLab1008 DAQ Module. The information provided here will facilitate the understanding of LabVIEW software and data acquisition hardware.  LabVIEW is a trademark of National Instruments Corporation (NI) and the data acquisition hardware we are using is from Measurement Computing (MCC).The cost of Minilab1008 USB DAQ Module is around $129See MCC site for more information on MiniLab1008 : http://www.measurementcomputing.com/See NI site for more information on LabVIEW: http://www.ni.com/labview/", "title": "MiniLab 1008 and LabVIEW", "url": "https://www.instructables.com/id/MiniLab-1008-and-LabVIEW/", "section": "technology", "steps": [{"step": 1, "steps_text": "The drivers provided with the Measurement Computing (MCC) DAQ modules do not\roffer direct control of the hardware from the LabVIEW software. We need Universal Library to communicate with the LabVIEW. See figure 1.1 for hierarchical communication link between LabVIEW and the MCC Minilab1008 DAQ.", "step_imgs": ["https://cdn.instructables.com/F06/GD9X/FJ6RWHG9/F06GD9XFJ6RWHG9.LARGE.jpg"], "step_title": "Step 1: Communication Link"}, {"step": 2, "steps_text": "There are two parts to a VI: the panel and the diagram. The panel resembles the front panel of an instrument and the diagram is where you make connections with various components. This VI will acquire the data from a specified channel and display it on front panel. There is no text programming involved in LabVIEW. The VI when complete should look like fig 1: ", "step_imgs": ["https://cdn.instructables.com/F1L/HH8T/FJ34CYIN/F1LHH8TFJ34CYIN.LARGE.jpg"], "step_title": "Step 2: Two Parts to a VI - Front Panel and Diagram"}, {"step": 3, "steps_text": "Click to start InstaCal software from Measurement Computing. This is necessary as it would allow the PC to detect the connected DAQ hardware.  \rClick on your desktop to start LabVIEW. \rClick NewVI to start a new VI application. \r", "step_imgs": [], "step_title": "Step 3: Detecting Hardware & Starting LabVIEW"}, {"step": 4, "steps_text": "For data acquisition to work we need to provide controls, functions and indicators in the VI. Controls allow us to change the value of parameters, indicators allow us to graph and chart data, and functions provide the processing or the input/output control of the acquired data. Step 1 - Adding Digital ControlExplore the Controls menu. Choose DIGITAL CONTROL from the Numeric window as shown in Fig 2. A field will appear on the panel, label it as \"Board #\".Repeat this 3 times by adding more digital control and label them as Sample Rate, Low Channel and High Channel. These controls will allow us to enter the numeric values for the Minilab1008 data acquisition board", "step_imgs": ["https://cdn.instructables.com/FD9/JZ32/FJ34CYIP/FD9JZ32FJ34CYIP.LARGE.jpg"], "step_title": "Step 4: Designing Front Panel"}, {"step": 5, "steps_text": "Step 2 - Adding Control for Error MessagesFor using the Error control, LabVIEW reads from a set of strings. From the String & Path Controls menu, as shown in Fig 3, select String Indicator and label it as Error Message. Remember this is a window for error messages relating the status of the hardware. ", "step_imgs": ["https://cdn.instructables.com/FVZ/YQB2/FJ34CYJO/FVZYQB2FJ34CYJO.LARGE.jpg"], "step_title": "Step 5: Designing Front Panel"}, {"step": 6, "steps_text": "Step 3 - Choosing Graph for plottingTo plot the acquired data, go to GRAPH menu as shown in Fig 4, select WAVEFORMGRAPH and label it as Display.NOTE: With manipulation of G objects, the front panel could look like as shown in Fig. 1.", "step_imgs": ["https://cdn.instructables.com/FLU/YVUT/FJ34CYJN/FLUYVUTFJ34CYJN.LARGE.jpg"], "step_title": "Step 6: Designing Front Panel"}, {"step": 7, "steps_text": "Click on the diagram part of the VI. You will notice another floating palette titled Functions. This\rpalette has a variety of functions and sub-VIs that control all aspects of the DAQ board or module and signal measurement and processing. If you have labeled all the numeric controls and indicators, then you will find their terminals on the diagram labeled appropriately. In case you forgot to label the numeric and strings just as you brought them into front panel it can be confusing. Use the right click mouse while selecting the terminal and choose \"Find Terminal\" from the menu. Alternatively, you can double-click on the terminal in the diagram and it will point to the control in the front panel. To get to the diagram, go to the Windows menu and select SHOW DIAGRAM. The diagram should look as shown in Fig. 5:\r", "step_imgs": ["https://cdn.instructables.com/FMJ/Y8UZ/FJ34CYJE/FMJY8UZFJ34CYJE.LARGE.jpg"], "step_title": "Step 7: Designing Diagram Panel"}, {"step": 8, "steps_text": "Change RepresentationTo change the numeric representation as shown in figure 5., right click on the numeric box and from the Representation menu change the numeric integer type as shown below:", "step_imgs": ["https://cdn.instructables.com/FG7/SI6U/FJ34CYJG/FG7SI6UFJ34CYJG.LARGE.jpg"], "step_title": "Step 8: Designing Diagram Panel"}, {"step": 9, "steps_text": "Step 1 - Adding Analog Input Function From Functions menu select MCC Icon and choose AlnScFg Input from Analog Input as shown in Fig 6NOTE: To turn on HELP, from the Help menu, choose Show Help . When the mouse is kept on any part of the diagram, a help window will show on the screen. For example the help for \"AInScFg\" is shown as in Fig 7.", "step_imgs": ["https://cdn.instructables.com/F25/L7E9/FJ34CYJD/F25L7E9FJ34CYJD.LARGE.jpg", "https://cdn.instructables.com/FPT/5S9T/FJ34CYJC/FPT5S9TFJ34CYJC.LARGE.jpg"], "step_title": "Step 9: Designing Diagram Panel"}, {"step": 10, "steps_text": "Step 2 - Add Signal Conditioning functions From the Functions menu select MCC and choose ToEng from Signal Conditioning as shownin Fig 8.Details of ToEng.VI is shown in Fig 9", "step_imgs": ["https://cdn.instructables.com/F1C/3KQX/FJ34CYJB/F1C3KQXFJ34CYJB.LARGE.jpg", "https://cdn.instructables.com/FOC/WTFY/FJ34CYJA/FOCWTFYFJ34CYJA.LARGE.jpg"], "step_title": "Step 10: Designing Diagram Panel"}, {"step": 11, "steps_text": "Step 3 - Add Error Message HandingFrom the Functions menu select MCC and choose ErrMsg from MISC (Calibration & Configuration) as shown in Fig. 10  Fig.11 shows the help for \"Err Msg\" function.", "step_imgs": ["https://cdn.instructables.com/F2N/4SHE/FJ34CYJ8/F2N4SHEFJ34CYJ8.LARGE.jpg", "https://cdn.instructables.com/F1Y/BWSX/FJ34CYJ7/F1YBWSXFJ34CYJ7.LARGE.jpg"], "step_title": "Step 11: Designing Diagram Panel"}, {"step": 12, "steps_text": "Step 4 - Numeric ConstantFrom the Functions menu select Numeric and choose Numeric Constant as shown in Fig 12.Note:'' Enter numeric value 1000 into the constant field. Repeat step 4 and enter value 0.The reason we are doing this is to provide an input to number of samples to collect and also toprovide an input to t0 (trigger time of the waveform). Please see figure 18 for more information.", "step_imgs": ["https://cdn.instructables.com/F8B/M80E/FJ34CYJ6/F8BM80EFJ34CYJ6.LARGE.jpg"], "step_title": "Step 12: Designing Diagram Panel"}, {"step": 13, "steps_text": "Step 5 - Ring Constant From the Functions menu select Numeric and choose Ring Constant as shown in Fig 13.Note: Enter Not Programmable text in the first constant field and then enter numeric value+-10V into the second constant field. To add a second field right click on the box and chooseAdd item after from the menu and then type +-10V.The reason we are doing this is to provide an input to the Range. This is used for collecting the A/D sample. The input voltage range for linear operation, single ended mode for MiniLAB1008 is\u00c2\u00b110Vmax.", "step_imgs": ["https://cdn.instructables.com/FUJ/CVG9/FJ34CYJM/FUJCVG9FJ34CYJM.LARGE.jpg"], "step_title": "Step 13: Designing Diagram Panel"}, {"step": 14, "steps_text": "Step 6 - Build WaveformFrom the Functions menu select Waveform and choose Build Waveform as shown in Fig 14.The reason we are building our own waveform is that we need to customize the x-axis scaling. Changing the X-axis to display Time would help us to visualize the graph in a meaning full manner. Once you insert the build waveform component drag the middle end to make it look as shown in the yellow box below:Note: Select the Position/Size cursor from the Tools palette in order to drag and increase the middle end.The help for Build Waveform is shown in Fig 15.", "step_imgs": ["https://cdn.instructables.com/F7A/FIA7/FJ34CYJL/F7AFIA7FJ34CYJL.LARGE.jpg", "https://cdn.instructables.com/FM2/3K4X/FJ34CYJF/FM23K4XFJ34CYJF.LARGE.jpg", "https://cdn.instructables.com/FCG/JVXE/FJ34CYJK/FCGJVXEFJ34CYJK.LARGE.jpg"], "step_title": "Step 14: Designing Diagram Panel"}, {"step": 15, "steps_text": "Final Step - Connecting the boxes At this point it is important to understand the tool bar. The tool bar is used for choosing different tools. Fig. 16 gives a tool bar description.While designing a diagram remember the following rules:For any Function or sub-VI the inputs to it are always to the left and the outputs are always to theright. To look at all the connections, go to the Help menu and choose \"Show Help\".With Help turned on, as you move your editing tool on a function/sub-VI the help screen will pop up. When the wire tool is placed over a function or a sub-VI, the terminals on the functions light up with the connections highlighted. This makes it easy to connect the wire to appropriate terminals.If the connections between two functions/sub-VIs are incompatible, then a dotted (-----) line will appear between the connections rather then a solid line. This means that the wire connection is carrying incompatible data (e.g. an array to a number or a cluster to an array). Check the connections again with the \"Help\" screen or by looking at Fig 18.Using the wire tool , connect the appropriate controls to the sub-VI as shown in Fig 18. Connect the graphing indicator on towards the end of your construction. When your implementation is complete, the tool bar will show the status of the VI. As said before if a connection is bad or is not appropriate, it will show on the diagram with a broken line. If the terminals are not connected appropriately, the tool bar will display the status as shown in Fig 17.", "step_imgs": ["https://cdn.instructables.com/FWT/19C9/FJ34CYJJ/FWT19C9FJ34CYJJ.LARGE.jpg", "https://cdn.instructables.com/FPL/L1WL/FJ34CYJI/FPLL1WLFJ34CYJI.LARGE.jpg"], "step_title": "Step 15: Designing Diagram Panel"}, {"step": 16, "steps_text": "Final Step On completion and if the wiring is correct, the diagram should look like the one shown in Fig. 18.There are some additional optional components and the wiring you see in the diagram:After connecting all the wires as shown in Fig.18, proceed to the front panel and fill in the appropriate information on the front panel as described below:Testing Low & High Channel as 0 for Channel control. Adjust your function generator to output 100 Hz, 2v pp sine wave signalDepending on the frequency of the input waveform, enter an appropriate sampling frequency number.The number that you enter should be at least twice the frequency of the input waveform.In the Count, put the same number as the Sample rate.After entering the appropriate information, click on the right arrow  as shown in fig.16 below to begin acquiring data.If the information entered was correct the collected signal will appear on the front panel.As you may have noticed, the data acquisition is done only at the time of clicking the right arrowTo do a continuous data acquisition click on the loop arrows and the data acquisition will continue until STOP button is pressed.THE ENDWritten by Tariq Naqvi", "step_imgs": ["https://cdn.instructables.com/FWT/19C9/FJ34CYJJ/FWT19C9FJ34CYJJ.LARGE.jpg", "https://cdn.instructables.com/FFW/55A6/FJ34CYJH/FFW55A6FJ34CYJH.LARGE.jpg"], "step_title": "Step 16: Designing Diagram Panel"}], "channel": "Software"}, {"category": "technology", "description": "An arduino is an open source physical computing platform designed to make experimenting with electronics more fun. This instructable will teach you how to make a variety of patterns of flashing lights using your arduino and eight LEDs.Ideally this would be done with the Vilros Ultimate Starting Kit for arduino, which contains all the necessary materials, hardware instructions, and a link to download the software instructions.", "title": "Arduino Lights", "url": "https://www.instructables.com/id/Arduino-Lights-1/", "section": "technology", "steps": [{"step": 1, "steps_text": "Attach the arduino and the breadboard to some sort of backboard that will hold them in place. The starter kit comes with such a backboard. The arduino has holes for screws to hold it in place, and the breadboard has a sticky bottom covered by a removable plastic covering. Note that this is not necessary, but helpful.", "step_imgs": [], "step_title": "Step 1: Hardware"}, {"step": 2, "steps_text": "Plug in the wires, LEDs, and shift register into the Arduino and breadboard as shown above. Note that the circle visible  on one end of the shift register should be facing the nearest edge of  the breadboard, and try to shove the shift register into the appropriate  holes as one fluid action, instead of one connector at a time. The  lower picture table details the location and plug in-points of every  piece of hardware. Additional note: the color of the LEDs is irrelevant; in fact having multiple colors can make the display more interesting.", "step_imgs": ["https://cdn.instructables.com/FU1/DAOL/IOVPS5A6/FU1DAOLIOVPS5A6.LARGE.jpg", "https://cdn.instructables.com/FTR/2XLL/IOVPS371/FTR2XLLIOVPS371.LARGE.jpg", "https://cdn.instructables.com/FMZ/09N8/IOVPS59F/FMZ09N8IOVPS59F.LARGE.jpg"], "step_title": "Step 2: Hardware Continued"}, {"step": 3, "steps_text": "Download/install the Arduino IDE software and Arduino Code to your computer. If you are using the starter kit, flip to page 3 and follow the steps through page 8. If not, the IDE is available at arduino.cc/en/Main/Software. Getting the Arduino Code requires having the starter kit, but I've provided the necessary code in the next step.", "step_imgs": [], "step_title": "Step 3: Software"}, {"step": 4, "steps_text": "If you have the instruction guide in the starter kit, follow the instructions to download the software instructions from the website. If you do not have the starter kit, here's the code, but without the explanations provided by the original. Please support the official release.Type these instructions into your Arduino sketch on your computer. Note: recommend not copying and pasting, as the format might change.int datapin = 2;int clockpin = 3; int latchpin = 4; byte data = 0;void setup (){    pinMode(datapin, OUTPUT);    pinMode(clockpin, OUTPUT);  pinMode(latchpin, OUTPUT); } void loop(){   //oneAfterAnother();          //All on, all off    //oneOnAtATime();         //Scroll down the line   //pingPong();                  //etc   //randomLED();   //marquee();   //binaryCount(); } void shiftWrite(int desiredPin, boolean desiredState) {   bitWrite(data,desiredPin,desiredState);   shiftOut(datapin, clockpin, MSBFIRST, data);   digitalWrite(latchpin, HIGH);    digitalWrite(latchpin, LOW); } void oneAfterAnother() {   int index;   int delayTime = 100;    for(index = 0; index <=7; index++)  {    shiftWrite(index, HIGH);     delay(delayTime);    }   for(index = 7; index >=0; index --)   {       shiftWrite(index, LOW);       delay(delayTime);    } } void oneOnAtATime() {   int index;   int delayTime = 100;  for(index = 0; index <= 7; index++)    {       shiftWrite(index, HIGH);       delay(delayTime);       shiftWrite(index, LOW);     }   for(index = 7; index >= 0; index --)   {       shiftWrite(index, HIGH);       delay(delayTime);    shiftWrite(index, LOW);     } } void pingPong() {   int index;    int delayTime = 100;    for(index = 0; index <= 7; index++)   {       shiftWrite(index, HIGH);        delay(delayTime);    shiftWrite(index, LOW);    }   for(index = 7; index >= 0; index--)   {       shiftWrite(index, HIGH);       delay(delayTime);     shiftWrite(index, LOW);    } }void randomLED(){   int index;   int delayTime = 100;   index = random(8);   shiftWrite(index, HIGH);   delay(delayTime);    shiftWrite(index, LOW); }void marquee() {    int index;   int delayTime = 200;   for(index = 0; index <= 3; index++)    {       shiftWrite(index, HIGH);        shiftWrite(index+4, HIGH);        delay(delayTime);       shiftWrite(index, LOW);    shiftWrite(index+4, LOW);    }}void binaryCount() {   int delayTime = 1000;   shiftOut(datapin, clockpin, MSBFIRST, data);   digitalWrite(latchpin, HIGH);    digitalWrite(latchpin, LOW);   data++;   delay(delayTime); }", "step_imgs": [], "step_title": "Step 4: Software Continued"}, {"step": 5, "steps_text": "Plug in your arduino to the computer running the arduino software from step 2. The code contains six lines that have the \"//\" marking them as comments but can serve as code instructions. Simply delete the // from the pattern you want to create, and the software will treat it as an instruction when you click \"upload\". To switch between patterns, replace the // on the pattern you no longer want and delete the // on the pattern that you do want.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 5: Using"}], "channel": "Arduino"}, {"category": "play", "description": "Card holder for most of the cards that make up your ship in Firefly.  This is a companion instructable to my previous one that describes how to make a good deck/discard and pieces holder for the board game:  Firefly Board Game Case From Foam Core", "title": "Hand Holder for Firefly Board Game ", "url": "https://www.instructables.com/id/Hand-Holder-for-Firefly-Board-Game/", "section": "play", "steps": [{"step": 1, "steps_text": "Half of the major footprint of Firefly the board game is the mass of cards that create your hand: Crew, Jobs, Money, Equipment, Ship Mods, Etc. So, tried to figure out a way to mitigate some of that footprint into a more manageable device. Please please share any modifications or other ways you manage your hand!! This is just a first attempt and always looking for something better. ", "step_imgs": [], "step_title": "Step 1: How Do You Manage All of the Cards? "}, {"step": 2, "steps_text": "I grabbed a piece of scrap foam core and started cutting to see what I could come up with. I liked the curved carousel as it provided an easy to see setup for all of the cards. Here you can see the progression from very rough concept to a semi rough template. ", "step_imgs": ["https://cdn.instructables.com/FU8/GGZM/II4YRSVH/FU8GGZMII4YRSVH.LARGE.jpg", "https://cdn.instructables.com/F0Y/O2XH/II4YRSVL/F0YO2XHII4YRSVL.LARGE.jpg"], "step_title": "Step 2: The Test and the Plan "}, {"step": 3, "steps_text": "Since I have plenty left over and out is extremely easy to work with, will be using foam core. Need a ruler to measure, hobby knife and / or specialty foam cutting tools, and glue (hot or elmers white is fine). Dimensions are 4\"x8\". The area that holds money is 1 1/2\"x4\". The holding slits are set every 1/2\" up the sides and every 3/4\" around the curve and are 1\" long. Space was left on the left side so cards would fit well between the curve and side but feel free to set up the holding slits however you like your hand. Experiment with a couple games to see what works for you. ", "step_imgs": ["https://cdn.instructables.com/FDL/TNJ3/II4YRSX1/FDLTNJ3II4YRSX1.LARGE.jpg", "https://cdn.instructables.com/F1F/Q0O1/II4YRSYQ/F1FQ0O1II4YRSYQ.LARGE.jpg"], "step_title": "Step 3: Dimensions and Tools "}, {"step": 4, "steps_text": "Use a cup or other appropriately sized thing to inscribe a half circle on one side of the panel. On the other side of the panel measure 1 1/2\" and draw a line across. That will be the start of the 1\" long 45\u00b0 cuts up both sides of the panel. Make a mark every 1/2 inch up the right side for 4\". Make a mark every 1/2 inch up the left side for 3\". Also make one mark at the 4\" on the left side. At the top, where the half circle is inscribed, make a mark that is in the middle (2\" from either side). Use the marks made at the 4\" for a guide.Now we are going to make the marks on the circle. We are just going to be using simple chords to make the marks for where the lines will go. Feel free to go big and use exact measurements with protractor and angles, but it's a card holder. Start with any number of your ruler touching the first measuring dot on the right of the circle. Then rotate the rule until it bisects the circle 3/4\" from the starting number. Repeat until you have about 6 marks going around the circle. Once you have the marks measured out, go back and make your 1\" guidelines. When making the lines for the circle, line up the outer dots with the center dot. ", "step_imgs": ["https://cdn.instructables.com/FQX/CEM7/II4YRT0E/FQXCEM7II4YRT0E.LARGE.jpg", "https://cdn.instructables.com/FO5/OJ21/II4YRT3B/FO5OJ21II4YRT3B.LARGE.jpg", "https://cdn.instructables.com/FGA/EPY9/II4YRT6A/FGAEPY9II4YRT6A.LARGE.jpg", "https://cdn.instructables.com/FMZ/CC9J/II4YRT7K/FMZCC9JII4YRT7K.LARGE.jpg"], "step_title": "Step 4: Measurements "}, {"step": 5, "steps_text": "This can actually be a little sloppy. A slightly wavy cut will give a better grip to the cards. I cut most of the way thru with the specialized foam cutting tool at a 45\u00b0 angle. Then I finished the cut freehand and didn't even try to make it pretty. I also cut a small slit on the side in the area that will hold the money. This will be used to slide in the paperclip that will hold the money. Cut some small pieces of scrap and glue to the bottom. This will allow the cards to poke out the bottom a bit and makes it easier to slide them in. If a basic card holder is all you want or need then you can stop here. You're done. Next step is beautification only. ", "step_imgs": ["https://cdn.instructables.com/FEB/SBFQ/II4YRT98/FEBSBFQII4YRT98.LARGE.jpg", "https://cdn.instructables.com/FOJ/1G0D/II4YRTAI/FOJ1G0DII4YRTAI.LARGE.jpg", "https://cdn.instructables.com/FZ7/Y8JT/II4YRTBT/FZ7Y8JTII4YRTBT.LARGE.jpg", "https://cdn.instructables.com/FRP/3QJV/II4YRTBY/FRP3QJVII4YRTBY.LARGE.jpg", "https://cdn.instructables.com/FG6/EDWR/II4YRTDU/FG6EDWRII4YRTDU.LARGE.jpg"], "step_title": "Step 5: Cutting"}, {"step": 6, "steps_text": "Once the glue is try for the bottom feet, grab your favorite color spray paint and make your new card holder pretty. Or go crazy and add hand drawn art, beads, wire, steam punk... those actually sound cooler, do those. After the paint is dry, take an old rewards card you have laying around and test fit all of the slits. I whipped up a quick demonstration to show how much space the card holder saves. It can also be picked up and moved much easier. In a pinch for space?  Lay the card holder on the board and just move them when you need to for ship movement.Hopefully this will give you ideas. Fill the comments with your improvements!", "step_imgs": ["https://cdn.instructables.com/FZX/B6II/II4YRTF0/FZXB6IIII4YRTF0.LARGE.jpg", "https://cdn.instructables.com/FDW/M3FD/II4YRTGU/FDWM3FDII4YRTGU.LARGE.jpg", "https://cdn.instructables.com/FY6/X805/II4YRTHF/FY6X805II4YRTHF.LARGE.jpg", "https://cdn.instructables.com/FZ9/WGM4/II4YRTKW/FZ9WGM4II4YRTKW.LARGE.jpg", "https://cdn.instructables.com/F6C/UMAD/II4YRTLK/F6CUMADII4YRTLK.LARGE.jpg"], "step_title": "Step 6: Finishing Touches "}], "channel": "Table Top"}, {"category": "play", "description": "This Instructable shows how to install and use a mod I wrote that lets you control Minecraft with python scripts. I'll focus on Windows, though OS X and Linux should work just as well.Python scripts can generate neat in-world things, and there are many examples on the web. With a few lines you can draw a giant glass sphere, and with a bit more work make a giant Sierpinski triangle in the sky and even import obj files like a space shuttle. I myself made fun scripts to draw a water-filled glass donut and a gigantic Klein bottle, to turn everything around into TNT and to control Minecraft with your brain using a MindFlex EEG toy. There is a whole book introducing programming using python scripts for Minecraft, and you can even make simple Minecraft-based games. I will also show how to do simple (and sometimes more elaborate) turtle-based drawings in Minecraft, while you can ride along with the drawing as the turtle.For a while now you could write python scripts for Minecraft on the Raspberry Pi. I wanted my kids to be able to do that, but we don't have a Pi, plus it would be nice to do this with the full desktop Minecraft. You could run your own server with the Raspberry Juice plugin which enables most of the python scripts to work. But not everyone wants to install and configure a server. So I wrote the Raspberry Jam Mod for Minecraft 1.8 (now ported to 1.8.8, 1.8.9 and 1.9 as well) that emulates most of the Raspberry Pi Minecraft protocol (about the same as the Raspberry Juice plugin provides) and lets Raspberry Pi python scripts run with full desktop Minecraft. (I later found out that someone wrote the mcpiapi mod for Minecraft 1.7.10 a couple of weeks earlier.) I wrote this Instructable initially for Python 2.7, but I think most of my samples will work for 3.x.I assume that you have basic facility with creating folders and downloading, unzipping, and copying files on Windows (or your operating system of choice).You can create Python scripts for Minecraft with a text editor, the IDLE environment which comes with Python, or with Visual Studio Python Tools on Windows. The last is actually the nicest in some ways, so I'll have some optional steps on how to do that.This summer I plan to teach coding and basic 3D geometry to gifted middle- and high-schoolers using Minecraft, Raspberry Jam Mod, Python and Visual Studio.If you want to do this with Minecraft Pocket Edition on Android instead, I have an Instructable for that, too.", "title": "Python Coding for Minecraft", "url": "https://www.instructables.com/id/Python-coding-for-Minecraft/", "section": "play", "steps": [{"step": 1, "steps_text": "The Forge manages Minecraft mods, and is needed for the Raspberry Jam Mod.I assume you have Minecraft installed.You need to run Minecraft 1.8/1.8.8/1.8.9/1.9 once (your choice of version). To do that, start the Minecraft Launcher, and after logging in, click on New Profile. Set the profile name to anything you want (e.g., \"Test of 1.8\") and then go to \"Use version\" and select \"Release 1.8.x/1.9\". Then click on \"Save Profile\", make sure the new profile is selected in the launcher, and click on \"Play\". Start a world and make sure it works.         Exit Minecraft and Minecraft Launcher.        Download Forge installer for your version.  Run the Forge installer. Default settings should work.        Start Minecraft. You will now have a new Forge profile.", "step_imgs": ["https://cdn.instructables.com/FDK/YQFI/I916HC9G/FDKYQFII916HC9G.LARGE.jpg", "https://cdn.instructables.com/FW6/UVHV/I7MXZ8VK/FW6UVHVI7MXZ8VK.LARGE.jpg", "https://cdn.instructables.com/F3W/2QU1/I7MXZ9F2/F3W2QU1I7MXZ9F2.LARGE.jpg"], "step_title": "Step 1: Install Forge for Minecraft"}, {"step": 2, "steps_text": "If you have Windows, once you have Forge, you can install everything using a Windows installer. This will install RaspberryJamMod, a Python interpreter, IDLE for Python and sample scripts. If you don't have Windows, or want more control, look at the next two steps (but you'll have to adapt them if you don't have Windows).", "step_imgs": ["https://cdn.instructables.com/F4K/2LXL/IRKFJXVN/F4K2LXLIRKFJXVN.LARGE.jpg"], "step_title": "Step 2: Windows Installer [automatic Install]"}, {"step": 3, "steps_text": "You need to decide if you want Python 2.7 or Python 3.x. The Adventures in Minecraft book uses 2.7, and most of the scripts floating around the web are for 2.7, but I have converted a lot of scripts for 3.x.1. Download your choice of Python installed from here. 2. Run the installer. 3. Click through to the Customize Python dialog, and make sure to scroll down to \"Add python.exe to path\", click on it and select \"Will be installed on local hard drive.\" If you don't add Python to the path, you won't be able to launch scripts with /python from within Minecraft.", "step_imgs": ["https://cdn.instructables.com/F2E/U1X3/I7RGG0J0/F2EU1X3I7RGG0J0.LARGE.jpg"], "step_title": "Step 3: Install Python [manual Installation]"}, {"step": 4, "steps_text": "1. Create a mods folder in your Minecraft folder. (To do that, press Windows-R, type %appdata%\\.minecraft, press enter. You will see everything in your Minecraft folder. If you already have a mods subfolder, you don't need to do anything. Otherwise, make one. On Windows 8, click on New folder, and then type in the name mods and press enter.)2. Download the mods.zipfile from the latest version of the Raspberry Jam Mod. Put the contents of the zip file (currently consisting of a number of folders with names like 1.8 and 1.10.2) inside the mods folder you had just made.3. Download the latest zip file containing sample Python scripts and the mcpi library from my Raspberry Jam Mod github release. (The scripts are supposed to work on both Python 2.7 and 3.x.)4. Open the downloaded zip file (in Chrome, by clicking on it at the bottom of the window). It has a mcpipy folder. Copy the mcpipy folder into your Minecraft folder. (To do that, click once on the mcpipy folder in the zip file, and press ctrl-c, then navigate to the %appdata%\\.minecraft folder as in step 1, and press ctrl-v).", "step_imgs": ["https://cdn.instructables.com/FX9/A02I/I7RGG177/FX9A02II7RGG177.LARGE.jpg", "https://cdn.instructables.com/FWJ/8N6D/I7RGG1D0/FWJ8N6DI7RGG1D0.LARGE.jpg", "https://cdn.instructables.com/FCN/1IXR/IMCB4XDT/FCN1IXRIMCB4XDT.LARGE.jpg", "https://cdn.instructables.com/FZK/4F8Y/I7RGG28P/FZK4F8YI7RGG28P.LARGE.jpg"], "step_title": "Step 4: Install Mod and Scripts"}, {"step": 5, "steps_text": "Start Minecraft, making sure that you use the Forge profile.Create a new world (it's too easy to mess things up with the python scripts). My daughter suggested I use Creative and Superflat. In Minecraft, type /py donut and press enter.If all goes well, a giant glass donut will be drawn around you, and then it will be filled with water.If you get something like a Script not found error, this probably means that you don't have the sample scripts installed in the %appdata%\\.minecraft\\mcpipy folder.If you get a 'Cannot run program \"python\"' error, you don't have your python directory in your system path. You may want to add it manually to the path, or just reinstall python, following the directions in Step 3 of my python install step.Running a new script with /py stops any earlier scripts running (if you don't like that, use /apy instead of /py). You can stop a script that's running by just typing /py without any arguments.", "step_imgs": ["https://cdn.instructables.com/FOH/5M17/I7RGG36T/FOH5M17I7RGG36T.LARGE.jpg", "https://cdn.instructables.com/FKZ/L8M9/I7RGG3GS/FKZL8M9I7RGG3GS.LARGE.jpg"], "step_title": "Step 5: Testing Mod"}, {"step": 6, "steps_text": "The easiest way to get started programming Minecraft in python is to start with one of the simpler sample scripts. I recommend making a shortcut on your desktop to the scripts folder (%appdata%\\.minecraft\\mcpipy). You can load the scripts into IDLE. A fun script to modify is my water-filled donut script (donut.py). For instance, change WATER to GRASS in the second last line to make a silly grass-filled donut. You can run this with /py donut from Minecraft, or just by pressing F5 in IDLE.Or to make a simple new script, create a helloworld.py file with your favorite text editor (even Notepad) in the scripts directory. Put at the top:from mine import *This imports the needed library code. It also conveniently imports all the functions from the math library as well as names for all the blocks. Connect to Minecraft with:mc = Minecraft()You can then send a \"Hello world!\" message to the user with:mc.postToChat(\"Hello world!\")If you want to create a diamond block right under the player, you can also do:playerPos = mc.player.getPos()\nmc.setBlock(playerPos.x,playerPos.y-1,playerPos.z,block.DIAMOND_ORE)The coordinates for setBlock() and getPos() are measured from the player's spawn point (which is thus (0,0,0)).(For a list of all the block names other than DIAMOND_ORE, see mcpi\\block.py in the scripts folder. You can also directly use Minecraft block numbers.)To run your script, save it and type /py helloworld in your Minecraft world and press enter.It's sometimes useful to set a whole rectangular prism of blocks at one time: use mc.setBlocks(). For instance, this excerpt from my mengersponge.py script draws an 81x81 cube at the player position (the script then recursively deletes--i.e., replaces with AIR--subblocks to form the fractal image in the screenshot):length = 3*3*3*3\nmc.setBlocks(playerPos.x,playerPos.y,playerPos.z,\n             playerPos.x+length-1,playerPos.y+length-1,playerPos.z+length-1,block.WOOL_PURPLE)Technical note: Starting with from mine import * imports a lot of stuff (Minecraft, block definitions, entity definitions, math) into our namespace. This is handy for focusing on the essentials for beginners (remember that I am going to be using this to teach coding to beginners). More advanced users may prefer being more pythonic by keeping the namespaces separate and putting in the header:import mcpi.minecraft as minecraft\nimport mcpi.block as block\nimport mcpi.entity as entity\nimport mathand then starting with mc = minecraft.Minecraft() or even mc = minecraft.Minecraft.create().", "step_imgs": ["https://cdn.instructables.com/FSG/01E8/I7RGG6GN/FSG01E8I7RGG6GN.LARGE.jpg", "https://cdn.instructables.com/FU4/PT7Z/I7RGG6XQ/FU4PT7ZI7RGG6XQ.LARGE.jpg", "https://cdn.instructables.com/FXH/QPTG/I7RGG6XR/FXHQPTGI7RGG6XR.LARGE.jpg", "https://cdn.instructables.com/F99/5X1Q/I916HBFJ/F995X1QI916HBFJ.LARGE.jpg", "https://cdn.instructables.com/FBP/7IZY/IA3YJVAY/FBP7IZYIA3YJVAY.LARGE.jpg"], "step_title": "Step 6: Getting Started Programming Minecraft in Python"}, {"step": 7, "steps_text": "A particularly simple way to draw in Minecraft is to use a turtle-based system. I made a very simple Turtle class (inspired by Martin O'Hanlon's MinecraftTurtle class) that I use to introduce middle- and high-schoolers to Minecraft python scripting. Start up a Minecraft world in creative mode, and make your player fly (double-tap spacebar). Initialize the script with:from mineturtle import *\nt = Turtle()(I wrapped all the Minecraft connection code inside the Turtle class and it also brings math into the namespace for convenience.) You can now do things like t.go(15) to draw a line while moving 15 blocks forward, t.right(45) to rotate 45 degrees to the right, t.down(30) to rotate 30 degrees down, and thus draw simple pictures. You move along with the turtle as it draws, which is fun, and the turtle starts off where the player is, pointing horizontally.For instance you can draw a horizontal square with:t.go(50)\nt.right(90)\nt.go(50)\nt.right(90)\nt.go(50)\nt.right(90)\nt.go(50)\nYou do a 7-sided star by doing:t.go(50)\nt.right(180.-180./7)seven times. Or just once in a loop:for i in range(7):\n    t.go(50)\n    t.right(180.-180./7)You can change materials with penblock(). For instance, a golden vertical star:t.penblock(block.GOLD_BLOCK)\nfor i in range(7):\n    t.go(50)\n    t.right(180.-180./7)And you can change the pen width with penwidth(x). For instance, this draws a very simple glass donut (actually, a thickened 90-gon, but who can tell the difference?):t.penblock(block.GLASS)\nradius = 20\ncircumference = 2 * radius * pi\nt.penwidth(10)\nfor i in range(90):\n    t.go(circumference/90)\n    t.left(360/90)Here are all the methods available:go(x): move x blocks forward (drawing if pen is down)                 back(x): move x blocks backward (drawing if pen is down)                 penup(): pause drawing resume drawing  left(angle): rotate left by angle (in degrees)                 right(angle): rotate right by angle (in degrees)                 up(angle): rotate up by angle (in degrees); beginners should not mix the left/right and up/down rotations or they may get unexpected results (technical note: the same as pitch(angle))         down(angle): rotate down by angle (in degrees) (technical note: the same as pitch(-angle))         pendelay(x): each movement or rotation of the turtle is delayed by x seconds; default is 0.05; set to zero for much faster drawing (the player will still move with each line drawn, but instantaneously from beginning to end)                 angle(x): set horizontal angle to x (clockwise in degrees; 0 = South, 90 = West, 180 = North, 270 = East); resets roll angle         verticalangle(x): set vertical angle to x (in degrees; upward is positive; 90 = vertically up; -90 = vertically down); resets roll angle         angles(compass,vertical,roll): set compass, vertical and roll angles; omitted arguments are taken to be zero    penblock(x): set material for drawing to block x; for a list of the predefined blocks, see mcpi/block.pygoto(x,y,z): set pen position to (x,y,z); you can also access the position as t.position.x, t.position.y and t.position.zfollow(): the player follows the turtle              nofollow(): the player doesn't follow the turtle            turtle(x): if x is PLAYER, this is the same as follow(), and if x is None, this is the same as nofollow(). If you are using Raspberry Jam Mod you can also use other entities than yourself as the turtle. For instance, turtle(HORSE) spawns a horse to use as a turtle (all the entities available are listed in mcpi/entity.py, but the living ones are best as others are unable to levitate; and the Ender Dragon cannot be controlled). The entity remains once the script is finished. To make it disappear, call turtle(None) or turtle(PLAYER).           penwidth(x): set stroke width to x (default is 1; wider strokes slow down drawing, and if follow mode is on, you may end up trapped inside the stroke, so at the end you should call penup() and back out of the drawing)         pitch(x), yaw(x) and roll(x): rotate turtle via pitch/yaw/roll angles (see next step of Instructable)       startface() and endface(): start and finish drawing a filled convex polygon      push() and pop(): save and restore drawing state (heading, material, face status, thickness; but not speed or turtle type); useful for L-systemsgridalign(): align the current position and turtle direction to the grid (the best approximation to the turtle's current direction is chosen)The mcpiapi mod, unlike my Raspberry Jam Mod, doesn't support setting the player's direction. This means that the player won't face the same direction as the turtle. (And there is some chance of other problems with turtle scripts.)Technical note: If you already have a Minecraft object mc, initialize with t = Turtle(mc). If you omit the Minecraft object when initializing the turtle, it's created for you, and in either case, you can access the Minecraft object via t.mc.You can also play with python code for controlling the turtle right from the Minecraft chat window.In Minecraft, run the turtleconsole.py script by typing: /py turtleconsole [enter].Then every python line you enter into chat will get executed by the python interpreter. To enter a line into chat, press T, type the line and press [enter]. To exit turtleconsole, just type /py [enter] or enter quit() [enter] into chat.The context includes a local variable t initialized to a Turtle() object, so you don't need to run any initialization code, just things like:t.penblock(block.GOLD_BLOCK)\nt.back(10)There is also a console for the full non-Turtle API: console.py (which includes a pre-initialized mc local variable). (Just don't put in any postToChat() calls, or they will confuse the interpreter.)", "step_imgs": ["https://cdn.instructables.com/F70/I5A2/I9P1V3AT/F70I5A2I9P1V3AT.LARGE.jpg", "https://cdn.instructables.com/FM6/MXS6/I9Q9MGK2/FM6MXS6I9Q9MGK2.LARGE.jpg", "https://cdn.instructables.com/F9F/XQDI/I9TR6A8R/F9FXQDII9TR6A8R.LARGE.jpg", "https://cdn.instructables.com/F2S/IZDI/I9Q9D8A2/F2SIZDII9Q9D8A2.LARGE.jpg", "https://cdn.instructables.com/FDC/8MDT/I9Q9D8A5/FDC8MDTI9Q9D8A5.LARGE.jpg"], "step_title": "Step 7: Simple Turtle-based Drawing"}, {"step": 8, "steps_text": "Using the left(), right(), up() and down() methods for the turtle is easy. But for some drawings we need more sophisticated 3D control. For instance, you might want to draw a donut tilted 45 degrees up. It's tempting to take the glass donut script from the previous step, and add before the loop:t.up(45) But that produces an unexpected result--see the picture. The reason for this is that the turtle will be climbing up all the time, while the d.left() method rotates it around the vertical axis, and so you get a spiral.Instead, what we need to do is yaw/pitch/roll rotatins of the turtle. See the picture from NASA (US government works are public domain) explaining how the three angles go, and just imagine that the airplane is your turtle. (Unfortunately, because of Minecraft limitations, the roll angle doesn't affect how the turtle looks or the point of view from which you're viewing.)  What we need to do to draw our sideways donut is first roll our turtle by 45 degrees with t.roll(45), and then when drawing the donut use t.yaw(-angle) instead of t.left(angle). The revised code is in the screenshot.What's nice about the yaw/pitch/roll rotations is that they are always relative to where the turtle is pointing, while left() and right() are relative to the Minecraft world.Finally, here is a much more advanced example. Let's draw a tree. This involves making a recursive function. Start with this to ensure that the drawing is done as fast as possiblefrom mineturtle import *\nt = Turtle()\nt.pendelay(0)\nt.turtle(None)Now we do our recursive tree function. The basic idea behind this is that a branch is just a smaller tree. So we make a function that takes a counter and a branch length. The counter specifies how many iterations the tree will go. For instance, counter=1 means just the trunk will be drawn, and counter=1 means the trunk and one set of branches will be drawn. def tree(counter,branchLen):\n  if counter == 0:\n    return\n  t.go(branchLen)\n  for i in range(4):\n    t.pitch(30)\n    tree(counter-1,branchLen*0.75)\n    t.pitch(-30)\n    t.roll(90)\n  t.back(branchLen)First, the code checks if our counter has run down to zero. If so, we don't have anything to draw. Then we draw a trunk. Then we draw four branches sticking out of it with a simple loop. To design this bit of code, I just imagine myself as the turtle, having just moved up along the trunk. To draw a branch, I tilt my self up by 30 degrees (i.e., t.pitch(30)) and draw a new tree of smaller size: its counter is less by one, and its trunk will be 3/4 of the length of my current trunk. I think tilt myself back down by 30 degrees. I rotate myself by 90 degrees and repeat the exercise. Finally, once I'm done with the branches, I go back down the trunk.Finally, I just need to invoke this code. I will make a tree with a counter of 6 and an initial branch length of 20. And for good measure, I'l make it out of wood, and of course vertically upward:t.penblock(block.WOOD)\nt.verticalangle(90)\ntree(6,20)This fractal tree doesn't look very realistic. We should make the trunk thick and the branches get thinner and thinner as they go outward (say, get half as thick, until they reach a single block), and we should switch from WOOD to LEAVES blocks as we go out. But most of all, real trees aren't that regular. We need some randomness. The simplest form of randomness is just to give each branch a chance of failing to grow, say a 20% chance. I implemented all of these in my fancytree.py script. The resulting tree looks surprisingly realistic for something produced by such a relatively simple piece of code. A funny side-effect of how I implemented it is that there is a 20% chance that nothing will be drawn--i.e., the tree has a chance of failing to grow, which is also realistic. And each time you run the script, you get something different. Another useful feature of the turtle drawing class is being able to draw not just lines but polygonal surfaces. To do this, just do t.startface(), draw your surface, and then do t.endface(). Once you're in face mode, each time you draw a line, the code actually draws a triangle: one vertex is the point the turtle was when t.startface() was called and the line is the opposite edge. This draws a pentagon tilted on its side by 45 degrees:t.roll(45)\nt.startface()\nfor i in range(5):\n  t.go(20)\n  t.yaw(360/5)\nt.endface()", "step_imgs": ["https://cdn.instructables.com/FJC/7QQ1/I9UDOQTA/FJC7QQ1I9UDOQTA.LARGE.jpg", "https://cdn.instructables.com/F4T/8APQ/I9UDOCSH/F4T8APQI9UDOCSH.LARGE.gif", "https://cdn.instructables.com/FON/NHL0/I9UDOYAV/FONNHL0I9UDOYAV.LARGE.jpg", "https://cdn.instructables.com/FB3/J19W/I9UDP9I7/FB3J19WI9UDP9I7.LARGE.jpg", "https://cdn.instructables.com/FWM/XKSJ/I9UDOC6V/FWMXKSJI9UDOC6V.LARGE.jpg", "https://cdn.instructables.com/FHG/Y0OR/I9YBZDRA/FHGY0ORI9YBZDRA.LARGE.jpg"], "step_title": "Step 8: Advanced Turtle-based Drawing"}, {"step": 9, "steps_text": "Draw a triangle. Now take each line of the triangle and replace it by a line with a triangular bump on it. Repeat. Like on the animated image (public domain, based on Wikipedia), you get a Koch snowflake. This can be modeled by a super-simple turtle-graphics program. Imagine that F means \"draw forward\", and \"+\" and \"-\" turn by 60 degrees, counterclockwise and clockwise, respectively. Then the initial triangle can be drawn by:F++F++FI.e., go forward, turn right by 120 degrees, then go forward, turn right by 120 degrees, go forward.The triangular bump line can be drawn by:F-F++F-FSo here's how we can generate a snowflake. We take the initial turtle program F++F++F to draw a triangle. Each F in it represents a line. So replace each F by F-F++F-F. If we keep on going, we generate the Koch snowflake.This is a simple example of an L-system. The idea behind an L-system is that we start with a string of characters (in this case F++F++F), and then a bunch of rules how to change the characters (in this case, the one rule to replace F with F-F++F-F) in each iteration. We apply this a bunch of times and we get a rather complicated string. For instance, after two iterations in the snowflake case, we get:F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-FAfter four, we get the image above. (To really get a fractal, the lines should shrink with each iteration, but that won't work in Minecraft.)There is a lot of really good information in this free PDF book.I wrote a very simple lsystem.py module. To implement the snowflake, start with boilerplate:import lsystem\nfrom turtle import *\nt = Turtle()\nt.pendelay(0)\nt.penblock(block.GOLD_BLOCK)Now we need to define the rules. I define the rules by a python dictionary:rules = { 'F': 'F-F++F-F' }Next we define the axiom, or starting point:axiom = 'F++F++F'Finally we need to tell the system what each of the symbols in the strings mean. For different L-systems, we will assign different meanings to them (rotations by different angles, for instance). So we need a second python dictionary specifying what is done for each symbol. If you don't specify an action for a symbol, the symbol is ignored when it is time for the turtle to draw the output (but it might be important for the generation). The meanings are given by a dictionary that specifies a function to call for each symbol. One-line functions can be specified with the lambda operator. In this case, all the functions are one-liners:dictionary = {\n  'F': lambda: t.go(2),\n  '+': lambda: t.yaw(60),\n  '-': lambda: t.yaw(-60)\n}Finally we invoke the L-system, specifying how many iterations (in this case 4):lsystem.lsystem(axiom, rules, dictionary, 4)There is one special trick for some L-systems. These L-systems are grid-aligned, with all the rotations being 90 degrees. The square curve (squarecurve.py) and dragon curve (dragoncurve.py) are nice examples. The trick is to call, somewhere near the beginning of your code:t.gridalign()This moves your turtle to an integer grid location, and aligns its heading to a grid direction. After this, the turtle will remain exactly grid aligned provided that you move it only by integer amounts (e.g., 7, not 7.1, and not even 7. or 7.0 as these are floating point in Python), and you rotate only by integer amounts that are multiples of 90 degrees (e.g., -180, or 90, but not 90.0 or 45). The dragon curve code also gives an example of a forward function that is a bit more complicated--instead of just a line, it draws a wall with an opening in it.Actually, calling gridalign() can sometimes be a good idea even if not all of your angles are right angles. You will probably get some round-off problems in a large image, but it can still look better. See the spacefilling curve example (rendered in purple stained glass!).L-systems don't have to be two-dimensional. You can include symbols that do yaw, pitch and roll rotations. For designing trees, a useful trick is to have stack commands: '[' to save the current drawing state to a stack and ']' to restore it. This will use the turtle module's push() and pop() methods. For instance, here's a snippet of code for drawing a simple tree (ltree.py):t.pitch(90)\nrules = { 'L':'[^FL]>[^FL]>[^FL]' }\naxiom = 'FL'\ndictionary = {\n  'F': lambda: t.go(10),\n  '^': lambda: t.pitch(20),\n  '>': lambda: t.roll(120),\n  '[': lambda: t.push(),\n  ']': lambda: t.pop()\n}\nlsystem.lsystem(axiom,rules,dictionary,5)\nThink of the L as a leaf (though this simple code doesn't actually draw the leaf--that would need to be added to the dictionary). We start with FL, which is a trunk plus a leaf. Then we replace each leaf by [^FL]>[^FL]>[^FL]. This is a set of three branches, each tilted by 20 degrees from the trunk, 120 degrees apart. The brackets ensure that after each new ^FL is drawn, we're back where we were before it. This repeats, so that the leaves on the branches are replaced by triples of branches, and so on.A more realistic tree could have more complex code for '['. It could make the succeeding branches shorter and thinner, and change their material as we get closer to the leaves (and then restore on ']'). I include such a tree as the demo code in lsystem.py, based on rules (with some tweaks) from the Geeky Blogger.You can also do grid-aligned 3D things. For instance, hilbert.py has a 3D Hilbert curve.Finally, you might want to introduce some randomization into the L-system rules. So far our rules were deterministic: a single string was given that replaces a symbol, e.g., 'F': 'F-F++F-F'. But instead of a simple replacement string, one can give a Python list of pairs (p,string), where p is a probability (from 0 to 1) and string is the string to use with that probability. The probabilities for a given source symbol had better not add up to more than 1, but they can add up to less than one--in that case, there is a chance that there will be no replacement. For instance, here's a slightly randomized version of geeky.blogger's tree:rules = {'A': [(0.55,'^f[^^f>>>>>>A]>>>[^^f>>>>>>A]>>>>>[^^f>>>>>>A]'),\n               (0.25,'^f>>[^^f>>>>>>A]>>>[^^f>>>>>>A]')]}This rule has a 55% chance of replacing an A with a three-branch structure, and a 25% chance of replacing it with a two-branch structure. This isn't very random--more randomness would make things even more lifelike. I attach a screenshot of a fairly sparse forest randomly generated using this rule (and random placement of trees, subject to a minimum distance).", "step_imgs": ["https://cdn.instructables.com/F99/YBVA/IA2K5Z1J/F99YBVAIA2K5Z1J.LARGE.gif", "https://cdn.instructables.com/FPJ/94O2/IA2K65P0/FPJ94O2IA2K65P0.LARGE.jpg", "https://cdn.instructables.com/FHF/N5K2/IA2K6D46/FHFN5K2IA2K6D46.LARGE.jpg", "https://cdn.instructables.com/F6E/Q03J/IA1IXIPY/F6EQ03JIA1IXIPY.LARGE.jpg", "https://cdn.instructables.com/FZG/G6F5/IA2K6GW9/FZGG6F5IA2K6GW9.LARGE.jpg", "https://cdn.instructables.com/FK6/SQWX/IA0WIII8/FK6SQWXIA0WIII8.LARGE.jpg", "https://cdn.instructables.com/FKV/IRGA/IA2K6JPJ/FKVIRGAIA2K6JPJ.LARGE.jpg", "https://cdn.instructables.com/FMN/1OJZ/IA3YLOJR/FMN1OJZIA3YLOJR.LARGE.jpg", "https://cdn.instructables.com/FHZ/36KL/IA3YUYJJ/FHZ36KLIA3YUYJJ.LARGE.jpg"], "step_title": "Step 9: L-system Fractals With Turtle Graphics"}, {"step": 10, "steps_text": "I also made a simple class for drawing with Cartesian coordinates. You can initialize with:from drawing import *\nd = Drawing()(This initializes the Minecraft connection and brings math and block names into the namespace.) Then you have several convenience methods:d.penwidth(x): sets thickness of points/lines/faces    d.line(x1,x2,x3,y1,y2,y3,block): draws line from (x1,x2,x3) to (y1,y2,y3) made from the block material    d.face(vertexlist,block): draws a face with the vertices in the vertexlist made from the block materialFor instance, you can do a rectangle sloped at 45 degrees made of glass at level 0 at the spawn point with:d.face([(0,0,0),(0,10,10),(10,10,10),(10,0,0)])For fun, I adapted Simon Tatham's really neat polyhedron generation code to use the Minecraft drawing class. His code starts with a number of random points on a sphere, and then simulates them repelling themselves until they stabilize into a configuration that is often regular. Then he has two neat methods of making a polyhedron out of these points, a face method and a vertex method. I put this in polyhedron.py. This script takes commandline arguments. For instance, to draw an icosahedron use 12 points and the vertex construction. Directly from Minecraft:/py polyhedron 12 vertexFor an dodecahedron, change vertex to face. You can also add one more argument for size. The polyhedron will be made of glass with stone edges and will be centered around the player.Technical note: If you already have a Minecraft object mc, initialize with d = Drawing(mc). In either case, you can access the Minecraft object via d.mc.", "step_imgs": ["https://cdn.instructables.com/FTL/B2VB/I9YBZHEG/FTLB2VBI9YBZHEG.LARGE.jpg", "https://cdn.instructables.com/FF7/T76H/I9YBZLIZ/FF7T76HI9YBZLIZ.LARGE.jpg"], "step_title": "Step 10: Cartesian Drawing"}, {"step": 11, "steps_text": "Minecraft normally pauses the game and goes to the Game menu when you alt-tab out of it or otherwise lose focus. This makes it harder to see what your python scripts are doing if you're launching them from outside of Minecraft. To do that, you can edit the options.txt file in your Minecraft directory (%appdata%\\.minecraft on Windows), change the pauseOnLostFocus:true line topauseOnLostFocus:falseand then save, and restart Minecraft.This is particularly nice for running python scripts interactively. In the screenshot, I am playing with Michael O'Hanlon's 3D turtle drawing (and, yes, that's Deep Space Nine in the background).", "step_imgs": ["https://cdn.instructables.com/FQU/HUTG/I9P1TJOI/FQUHUTGI9P1TJOI.LARGE.jpg", "https://cdn.instructables.com/F8L/WKEU/I9P1TJNJ/F8LWKEUI9P1TJNJ.LARGE.jpg", "https://cdn.instructables.com/FW1/C69Z/I9P1TNTC/FW1C69ZI9P1TNTC.LARGE.jpg"], "step_title": "Step 11: Optional: Disable Pause on Loss of Focus"}, {"step": 12, "steps_text": "There are basically two different techniques for drawing mathematically defined objects with a python script in Minecraft.One way is to define a solid object by an inequality. For instance, a sphere centered on (x0,y0,z0) with radius r can be defined by the inequality:(x-x0)**2 + (y-y0)**2 + (z-z0)**2 <= r**2(I.e., the distance to (x0,y0,z0) is at most r.) So to draw a sphere, just loop through all points (x,y,z) in a cube of side-length 2*r+1 surrounding (x0,y0,z0), and draw a block if the above inequality holds. I learned this technique from the sample nt7s_sphere.py script. Start with the standard header and init Minecraft connection code:from mine import *\nmc = Minecraft()\nThen just do:radius = 8\nplayerPos = mc.player.getPos()\nfor x in range(radius*-1,radius):\n  for y in range(radius*-1, radius):\n    for z in range(radius*-1,radius):\n      if x**2 + y**2 + z**2 < radius**2:\n        mc.setBlock(playerPos.x + x, playerPos.y + y + radius, playerPos.z - z - 10, block.GLASS)This draws a sphere of the specified radius above the player, and a little offset in the z-direction.I use the same technique, but with a more complicated formula, in my donut.py script (yes, this is more complicated than the turtle-based method):for x in range(-R-r,R+r):\n     for y in range(-R-r,R+r):\n        xy_dist = math.sqrt(x**2 + y**2)\n        if (xy_dist > 0):\n           ringx = x / xy_dist * R # nearest point on major ring\n           ringy = y / xy_dist * R\n           ring_dist_sq = (x-ringx)**2 + (y-ringy)**2\n           for z in range(-R-r,R+r):\n               if (ring_dist_sq + z**2 <= r**2):\n                  mc.setBlock(mcx+x, mcy+z, mcz+y, mcblock, mcmeta)While the inequality technique works best for solid shapes, you can use it for hollow shapes in two ways. One way is to use two inequalities, for instance in the case of the sphere one to make sure that we're within the outer radius of the center and another to make sure we're not closer than the inner radius. The other way is just to draw another object with smaller dimensions made out of air inside the larger solid object, much as in my donut.py script, I initially draw a glass donut, and then replace the inside of it with water.", "step_imgs": ["https://cdn.instructables.com/FNM/67HD/I7RGGFW8/FNM67HDI7RGGFW8.LARGE.jpg"], "step_title": "Step 12: Advanced Notes 1: Drawing Objects Defined by an Inequality"}, {"step": 13, "steps_text": "One can also draw a surface by parametrizing it with two parameters, say a and b, and then looping over a range of these parameters, setting blocks where needed. In my Klein bottle and Mobius strip scripts, I have a general draw_surface() method that lets one do this. For instance, the Mobius strip (see my mobius.py script) is defined by the three formulae:x = (3 + a * cos(b/2)) * cos(b)\ny = a * sin(b/2)\nz = (3 + a * cos(b/2)) * sin(b)with a ranging from -1 to 1 and b ranging from 0 to 2*pi (yet another reason why this can be in the pi/e contest?). You can think of b as defining the angle around the circuit, and a moving one from one edge to the other.Using scripts like this, you need to ensure that in your loops over a and b, the steps are sufficiently small that there are no gaps in the surface. Unless that's the effect you're after.For details and examples see mobius.py, klein.py and klein2.py.", "step_imgs": ["https://cdn.instructables.com/FPZ/HM4P/I7RGGHSV/FPZHM4PI7RGGHSV.LARGE.jpg", "https://cdn.instructables.com/FBO/L5Y1/I7RGG0F1/FBOL5Y1I7RGG0F1.LARGE.jpg"], "step_title": "Step 13: Advanced Notes 2: Drawing an Object Defined by a Parametric Surface"}, {"step": 14, "steps_text": "You can find parametric equation for knots on the net. This time, we're going to do things slightly different from before. Before, we had loops driving calls to mc.setBlock() directly. But in our surface plots, such as the Klein bottle, often the same block would get drawn multiple times, which is slow and inefficient. A better way is to keep track of the set of exact blocks that were already drawn to avoid redoing the same thing.Let me go through an example like that (in knot.py) to draw a knot. Start with a standard header like:from mine import *\nWe now need to generate our knot. I used the cinquefoil formulas from here. This requires looping a parameter t from 0 to 2*pi, with small enough steps to ensure we don't have gaps. I used 10000 steps. Since this is done in-memory, and computers are fast, and overlapping blocks are only sent once to Minecraft, it's easier to easier to do more steps than to think how many is enough. It's important for the coordinates that go in the dictionary to be integers so we can tell that the same block is being drawing (a block at (1.1,1.2,1.4) and a block at (1,1,1) are the same thing in Minecraft).We first initialize and set the position of the knot relative to the player. Note that the player position need not be an integer (you might not be standing exactly aligned with a block) and should be turned into an integer.mc = Minecraft()\nplayerPos = mc.player.getPos()\nscale = 12\nx0 = int(playerPos.x)\ny0 = int(playerPos.y + 5*scale)\nz0 = int(playerPos.z)Now we make an empty set named done to store the coordinates we've already drawn:done = set()And we draw the set:t = 0\nwhile t < 2*pi:\n  x = x0+int( scale * cos(2*t) * (3 + cos(5*t)) )\n  y = y0+int( scale * sin(2*t) * (3 + cos(5*t)) )\n  z = z0+int( scale * sin(5*t) )\n  if (x,y,z) not in done:\n     mc.setBlock(x,y,z,block.GOLD_BLOCK)\n     done.add((x,y,z))\n  t += 2*pi / 10000This only draws data that isn't already drawn. Note that we need to round off the x, y and z coordinates with the int() function. That's the magic behind the overlap removal: when the rounded coordinates are the same, only one block is drawn. (Note: the double parenthesis in the done.add((x,y,z)) line are due to the fact that what we're adding to the set is the coordinate triple (x,y,z).)The above code is in knot.py.The knot would look better if the rope were thicker. There are many ways one can do that. An inefficient way, but easy since computers are fast these days, is just to draw a little ball instead of a point at each pixel. To do that, first I make a little utility function to draw a ball while checking in the done set to ensure there are no duplicate blocks:def ball(x0,y0,z0,r,block,done):\n  for x in range(-r,r):\n    for y in range(-r,r):\n      for z in range(-r,r):\n         if (x**2 + y**2 + z**2 <= r**2):\n            if not (x0+x,y0+y,z0+z) in done:\n               mc.setBlock(x0+x,y0+y,z0+z, block)\n               done.add((x0+x,y0+y,z0+z))This uses the inequality method to fill in a ball at (x0,y0,z0), of radius r.Then just modify our knot-making while loop to make a ball instead of just a point:scale = 10\nx0 = int(playerPos.x)\ny0 = int(playerPos.y + 5*scale)\nz0 = int(playerPos.z)\ndone = set()\nt = 0\nwhile t < 2*pi:\n  x = x0+int( scale * cos(2*t) * (3 + cos(5*t)) )\n  y = y0+int( scale * sin(2*t) * (3 + cos(5*t)) )\n  z = z0+int( scale * sin(5*t) )\n  ball(x,y,z,4,block.GOLD_BLOCK,done)\n  t += 2*pi / 10000The result is in knot2.py in the sample scripts.Other sample knots are in trefoil.py, trefoil2.py and borromean.py. If you draw with multiple materials, you can use a dictionary in place of a set, or just go sequentially through the different materials and clear the set before each (that's what I do in trefoil2.py and borromean.py).", "step_imgs": ["https://cdn.instructables.com/FNG/N0ZG/I7SVTXXQ/FNGN0ZGI7SVTXXQ.LARGE.jpg", "https://cdn.instructables.com/F9D/8ILL/I7SVTYO9/F9D8ILLI7SVTYO9.LARGE.jpg", "https://cdn.instructables.com/FFT/LSGV/I7MYAEMS/FFTLSGVI7MYAEMS.LARGE.jpg"], "step_title": "Step 14: Advanced Notes 3: Knots"}, {"step": 15, "steps_text": "In another Instructable, I describe how to hack a Mindflex EEG toy to work over Bluetooth. Using python and a modified version of the NeuroPy package, you can now control Minecraft with your brain. Here's how to do it, either with the Mindflex or with a full Mindwave Mobile set. In my example scripts, I do this in the neurosky.py script.Start by importing relevant packages and initializing Minecraft:from mine import *\nfrom NeuroPy.NeuroPy import NeuroPy\nmc = Minecraft()Then connect to the EEG headset. My hacked Mindflex EEG toy connects to my Windows laptop as COM11 and works over 57600 baud. It also needs a special initialization string to be sent to it to switch it to 57600 baud (and raw mode). This was done with:eeg = NeuroPy(\"COM11\",57600,True)If you have an official Mindwave Mobile (or are using Mindflex but left it at 9600 baud), then you can omit the \",True\" part.Now we set up a simple callback routine that will move you upward (this needs Creative mode) when the \"meditation\" value from the eeg (which ranges from 0 to 100) goes above 60, and to move downward when it goes below 40:up = 60\ndown = 40\ndef callback(a):\n    mc.postToChat(a)\n    if a > up:\n       pos = mc.player.getPos()\n       pos.y = pos.y + 1\n       if mc.getBlock(pos.x,pos.y,pos.z) == block.AIR.id:\n          mc.player.setPos(pos)\n    elif a < down:\n       pos = mc.player.getPos()\n       pos.y = pos.y - 1\n       if mc.getBlock(pos.x,pos.y,pos.z) == block.AIR.id:\n          mc.player.setPos(pos)\neeg.setCallBack(\"meditation\", callback)\nFor good measure, I posted the meditation value to chat. Now, all we need to do is start up the EEG and inform the user:mc.postToChat(\"Connecting to EEG\")\neeg.start()\nmc.postToChat(\"To fly up, be meditative\")\n      Finally, we need to keep the script from exiting, by starting an endless loop of sleeping: while True:\n    time.sleep(10)(My neurosky.py script is slightly fancier by letting you select whether to work with the \"meditation\" or the \"attention\" value from the headset. By default it does attention, but /py neurosky m will start it in meditation mode.)Then turn on the headset, and start the script with /py scriptname. To stop the script, do /py again.", "step_imgs": ["https://cdn.instructables.com/FFB/0ACU/I916H832/FFB0ACUI916H832.LARGE.jpg", "https://cdn.instructables.com/FKR/DNMK/I916H8J0/FKRDNMKI916H8J0.LARGE.jpg"], "step_title": "Step 15: Advanced Note 4: Flying With Your Brain"}, {"step": 16, "steps_text": "If you're running on Windows, Visual Studio (I recommend free Visual Studio Express for Desktop 2015) together with the Python Tools is a nice way to develop python code for Minecraft. (But if you used my Windows installer for the mod, you'll need a full official Python installation instead of what I bundled, or else you'll need to use PTVS to set up a custom environment pointed to %appdata%\\.minecraft\\pythonX.)A really useful thing is that Visual Studio's code completion will help you with the Minecraft python api. For instance, when you type \"block.\" it will pop up a list of all the block types (AIR, BED, etc.).Make sure you have installed Python, the mod, and the sample scripts.1. Download and install Visual Studio Community Edition 2013.2. Download and install Python Tools for Visual Studio (PTVS 2.1 VS 2013.msi).3. Start Visual Studio. 4. Click on \"Open Project\", search for your sample scripts folder (%appdata%\\.minecraft\\mcpipy with Raspberry Jam Mod) and load the mcpipy.sln solution.5. In the Solution Explorer window on the right, you can choose an existing script to modify, for instance knot2.py (or you can create a new one by clicking on the bold mcpipy in the Solution Explorer and choosing from the main menu \"Project\", \"Add new item\", and then choosing \"Python\" and \"Empty module\").Now you can edit the script to your heart's content.", "step_imgs": ["https://cdn.instructables.com/F9S/GO9Q/I95GTKU2/F9SGO9QI95GTKU2.LARGE.jpg", "https://cdn.instructables.com/FEN/5UMG/I95GTKU3/FEN5UMGI95GTKU3.LARGE.jpg"], "step_title": "Step 16: Optional: Visual Studio With Python and Minecraft: Getting Started"}, {"step": 17, "steps_text": "Because we set up all the scripts to be part of one project, to run or debug a script, you need to tell Visual Studio which script is the one you want to run. Right click on the script in the Solution Explorer window (if you lose the Solution Explorer, go to the \"Windows\" menu and choose \"Reset Window Layout\") and \"Set as Startup File\".You will also want to have Minecraft running with a world opened, or otherwise your script won't be able to connect to Minecraft.After setting the startup file, you can run by pulling down \"Debug\", and choosing \"Start debugging\" (or just press F5) or \"Start without debugging\" (ctrl-F5). If you choose \"Start debugging\", the script will run much more slowly, but you will have useful debug features, like the ability to pause the script at any time, step through it step-by-step (there are useful buttons on the toolbar), and examine the variables while running (see the \"Autos\" and \"Locals\" boxes).You can also run in debug mode up to a particular line in the script by right-clicking on the line and choosing \"Run to cursor\". This is handy if you know that something is wrong in your script around that line, and you want to have a look at the variables at that point. For instance, if you run the knot2.py script up to around the line that invokes draw_data(), you can see the contents of the knot dictionary that stores the list of blocks to be drawn.", "step_imgs": ["https://cdn.instructables.com/FFK/UCCM/I95GTNQI/FFKUCCMI95GTNQI.LARGE.jpg", "https://cdn.instructables.com/FZ0/Y9SZ/I95GTOVH/FZ0Y9SZI95GTOVH.LARGE.jpg", "https://cdn.instructables.com/FUS/SD09/I95GTKTY/FUSSD09I95GTKTY.LARGE.jpg", "https://cdn.instructables.com/F2B/BO44/I95GTPVK/F2BBO44I95GTPVK.LARGE.jpg"], "step_title": "Step 17: Optional: Visual Studio With Python and Minecraft: Running and Debugging"}, {"step": 18, "steps_text": "The best resource for programming Minecraft in python is the Adventures in Minecraft book by Martin O'Hanlon.O'Hanlon also has a lot of good information on the stuffaboutcode.com site. In particular, he has an API reference here. The Raspberry Jam Mod (and mcpiapi mod) supports just about everything that the Raspberry Juice server plugin does. The real-time working analog clock in the picture above is from one of the stuffaboutcode scripts (sitting above one of my donuts): /py stuffaboutcode_clockA rather cool thing that O'Hanlon did was to write a python script to convert Wavefront  mesh.obj files to Minecraft. I've adapted this to convert 3DS, PLY and binary STL files as well. For instance, you can draw a space shuttle with /py render shuttle (there are .txt files describing the block choices in the mcpipy/models directory; the meshes will automatically be downloaded).", "step_imgs": ["https://cdn.instructables.com/F7G/DQB6/I7RGG8GG/F7GDQB6I7RGG8GG.LARGE.jpg", "https://cdn.instructables.com/FB6/9X4K/I7YLKRE1/FB69X4KI7YLKRE1.LARGE.jpg", "https://cdn.instructables.com/F5F/1YI6/I7YLKRGP/F5F1YI6I7YLKRGP.LARGE.jpg"], "step_title": "Step 18: Additional Resources"}], "channel": "Video Games"}, {"category": "play", "description": "I absolutely love outdoor summer games, but since its winter in Seattle, I wanted to bring one of my favorite games indoors and make it a more apartment-friendly size. I also really like games with high replay value and ones you can play with your friends.\nI don't have access to wood cutting tools, so I needed a material for the playing board that I could cut with an X-Acto knife. I settled on Foamboard for the board instead of wood because it is really easy to cut, inexpensive, and is way more than strong enough for the bean bag board.\u00a0\nThis project is simple to do and took approximately 1 to 1.5 hours.", "title": "Foamboard Desktop Bean Bag Toss", "url": "https://www.instructables.com/id/Foamboard-Desktop-Bean-Bag-Toss/", "section": "play", "steps": [{"step": 1, "steps_text": "\n          There are a few ways that you can customize this so some of the materials are marked as optional.\nI used hot glue to make the bean bags because it is very quick and easy if you use felt. If you don't use felt you may want to use a needle and thread to make the edges look finished.Bean Bags:\n\t\t2 pieces of felt, one of each color. You will only need\u00a01/2 of a sheet of 8.5\" x 11\" felt for four 2\" by 2\" bean bags.\n\t\tHot Glue Gun with\u00a0about\u00a03 sticks of hot glue\n\t\t1/4 cup of rice\n\t\tTeaspoon measure\n\t\tRuler\n\t\tPermanent Marker\n\t\tScissors\n\t\tThread, Pins, and Needle if you are sewing the bean bags\nPlaying Board:\n\t\t1 Foam Board- 16\" x 20\" x 3/16\"\n\t\tX-Acto knife (and you may need an extra blade on hand)\n\t\tX-Acto cutting mat (optional)\n\t\tRulers (You may want a metal-edged ruler as well\u00a0to use with the X-Acto knife\u00a0because X-Acto knives\u00a0sometimes cut into\u00a0plastic rulers.)\n\t\tA Yard Stick\n\t\tHot Glue with about\u00a010 glue sticks\n\t\tGlue stick or crafters glue\n\t\tMasking Tape\n\t\tScotch tape (optional)\n\t\tPermanent marker (a thin marker for marking lines and a thick marker for design if you want them)\n\t\t6-8\u00a0large flat back glass marbles\u00a0", "step_imgs": ["https://cdn.instructables.com/FIT/TCJA/GYVDHXZD/FITTCJAGYVDHXZD.LARGE.jpg"], "step_title": "Step 1: "}, {"step": 2, "steps_text": "The first step is cutting out the Top piece for the board. I settled on a 10\" by 5\" board because it seemed like a good sized target to aim for at the end of a table.\u00a0\nUse a corner of the board to make your measuring easier for the first piece.\u00a0\nThen use your X-Acto knife and a metal edged ruler (if you have one) on top of a cutting mat to cut straight lines down the marked lines on the Foamboard.\u00a0", "step_imgs": ["https://cdn.instructables.com/FRG/37UX/GYQESMDB/FRG37UXGYQESMDB.LARGE.jpg", "https://cdn.instructables.com/FZW/9QSU/GYUQTFWA/FZW9QSUGYUQTFWA.LARGE.jpg", "https://cdn.instructables.com/FBB/BKKB/GYQESMD6/FBBBKKBGYQESMD6.LARGE.jpg"], "step_title": "Step 2: Cutting Out the Top Piece"}, {"step": 3, "steps_text": "The next step is cutting out the Back of the board. 4\" tall seemed to produce a good slope. Since the width of the Top is 5\", the piece you cut out should be 4\"by 5\". You can cut this right next to the cut for the top piece.\u00a0", "step_imgs": ["https://cdn.instructables.com/F7Z/YBXG/GYVDHY17/F7ZYBXGGYVDHY17.LARGE.jpg"], "step_title": "Step 3: Cutting Out the Back Piece"}, {"step": 4, "steps_text": "I used a cup that had a decent sized circle (2.75\" diameter) to trace onto the Top piece of the foamboard. I centered it width wise and placed it in the upper area of the Top piece.\u00a0\nThen you need to cut the circle out of the foamboard. One trick to cut foam board circles is to score the inside of the circle and remove pieces as you go around the circle. This helps you keep the lines crisp around the circle because you have closer beginning and end points to follow.\nAlso, if you are having trouble removing the pieces, flip the Foamboard over and use your X-Acto knife to follow the lines on the paper backing that you can see to release the pie shaped pieces.\u00a0\nAfter you have completely cut out all of the pieces of the circle and made sure the edges are crisp and clean, you can move on to the next step.\u00a0", "step_imgs": ["https://cdn.instructables.com/FYC/TQOI/GYQESMDM/FYCTQOIGYQESMDM.LARGE.jpg", "https://cdn.instructables.com/F8D/DM0T/GYUQTFVY/F8DDM0TGYUQTFVY.LARGE.jpg", "https://cdn.instructables.com/FTS/5Q4P/GYUQTFWD/FTS5Q4PGYUQTFWD.LARGE.jpg", "https://cdn.instructables.com/F23/ICOA/GYUQTFWE/F23ICOAGYUQTFWE.LARGE.jpg"], "step_title": "Step 4: Placing and Cutting the Hole in the Top Piece"}, {"step": 5, "steps_text": "\n          At this point you will want to plug in your hot glue gun and let it warm up to use in the next step.\u00a0\nFor this step, you will need two right-angle triangular Side pieces. I wanted the triangular Side pieces glued on the outside of the Back piece (essentially making the board 3/16\" x 2 wider) so that the seams from the Side pieces and Top piece are visible on the top. This is because I am going to keep the side pieces bare (except for a masking tape trim) and the Top piece is going to be covered with decorative paper anyways. You can see in the first picture that the triangles needs to be 4 and 3/16 of an inch tall to accomodate the width of the Top piece once it is positioned in.\u00a0\nThe approximate measurements for the triangles are 4 3/16\" H x 9.08\" W with a 10\"diagonal. It is okay to be slightly off because you can trim any excess with an X-Acto knife.\nIf you have changed the length of the top piece to your choosing, another way to determine your length for the Side pieces is by using the formula a2+b2=c2. For a right triangle with a height of 4.1875\" and a diagonal of 10 the math would look like this:\u00a0\n\n\t\ta2+b2=c2\n\t\t4.1875+b2 =102\n\t\t17.535+ b2= 100\n\t\tb2= 100-17.535\n\t\tb2=82.465\n\t\tb=9.08\n\tAnd now after you cut out the two triangular Side pieces, you will have all of your pieces ready to assemble.Your hot glue gun should be ready to use now, so on to the next step :)\n\t\u00a0", "step_imgs": ["https://cdn.instructables.com/F5V/AW5U/GYQESMDQ/F5VAW5UGYQESMDQ.LARGE.jpg", "https://cdn.instructables.com/FAD/0T5Q/GYQESMDO/FAD0T5QGYQESMDO.LARGE.jpg", "https://cdn.instructables.com/FLG/2MNY/GYWSZ4KY/FLG2MNYGYWSZ4KY.LARGE.jpg"], "step_title": "Step 5: Warm Up Hot Glue Gun and Cut Out Triangular Side Pieces"}, {"step": 6, "steps_text": "The first pieces to be glued together will be the Back piece and each of the two Side pieces.Make sure you have the 5\" width of the Back piece oriented correctly.\nPlace a thin line of hot glue on the edge of the Back piece, then attach it perpendicularly to the Side piece, keeping edge of the Side piece flush with the rear face of the Back piece (see pictures.) Try to keep the angle between the two pieces as close to 90\u00b0 as possible. Also, make sure you hold the pieces still for a few seconds until the glue has cooled. Repeat this step for the other Side piece, at the opposite edge of the Back piece; the result should look like the second picture.", "step_imgs": ["https://cdn.instructables.com/FR3/B3C8/GYUQTFWH/FR3B3C8GYUQTFWH.LARGE.jpg", "https://cdn.instructables.com/F5V/AW5U/GYQESMDQ/F5VAW5UGYQESMDQ.LARGE.jpg", "https://cdn.instructables.com/FPU/UU9T/GYQFN2ET/FPUUU9TGYQFN2ET.LARGE.jpg"], "step_title": "Step 6: Attaching the Side Pieces to the Back Piece."}, {"step": 7, "steps_text": "This is the hardest part of the board assembly (and the whole project.) You will need to place hot glue on the edges of the Top piece and tension-fit it between the Side pieces as shown in the first picture. You should also place a line of glue on the upward-facing edge of the Back piece.\nIf you want to do one edge at a time, make sure the glue on the first edge is dry before doing the opposite edge. You will need to flip the board over and push the Top piece out slightly, so that you can work on the unglued edge.\nYour board will have some points at the edges, but they will be trimmed down in the next step. Just try to get the edges attached to each other as flush as possible.\u00a0", "step_imgs": ["https://cdn.instructables.com/F1Z/P20G/GYQESMD5/F1ZP20GGYQESMD5.LARGE.jpg", "https://cdn.instructables.com/FLQ/G9IH/GYWSZ4JP/FLQG9IHGYWSZ4JP.LARGE.jpg", "https://cdn.instructables.com/FPU/UU9T/GYQFN2ET/FPUUU9TGYQFN2ET.LARGE.jpg"], "step_title": "Step 7: Placing the Top Piece"}, {"step": 8, "steps_text": "It is pretty hard to align the edges perfectly, so if you find that they are slightly uneven in some spots (like the way the Side pieces protrude above the Top of mine) you can take an X-Acto knife flush the the edge and carefully push the knife down the edge, with the blade of the knife staying flat against the Top piece. Make sure you don't pull the knife towards yourself, but instead push it away from you to avoid accidentally cutting yourself.\nThere may also be extra points at the top and bottom of the Top piece that you can do the same X-Acto knife treatment to if you want your edges rounded like I did (see second and third pictures.)", "step_imgs": ["https://cdn.instructables.com/FP1/NGMW/GYQFN2EI/FP1NGMWGYQFN2EI.LARGE.jpg", "https://cdn.instructables.com/F5G/U1GB/GYQFN2ER/F5GU1GBGYQFN2ER.LARGE.jpg", "https://cdn.instructables.com/FBS/8PDZ/GYUQTFW9/FBS8PDZGYUQTFW9.LARGE.jpg"], "step_title": "Step 8: Trimming Excess Corners/ Edges"}, {"step": 9, "steps_text": "I needed a bit of a break from foam building, and since my Hot Glue Gun was already warmed up, I decided to move on to the bean bags before finishing up the playing board.\nI figured that 2\" x 2\" squares were a good size for the 2.75\" diameter hole. So take your two pieces of felt and make a couple 2 inch wide strips with both colors.\u00a0\nThen mark every 2 inches on each side of the strips and connect them until you have 8 squares of each color (16 squares in total.) Connects\nCut these squares out and place them in a pile for each color. Try to note which side of each square has the markings on it, so that you can keep those sides on the inside of the assembled bean bag.", "step_imgs": ["https://cdn.instructables.com/FZD/ROP0/GYQESMD8/FZDROP0GYQESMD8.LARGE.jpg", "https://cdn.instructables.com/FSS/09QR/GYUQTFWO/FSS09QRGYUQTFWO.LARGE.jpg", "https://cdn.instructables.com/F3G/CUZ0/GYUQTFW5/F3GCUZ0GYUQTFW5.LARGE.jpg"], "step_title": "Step 9: Taking a Quick Detour to the Bean Bags"}, {"step": 10, "steps_text": "Take one square of felt and place thin lines of hot glue around 3 of the 4 sides. Again, try to keep the side with markings (if there are any visible) on the inside. Then take another square of the same color and lightly place it on top and start pressing around the edges like you are making a ravioli. You will end up with a pocket like in picture 2.\nThen take your pocket in one of your hands and pinch it slightly to open up the unglued side. Take your rice and teaspoon measure and place 1.5 teaspoons of rice into the pocket. Then take your hot glue gun and carefully put a thin line of glue on the upper inside and press the final edge closed. If it seems like the rice isn't fitting in some, push the rice down slightly and it should all fit. You want to make the bean bags as close to the same weight as you can to make the game fair. \u00a0\nTo make sure all the edge are sealed, look around them carefully and poke at them to make sure rice doesn't come out. If there is a hole, take the hot glue gun and put a tiny amount of glue on the inside of the hole and press it closed.\nAfter you have glued all of the bean bags and they have cooled, inspect the edges for hot glue overflow and trim them as necessary.\u00a0\nNow your bean bags are done!", "step_imgs": ["https://cdn.instructables.com/FR9/TYQO/GYUQTFW6/FR9TYQOGYUQTFW6.LARGE.jpg", "https://cdn.instructables.com/FO6/839E/GYUQTFW8/FO6839EGYUQTFW8.LARGE.jpg", "https://cdn.instructables.com/FDF/5IMC/GYUQTFW7/FDF5IMCGYUQTFW7.LARGE.jpg", "https://cdn.instructables.com/F5O/MA7D/GYWSZ4JG/F5OMA7DGYWSZ4JG.LARGE.jpg", "https://cdn.instructables.com/F6Y/9JVY/GYVDHY20/F6Y9JVYGYVDHY20.LARGE.jpg"], "step_title": "Step 10: Assembling the Bean Bags"}, {"step": 11, "steps_text": "I wanted to put a manilla folder layer on the top and back to make sure I had the smoothest work surface to deal with. Simply cut out two pieces of manilla folder in the size of the top and back and glue it to its respective spot. Manilla folders are thick so any type of glue will work here. I like using Loctite Indoor safe crafters glue for a quick-dry, low-moisture tacky glue. If your piece is really smooth you can skip this step.\nAfter you glue the top piece on you can flip the board over and cut the hole out. If you want to measure out where the hole is first you can do that. To do that, place the piece onto the manilla folder and trace the circle positioning onto the folder.\u00a0", "step_imgs": ["https://cdn.instructables.com/FNE/15VM/GYUQTFW4/FNE15VMGYUQTFW4.LARGE.jpg", "https://cdn.instructables.com/FMP/JKVC/GYWSZ4J9/FMPJKVCGYWSZ4J9.LARGE.jpg", "https://cdn.instructables.com/FHL/0CJW/GYVDHY0M/FHL0CJWGYVDHY0M.LARGE.jpg", "https://cdn.instructables.com/FXZ/X7WI/GYUY0VLO/FXZX7WIGYUY0VLO.LARGE.jpg"], "step_title": "Step 11: Manilla Folder Layer"}, {"step": 12, "steps_text": "Because the board will need to stay in one place even with bean bags being thrown at it, you will need to add some heft that wood has but foamboard lacks. The easiest way to do this is to glue at least 6 marbles or other small weights to the underside of the foamboard. ( I had 8 marbles laying around so I added an extra 2 for some more security.) Hot glue is the best glue to use for this part because it \"dries\" very quickly.\u00a0\nI tried putting two on the inside of the back, but they were visible to players, so I removed those and placed them elsewhere.\u00a0\nPeople won't really see the bottom part; even if you do need to pick the board up to retrieve bean bags that score, the weights should be pretty well-hidden.\u00a0", "step_imgs": ["https://cdn.instructables.com/FTO/P897/GYUY0VLN/FTOP897GYUY0VLN.LARGE.jpg"], "step_title": "Step 12: Gluing Flat Back Marbles on the Underside"}, {"step": 13, "steps_text": "Now it is time to begin decorating and finishing the edges of the playing board. I love the look of masking tape ( I might be weird), so I wanted to seal the edges of the foamboard with it, and leave some of the masking tape still visible on the side as a decoration.\nTo make the masking tape look good you will want sharp scissors to cut the edge of it instead of just ripping it with your hands. To do this, rip a piece that is slightly too big and start placing it on one edge. Then snip the tape where it meets the other end of the edge, and smooth the tape down. Also, make sure to center the masking tape around the edge well to make it even on both sides.\nI went around every edge of the board with masking tape to make sure all of the edges were sealed and sturdy. If you don't like masking tape or your edges are perfectly smooth, you can skip this step.\u00a0", "step_imgs": ["https://cdn.instructables.com/FYK/45WC/GYUQTFWB/FYK45WCGYUQTFWB.LARGE.jpg", "https://cdn.instructables.com/FQ6/EAT3/GYVDHXVT/FQ6EAT3GYVDHXVT.LARGE.jpg", "https://cdn.instructables.com/FVD/2NK9/GYUQTFW1/FVD2NK9GYUQTFW1.LARGE.jpg"], "step_title": "Step 13: Finishing the Edges"}, {"step": 14, "steps_text": "Now you are ready to cut and place the top decorative piece of paper. You can choose any design you want for this part. I didn't want anything too busy or with too many lines, at the risk of being distracting. I went with a simple circular pale-blue and yellow pattern.\u00a0\nSince the paper is more fragile than the manilla folder, you will\u00a0definitely\u00a0want to position and cut the circle out before gluing it to the front. Use the same method as before. Place the board upside down and trace the circle in its correct position.\u00a0\nAfter you cut out the pattern, use a glue stick to glue the paper to the manilla folder. Any other type of glue will cause the paper to warp because of moisture. If you don't have glue stick, double-sided tape may also work.\u00a0", "step_imgs": ["https://cdn.instructables.com/FU5/JZM8/GYUY0VLM/FU5JZM8GYUY0VLM.LARGE.jpg", "https://cdn.instructables.com/F14/VEL3/GYWSZ4IU/F14VEL3GYWSZ4IU.LARGE.jpg", "https://cdn.instructables.com/FLP/GMTD/GYVDHXVR/FLPGMTDGYVDHXVR.LARGE.jpg", "https://cdn.instructables.com/FIF/TD0W/GYQESMD9/FIFTD0WGYQESMD9.LARGE.jpg"], "step_title": "Step 14: Decorating Time."}, {"step": 15, "steps_text": "At this point you can add whatever decorations you would like to customize your playing board.\nI wanted to outline the inside of the center hole in black to make it more visible, but if you choose a black top, you would obviously not need this step. I also outlined the outside of the circle in black to match the inside.\nI also did outlining stripes with a Sharpie permanent marker on the top and sides to make it easier to focus on the target at far distances.\u00a0\nWhen you are done decorating and customizing you are ready to play!\u00a0", "step_imgs": ["https://cdn.instructables.com/FQV/BLTF/GYQESMDD/FQVBLTFGYQESMDD.LARGE.jpg", "https://cdn.instructables.com/FZQ/PW7K/GYQESMDH/FZQPW7KGYQESMDH.LARGE.jpg", "https://cdn.instructables.com/F2M/UMCH/GYVDHY0R/F2MUMCHGYVDHY0R.LARGE.jpg", "https://cdn.instructables.com/FWN/9C8W/GYQFN2EQ/FWN9C8WGYQFN2EQ.LARGE.jpg", "https://cdn.instructables.com/F2Z/13IU/GYUY0VLQ/F2Z13IUGYUY0VLQ.LARGE.jpg"], "step_title": "Step 15: Customizing"}], "channel": "Table Top"}, {"category": "technology", "description": "If you have Cannon 500d you know already that it doesn't have a external mic jack. But you can add one within a couple hours. \u00a0XCFloresX photography does an awesome job of this mod on a youtube video. Watch his video first!\u00a0 My instructions are just a specific case for my camera and the 3.5mm jack I chose to use. I have the Asian model not the Rebel.Note: Make sure you get all the screws out before you remove the back case. The back case comes off quite easy. My camera had a screw hiding below a sticker. \u00a0 When you take the back cover off be careful not to damage the ribbon attached to the circuit board. \u00a0Tools: Small Philips screwdriver - make sure it fits properly in the head, \u00a0these little screw heads will strip out easily. Small Flat screwdriver - to pry off the back cover. Drill\u00a0 Hot Knife or a small saw, something cut plastic\u00a0 Soldering Iron Knife Small file or Dremel\u00a0 3.5 or 2.5 2 pole \u00a0audio jack", "title": "Cannon 500d External Mic Mod", "url": "https://www.instructables.com/id/Cannon-500d-external-mic-mod/", "section": "technology", "steps": [{"step": 1, "steps_text": "As you can see in the picture, the jack body is a little too wide to fit in.So I used a pair of bolt cutters to cut the material in yellow out.", "step_imgs": ["https://cdn.instructables.com/FIK/ZQ2S/HP0CRJNA/FIKZQ2SHP0CRJNA.LARGE.jpg"], "step_title": "Step 1: Placing the Jack"}, {"step": 2, "steps_text": "Be careful cutting the internal mic wires. Allow your self enough wire to work and stip the wires. They are very tough to strip! And I also bent down the jack tabs to ensue the back case would fit back on. The back cover has a metal shield inside it so I added a small piece of electrical tape to ensure the jack contacts didn't short out.\u00a0 \u00a0", "step_imgs": ["https://cdn.instructables.com/F46/5OKC/HP0CRJNE/F465OKCHP0CRJNE.LARGE.jpg", "https://cdn.instructables.com/FT6/112J/HP0CRJNJ/FT6112JHP0CRJNJ.LARGE.jpg"], "step_title": "Step 2: Soldering the Jack"}, {"step": 3, "steps_text": "The yellow shows where I had to remove material from the back cover.\u00a0 I used a hot knife to remove the plastic and then a grinder to remove small amount of metal required. NOTE: Try not to get any small bits of plastic or metal into the body of your camera. Nothing good can come from that. \u00a0 \u00a0", "step_imgs": ["https://cdn.instructables.com/FZW/ZHT9/HP0CRJNI/FZWZHT9HP0CRJNI.LARGE.jpg", "https://cdn.instructables.com/FCP/H15Z/HP0CRJQV/FCPH15ZHP0CRJQV.LARGE.jpg"], "step_title": "Step 3: Back Cover Material Removal."}, {"step": 4, "steps_text": "It took me 3 tries to get the cover back on and fitted properly. Hint: I had plugged a 3.5mm male into the jack to help hold it in place while trying to get the case closed. When it is done the jack made a very snug fit. \u00a0", "step_imgs": ["https://cdn.instructables.com/FMB/Z9M3/HP0CRJR5/FMBZ9M3HP0CRJR5.LARGE.jpg"], "step_title": "Step 4: The Test Fit"}, {"step": 5, "steps_text": "Drill a hole in the side cover to just fit around the jack. Hint: to get the hole in the right place: put a piece of tape in the cover where the hole should be. then align the side cover along the x axis and draw a line. then repeat the procedure for the y axis. where the 2 lines cross is where the hole center should be. This hole needs to be very exact because there is no room for movement. measure twice and cut once. \u00a0 \u00a0", "step_imgs": ["https://cdn.instructables.com/FFS/II4D/HP0CRJRH/FFSII4DHP0CRJRH.LARGE.jpg"], "step_title": "Step 5: Drilling a Hole in the Side Cover"}], "channel": "Photography"}, {"category": "technology", "description": "The goal of this project is to make an LED matrix, which can react to sound, not only by detecting the amplitude, but also by controlling animations based on the frequency spectrum and beats of an song. Some of the finished animations are straight forward and you can see a connection between the audio and visual like the audio spectrum monitor in the video. Other animations are more ambiguous where for example on each beat some LED light up and/or move and change their color. The presented system gives you a lot of freedom in what should happen.For this an audio signal is pre-processed by a filter and then processed by a micro-controller. The controller calculates the intensity of the frequency spectrum with the Fast Fourier Transformation (FFT) and performs a simple beat detection. This data gives us insight about the amplitude and frequency spectrum of the audio signal and the beats of the song. Since a controller does the calculations this project is self-sufficient and independent from e.g. a PC. I'll explain in the following steps the theory and thought process behind this project.", "title": "Make Lights React to Audio", "url": "https://www.instructables.com/id/Make-Lights-react-to-Audio/", "section": "technology", "steps": [{"step": 1, "steps_text": "Before starting a project you should make a rough concept what it should be able to do. The basic idea is simple: a stereo audio signal is read by a controller, which then does some math and outputs an pattern on a LED matrix. Additionally there should be an display for feedback an some way to control the system.Hardware concept The controller for this project needs to be able to read 2 analog values a once, which means that the controller needs 2 ADC units. It should also support DMA, to make the data acquisition independent from the CPU. The DMA would also help to output the data to the LED drivers. While an Cortex M4 controller would give more computing power, I decided to use an atxmega128A3U controller, because the are cheaper and easier to obtain (they are sold with an pre-programmed bootloader on the german ebay page for people who don't have a programmer) while still providing all required features.The audio signal needs to be amplified and brought on an level to be read properly by the controller. Additionally the signal should be filtered to eliminate calculation errors in the FFT. While not absolutely necessary an AGC was added. This servers as an protection of the audio input stage and smooths extreme changes in the signal level.As LED I choose WS2812 LED, mainly because I still had some of them, but also because they are convenient to use. The LED were placed behind ping-pong balls, which serve as diffusor for the light. The LEDs were arranged as an 7x6 matrix.Lastly I added an I2C-based OLED display and a rotary encoder with button as input-output interface for the user. This allows us to easily debug the program and implement a simple menu to control the finished project.This setup allows us to sample the audio data, process it an make a nice animation on the LED matrix.On the picture you can also see an audio amplifier with speaker. This is used to hear the signal, which is sampled by the controller. For the final version of the project it won't be used.The basic idea of functionalityReal-time audio analysis uses a lot of resources, which the used controller doesn't have. With the current system it's possible to sample data and do all the calculations 20 times per second. While this is enough to make certain reactions look quite good, more complex animations will look sloppy, if you would present it with 20 frames per second. The controller refreshes the display at a rate of 60 frames per second. This makes animations look very smooth, especially if you fade the color. The animation system gets fed with new data 20 times per second and uses this data as template for the animation. While this approach is far from being real-time reaction to the music, it's enough to trick the human perception in an immediate reaction.", "step_imgs": ["https://cdn.instructables.com/FZF/MNVD/I66CSFQJ/FZFMNVDI66CSFQJ.LARGE.jpg"], "step_title": "Step 1: Concept and Theory"}, {"step": 2, "steps_text": "You can find the schematics as KiCAD project on githubWhile the schematics look overwhelming at the first glance, they are actually quite simple. There are 2 audio input stages, because there are two audio inputs. One from the left channel and one from the right channel. Each input stage consists of a voltage divider, a AGC and a filter. The voltage divider serves as an protection, because it has a high resistance and lowers the voltage level of the signal. Next the AGC is a second form of protection, but the main reason is to even out extreme changes in the amplitude of the signal. The filter is a bandpass, which lets frequencies between 16Hz and 16kHz through. This is roughly the frequency range a human adult can hear. While not completely necessary, a filter should always be used to reduce the amount of alias/computation error in the FFT.The rest of the schematics are the default circuits needed to get the controller to work. The power supply has several inductors to filter and smoothen the ripple of the supply voltage. This increases the quality of the analog signals. This input stage was taken from this project. The amplifier between filter and controller (U5) was added in this prototype just in case the signal was too weak. But it turned out that this amp stage isn't needed. Although not needed it still stabilizes the signal. The connector for the stereo potentiometer can be shorted between pin 1-3 and 2-4.", "step_imgs": ["https://cdn.instructables.com/FCF/IKNX/I66CSJQD/FCFIKNXI66CSJQD.LARGE.jpg", "https://cdn.instructables.com/F5G/L2LB/I66CSK34/F5GL2LBI66CSK34.LARGE.jpg"], "step_title": "Step 2: Hardware"}, {"step": 3, "steps_text": "You can find the software as Atmel Studio Project on githubThere are 2 projects in this git. The Basic project includes all basic functions to measure and calculate the data. It also includes a class for WS2812 LED. The Matrixproject includes all data for my project based an an 7x6 LED-matrix with WS2812 LED. As this is very specific, this code is more of an inspiration and example for what you can do.This part is the most complex of this project as the software needs to do a lot of things.Sampling the Data First you need to get the data into the controller. This is done by sampling the audio signal with an ADC. The sampling frequency depends on the frequency range you want to work with. If you sample the signal with a rate of 32kHz you can recreate signals up to 16kHz with the Fourier Transformation (FT). This is the frequency range we want to work with.To make this work a timer is set to trigger with an frequency of 32kHz and read an value from the ADC each time this happens. Since the atxmega controller has an DMA controller, this is used to automate the process. DMA (Direct Memory Access) allows you to move data from one point in the memory to another completely in hardware. The DMA is set up in a way, that it moves the result from the ADC to a specific place in the RAM whenever it's triggered by the timer. We sample 128 values per channel.Fast Fourier Transformation (FFT) We use the elmchan FFT library for this project. Usually a FT uses a lot of calculation time, but allows you to recreate each frequency within the given signal spectrum. The FFT simplifies this process and speeds it up. The disadvantage is, that it doesn't give you specific frequencies but frequency bands. For the purpose of this project this data is good enough.Since we sample 128 values, the FFT will give us 64 results. Because of the sampling rate (32kHz) we can recreate frequencies up to 16kHz, which will be divided into 64 bands by the FFT. 16000 / 64 = 250. This means each FFT band describes the level of 250Hz. FFT band 1 gives an value for 1Hz to 250Hz, band 2 for 251Hz to 500Hz, band 3 for 501Hz to 750Hz and so on. By increasing the number of input samples you could increase this resolution, but also increase the needed calculation time.Those 64 bands are consolidated into 7 bands, which are used for the matrix, which has a width of 7 LED. Some effects are still based on the original 64 bands.The algorithm to calculate the FFT is coded in a way, that it doesn't do all the calculation steps at once, but splits them into smaller pieces. This is done to give the controller time to calculate other thing in between those steps. If you don't do this, the animations will sometimes stutter, which doesn't look good.The human ear reacts different to certain frequencies. It's very sensible to frequencies around 4kHz and not sensible to very low and high frequencies. In an audio signal the low frequencies will have a high amplitude, which leads to high FFT results, and low amplitudes in the middle frequencies, which leads to low FFT results. This makes it hard to do calculations with. To counter this a very simple reverse a-weighting system is used. The coefficients are pre-calculated for each band and multiplied with each of the 64 FFT bands.Beat DetectionThe basic idea behind this is simple: average the power of the sound level. If the current power level is way higher than this average you have an beat. To do this properly you would need to sample the audio signal continuously, which we don't do. But we'll still use this idea.The FFT results are split into 3 bands: low, medium and high. Those values are averaged over time as a moving average. If the current level is higher than 50% to 100% (depending on the band) of this average it's evaluated as beat. This works very well with a metronome, which produces a simple sound, but doesn't work too well with complex signals like songs. The beat detection in the lower band works the best and the middle band the worst when there are vocals in the song.What to do with that data?As an example I'll explain how the mono spectrum display works. You can find the code in the complete project in animations.cpp in the function void anim_monospektrum_step(). This animation is used in the intro video.The values of the 7 consolidated bands are set as target values for the height of the columns. It's scaled in a way, that this value ranges between 0 and 9000. The target color offset is set by the amplitude. The actual values, which will be used to calculate the output, slowly change their value to match the target value. This makes the animation look very fluid and prevents sudden jumps.The matrix has a height of 6 LED. This means each LED covers 9000 / 6 = 1500 counts of the actual value. If the actual value of a band is 1500, only the LED in the bottom would light up. If the value was 3000 the two most bottom LED would light up. As long the actual value is greater than 1500 we light up one more LED and subtract 1500 from the value. If, after this process, the value is not 0, the LED above the last full-lit LED is lighted as well, but the brightness is scaled with the value. The lower the remaining value, the lower the brightness.As an additional detail the bands will flash when a beat within this band is detected.", "step_imgs": ["https://cdn.instructables.com/FFE/YAIC/I66CSK3T/FFEYAICI66CSK3T.LARGE.jpg", "https://cdn.instructables.com/FQJ/E6R4/I66CSK3J/FQJE6R4I66CSK3J.LARGE.jpg", "https://cdn.instructables.com/F6H/V362/I66CSK3S/F6HV362I66CSK3S.LARGE.jpg", "https://cdn.instructables.com/FTY/R6ZM/I66CSK3P/FTYR6ZMI66CSK3P.LARGE.jpg", "https://cdn.instructables.com/FWH/DYQN/I66CSK3R/FWHDYQNI66CSK3R.LARGE.jpg"], "step_title": "Step 3: Software"}, {"step": 4, "steps_text": "The most complex part of the hardware is the audio input stage. If you don't want to use a stereo, but a mono signal, you can simply cut one of the input stages. If you want it even simpler you could just a very simple input stage, which has a high resistance and only a filter. You may need to add another amplifier stage to this. If you are using an Arduino it's not possible to copy and paste the provided sourcecode, since the Arduino Board isn't based on a atxmega controller.If you want to use this project with another controller, you need to adapt the code yourself. The following steps should give you an idea on what to do:The first thing you need to do is sample the audio signal. We need 128 data points and want a sample frequency of about 32kHz. The simplest way to do this is to make a loop, which reads the ADC and then pauses for about 30\u00b5s. The 30\u00b5s delay in combination with the time needed to read the data should give an roughly accurate sample frequency.The next step is the FFT. Some nice guy put the FFT library used in this project in a convenient library for Arduino. This comes with an example, which explains how you use it. The example uses the free-run mode of the ADC, which unfortunately doesn't run at 30kHz. This isn't necessarily a bad thing, but your frequency range will be affected and your FFT buckets will have a different resolution. You can of course also check the official project of the FFT library.If you want to implement an beat detection just take a look at the explanation in the software part or the code of my project. This is basic math and can be copy/pasted.What happens after that is you imagination. The most used methods to make sweet animations, color fading or whatever you want to do are these:target/actual value: The target value is derived from the FFT data. The actual value slowly changes until it reaches the target value.  moving average: You remember the last X values. Add those values up and divide them by X. This gives you the moving average  weighted moving average: This is kinda like the moving average, but newer values have a higher influence on the result than older values. value = ((value * (NUM - 1)) + new_value) / NUM. NUM can be freely chosen; Higher means it adapts slower/smootherThose methods allow you to make fluid looking animations. If you take the data direct from the FFT you may see sudden jumps in e.g. your color fading. I use the actual/target value system and weighted moving average most of the time.A very simple example on how to use this formulas is this line of code: color = ((color * 15) + fft_bucket_h_l) / 16;It calculates a weighted moving average of the FFT bucket with the highest value on the left channel. This value can then be used to set the color of an RGB LED. Congratulations! You just made an LED, which changes its color depending on the most dominant frequency.At first glance all this math might look overwhelming, but luckily all the hard work is already done. If you spend some time to work your way into this project you'll see that you can make awesome effects with some simple math you've learned at school.Important data for you to use The FFT data can be accessed via the fft class like this: fft_result_t *fft_left = fft.getLeft();  for channel 1 fft_result_t *fft_right = fft.getRight(); for channel 2The result structure looks like this: typedef struct {  uint16_t spectrum[FFT_N / 2]; uint16_t adc_min, adc_max; } fft_result_t;spectrum is an array of 64 elements, which hold the result from the FFT. adc_min and adc_max are the minimum and maximum values of the signal. Within the animation.cpp, where you should place your animation code you have access to the following global variablesuint16_t bands_l[ANIM_BAND_NUM], bands_r[ANIM_BAND_NUM]; arrays which hold the data of the 7 condensed bands uint16_t amplitude_l, amplitude_r; amplitude, derived by the adc_min and adc_max values uint8_t beats, bpm_h, bpm_m, bpm_l, bpm_all; beats contains a bitmask, which lets you check if there was a beat in a specific band. The other variable give you the beats per minute for the high, mid, low and all (any) band uint8_t fft_bucket_h_l, fft_bucket_h_r, fft_bucket_l_l, fft_bucket_l_r; number (0 ... 63) of the FFT bucket with the highest and lowest value For all variables _l refers to the left channel and _r to the right.", "step_imgs": ["https://cdn.instructables.com/FH7/3N0V/I66CU214/FH73N0VI66CU214.LARGE.jpg", "https://cdn.instructables.com/FRE/O6KP/I66CU218/FREO6KPI66CU218.LARGE.jpg"], "step_title": "Step 4: Simplified Version and Getting Started"}, {"step": 5, "steps_text": "While this system, especially if you make your own version with an Arduino, doesn't seem very powerful, it allows you to make neat looking lights and animations, which react to sound. The \"advanced\" version based on the atxmega controller offers a lot of power, thanks to the DMA options. In contrast to most other projects of this kind you have many options how you want to react. It's also completely independent from other devices. It only needs a power supply and the audio signal as an input and can control different devices. This project is focused on the output on an LED matrix, but with the help of an FFT you can also realize way different projects. A different idea would be to make a lock, which opens when you play a certain melody. For this the melody needs to be very simple and the frequencies of the tones should not be too close together, so you can make a better distinction between them. Think of something like the ocarina songs in Zelda. You should also increase the number of samples for the FFT, to increase the frequency resolution. Then you need to look for a certain pattern and when this is right you could move a servo to open/close a lock.I hope this guide gave you some inspiration and you learned something new for your own projects.", "step_imgs": [], "step_title": "Step 5: Conclusion"}], "channel": "Audio"}, {"category": "technology", "description": "// Watch video here: https://www.youtube.com/watch?v=omZ538TElCU  /* Accelerometer connection pins (I2C) to Arduino are shown below:Arduino     Accelerometer ADXL345   A5            SCL   A4            SDA   3.3V          CS   3.3V          VCC   GND           GND */ #include  #include ADXL345 adxl; //variable adxl is an instance of the ADXL345 libraryint x,y,z;   int rawX, rawY, rawZ; float X, Y, Z; float rollrad, pitchrad; float rolldeg, pitchdeg;void setup(){   Serial.begin(9600);   adxl.powerOn(); }void loop(){   adxl.readAccel(&x, &y, &z); //read the accelerometer values and store them in variables  x,y,z   // Output (x,y,z) on horizontal plane should be approximately (0,0,255)    // the following 3 lines is for an offset   rawX=x+360;   rawY=y+170;   rawZ=z+10;       X = rawX/521.00; // used for angle calculations   Y = rawY/521.00; // used for angle calculations   Z = rawZ/521.00; // used for angle calculations       rollrad = atan(Y/sqrt(X*X+Z*Z));  // calculated angle in radians   pitchrad = atan(X/sqrt(Y*Y+Z*Z)); // calculated angle in radians      rolldeg = 180*(atan(Y/sqrt(X*X+Z*Z)))/PI; // calculated angle in degrees   pitchdeg = 180*(atan(X/sqrt(Y*Y+Z*Z)))/PI; // calculated angle in degrees   // print out values:      Serial.print(\"x: \"); Serial.print(x);    // raw data without offset   Serial.print(\" y: \"); Serial.print(y);     // raw data without offset   Serial.print(\" z: \"); Serial.print(z);     // raw data without offset   Serial.print(\" rawX = \"); Serial.print(rawX); // raw data with offset   Serial.print(\" rawY = \"); Serial.print(rawY); // raw data with offset   Serial.print(\" rawZ = \"); Serial.print(rawZ); // raw data with offset   Serial.print(\" X = \"); Serial.print(X);    // raw data with offset and divided by 256   Serial.print(\" Y = \"); Serial.print(Y);    // raw data with offset and divided by 256   Serial.print(\" Z = \"); Serial.print(Z);    // raw data with offset and divided by 256  Serial.print(\"\\t Angle according to x axis (Roll(deg)) = \"); Serial.print(rolldeg);      // calculated angle in degrees   Serial.print(\"\\t Angle according to y axis (Pitch(deg)) = \"); Serial.println(pitchdeg);  // calculated angle in degrees   // Serial.print(\" Roll(rad) = \"); Serial.print(rollrad);   // calculated angle in radians   // Serial.print(\" Pitch(rad) = \"); Serial.print(pitchrad); // calculated angle in radians }", "title": "ACCELOROMETER WITH Adxl 345", "url": "https://www.instructables.com/id/ACCELOROMETER-WITH-adxl-345/", "section": "technology", "steps": [{"step": 1, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/F9K/05Z4/IHHLCWKJ/F9K05Z4IHHLCWKJ.LARGE.jpg", "https://cdn.instructables.com/FZ3/UNUJ/IHHLCV1C/FZ3UNUJIHHLCV1C.LARGE.jpg", "https://cdn.instructables.com/FI8/5FBB/IHHLCV0L/FI85FBBIHHLCV0L.LARGE.jpg"], "step_title": "Step 1: "}], "channel": "Arduino"}, {"category": "technology", "description": "Forward: This instructable was roiginally posted at https://www.instructables.com/id/How-to-make-LED-Fader-using-Digispark/ My students and I developed it into this exemplar, for wich they received a very good mark. Viewing the following video may leave you with a sense of too much too fast. Please continue to read this Instructable which documents my students' Tanner and Amanda's culminating math project. The concept of the project was to get my students to extend obtuse angles to beyond simple trigonometry, and solving triangles. Instead I wanted them to enjoy the experience of some authentic learning as they explored an application of the sine function that isn't found in their textbook.  Play Video  \u00a0", "title": "Digispark RGB LED Fader", "url": "https://www.instructables.com/id/Digispark-RGB-LED-Fader/", "section": "technology", "steps": [{"step": 1, "steps_text": "The Digispark The Digispark is one of the smallest and cheapest USB Arduino processors available today. It is bassed on the ATTiny85 processor. The Digispark is very easy to program using a version of the Arduino IDE tailored to the ATTiny 85 processor. The most significant difference from boards such as the Arduino Uno is pins assignments. The Digispark only has 6 data pins and three power pins as opposed to the Uno's 32. You can learn more about the Digispark at http://digistump.com. In this project we use pins 0, 1, and 4 as well as the GND pin.", "step_imgs": ["https://cdn.instructables.com/FL5/2Q8H/HIDCOVG6/FL52Q8HHIDCOVG6.LARGE.jpg", "https://cdn.instructables.com/FTC/6I1J/HIAQ8905/FTC6I1JHIAQ8905.LARGE.jpg"], "step_title": "Step 1: Which Processor Board to Use?"}, {"step": 2, "steps_text": "What is PWM? Processor boards such as the Digispark can modulate the power sent to an LED giving the effect of fading while still providing a digital on or off signal. The process is known as Pulse Width Modulation or PWM. PWM switches on for a percentage of a duty cycle and off for the remainder. In a 12 volt circuit, the effect of 6 volts can be achieved if the power is switched on and off rapidly 50% of the time. This avoids heat issues that would be associated with using a rheostat or potentiometer. PMW values extend from 0 to 255, representing 0% to 100%.duty cycle. A PWM value of\u00a0 64 corresponds to a 25% (0.25*255) duty cycle or 1/4 power. Similarly a PWM value of 191 corresponds to a duty cycle of 75% (0.75*255) or 3/4 power. Now that we understand what PWM is, how do we generate a series of values that will give a subtle ebbing of LED intensity.", "step_imgs": ["https://cdn.instructables.com/F7V/F6RZ/HI3TYPIR/F7VF6RZHI3TYPIR.LARGE.jpg"], "step_title": "Step 2: Pulse Width Modulation"}, {"step": 3, "steps_text": "Three Waves are Better than One The basic sine wave function generates numbers from -1 to 1.\u00a0 How do we modify the basic function for use as a PWM number generator? general form: y = a*sin(b*x + c) + d Where   a changes the amplituded (how tall the wave is)  b changes the period (how long the wave is)  c causes a phase shift along the x axis  d raises or lowers the wave along the y axis  \u00a0  The sine wave produces numbers between -1 and +1. This causes an issue because PWM values can not be negative. The first change we need to make is to add 1 by substituting 1 for d in the formula. y=a*sin(b*x+c)+1 will give us values between 0 and 2.  Next we needed to increase the amplitude to produce our maximum PWM value of 255. As it stands the max value is 2. Therefore 255/2= 127.5. The PWM needs to be an integer so we settle on 127 which will gives us a max of 254. Now the formula looks like this:  y=127*(sin(b*x+c)+1) note the additional brackets.  We have three LEDs which we want to interact together to give subtle shifts in additive colour values. Therefore we had to use a phase shift for each colour. This where it gets tricky for us. Computers use radians not degrees. Therefore the phase shift had to be expressed in radians. It turns out the conversion is simple. 90\u00b0 = 90/180*PI radians or 1/2*PI radians. A 270\u00b0 phase shift would require 3/2*PI radians. If we do not alter the period we now have three functions, one for each colour of our LED  \u00a0  red=127*(sin(x)+1)  green=127*(sin(x+1/2*PI)+1)  blue=127*(sin(x+3/2*PI)+1)", "step_imgs": ["https://cdn.instructables.com/F45/5UR2/HI3TQDS3/F455UR2HI3TQDS3.LARGE.jpg"], "step_title": "Step 3: The Sine Wave Function"}, {"step": 4, "steps_text": "\n          Arduinos are simple to program and the IDE is free under the CC licence. The Digispark uses a modified version fo the Arduino IDE which includeds special libraries to reflect the change in pin assignments etc. The Digispark Arduino IDE is available at http://digistump.com/wiki/digispark/tutorials/basics\u00a0 and http://digistump.com/wiki/digispark ARDUINO BOARD IDE 1.0.3 CODE //Declare all variables int LED1; // these variables will be used to hold the led PWM values int LED2; int LED3; int p0=0; /* these variables will assign a variable to receive PWM values and pass them to their respective pins*/ int p1=1; int p4=4; float x; /*this a variable that will receive the angle value from variable i. This value is converted to radians in the sine function and will be used to generate the PWM values */ float r; // these variables will receive the PWM values calculated by the three sine functions float g; float b; // the setup routine runs once when you press reset; void setup() {\u00a0\u00a0\u00a0\u00a0 // initialize the digitals pin as an output. pinMode(p0, OUTPUT); //sets up pin 0 for pwm pinMode(p1, OUTPUT); //sets up pin 1 for pwm pinMode(p4, OUTPUT); //sets up pin 4 for pwm /*Run a diagnostic test that will verify that each colour of LED is working. Turns on the LEDs consecutively with a delay of one second between each*/ digitalWrite(p0, HIGH);\u00a0\u00a0 delay(1000); digitalWrite(p1, HIGH); delay(1000); digitalWrite(p4, HIGH); delay(1000); //Turn off LEDs one after the other with a one second deleay between each digitalWrite(p0, LOW); delay(1000); digitalWrite(p1, LOW); delay(1000); digitalWrite(p4, LOW); \u00a0delay(1000);\u00a0\u00a0 } // the loop routine runs over and over again forever: void loop() { /*The for loop generates a value for a variable i which corresponds to 0 to 360 degrees. I is increased by 1 with each iteration.\u00a0 It is later converted to radians within the loop. Once i reaches 360 it resets back to 0. This establishes the periodic behaviour of the sine fun functions*/ for (int i=0; i<360; i++) { //convert i into a floating point variable that can be used with PI \u00a0\u00a0 x=float(i); /* to calculate r,g,b the sine function is modified to increase amplitute (127*) to create a phase shift (x+1/2*PI) and (x+3/2*PI) finally the sine wave is raised to illiminate negative values below zero by adding 1*/ \u00a0\u00a0 r=127*(sin(x/180*PI)+1); \u00a0\u00a0 g=127*(sin(x/180*PI+3/2*PI)+1); \u00a0\u00a0 b=127*(sin(x/180*PI+0.5*PI)+1); \u00a0\u00a0 //convert flaot r,g,b to integers that can be assigned to LED PWM numbers \u00a0\u00a0 LED1= int(r); \u00a0\u00a0 LED2= int(g); \u00a0\u00a0 LED3= int(b); \u00a0\u00a0 //write LED levels to p0, p1, p4 (ASSIGN PWM values to LEDs) \u00a0\u00a0 analogWrite (p0,LED1); \u00a0\u00a0 analogWrite (p1,LED2); \u00a0\u00a0 analogWrite (p4,LED3); \u00a0\u00a0 //wait for 1/100 of a second \u00a0\u00a0\u00a0 delay(100);   } } In this project a number from 0-255 is used to represent 0%-100% duty cycle (brightness), sine function is used to generate it. Digispark uses sine function to generate the PWM (pulse width modulation). We convert the radians to degree's for the red, green, blue cycles. This is used to change the language for the computer to understand. One small difference from regular Arduino boards and the Digispark is that the program compiler prompts you to attach the Digispark when it is ready to upload. If you leave it connected you will get a compiler error.\n        ", "step_imgs": ["https://cdn.instructables.com/FXQ/G06K/HI3U502W/FXQG06KHI3U502W.LARGE.jpg"], "step_title": "Step 4: Arduino Program"}, {"step": 5, "steps_text": "\n          MATERIALS REQUIRED (In order)ItemSupplierCat #Quantity     220 ohm resistor     digikey.com     220QBK-ND     3     RGB LED     digikey.com     754-1492-ND     1     Female header 3 pin     digikey.com     S7001-ND     1     Female header 6 pin     digikey.com     S7004-ND     1     Rectangular Connectors - Headers, Male Pins     digikey.com     S1011E-06-ND     1     Rectangular Connectors - Headers, Male Pins     digikey.com     S1011E-03-ND     1     PC DUAL-MINI BOARD     thesource.ca     2760148     1     Digispark development board     digistump.com     n/a     1 Optional one stop shooping instead of buying components separately is possible by purchasing the Digispark Starter kit from dgistump.com This kit has everything you need.", "step_imgs": ["https://cdn.instructables.com/FK8/UJIW/HI3TKTKO/FK8UJIWHI3TKTKO.LARGE.jpg"], "step_title": "Step 5: The Bits"}, {"step": 6, "steps_text": "\n          The process of building the Fader was quite simple but required a steady hand when soldering.   Cut out an 8x9 hole square hole from the perf board     Solder female header pins to DigiSpark     Solder the bits ( male header pins, resistors, RGB LED(longest leg is your ground)     \u00a0The resistors are soldered to the perf board\u00a0 in the PWM pins 1 and 4     Then solder the resistors to the LED legs     Solder the longest leg of the LED (ground) to the ground pin, cover the wire with insulation to avoid shorting out.     Then use the Arduino 1.0.3 program to write your code (provided above) to program your PWM to your chip     Plug in and play and your ready to go with your LED fader ", "step_imgs": ["https://cdn.instructables.com/FZI/XP12/HI3U4ZM0/FZIXP12HI3U4ZM0.LARGE.jpg", "https://cdn.instructables.com/F12/HCFE/HI3U4ZLX/F12HCFEHI3U4ZLX.LARGE.jpg", "https://cdn.instructables.com/F9E/442X/HIDCOVG7/F9E442XHIDCOVG7.LARGE.jpg", "https://cdn.instructables.com/F38/ULKN/HI3TYPMX/F38ULKNHI3TYPMX.LARGE.jpg", "https://cdn.instructables.com/FLZ/Z9VT/HI3TKTKN/FLZZ9VTHI3TKTKN.LARGE.jpg"], "step_title": "Step 6: Building the Digispark Fader"}, {"step": 7, "steps_text": "Extensions: A possible extension for this project would be to include a light dependent resistor and code that would turn on the Fader only if the room was dark enough.\u00a0 This would require more hardware research and mathematical modeling. The extra hardware would be an LDR a 10Kohm resistor While conferencing with the students it became evident that this project solidified their knowledge of the behaviour of trig ratios of obtuse angles. They were able to synthesize the knowledge and apply to a completely new circumstance. They were also able to demonstrate a great understanding and confidence when\u00a0 quizzed about simple trig ratios, sine law and cosine law. They also were able to relate trig concepts back to the first unit which dealt with mathematical modelling.\u00a0 Here is the fader in action with a diffuser so you can see the colour shifts more easily.Credits:  Digispark:digistump.com  Arduino: Arduino.cc  Digikey: digikey.com  The Source: thesource.com  Animoto produced using Animoto.com account  Third party credit for music in video to Cool Affair\u00a0 Black and Brown  The course is MAP4C taught at the Renfrew Adult H.S, Renfrew County DSB, Ontario, Canada  Teacher: Marc Fournier  Students: Tanner Roderick and Amanda Reckzin  Date of completion June 26, 2013.  \u00a0 Feel free to post a comment. Email responses or inquiries should be directed to fournierm@rcdsb.on.ca.\n        ", "step_imgs": ["https://cdn.instructables.com/FOC/ZL3V/HIAQ8EYF/FOCZL3VHIAQ8EYF.LARGE.jpg", "https://cdn.instructables.com/FNT/CSBN/HIF0C3I6/FNTCSBNHIF0C3I6.LARGE.jpg"], "step_title": "Step 7: Thanks for Checking Us Out!"}], "channel": "Arduino"}, {"category": "technology", "description": "Passive antennas increase power and range No disassembly or soldering necessary Inexpensive I\u2019ve been experimenting with my Z-Wave Plus system to increase the range of my battery powered door/window sensors. I use them to monitor my rat/mouse traps and needed more distance. See my other instructable https://www.instructables.com/id/Wireless-Mouse-Tr...If you don't want to read all the tech info below, try taping a straight 8\" copper or piano wire to a sensor as close to the internal antenna (see the black pen marks in picture 1 & 2) as possible and see if it increases the range. Also tape an 8\" wire to your Z-Wave hub near the internal antenna, for the Smartthings V3 hub tape it to the front on the right side as you are looking at the face of the hub. To test, trigger the sensor 20 times before and after adding the antennas then check history to see how many events are recorded.Placing the wire close to the internal antenna is critical. Both my sensors were taken apart to find where the internal antennas are located. By moving the passive antenna in the first picture over the internal antenna (the internal position is marked in black) the sensor went from recording 0/10 to 10/10 successful open close events recorded in history from the same location.Testing ProcedurePassive antennas (thin copper wires) were attached to the sensors and tested for signal strength with a Hackrf One SDR (Software Defined Radio). Lengths of \u00bc, \u215d and 1 wavelength were compared with no antenna. The \u215d wavelength antenna performed the best, it delivered ~4X more power on one of the sensors!Below are the results in dB. dB is a log scale so a 3dB increase in power is 2x the power. For example if you go from -50dB to -47dB the power has increased by 3dB or doubled. Power Levels were measured at 916MHz US Z-Wave PLus frequency. For each measurement separated by a comma in the data below, the door sensor was triggered ~10 times and the peak of the 10 triggers was recorded.916MHz Peak Power Test Results5/8 wavelength passive antenna (approximately 4X the power of no antenna!)-55.6db, -55.4db, -55.6db, -55.6db, -56.3db1 wavelength-59.9dB, -59.4db, -59db 1/4 wavelength -64.7dB, -66.4db, -62.8db No passive antenna (stock) -71db, -68.5db, -69.1db, -67.4dbNoteZ-Wave and Z-Wave Plus use the same frequency. Z-Wave Plus is the newer version with longer range and better battery life so get Z-Wave Plus if you can.These are the two sensors I'm using.Monoprice Z-Wave Plus Door/Window Sensor, NO LOGO (This one had 4x power gain with the 5/8 antenna) Update: The sensor was taken apart to locate the internal antenna, place the passive antenna on top of any of the black marks in photo 2.https://www.monoprice.com/product?c_id=122&cp_id=1...Monoprice Z-Wave Plus Door and Window Sensor, No Logo (Had a much lower power gain) Update: The sensor was taken apart to find where the internal antenna was located and showed a huge improvement in the amount of recorded test events (0/10 recorded events old location, 10/10 new location) by moving the antenna over the black dot in the 1st picture.)https://www.monoprice.com/product?p_id=24259", "title": "Z-Wave Antenna", "url": "https://www.instructables.com/id/Z-Wave-Antenna/", "section": "technology", "steps": [{"step": 1, "steps_text": "Find your Z-wave frequency in the wikipedia list below. A lot of countries have 2 frequencies, if you are not sure what frequency your Z-wave device is on pick the average of the 2. Most documentation says that the US frequency is 908.42MHz, I measured both my sensors at the second frequency 916MHz.Z-Wave frequency list  https://en.wikipedia.org/wiki/Z-WaveTake your frequency and put it in this calculator link below to get 1 wavelength and then multiply it by \u215d to get 5/8 wavelength, this will be your antenna/wire length.https://www.everythingrf.com/rf-calculators/freque...Here is how to calculate length for the 2 US frequenciesZ-wave plus 908.42MHz : wavelength = 0.33001526m  =  12.99inches   : \u215d wavelength = 8.11inchesZ-wave plus 916MHz : wavelength 0.32728434  =  12.88inches  : \u215d wavelength = 8.05inchesCut a small gauge copper wire or piano wire to the 5/8 wavelength you calculate. You can get piano wire at the hardware store, get the thinnest they have.Tape the wire to the side of the sensor and test!Tip: For longer range, try pointing the front of your z-wave hub at the furthest sensor. I have Samsung Smartthings v3 hub, their website says the strongest reception is from the front.", "step_imgs": [], "step_title": "Step 1: Making a Passive Antenna"}, {"step": 2, "steps_text": "The first picture is with the passive 5/8 wavelength antenna taped to the front, the second picture is with no antenna.I used a Hackrf One because I could borrow it from a friend. It\u2019s overkill for measuring Z-wave, there are cheaper SDR\u2019s that should work though I\u2019m not familiar with them. You need one that will measure frequencies in the z-wave range, ~850Mhz to ~950Mhz. If anyone figures out how to measure with a less expensive SDR please comment.Measurement EquipmentHackrf One ~$300  https://greatscottgadgets.com/hackrf/  https://www.seattletechnicalbooks.com/hackrf  I think this is the antenna, will update after I ask my friend.  https://greatscottgadgets.com/hackrf/ Measurement SoftwareI used this free spectrum analyzer, \u2018Pavsa hackrf spectrum analyzer\u2019. It was easy to setup, was reliable and worked well.  https://github.com/pavsa/hackrf-spectrum-analyzerMeasurement SettingsSet the spectrum analyzer to start just below and end just above your z-wave frequency, for me it was 915Mhz to 917Mhz. I played around with the number of samples and FFT Bin (Hz) until I got consistent measurements, 5000 Bin (Hz) and 65536 samples worked well. On the chart options tab choose \u2018Waterfall enabled\u2019, \u2018Show peaks\u2019 and \u2018Persistent display\u2019, and set \u2018Persistence time\u2019 to 60 seconds.", "step_imgs": ["https://cdn.instructables.com/FTC/XT0M/JRKYV9GM/FTCXT0MJRKYV9GM.LARGE.jpg", "https://cdn.instructables.com/FJK/A4YR/JRKYV9GN/FJKA4YRJRKYV9GN.LARGE.jpg"], "step_title": "Step 2: How the Measurements Were Made"}, {"step": 3, "steps_text": "Try taping a 5/8 wavelength wire (8\" for US Z-wave) to the front right side of your Smartthings V3 hub, the testing below shows that it extends the range.I found a picture of the Smartthings V3 hub circuit board, see the link below. The Z-wave antenna is in front of the hub, directly forward of the power connector. The picture below is the bottom of the circuit board so the passive antenna needs to go on the right side. For other brands of hubs, try to find where the internal antenna is mounted and place the wire close as possible.https://community.smartthings.com/t/should-i-wait-...I couldn't find a way to force the Smartthings hub to send an outgoing signal for measuring with the SDR so I triggered my sensors 15 times each with no passive hub antenna and 15 times again with a passive hub antenna at ~40' from the hub. The history was checked to see how many events were recorded. My results with the passive hub antenna were near perfect.Results without Passive Hub AntennaRectangular Sensor 11/15 (recorded events/total times sensor was triggered)Rounded Sensor 13/15Results with Passive Hub AntennaRectangular Sensor 15/15Rounded Sensor  14/15", "step_imgs": ["https://cdn.instructables.com/FPG/JAFC/JSPAEH8T/FPGJAFCJSPAEH8T.LARGE.jpg"], "step_title": "Step 3: \u200bSmartthings V3 Hub Passive Antenna"}], "channel": "Wireless"}, {"category": "technology", "description": "For this tutorial I am going to interface a HC-SR04 ultrasonic distance sensor to a LinkIt One board.The HC-SR04 works using an echo system - a tiny pulse of high frequency noise (way above human hearing range) is emitted from one side of the board, it bounces off a nearby object and returns.When the return signal is received we do some maths which basically amounts to dividing the time taken between the pulse being sent and received by 2 and then dividing that figure by 29.1 to tell us how far the sound travelled and therefore how far away an object is.", "title": "LinkIt One Tutorials - #11 HC-SR04 Ultrasonic Distance Sensor", "url": "https://www.instructables.com/id/LinkIt-One-tutorials-10-HC-SR04-Ultrasonic-Distanc/", "section": "technology", "steps": [{"step": 1, "steps_text": "LinkIt One boardHC-SR04 Ultrasonic Distance SensorTry your favourite auction siteLi-Ion batteryBreadboardGrove LCD RGB Backlight display4 Male to male jumper wires", "step_imgs": ["https://cdn.instructables.com/FYW/S0QA/IFWRL54K/FYWS0QAIFWRL54K.LARGE.jpg", "https://cdn.instructables.com/FBV/ED5D/IFWRL556/FBVED5DIFWRL556.LARGE.jpg", "https://cdn.instructables.com/FJ4/3V3F/IFWRL5CT/FJ43V3FIFWRL5CT.LARGE.jpg", "https://cdn.instructables.com/FF5/0DFH/IFWRL54I/FF50DFHIFWRL54I.LARGE.jpg", "https://cdn.instructables.com/FLP/0VZ9/IFWRL54J/FLP0VZ9IFWRL54J.LARGE.jpg"], "step_title": "Step 1: Materials Required"}, {"step": 2, "steps_text": "Download the attached Arduino sketch distanceSensor.ino and load it into the Arduino IDE.Connect the LinkIt One via micro USB and upload the sketch to the board.Disconnect the USB lead from the LinkIt One.", "step_imgs": ["https://cdn.instructables.com/FEN/CC4Q/IFWRL5N8/FENCC4QIFWRL5N8.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 2: Uploading the Sketch to the LinkIt One Board"}, {"step": 3, "steps_text": "Connect the Grove LCD RGB Backlight display to the Grove port on the LinkIt One marked \"SCL SDA 5V GND\"Insert the HC-SR04 distance sensor into 4 columns of the breadboard with the front facing outwards. I have used columns 40 through 43.Column 40 has the GND pinColumn 41 has the Echo pinColumn 42 has the Trig pinColumn 43 has the Vcc pinConnect a black male to male jumper wire from column 40 (GND) to GND on the LinkIt One.Connect a green male to male jumper wire from column 41 (Echo) to D2 on the LinkIt One.Connect a yellow male to male jumper wire from column 42 (Trig) to D3 on the LinkIt One.Connect a red male to male jumper wire from column 43 (Vcc) to 5v on the LinkIt One.Ensure the BAT/USB switch on the LinkIt One is set to USB and plug the battery in.Finally, switch the BAT/USB switch to BAT and go have some distance measuring fun.", "step_imgs": ["https://cdn.instructables.com/FR8/9UOP/IFWRL5OK/FR89UOPIFWRL5OK.LARGE.jpg", "https://cdn.instructables.com/F6V/QZHT/IFWRL5NX/F6VQZHTIFWRL5NX.LARGE.jpg", "https://cdn.instructables.com/FZV/C822/IFWRL5O0/FZVC822IFWRL5O0.LARGE.jpg", "https://cdn.instructables.com/FHD/OKPK/IFWRL5NU/FHDOKPKIFWRL5NU.LARGE.jpg", "https://cdn.instructables.com/FOH/G9PH/IFWRL5NY/FOHG9PHIFWRL5NY.LARGE.jpg", "https://cdn.instructables.com/FIH/10SH/IFWRL5NV/FIH10SHIFWRL5NV.LARGE.jpg", "https://cdn.instructables.com/F2M/WUMT/IFWRL5NW/F2MWUMTIFWRL5NW.LARGE.jpg"], "step_title": "Step 3: Connect the Parts to the LinkIt One"}, {"step": 4, "steps_text": "The numbers tend to jump slightly.How would you prevent them jumping?If you connect the Vcc pin to 3.3v rather than 5v the sensor cannot judge distances as far as with 5v.Ask yourself why.Verify the distances recorded with a tape measure. Are they accurate?If not, how can you make them more accurate?", "step_imgs": ["https://cdn.instructables.com/FCL/HCU8/IFWRL60C/FCLHCU8IFWRL60C.LARGE.jpg"], "step_title": "Step 4: What Next?"}], "channel": "Microcontrollers"}, {"category": "technology", "description": "A data logger is similar to an oscilloscope, but is used to register data over relatively long periods of time, typically a minimum of many hours or days, instead of a few microseconds. Data loggers can be standalone devices, with their own built in interface (keypads, displays, etc.), or like the Analog Discovery 2, which connects to your computer to record the data via the Waveforms 2015 software. Either way, they can be powerful data collection tools. They are also very simple tools with very few \"moving parts\" so to speak, so this I'ble will be short and sweet.For this Instructable you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Data Logger With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Data-Logger-With-the-Analog-Discovery-2/", "section": "technology", "steps": [{"step": 1, "steps_text": "If you want some help getting your AD2 set up and calibrated, or installing Waveforms 2015, check out this quick start I'ble collection.Once you have your AD2 and Waveforms 2015 all set up, open the Data Logger by clicking on the \"Logger\" button.This will open the Data Logger window.Along the top you'll see the \"File\", \"Control\", and \"Window\" options.Under \"File\" you'll see several options.You can \"Save\" the current data logger settings, or \"Open\" a previously saved project. \"Export\" lets you save the current data logger preview plot data, either as an image of the window in most common formats, e.g. *.bmp, *.jpg, *.tif, etc., or as a data file with the plot window information in either *.csv, *.txt, or *.tdms formats. \"Close Logger\" will close the data logger window. This will not clear the current settings as long as you don't close Waveforms 2015 completely. Just click on the \"Logger\" button again and the window will pop back open with all of the same settings.Under \"Control\", you have access to the tool's Run and Stop commands.\"Window\" lets you switch between any tool windows currently open, the Waveforms 2015 welcome window, or the Help window.Below that, you'll find the data logger controls, both for the channel grid as well as for the plot.All of the channels are loaded into the grid by default, but you can add more instances of the same channels by clicking  .Click   to either delete a single highlighted channel or clear the entire grid.With a channel highlighted, click   to edit the channel, which gives you two option tabs. You can change the channel to observe a different data parameter by clicking the \"Item\" tab.Clicking on the \"Function\" tab allows you to set your own math channel using some basic math functions and one of the 6 predefined channels as a starting point. lets you add minimum and maximum parameters to the grid. These reflect the min/max values currently observable in the data window.Click   to run the data logger. Once the tool is running, this button becomes  , which will stop the data logger. and   determine the sample rate, and by extension how much data/time the plot window will display. By adjusting the two parameters, you can vary the data sample rate from 1 sample every 100 ms for a total of 1 s, all the way up to 1 sample every 1 min for a total of 86,400 mins, which comes out to 60 days.An alternate way to adjust the time/sample rate is provided by clicking  . You can adjust the total number of samples, which will use the value in the \"Update\" box and auto-adjust the time value in the \"History\" box to fit that many samples at the determined rate. You can also adjust the offset, range, and attenuation for C1 and C2. provides another way to export the plot window data as mentioned before.Click   to clear all plot data from the window. Unless you save the data first, it will be unrecoverable. displays the RMS frequency and auto-adjusts according to the value set in the \"Update\" box.The Data Logger tool makes use of the same input channels as the Oscilloscope tool. These are labeled \"1 +/-\" for C1 and \"2 +/-\" for C2 on the AD2 30-pin header. Use of the Data Logger will lock out the Oscilloscope tool.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 1: The Data Logger"}, {"step": 2, "steps_text": "As you can see the Data Logger on the Analog Discovery 2 is a simple to use tool that can collect a significant amount of data, and is also widely adjustable to meet the time requirements of many different systems.As always, thanks for reading. If you have questions, please ask them in the comments below, though PMs are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: That's It!"}], "channel": "Tools"}, {"category": "technology", "description": "Este projeto consiste em um rob\u00f4, que atrav\u00e9s da leitura realizada por um dispositivo, equipado com um sensor piezoel\u00e9trico, captura os espectros das vibra\u00e7\u00f5es no solo, pode identificar e localizar, com o processamento dos dados por uma rede neural, poss\u00edveis vazamentos de \u00e1gua em uma tubula\u00e7\u00e3o.O processamento destes dados \u00e9 realizado por algoritmos instalados na DRAGONBOARD 410c. Os dados tamb\u00e9m s\u00e3o enviados para um servi\u00e7o na nuvem, respons\u00e1vel por auxiliar no processo de Integ\u00eancia Artificial do projeto.Este projeto foi desenvolvido no Hackaton Qualcomm, durante a TecnoFACENS da Faculdade de Engenharia de Sorocaba (FACENS), participaram do projeto os graduandos de engenharia mecatr\u00f4nica Eneo Juliano Bovino, Felipe Xavier, Lucas de Sousa Rodrigues, Rog\u00e9rio Ap. Gomes Polo e Ronaldo P. Gomes Polo. Tamb\u00e9m participou do projeto o aluno Daniel de Castro Pacheco graduando de engenharia mec\u00e2nica na Universidade Newton Paiva de Belo Horizonte. O projeto contou com o apoio dos graduandos de engenharia mecatr\u00f4nica da FACENS, Lucas Nunes Monteiro e Felipe Crispim da Silva Salvagnini.", "title": "Sistema Aut\u00f4nomo Localizador De Vazamentos", "url": "https://www.instructables.com/id/Sistema-Aut%C3%B4nomo-Localizador-De-Vazamentos/", "section": "technology", "steps": [{"step": 1, "steps_text": "Para realiza\u00e7\u00e3o deste projeto, os seguintes materiais foram utilizados:1 Arduino Due1 Dragonboard 410c2 Drivers para motor de corrente continua contendo cada um:4 Transistores BC5484 Diodos 1n40074 Resistores 4k7\u2126 \u00bc W1 Driver para servo motor contendo:1 Transistores BC5481 Diodos 1N40071 Resistores 4k7\u2126 \u00bc W1 Mouse USB1 Teclado USB1 Monitor1 Cabo HDMI1 Rob\u00f4 De Esteiras - Plataforma Zumo1 Mini dispositivo de cremalheira e engrenagem1 Servo motor 9g", "step_imgs": ["https://cdn.instructables.com/FSS/PLO8/J8YRLI28/FSSPLO8J8YRLI28.LARGE.jpg"], "step_title": "Step 1: Lista De Materiais"}, {"step": 2, "steps_text": "Para a aquisi\u00e7\u00e3o dos dados pelo sensor piezoel\u00e9trico,  faz se necess\u00e1rio, o desenvolvimento de um dispositivo com pinh\u00e3o e  cremalheira, conforme desenhos anexados, neste caso as pe\u00e7as foram fabricadas por uma impressora 3D, devido ao fato de se tratar de um prot\u00f3tipo e ao curto tempo de execu\u00e7\u00e3o, fixou-se o dispositivo na plataforma zumo, utilizando fita dupla face, conforme v\u00eddeo.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 2: Adapta\u00e7\u00e3o Mec\u00e2nica"}, {"step": 3, "steps_text": "Para executar  a movimenta\u00e7\u00e3o dos motores do rob\u00f4 ZUMO e do dispositivo de captura, fez-se necess\u00e1ria a montagem de dois drivers para os motores de corrente continua e um driver para o servo motor, conforme as figuras acima, sendo a primeira figura o driver para um motor de corrente continua e a segunda o driver para um servo motor.", "step_imgs": ["https://cdn.instructables.com/FDX/7J2A/J8YRDV4J/FDX7J2AJ8YRDV4J.LARGE.jpg"], "step_title": "Step 3: Acionamento Dos Motores"}, {"step": 4, "steps_text": "Para obten\u00e7\u00e3o do espectro de \u00e1udio das vibra\u00e7\u00f5es do solo, foi utilizado um dispositivo desenvolvido como parte do TCC de Engenharia Mecatr\u00f4nica dos graduandos Lucas Nunes Monteiro e Felipe C. da Silva Salvagnini, maiores detalhes sobre o TCC e sobre o dispositivo podem ser solicitados atrav\u00e9s do email lucasnunes_tec@hotmail.com.Este dispositivo utiliza-se de um sensor piezoel\u00e9trico e uma placa de circuito que realiza a filtragem e amplifica\u00e7\u00e3o do sinal.As frequ\u00eancias de interesse para o projeto est\u00e3o entre 100Hz e 800Hz. Para isso o dispositivo de sensoriamento foi configurado com uma frequ\u00eancia de amostragem de 3 kHz para que sejam respeitada as condi\u00e7\u00f5es do teorema de amostragem de Nyquist, onde a frequ\u00eancia de aquisi\u00e7\u00e3o deve estar pelo menos duas vezes acima das frequ\u00eancias estudadas.A aquisi\u00e7\u00e3o \u00e9 habilitada e desabilitada atrav\u00e9s da interrup\u00e7\u00e3o do Arduino DUE.", "step_imgs": ["https://cdn.instructables.com/FG0/IQUC/J8YRLPII/FG0IQUCJ8YRLPII.LARGE.jpg"], "step_title": "Step 4: Obten\u00e7\u00e3o Do \u00c1udio"}, {"step": 5, "steps_text": "Devido a grande quantidade de dados, cerca de 3000 pontos por segundo, do tipo inteiro de 32 bits, gerados pelo dispositivo de sensoriamento e necess\u00e1rios para processamento dos algoritmos na DRAGONBOARD 410c, foi utilizado o Arduino DUE para fazer uso de uma entrada anal\u00f3gica com maior poder de processamento, isso foi necess\u00e1rio por que o Shield de interfaceamento Grove Seeed Sensor Mezzanine instalado na DRAGONBOARD 410c, que possui um microcontrolador ATmega 328, n\u00e3o possui poder de processamento para essa opera\u00e7\u00e3o.O Arduino DUE foi configurado para receber os comandos enviados da plataforma QUALCOMM DRAGONBOARD 410c via comunica\u00e7\u00e3o serial.As a\u00e7\u00f5es configuradas no Arduino foram:Realizar a aquisi\u00e7\u00e3o dos dados;Transmitir os dados obtidos para a DRAGONBOARD 410c;Segue a programa\u00e7\u00e3o:#include<math.h>#define Numb_Sample  3000\n#define DAC_Input A0#define SERVO 7 \n#define PosServoMin 4\n#define PosServoMax 6\n#define Period 60\nunsigned int Scont=0,SNow=PosServoMin;\nunsigned long int DAC[Numb_Sample],ind=Numb_Sample;\nvoid TC3_Handler()\n{  \n  TC_GetStatus(TC1, 0);\n  if (ind < Numb_Sample)\n    DAC[ind++] = analogRead(DAC_Input);\n  if(Scont<Period)\n  {\n    if(Scont==SNow)\n      digitalWrite(SERVO,LOW);\n    Scont++;\n  }\n  else\n  {\n    digitalWrite(SERVO,HIGH);\n    Scont=0;\n  }\n}\nvoid SendNumber(unsigned long int numb)\n{\n  for(int i=0; i<sizeof(unsigned long int);i++)\n  {\n    char c = (numb&(255<<sizeof(unsigned long int)-i-1));\n    Serial.print(c);\n  }\n}\n// fun\u00e7\u00e3o de inicia\u00e7\u00e3o de interrup\u00e7\u00e3o\nvoid TimerStart(Tc *tc, uint32_t channel, IRQn_Type irq, uint32_t freq)\n{\n  // desabilita write protect\n  pmc_set_writeprotect(false);\n  // habilita perif\u00e9rico do clock TC1 Channel 0\n  pmc_enable_periph_clk(irq);\n  TC_Configure(/*clock*/ tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_TCCLKS_TIMER_CLOCK1);\n  uint32_t rc = VARIANT_MCK / 2 / freq; // clock master / 2 / frequencia requisitada\n  TC_SetRA(tc, channel, rc >> 1); // 50% duty cycle\n  TC_SetRC(tc, channel, rc);\n  TC_Start(tc, channel);\n  tc->TC_CHANNEL[channel].TC_IER =  TC_IER_CPCS | TC_IER_CPAS;   // habilita os registradores\n  tc->TC_CHANNEL[channel].TC_IDR = ~(TC_IER_CPCS | TC_IER_CPAS); // desabilita os registradores\n  NVIC_EnableIRQ(irq); // habilita interrup\u00e7\u00e3o\n}void setup () \n{\n  Serial.begin(115200);\n  pinMode(DAC_Input, INPUT);\n  TimerStart(TC1, 0, TC3_IRQn, 1500);//Init the Timer\n  //TC_Stop(TC1, 0);\n  pinMode(SERVO,OUTPUT); \n}void loop()\n{\n  /*//while(!Serial.available());\n  char rc;//=Serial.read();\n  int indice = 0; \n  if(rc==0)\n  {\n    while(!Serial.available());\n    rc=Serial.read();\n    switch(rc)\n    {\n       case 1:\n        indice=0;\n        while(!Serial.available());\n        while((rc=Serial.read())!=0xFF)\n        {\n          indice <<= 8;\n          indice += rc;\n          while(!Serial.available());\n        }\n        Serial.print(0);\n        Serial.print(2);\n        SendNumber(DAC[indice]);\n        Serial.print(0xFF);\n        break;\n       case 3:\n        while(!Serial.available());\n        if((Serial.read())==0xFF)\n        {\n            SNow=PosServoMax;\n            delay(500);\n            ind=0;\n            //TC_Start(TC1, 0);\n            while(ind<Numb_Sample);\n            //TC_Stop(TC1, 0);\n            SNow=PosServoMin;\n            delay(500);\n            Serial.print(0);\n            Serial.print(4);\n            Serial.print(0xFF);\n        }\n        break;\n    }\n  }\n  else if(rc=='2')\n  {\n    Serial.print(\"Test Servo Motor\\n\");\n    while(!Serial.available());\n    rc=Serial.read();  \n    if(rc=='1')\n    {\n      Serial.print(\"Mode 1\\n\");\n      SNow=PosServoMax;\n    }\n    if(rc=='2')\n    {\n      Serial.print(\"Mode 2\\n\");\n      SNow=PosServoMin;\n    }\n  } */\n  SNow=PosServoMax;\n  delay(100);\n  SNow=PosServoMin;\n  delay(100);\n}", "step_imgs": ["https://cdn.instructables.com/F4O/DR3M/J8YRAXT8/F4ODR3MJ8YRAXT8.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 5: Configura\u00e7\u00e3o Do Arduino DUE (linguagem C)"}, {"step": 6, "steps_text": "Para a comunica\u00e7\u00e3o dos dados entre o Ardu\u00edno DUE e a DRAGONBOARD 410c, inicialmente utilizou-se a interface da figura acima, o que n\u00e3o foi poss\u00edvel executar, ent\u00e3o optou-se pelo uso de uma interface USB CDC entre o Arduino DUE e a DRAGONBOARD 410c, que necessitaria da recompila\u00e7\u00e3o do KERNEL da DRAGONBOARD 410c, que n\u00e3o se fez por causa do curto tempo dispon\u00edvel.", "step_imgs": ["https://cdn.instructables.com/F2D/NY9C/J8YRDWHC/F2DNY9CJ8YRDWHC.LARGE.jpg"], "step_title": "Step 6: Interfaceamento Das Tecnologias"}, {"step": 7, "steps_text": "Foi configurada para enviar ao Arduino DUE os comandos para realizar a aquisi\u00e7\u00e3o de dados e transmitir os dados obtidos. Segue c\u00f3digo abaixo.Observa\u00e7\u00e3o: A abordagem utilizada no c\u00f3digo, n\u00e3o funcionou devido aos n\u00edveis de tens\u00e3o utilizados pelo Ardu\u00edno DUE e o Mezzanine serem incompat\u00edveis. Por isso optou-se pelo interfaceamento USB, que necessitaria da recompila\u00e7\u00e3o do KERNEL na DRAGONBOARD 410c para que a porta fosse criada corretamente para a comunica\u00e7\u00e3o.import timeimport serial\nimport pandas as pd\nimport numpy as np\n# Configura\u00e7\u00e3o da conex\u00e3o serial\nser = serial.Serial(\n    port='/dev/ttyAMC0', #tty96B0',\n    baudrate=250000,\n    parity=serial.PARITY_NONE,\n    stopbits=serial.STOPBITS_ONE,\n    bytesize=serial.EIGHTBITS\n)ser.isOpen()print('Enter your commands below.\\r\\nInsert \"exit\" to leave the application.')input=1\nwhile 1 :\n    input = input(\">> \")\n    if input == 'exit':\n        ser.close()\n        exit()\n    elif input == 'read':\n        ser.write(0) # Envia o comando para o Arduino DUE realizar a coleta dos dados\n        ser.write(1) # Envia o comando para o Arduino DUE transmitir os dados coletados        lista = []        for i in range(3000):\n            ser.write(i/256)\n            ser.write((i<<8)/256)\n            while ser.inWaiting() > 0:\n                out = ser.read(2)\n                if(out == 0x0002):\n                    atual = 0\n                    c = ser.read(1)\n                    while(c != 0xFF):\n                        atual << 8\n                        atual += c\n                        c = ser.read(1)\n                lista.append(atual)", "step_imgs": ["https://cdn.instructables.com/F7W/5J1V/J8YRAXZ6/F7W5J1VJ8YRAXZ6.LARGE.jpg"], "step_title": "Step 7: Configura\u00e7\u00e3o Da DRAGONBOARD 410c (Python)"}, {"step": 8, "steps_text": "Para poder realizar uma primeira an\u00e1lise dos dados obtidos atrav\u00e9s do sensor, se fez necess\u00e1ria a convers\u00e3o dos arquivos no formato WAV, fornecidos pelos alunos autores do TCC e colaboradores do projeto, para valores num\u00e9ricos, que s\u00e3o utilizados nos algoritmos de an\u00e1lise embarcados na DRAGONBOARD 410c. Para realizar esta convers\u00e3o foi escrito um algoritmo em PYTHON 3 que l\u00ea o arquivo WAV e salva os dados do espectro em um arquivo CSV. O algoritmo utilizado segue abaixo e em anexo para download.Esse algoritmo n\u00e3o se faz necess\u00e1rio para o funcionamento do sistema, j\u00e1 que o Arduino DUE j\u00e1 enviar\u00e1 esses dados em um array de valores num\u00e9ricos.# coding: utf-8# Leitura e convers\u00e3o dos audios para csv# M\u00d3DULOS UTILIZADOS\nimport wave\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt# FUN\u00c7\u00c3O PARA CONVERTER WAV EM DADOS DO ESPECTRO E SALVAR CSV\ndef audio_to_csv(file_name):\n    wave_file = wave.open(file_name+'.wav', 'rb')\n    data_size = wave_file.getnframes()\n    sample_rate = wave_file.getframerate()\n    time_step = 1/sample_rate\n    waveData = wave_file.readframes(data_size-1)\n    signal = np.fromstring(waveData, dtype='int32')\n    Time=np.linspace(start=0,stop=data_size/sample_rate,num=data_size,endpoint=True)\n    df = pd.concat([pd.DataFrame(signal), pd.DataFrame(Time)], axis=1)\n    df.to_csv(file_name + '.csv', index=False)\n    return df# CARREGANDO DATA FRAME COM OS DADOS DO AUDIO\nfile_name = 'Solo_com_Vazamento'\ndf_vazamento = audio_to_csv(file_name)\ndf_vazamento.columns = ['amp', 'time']\nfile_name = 'Solo_sem_Vazamento'\ndf_sem_vazamento = audio_to_csv(file_name)\ndf_sem_vazamento.columns = ['amp', 'time']# GR\u00c1FICO DO ESPECTRO DE AUDIO\nfigure, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(20,10))\nax1.plot(df_vazamento['time'], df_vazamento['amp'])\nax1.set_title('Solo com Vazamento', fontdict={'fontsize': 20, 'fontweight': 'bold'})\nax1.set_xlabel('Tempo [s]', fontdict={'fontsize': 16})\nax1.set_ylim([-4e8,4e8])\nax2.plot(df_sem_vazamento['time'], df_sem_vazamento['amp'])\nax2.set_title('Solo sem Vazamento', fontdict={'fontsize': 20, 'fontweight': 'bold'})\nax2.set_xlabel('Tempo [s]', fontdict={'fontsize': 16})\nax2.set_ylim([-4e8,4e8])\nfigure.tight_layout(h_pad=5)\nplt.show()", "step_imgs": ["https://cdn.instructables.com/FYC/M54T/J8YRMH20/FYCM54TJ8YRMH20.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 8: INTERPRETA\u00c7\u00c3O DOS ARQUIVOS DE AUDIO"}, {"step": 9, "steps_text": "Com o PYTHON 3 \u00e9 realizada a transformada de Fourier, este artificio matem\u00e1tico realiza a transforma\u00e7\u00e3o do sinal do dom\u00ednio do tempo para o dom\u00ednio da frequ\u00eancia, onde se torna poss\u00edvel analisar as varias frequ\u00eancias, e suas amplitudes, que comp\u00f5em aquele sinal. Pela an\u00e1lise visual do gr\u00e1fico da transformada de Fourier um profissional com conhecimentos espec\u00edficos poder\u00e1 identificar a exist\u00eancia de algum vazamento na tubula\u00e7\u00e3o. Estes gr\u00e1ficos servir\u00e3o para valida\u00e7\u00e3o das an\u00e1lises realizadas pelo algoritmo de detec\u00e7\u00e3o autom\u00e1tica.Limitando o eixo das frequ\u00eancias entre 100Hz e 800Hz, fica claro a exist\u00eancia de vazamentos quando se observam dist\u00farbios nesse range de frequ\u00eancias.# coding: utf-8<br><br># M\u00f3dulos utilizados para processamento da transformada de Fourier\nimport pandas as pd\nimport numpy as np\nimport wave\nfrom matplotlib import pyplot as plt<br><br># Fun\u00e7\u00e3o que realiza a transformada de Fourier e plota os gr\u00e1ficos para an\u00e1lise\ndef Fourier(df_list):\n    Fs = 44100;  # Taxa de amostragem em Hz\n    Ts = 1.0/Fs; # Intervalo de amostragem\n    y = pd.concat(df_list)\n    t = y['time'] # Vetor de tempos    \n    y = y['amp'] # Vetor de amplitudes<br>    n = len(y) # Comprimento do sinal\n    k = np.arange(n)\n    T = n/Fs\n    frq = k/T\n    frq = frq[range(n//2)]<br>    Y = np.fft.fft(y)/n\n    Y = Y[range(n//2)]\n    tmp = pd.DataFrame()\n    tmp['amp'] = abs(Y)\n    tmp['freq'] = frq\n    max_lim = max(tmp['amp'][(tmp['freq']>=100) & (tmp['freq']<=800)])    \n    fig, ax = plt.subplots(2, 1, figsize=(20,10))\n    ax[0].plot(t,y)\n    ax[0].set_xlabel('Time')\n    ax[0].set_ylabel('Amplitude')\n    ax[1].plot(frq,abs(Y),'r')\n    ax[1].set_xlim([100,800])\n    ax[1].set_ylim([0,max_lim])\n    ax[1].set_xlabel('Freq (Hz)')\n    ax[1].set_ylabel('|Y(freq)|')\n    plt.show()    \n    return frq, abs(Y)<br># Fun\u00e7\u00e3o que realiza a carga dos dados do CSV e chama a fun\u00e7\u00e3o de Fourier\ndef read_csv(file_name, init, final):\n    df = pd.read_csv(file_name + '.csv')\n    df.columns = ['amp','time']\n    delta = final-init\n    if init*44100 > len(df) or final*44100 > len(df):\n        init = (len(df)/44100)-delta\n        if init < 0:\n            init = 0\n        final = len(df)/44100\n    freq, amp = Fourier([df[int(init*44100):int(final*44100)]])\n    df = pd.DataFrame()\n    df['freq'] = freq\n    df['amp'] = amp\n    df = df[(df['freq']>=100) & (df['freq']<=800)]\n    mx = sorted(df['amp'])\n    print(\"M\u00e9dia das amplitudes:\", np.round(np.mean(mx)))\n    print(\"Percentuais em rela\u00e7\u00e3o a m\u00e9dia das amplitudes.\")\n    print(\"100 maiores amplitudes \", np.mean(mx[-100:])//df['amp'].mean()*100, \"%\", sep=\"\")\n    print(\"50 maiores amplitudes:\", np.mean(mx[-50:])//df['amp'].mean()*100, \"%\", sep=\"\")\n    print(\"10 maiores amplitudes:\", np.mean(mx[-10:])//df['amp'].mean()*100, \"%\", sep=\"\")\n    print(\"Maior amplitude:\", np.mean(mx[-1:])//df['amp'].mean()*100, \"%\", sep=\"\")<br>read_csv('Solo_com_Vazamento', 2, 10) # Exemplo de gr\u00e1ficos para vazamento<br>read_csv('Solo_sem_Vazamento', 2, 10) # Exemplo de gr\u00e1ficos para sem vazamento", "step_imgs": ["https://cdn.instructables.com/FWM/97E5/J8YRCUKW/FWM97E5J8YRCUKW.LARGE.jpg", "https://cdn.instructables.com/FUM/MPA5/J8YRCX5D/FUMMPA5J8YRCX5D.LARGE.jpg", "https://cdn.instructables.com/FBP/I8GM/J8YRCX5E/FBPI8GMJ8YRCX5E.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 9: An\u00e1lise Visual Do Sinal"}, {"step": 10, "steps_text": "Utilizou-se um algoritmo em R para realizar o processamento e extra\u00e7\u00e3o das features (caracter\u00edsticas) dos dados obtidos.Este primeiro algoritmo realiza uma extra\u00e7\u00e3o identificada, onde \u00e9 necess\u00e1rio saber se o arquivo de \u00e1udio trata-se de uma amostra vazamento detectado ou n\u00e3o, isso por que os dados resultantes desse processo servir\u00e3o para o treinamento da rede neural utilizada.Para quando o sistema estiver em modo de opera\u00e7\u00e3o um algoritmo um pouco diferente ser\u00e1 executado, onde n\u00e3o este far\u00e1 a extra\u00e7\u00e3o n\u00e3o identificada, gerando somente as caracter\u00edsticas sem uma identifica\u00e7\u00e3o.Estas features ou carater\u00edsticas s\u00e3o propriedades ac\u00fasticas compostas por varias informa\u00e7\u00f5es referentes ao espectro de \u00e1udio capturado, abaixo seguir\u00e1 uma descri\u00e7\u00e3o (em ingl\u00eas) destas caracter\u00edsticas.Este algoritmo faz parte de um projeto dispon\u00edvel no GitHub e pode ser acessado atrav\u00e9s deste link, o mesmo foi modificado para atender as especifica\u00e7\u00f5es do projeto.O software usado para rodar o algoritmo \u00e9 gratuito, download do interpretador R e do R Studio.Caracter\u00edsticas extra\u00eddas:meanfreq: mean frequency (in kHz)sd: standard deviation of frequencymedian: median frequency (in kHz)Q25: first quantile (in kHz)Q75: third quantile (in kHz)IQR: interquantile range (in kHz)skew: skewness (see note in specprop description)kurt: kurtosis (see note in specprop description)sp.ent: spectral entropysfm: spectral flatnessmode: mode frequencycentroid: frequency centroid (see specprop)peakf: peak frequency (frequency with highest energy)meanfun: average of fundamental frequency measured across acoustic signalminfun: minimum fundamental frequency measured across acoustic signalmaxfun: maximum fundamental frequency measured across acoustic signalmeandom: average of dominant frequency measured across acoustic signalmindom: minimum of dominant frequency measured across acoustic signalmaxdom: maximum of dominant frequency measured across acoustic signaldfrange: range of dominant frequency measured across acoustic signalmodindx: modulation index. Calculated as the accumulated absolute difference between adjacent measurements of fundamental frequencies divided by the frequency rangelabel: leakage or without_leakageAlgoritmo usado:packages <- c('tuneR', 'seewave', 'fftw', 'caTools', 'randomForest', 'warbleR', 'mice', 'e1071', 'rpart', 'xgboost', 'e1071')if (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n  install.packages(setdiff(packages, rownames(installed.packages())))  \n}library(tuneR)\nlibrary(seewave)\nlibrary(caTools)\nlibrary(rpart)\nlibrary(rpart.plot)\nlibrary(randomForest)\nlibrary(warbleR)\nlibrary(mice)\nlibrary(xgboost)\nlibrary(e1071)specan3 <- function(X, bp = c(0,22), wl = 2048, threshold = 5, parallel = 1){\n  # To use parallel processing: library(devtools), install_github('nathanvan/parallelsugar')\n  if(class(X) == \"data.frame\") {if(all(c(\"sound.files\", \"selec\", \n                                         \"start\", \"end\") %in% colnames(X))) \n  {\n    start <- as.numeric(unlist(X$start))\n    end <- as.numeric(unlist(X$end))\n    sound.files <- as.character(unlist(X$sound.files))\n    selec <- as.character(unlist(X$selec))\n  } else stop(paste(paste(c(\"sound.files\", \"selec\", \"start\", \"end\")[!(c(\"sound.files\", \"selec\", \n                                                                        \"start\", \"end\") %in% colnames(X))], collapse=\", \"), \"column(s) not found in data frame\"))\n  } else  stop(\"X is not a data frame\")\n  \n  #if there are NAs in start or end stop\n  if(any(is.na(c(end, start)))) stop(\"NAs found in start and/or end\")  \n  \n  #if end or start are not numeric stop\n  if(all(class(end) != \"numeric\" & class(start) != \"numeric\")) stop(\"'end' and 'selec' must be numeric\")\n  \n  #if any start higher than end stop\n  if(any(end - start<0)) stop(paste(\"The start is higher than the end in\", length(which(end - start<0)), \"case(s)\"))  \n  \n  #if any selections longer than 20 secs stop\n  if(any(end - start>20)) stop(paste(length(which(end - start>20)), \"selection(s) longer than 20 sec\"))  \n  options( show.error.messages = TRUE)\n  \n  #if bp is not vector or length!=2 stop\n  if(!is.vector(bp)) stop(\"'bp' must be a numeric vector of length 2\") else{\n    if(!length(bp) == 2) stop(\"'bp' must be a numeric vector of length 2\")}\n  \n  #return warning if not all sound files were found\n  fs <- list.files(path = getwd(), pattern = \".wav$\", ignore.case = TRUE)\n  if(length(unique(sound.files[(sound.files %in% fs)])) != length(unique(sound.files))) \n    cat(paste(length(unique(sound.files))-length(unique(sound.files[(sound.files %in% fs)])), \n              \".wav file(s) not found\"))\n  \n  #count number of sound files in working directory and if 0 stop\n  d <- which(sound.files %in% fs) \n  if(length(d) == 0){\n    stop(\"The .wav files are not in the working directory\")\n  }  else {\n    start <- start[d]\n    end <- end[d]\n    selec <- selec[d]\n    sound.files <- sound.files[d]\n  }\n  \n  # If parallel is not numeric\n  if(!is.numeric(parallel)) stop(\"'parallel' must be a numeric vector of length 1\") \n  if(any(!(parallel %% 1 == 0),parallel < 1)) stop(\"'parallel' should be a positive integer\")\n  \n  # If parallel was called\n  if(parallel > 1)\n  { options(warn = -1)\n    if(all(Sys.info()[1] == \"Windows\",requireNamespace(\"parallelsugar\", quietly = TRUE) == TRUE)) \n      lapp <- function(X, FUN) parallelsugar::mclapply(X, FUN, mc.cores = parallel) else\n        if(Sys.info()[1] == \"Windows\"){ \n          cat(\"Windows users need to install the 'parallelsugar' package for parallel computing (you are not doing it now!)\")\n          lapp <- pbapply::pblapply} else lapp <- function(X, FUN) parallel::mclapply(X, FUN, mc.cores = parallel)} else lapp <- pbapply::pblapply\n  \n  options(warn = 0)\n  \n  if(parallel == 1) cat(\"Measuring acoustic parameters:\")\n  x <- as.data.frame(lapp(1:length(start), function(i) { \n    r <- tuneR::readWave(file.path(getwd(), sound.files[i]), from = start[i], to = end[i], units = \"seconds\") \n    \n    b<- bp #in case bp its higher than can be due to sampling rate\n    if(b[2] > ceiling(r@samp.rate/2000) - 1) b[2] <- ceiling(r@samp.rate/2000) - 1 \n    \n    \n    #frequency spectrum analysis\n    songspec <- seewave::spec(r, f = r@samp.rate, plot = FALSE)\n    analysis <- seewave::specprop(songspec, f = r@samp.rate, flim = c(0, 280/1000), plot = FALSE)\n    \n    #save parameters\n    meanfreq <- analysis$mean/1000\n    sd <- analysis$sd/1000\n    median <- analysis$median/1000\n    Q25 <- analysis$Q25/1000\n    Q75 <- analysis$Q75/1000\n    IQR <- analysis$IQR/1000\n    skew <- analysis$skewness\n    kurt <- analysis$kurtosis\n    sp.ent <- analysis$sh\n    sfm <- analysis$sfm\n    mode <- analysis$mode/1000\n    centroid <- analysis$cent/1000\n    \n    #Frequency with amplitude peaks\n    peakf <- 0#seewave::fpeaks(songspec, f = r@samp.rate, wl = wl, nmax = 3, plot = FALSE)[1, 1]\n    \n    #Fundamental frequency parameters\n    ff <- seewave::fund(r, f = r@samp.rate, ovlp = 50, threshold = threshold, \n                        fmax = 280, ylim=c(0, 280/1000), plot = FALSE, wl = wl)[, 2]\n    meanfun<-mean(ff, na.rm = T)\n    minfun<-min(ff, na.rm = T)\n    maxfun<-max(ff, na.rm = T)\n    \n    #Dominant frecuency parameters\n    y <- seewave::dfreq(r, f = r@samp.rate, wl = wl, ylim=c(0, 280/1000), ovlp = 0, plot = F, threshold = threshold, bandpass = b * 1000, fftw = TRUE)[, 2]\n    meandom <- mean(y, na.rm = TRUE)\n    mindom <- min(y, na.rm = TRUE)\n    maxdom <- max(y, na.rm = TRUE)\n    dfrange <- (maxdom - mindom)\n    duration <- (end[i] - start[i])\n    \n    #modulation index calculation\n    changes <- vector()\n    for(j in which(!is.na(y))){\n      change <- abs(y[j] - y[j + 1])\n      changes <- append(changes, change)\n    }\n    if(mindom==maxdom) modindx<-0 else modindx <- mean(changes, na.rm = T)/dfrange\n    \n    #save results\n    return(c(duration, meanfreq, sd, median, Q25, Q75, IQR, skew, kurt, sp.ent, sfm, mode, \n             centroid, peakf, meanfun, minfun, maxfun, meandom, mindom, maxdom, dfrange, modindx))\n  }))\n  \n  #change result names\n  \n  rownames(x) <- c(\"duration\", \"meanfreq\", \"sd\", \"median\", \"Q25\", \"Q75\", \"IQR\", \"skew\", \"kurt\", \"sp.ent\", \n                   \"sfm\",\"mode\", \"centroid\", \"peakf\", \"meanfun\", \"minfun\", \"maxfun\", \"meandom\", \"mindom\", \"maxdom\", \"dfrange\", \"modindx\")\n  x <- data.frame(sound.files, selec, as.data.frame(t(x)))\n  colnames(x)[1:2] <- c(\"sound.files\", \"selec\")\n  rownames(x) <- c(1:nrow(x))\n  \n  return(x)\n}processFolder <- function(folderName) {\n  # Start with empty data.frame.\n  data <- data.frame()\n  \n  # Get list of files in the folder.\n  list <- list.files(folderName, '\\\\.wav')\n  \n  # Add file list to data.frame for processing.\n  for (fileName in list) {\n    row <- data.frame(fileName, 0, 0, 20)\n    data <- rbind(data, row)\n  }\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  # Move into folder for processing.\n  setwd(folderName)\n  \n  # Process files.\n  acoustics <- specan3(data, parallel=1)\n  \n  # Move back into parent folder.\n  setwd('..')\n  \n  acoustics\n}gender <- function(filePath) {\n  if (!exists('genderBoosted')) {\n    load('model.bin')\n  }\n  \n  # Setup paths.\n  currentPath <- getwd()\n  fileName <- basename(filePath)\n  path <- dirname(filePath)\n  \n  # Set directory to read file.\n  setwd(path)\n  \n  # Start with empty data.frame.\n  data <- data.frame(fileName, 0, 0, 20)\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  # Process files.\n  acoustics <- specan3(data, parallel=1)\n  \n  # Restore path.\n  setwd(currentPath)\n  \n  predict(genderCombo, newdata=acoustics)\n}# Load data\nleakage <- processFolder('caminho para o pasta com samples de \u00e1udio com vazamento')\nwithout_leakage <- processFolder('caminho para o pasta com samples de \u00e1udio sem vazamento')# Set labels.\nleakage$label <- 1\nwithout_leakage$label <- 2\ndata <- rbind(leakage, without_leakage)\ndata$label <- factor(data$label, labels=c('leakage', 'without_leakage'))# Remove unused columns.\ndata$duration <- NULL\ndata$sound.files <- NULL\ndata$selec <- NULL\ndata$peakf <- NULL# Remove rows containing NA's.\ndata <- data[complete.cases(data),]# Write out csv dataset.\nwrite.csv(data, file='features.csv', sep=',', row.names=F)", "step_imgs": ["https://cdn.instructables.com/F8P/OIW8/J8YRMLRA/F8POIW8J8YRMLRA.LARGE.jpg", "https://cdn.instructables.com/FC7/T9OL/J8YRMODA/FC7T9OLJ8YRMODA.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 10: Algoritmo Em R Para Extra\u00e7\u00e3o Das Features Dos Dados"}, {"step": 11, "steps_text": "A ideia do uso de uma rede neural, \u00e9 a de realizar um reconhecimento automatizado atrav\u00e9s dos dados coletados pelo dispositivo de sensoriamento.A rede neural utilizada \u00e9 do tipo MLP (Multilayer Perceptron), este modelo \u00e9 treinado com dados previamente identificados e ap\u00f3s esse treinamento o modelo implantado no sistema conseguir\u00e1 realizar a identifica\u00e7\u00e3o autom\u00e1tica do sinal recebido, informando se naquele ponto existe um vazamento ou n\u00e3o.Foi necess\u00e1rio realizar uma filtragem dos dados de entrada, pois algumas caracter\u00edsticas estavam diminuindo a taxa de acerto da rede ao inv\u00e9s de melhora-la. N\u00e3o foi realizado nenhuma abordagem estat\u00edstica muito aprofundada, mas mesmo com um trabalho mais superficial pode-se chegar a algumas vari\u00e1veis com bons desempenhos.Para os testes realizados o modelo obteve um desempenho muito bom, alcan\u00e7ando na maioria dos testes uma taxa de acerto de 100%, como pode ser observado na imagem anexa.Este algoritmo \u00e9 utilizado para treinar o modelo da rede e retornar a taxa de acerto do mesmo. No sistema de detec\u00e7\u00e3o um algoritmo um pouco diferente seria usado, pois ele realizaria o treino ou receberia um modelo j\u00e1 treinado da nuvem ou de alguma outra fonte e com esse modelo realizaria as predi\u00e7\u00f5es para cada leitura realizada.# coding: utf-8import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split as tts\nfrom sklearn.neural_network import MLPClassifier as MLP\nfrom sklearn.metrics import classification_report as cr\nfrom sklearn.metrics import confusion_matrix as cm# Leitura dos dados do CSV\ndf = pd.read_csv('features.csv')\n# Separa\u00e7\u00e3o das entradas\ndf_X = df[df.columns[:len(df.columns)-1]]\n# Filtrando as entradas\ndf_X = df_X[['IQR','meanfun','sd','Q25','sfm','centroid','meandom','mindom']]\n# Separa\u00e7\u00e3o das saidas\ndf_Y = df[df.columns[-1]]\n# Discretiza\u00e7\u00e3o das saidas\ndf_Y = pd.get_dummies(df_Y)\ndf_Y = df_Y['leakage']# Separando dados para treino e teste\nX_train, X_test, Y_train, Y_test = tts(df_X, df_Y, test_size=0.1)# Criando modelo de rede neural\nmodelo = MLP(alpha=0.0001, learning_rate_init=0.0001, hidden_layer_sizes=(50,50,50,50), max_iter=10000, activation='tanh', solver='lbfgs')# Treinando modelo\nmodelo.fit(X_train, Y_train)\nresult = modelo.predict(X_test)# Imprimindo resultados\nreport = cr(Y_test, result)\nmat = cm(y_pred=result, y_true=Y_test)\nprint(\"Matriz de confus\u00e3o\")\nprint(mat, end=\"\\n\\n\")\nprint(\"Relat\u00f3rio de Classifica\u00e7\u00e3o\")\nprint(report)", "step_imgs": ["https://cdn.instructables.com/FJB/3AMJ/J8YRMS74/FJB3AMJJ8YRMS74.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 11: Rede Neural"}], "channel": "Electronics"}, {"category": "No category to show", "description": "In electronics it is important that one be able to recognize wave patterns and their meanings. A good understanding of the trigonometric functions (SIN, COS, TAN, CSC, SEC, COT) is a must.\rThe following program will graph these functions and facilitate the study of AMPLITUDE, PHASE SHIFT, VERTICAL TRANSLATION and PERIOD. One is able to graph functions that are ADDED, SUBTRACTED, ABSOLUTE VALUE, and functions raised EXPONENTIALLY.\rFor the biginner, it is best to experiment using one function, the SIN for example. Procede as follows and use the (H)ELP screen frequently to check out definitions:\rNOTE: If you succeed in mastering only the SIN and the COS functions you are doing well.\ra) Do Amplitude, Period, Phase Shift, and Vertical Tanslation with SIN. Do several examples of each on the SIN function until you are comfortable with the meaning of each operation.\rb) Repeat the above using the COS function.\rc) Using only the SIN and the Cos functions, experiment doing ADDITION, SUBTRUATION, ABSOLUTE VALUE, and EXPONENTIALS.\rd) Experiment using the other Trig functions. Look up the meaning of the word ASYMPTOTE and graph the TAN function.   See the curve a-s-y-m-p-t-o-t-e !\rWhen you RUN PT.EXE wait a few seconds while the program loads and auto-executes.\rIgnore the address, etc., on the title page.\r", "title": "Trigonometric Functions", "url": "https://www.instructables.com/id/Trigonometric-Functions/", "section": "home", "steps": [], "channel": "No channel to show"}, {"category": "No category to show", "description": "YES, another great STEM activity with a new twist to the \u201cegg-drop\u201d\u2026Students are tasked to design and construct a soda bottle H2O rocket, successfully launch with its (egg) payload and recover unbroken (See Step\u00a014 - Design Brief).\n\tWe spend time initially discussing the \"design process\". There are many versions, but the majorities have several steps in common: problem statement; defining criteria; research; brain-storming; modeling; testing; improvements; manufacture...\n\tMany valuable lessons that can be incorporated into unit, i.e. Newton's Laws of Motion, Trigonometry, English-to-Metric Conversion, Statistics.Concepts covered:\n\tEngineers develop models to evaluate possible solutions.\n\tKnowledge gained in other disciplines impact development of products & systems.Lessons Learned: \n\tResearch & development are problem-solving techniques widely used in the business world & technology.Application:\n\tStudents will apply research and the design process to solve problems in and beyond the classroom...\n\t\u00a0", "title": "Soda Bottle Rocket Launcher($13.97) a Child's Smile(PRICELESS!)", "url": "https://www.instructables.com/id/Soda-Bottle-Rocket-Launcher1397-A-Childs-Smil/", "section": "home", "steps": [{"step": 1, "steps_text": "To level the \u201cplaying field\u201d, I constructed the launch pad\u2026 the materials you\u2019ll require, with the exception of the tire valve, can be found at building supply or hardware stores. 10 feet - 1/2\" PVC Pipe Schedule 40(DON\u2019T CONFUSE WITH CPVC)\u00a0 (1)\u00a0 2\u201d Long Piece, 1-1/2\u201d PVC Pipe Schedule 40 \u00a0 (4) 1/2\u201d Slip End Caps(2) 1/2\u201d Slip Tees(1) 1/2\" Tee, Slip & Internal Thread (1) 1/2\" Adapter, Slip & External ThreadNOTE: THE INTERNAL & EXTERNAL THREADED PARTS ALLOW DISASSEMBLING FOR EASY STORAGE.(1) Small Can PVC Cement(1) Small Can\u00a0 PVC Cleaner(2) Hose Clamps w/at least 2\u201d Diameter(9) Multi-Purpose/Zip-Ties, minimum 8\u201d Long\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (1) Small Roll Duct Tape(1) Small Roll Teflon Tape(1) Small Roll of 2\u201d Painter or Masking Tape(1) Tire Valve/Stem \u2013 Local Automotive Supply Store15 feet Twine or Thin Rope(2) 2-Liter Soda Bottles\u00a0TOOLS:Tape Measure & PencilHand Saw (Hack-saw, Back-Saw, or X-Cut)Portable Drill 1/2\", 3/16\u201d & 1/4\" Twist Drill BitsPliersHeat Gun or CandleScissors or X-Acto KnifeAir Pump w/Pressure Gauge or Air Compressor", "step_imgs": ["https://cdn.instructables.com/FAG/2LJ0/GYUY0ZD4/FAG2LJ0GYUY0ZD4.LARGE.jpg", "https://cdn.instructables.com/F77/I510/GYUY0ZD6/F77I510GYUY0ZD6.LARGE.jpg"], "step_title": "Step 1: Constructing Launch Pad"}, {"step": 2, "steps_text": "CUT THE PIPE, six pieces, 12 inches long; one piece, 24 inches long; and one, 8 inches long of 1/2\u201d PVC.DRILL HOLE FOR TIRE VALVE, place an end cap on a piece of scrap wood, holding securely with pliers, first drill 1/4\" pilot hole and then 1/2\u201d hole in the top INSERT THE VALVE, slide the valve through the hole in the end cap; grab the end of the valve cap with pliers and pull until fully seated.", "step_imgs": ["https://cdn.instructables.com/FAD/84TW/GYUY0ZDF/FAD84TWGYUY0ZDF.LARGE.jpg", "https://cdn.instructables.com/FZT/OZWC/GYUY0ZDT/FZTOZWCGYUY0ZDT.LARGE.jpg", "https://cdn.instructables.com/F2Y/5OBQ/GYUY1CFE/F2Y5OBQGYUY1CFE.LARGE.jpg"], "step_title": "Step 2: Let's Begin..."}, {"step": 3, "steps_text": "GLUE & ASSEMBLE THE BASE, lay-out the pieces in the order in which they will be assembled: end cap, 12-inch section, slip tee, 12-inch sections, end cap, etc. Clean the outside of the pipe and inside of the fitting with PVC pipe cleaner. Glue the pieces one at a time, cement sets in seconds\u2026Attach the 8\u201d piece of PVC to the base with a pipe clamp to act as a string guide.\u00a0 \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FZ1/JXFZ/GYUY0ZDO/FZ1JXFZGYUY0ZDO.LARGE.jpg", "https://cdn.instructables.com/FSM/AINO/GYUY0ZDQ/FSMAINOGYUY0ZDQ.LARGE.jpg", "https://cdn.instructables.com/F3O/AC90/GYUY0ZDR/F3OAC90GYUY0ZDR.LARGE.jpg"], "step_title": "Step 3: Glue & Assemble Base"}, {"step": 4, "steps_text": "CREATE BOTTLE SEAL, this bulge will create a seal between the pipe and the soda bottle. Mark the vertical piece 10-inches from the open end. Using a candle or heat-gun, heat the pipe evenly at this mark until it becomes soft. Grasp pipe on either side of mark and push together to create a slight bulge. Hold the pipe straight until cool and no longer soft.", "step_imgs": ["https://cdn.instructables.com/FE0/US6O/GYUY1CBM/FE0US6OGYUY1CBM.LARGE.jpg", "https://cdn.instructables.com/FO5/0ZO5/GYUY1CFL/FO50ZO5GYUY1CFL.LARGE.jpg", "https://cdn.instructables.com/FTF/OGLZ/GYUY0ZEW/FTFOGLZGYUY0ZEW.LARGE.jpg"], "step_title": "Step 4: Creating Bottle Seal"}, {"step": 5, "steps_text": "BOTTLE CLAMP; holds bottle tight to bulge. Tape nine (9) zip-ties together with duct tape, making sure the ties all face the same direction, are parallel and their heads line up evenly. Tape both sides to hold securely.Slide a soda bottle over the end of the pipe until it seats against the bulge. Wrap the zip-ties around the pipe with the heads facing inward, catching the lip of the bottle. Secure the zip-ties\u00a0 with a hose clamp.\u00a0", "step_imgs": ["https://cdn.instructables.com/FC9/D027/GYUY0ZGJ/FC9D027GYUY0ZGJ.LARGE.jpg", "https://cdn.instructables.com/FZR/2HQB/GYUY0ZH4/FZR2HQBGYUY0ZH4.LARGE.jpg"], "step_title": "Step 5: Bottle Clamp"}, {"step": 6, "steps_text": "LAUNCH TRIGGER; cut the top and bottom off a 2-liter soda bottle with a pair of scissors. Flatten the middle section using care not to crease it, held with painter\u2019s tape, cut a 1-1/4 inch hole through both sides. This will hold the trigger in position until you\u2019re ready to launch. Drill a 3/16\u201d in the side of a 3-inch piece of 1-1/2 inch PVC pipe. Tie piece of 10-foot string through the hole.", "step_imgs": ["https://cdn.instructables.com/FVZ/XC2Z/GYUY0ZFF/FVZXC2ZGYUY0ZFF.LARGE.jpg", "https://cdn.instructables.com/FGS/5ABX/GYUY0ZG0/FGS5ABXGYUY0ZG0.LARGE.jpg", "https://cdn.instructables.com/FD0/U5PH/GYUY0ZHA/FD0U5PHGYUY0ZHA.LARGE.jpg"], "step_title": "Step 6: Launch Trigger"}, {"step": 7, "steps_text": "ASSEMBLE TRIGGER MECHANISM; slide the \u201ctrigger spring\u201d over the end of the pipe, the zip-ties and snuggly against the pipe clamp. Next, slide the \u201ctrigger\u201d over the pipe and zip-ties. Thread the string through the holes in the \u201cspring\u201d and the \u201cguide\u201d. Conduct a test; the \u201cspring\u201d should hold the \u201ctrigger\u201d up and over the ties\u2026it should drop, allowing the ties to open up when you pull the string.", "step_imgs": ["https://cdn.instructables.com/FD0/U5PH/GYUY0ZHA/FD0U5PHGYUY0ZHA.LARGE.jpg"], "step_title": "Step 7: Assemble Trigger Mechanism"}, {"step": 8, "steps_text": "LAUNCH SEQUENCE! Fill the soda bottle about one-third full of water and slide onto the end of the pipe until it\u2019s seated against the bulge. Slip the ties over the bottle\u2019s lip and slide the trigger up over the ties. Pressurize the launcher with either a bicycle pump or air compressor. Exercise caution not to exceed 70 psi\u20263-2-1\u2026 PULL THE STRING!!!", "step_imgs": [], "step_title": "Step 8: Launch Sequence!"}, {"step": 9, "steps_text": "Rocket does not launch:\n1. Vertical piece of PVC pipe may need to be sanded a little so that mouth of bottle slids on/off easily. Caution not to sand down seal too much...\n2. As you charge launcher, water/air escaping...loosen pipe clamp, seat bottle neck against seal,\u00a0reposition\u00a0zip-ties, re-tighten clamp.", "step_imgs": [], "step_title": "Step 9: Trouble-Shooting"}, {"step": 10, "steps_text": "Respect as you would a loaded firearm...\n\tRecommend 70 psi...not to exceed 90...worse case scenario, rocket could explode w/a loud\"BANG\", possibly causing ear damage.\n\tLaunch in a large open area away from parked cars and populated areas. Designate stand-off distance of 25 feet from launcher.\n\tRestrict payloads...no rocks!\n\tAdult(s) only charge system. Wear eye & hearing protection. Have your back towards launcher as charging.\n\tThese are by no means all inclusive...list will grow w/experience.", "step_imgs": [], "step_title": "Step 10: Safety Precautions"}, {"step": 11, "steps_text": "\n\t\u00a0We calculated rockets elevation with a home-made elevation tracker for less than $.50 cents or you can purchase a commercial one at most hobby/model stores for $20...\n\tOurs was constructed with a meter stick, protractor, some string and a weight (flat washer).The tracker is designed to measure the angle a rocket reaches from a known distance from the launch pad and a mathematical formula. Note: More accurate if the angle is below 45 degrees.(Tangent of Angle) X (Distance from the Launch Pad) = Rocket AltitudeI use two (2) students, a \u201ctracker\u201d, whose responsibility is to track the rocket from launch to the highest point of flight (apogee) and determine the angle. A \u201crecorder\u201d, who calculates and records the data, both are positioned 300 feet from the launch pad and at right angle to wind. \u00a0For ease, we use a table with values of the tangent for various values of angle (See\u00a0Step 12\u00a0\u2013 Table of Tangent Angle).Example: If you are 300 feet away from the pad, and measure an angle of 27 degrees, the tangent of 27 = .5\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .5 X 300 = 150 feet altitude", "step_imgs": ["https://cdn.instructables.com/F2D/ZHGJ/GYVDIINM/F2DZHGJGYVDIINM.LARGE.jpg", "https://cdn.instructables.com/FJS/HS4O/GYVDIINH/FJSHS4OGYVDIINH.LARGE.jpg"], "step_title": "Step 11: Calculating Rocket's Altitude"}, {"step": 12, "steps_text": "\n\t\t\t\t\u00a0Table of Angles and Their Tangents\n\t\t\t\tAngle\n\t\t\t\tTangent\n\t\t\t\t\u00b0 \u00b0\n\t\t\t\tAngle\n\t\t\t\tTangent\n\t\t\t\t\u00b0 \u00b0\n\t\t\t\tAngle\n\t\t\t\tTangent\n\t\t\t\t0\n\t\t\t\t0.0000\n\t\t\t\t30\n\t\t\t\t0.5773\n\t\t\t\t60\n\t\t\t\t1.7317\n\t\t\t\t1\n\t\t\t\t0.0175\n\t\t\t\t31\n\t\t\t\t0.6008\n\t\t\t\t61\n\t\t\t\t1.8037\n\t\t\t\t2\n\t\t\t\t0.0349\n\t\t\t\t32\n\t\t\t\t0.6248\n\t\t\t\t62\n\t\t\t\t1.8804\n\t\t\t\t3\n\t\t\t\t0.0524\n\t\t\t\t33\n\t\t\t\t0.6493\n\t\t\t\t63\n\t\t\t\t1.9622\n\t\t\t\t4\n\t\t\t\t0.0699\n\t\t\t\t34\n\t\t\t\t0.6744\n\t\t\t\t64\n\t\t\t\t2.0499\n\t\t\t\t5\n\t\t\t\t0.0875\n\t\t\t\t35\n\t\t\t\t0.7001\n\t\t\t\t65\n\t\t\t\t2.1440\n\t\t\t\t6\n\t\t\t\t0.1051\n\t\t\t\t36\n\t\t\t\t0.7265\n\t\t\t\t66\n\t\t\t\t2.2455\n\t\t\t\t7\n\t\t\t\t0.1228\n\t\t\t\t37\n\t\t\t\t0.7535\n\t\t\t\t67\n\t\t\t\t2.3553\n\t\t\t\t8\n\t\t\t\t0.1405\n\t\t\t\t38\n\t\t\t\t0.7812\n\t\t\t\t68\n\t\t\t\t2.4745\n\t\t\t\t9\n\t\t\t\t0.1584\n\t\t\t\t39\n\t\t\t\t0.8097\n\t\t\t\t69\n\t\t\t\t2.6044\n\t\t\t\t10\n\t\t\t\t0.1763\n\t\t\t\t40\n\t\t\t\t0.8390\n\t\t\t\t70\n\t\t\t\t2.7467\n\t\t\t\t11\n\t\t\t\t0.1944\n\t\t\t\t41\n\t\t\t\t0.8692\n\t\t\t\t71\n\t\t\t\t2.9033\n\t\t\t\t12\n\t\t\t\t0.2125\n\t\t\t\t42\n\t\t\t\t0.9003\n\t\t\t\t72\n\t\t\t\t3.0767\n\t\t\t\t13\n\t\t\t\t0.2309\n\t\t\t\t43\n\t\t\t\t0.9324\n\t\t\t\t73\n\t\t\t\t3.2698\n\t\t\t\t14\n\t\t\t\t0.2493\n\t\t\t\t44\n\t\t\t\t0.9656\n\t\t\t\t74\n\t\t\t\t3.4862\n\t\t\t\t15\n\t\t\t\t0.2679\n\t\t\t\t45\n\t\t\t\t1.0000\n\t\t\t\t75\n\t\t\t\t3.7306\n\t\t\t\t16\n\t\t\t\t0.2867\n\t\t\t\t46\n\t\t\t\t1.0354\n\t\t\t\t76\n\t\t\t\t4.0091\n\t\t\t\t17\n\t\t\t\t0.3057\n\t\t\t\t47\n\t\t\t\t1.0722\n\t\t\t\t77\n\t\t\t\t4.3295\n\t\t\t\t18\n\t\t\t\t0.3249\n\t\t\t\t48\n\t\t\t\t1.1105\n\t\t\t\t78\n\t\t\t\t4.7023\n\t\t\t\t19\n\t\t\t\t0.3443\n\t\t\t\t49\n\t\t\t\t1.1502\n\t\t\t\t79\n\t\t\t\t5.1418\n\t\t\t\t20\n\t\t\t\t0.3639\n\t\t\t\t50\n\t\t\t\t1.1916\n\t\t\t\t80\n\t\t\t\t5.6679\n\t\t\t\t21\n\t\t\t\t0.3838\n\t\t\t\t51\n\t\t\t\t1.2347\n\t\t\t\t81\n\t\t\t\t6.3095\n\t\t\t\t22\n\t\t\t\t0.4040\n\t\t\t\t52\n\t\t\t\t1.2798\n\t\t\t\t82\n\t\t\t\t7.1099\n\t\t\t\t23\n\t\t\t\t0.4244\n\t\t\t\t53\n\t\t\t\t1.3269\n\t\t\t\t83\n\t\t\t\t8.1372\n\t\t\t\t24\n\t\t\t\t0.4452\n\t\t\t\t54\n\t\t\t\t1.3762\n\t\t\t\t84\n\t\t\t\t9.5045\n\t\t\t\t25\n\t\t\t\t0.4663\n\t\t\t\t55\n\t\t\t\t1.4279\n\t\t\t\t85\n\t\t\t\t11.4157\n\t\t\t\t26\n\t\t\t\t0.4877\n\t\t\t\t56\n\t\t\t\t1.4823\n\t\t\t\t86\n\t\t\t\t14.2780\n\t\t\t\t27\n\t\t\t\t0.5095\n\t\t\t\t57\n\t\t\t\t1.5396\n\t\t\t\t87\n\t\t\t\t19.0404\n\t\t\t\t28\n\t\t\t\t0.5317\n\t\t\t\t58\n\t\t\t\t1.6001\n\t\t\t\t88\n\t\t\t\t28.5437\n\t\t\t\t29\n\t\t\t\t0.5543\n\t\t\t\t59\n\t\t\t\t1.6640\n\t\t\t\t89\n\t\t\t\t56.9168", "step_imgs": [], "step_title": "Step 12: Table of TAN(Angle)"}, {"step": 13, "steps_text": "\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0Student's NameAngleTangentAltitude\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\t\t\t\t\u00a0\u00a0\u00a0\u00a0\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0\n\t\t\t\t\u00a0Mean=the sum of the values of data set, divided by number of values in a data set.\u00a0\u00a0 Mode= most frequently occurring value in a data setMedian= value that occurs in middle of data set arranged in chronological order.\u00a0 NOTE: Data set w/odd# of values always has median\u2026for even# of values, two middle values are averaged w/results being the medianRange= difference between the largest & smallest values that occur in a data set", "step_imgs": [], "step_title": "Step 13: Rocket Data Sheet"}, {"step": 14, "steps_text": "\n\t\u00a0\u00a0Client: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0US based school supply store chain\u00a0Target Consumer:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Educators, youth groups, clubs, & home-schooled, etc.\u00a0Problem Statement:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Proven fact that America\u2019s youth are falling further and further behind other countries in areas of science, technology, engineering and mathematics. To further compound matters, national, state and local governments are facing deeper and deeper budget cuts each year. How can we help classroom teacher meet these challenges and still offer a quality education with dwindling resources?\u00a0Design Statement:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Develop a \u201cturn-key\u201d unit on rocket propulsion. Content as minimum should include topics: Newton\u2019s 3 Laws, calculating rate & height of assent, design process. Able to achieve same comparable results of more expensive \u201ckits\u201d yet at a portion of the costs. Content covers topics taught in other disciplines. Materials consist of common house-hold items or off-the-shelf at local retailers. \u00a0Constraints: 1.\u00a0\u00a0\u00a0 2-Liter soda bottle2.\u00a0\u00a0\u00a0 Achieve minimum height of 20 feet3.\u00a0\u00a0\u00a0 Successfully launch and recover payload (egg)4.\u00a0\u00a0\u00a0 Gross Rocket Weight (GRW) 160 grams or less. 5.\u00a0\u00a0\u00a0 Inexpensive, utilize common house-hold items\u00a0\u00a0\u00a0\u00a0", "step_imgs": [], "step_title": "Step 14: Design Brief"}, {"step": 15, "steps_text": "CATEGORIES54321DesignSimple, Clean, excellent choice of materialsSimple, Clean; minor changes while constructingComplex, major changes to original designToo Complex; materials incompatibleIncompleteConstructionGRW less than 160gGRW less than or equal 170 gramsGRW less than or equal 180 gramsGRW less than or equal 190 gramsFails to Complete on scheduleLaunchingZero Structural FailuresMinor Structural Failure; launch unaffectedMinor Structural Failure; affects launch & altitudeMajor Structural Failure; barely manages to launchFails to LaunchHeight50 Feet (+)40 Feet (+)30 Feet (+)Grter/Equal 20 feetLess Than 20 FeetRecovery System FunctionFunctions as designedMinor malfunction; no impact on payloadMajor malfunction; significant impactMajor malfunction; extensive damage to payload\u00a0System failurePayloadNo damageSuperficial cracks; contents undamagedClearly visible cracks; contents seepingShell broken; contents leakingShell destroyed; contents unrecoverable", "step_imgs": [], "step_title": "Step 15: Rocket Rubric"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "Every city has a few houses that go overboard with giant lighted lawn decorations during the Christmas holiday. \u00a0The thought of hand drilling zillions of holes for stuffing with tiny lights has kept me from even putting up a few small decorations.\n\u00a0\nThis year, I'm changing that\u2026as a member of TechShop, I have access to a cool CNC router (love that ShopBot!). \u00a0So, I'm going to make it do the tedious work of drilling all those holes and cutting out the decoration's shape.\nThis instructable walks through the design/drawing of a \"Star of Bethlehem\". It also shows how to reduce laying out more than a hundred holes for lights to a matter of a couple simple steps. \u00a0\nI used VCarve Pro to layout the entire project and to create the toolpaths for the ShopBot.\n\u00a0\nMost steps will have at least three photos to help explain what needs to be done. \u00a0The first photo shows where on VCarve's screen to find the tool. \u00a0The second photo shows the settings used by that tool. \u00a0The third photo shows what the drawing should look like after using the drawing tool so you can verify what each tool is supposed to do.\nI made this at TechShop San Jose and plan to use this project for the November 2012 ShopBot Meetup. \u00a0For more info on TechShop, visit their website at http://techshop.ws", "title": "How to Quickly Create a Lighted Christmas Star", "url": "https://www.instructables.com/id/How-to-Quickly-Create-a-Lighted-Christmas-Star/", "section": "home", "steps": [{"step": 1, "steps_text": "\n          Materials\n\n\t\tHalf sheet of 1/2\u201d exterior grade plywood\n\t\tHalf sheet of backer material (because we\u2019re going to drill through our plywood and don\u2019t want to tear up the \u2018Bot\u2019s surface)\n\t\tExterior paint\n\t\tSandpaper (a sheet or two of 180 or 220 grit)\n\t\tChristmas lights (buy these before you go any further so you know how many holes to drill)\n\t\tI used two strands of Philips twinkling cool white LED indoor/outdoor lights, 60 lights/strand, 120 lights total (make sure your lights are rated for exterior use!)\nTools\n\n\t\t1/4\u201d end mill bit (preferably rated for plunging\u2026mine were purchased from http://centuriontools.com)\n\t\tShopBot big enough to handle a half sheet of plywood\n\t\tVCarve Pro software (available on TechShop\u2019s hub machines)\n\t\tPalm or orbital sander\n\t\tLaminate trimmer with a\u00a0flush cutting bit.", "step_imgs": [], "step_title": "Step 1: Materials & Tools"}, {"step": 2, "steps_text": "\n          In order to make the ShopBot do the dirty work of drilling all those holes, a bit of vector drawing work needs to be done.\u00a0 The vectors in our drawing will be converted into the toolpaths that tell the ShopBot where to drill the holes and how to cut out the star\u2019s shape.\nIf the drawing steps aren\u2019t quite clear, study the partial screen shots that go with each step.\u00a0 They should show all the settings and details required along the way.\u00a0 It\u2019s important to not skip steps, not wander off on your own, and to verify each step was successful before moving to the next part.\nPlease leave questions in the Comments section below if there\u2019s anything that\u2019s confusing, unclear, broken, etc.\u00a0 Instructables are fairly easy to correct. If it\u2019s confusing you, it\u2019ll confuse somebody else, so please let me know and I\u2019ll try to clear it up.\nI used VCarve Pro v6.503 to draw my Star.\nCreate a new file (see the first image in this step to see the settings listed below):\n\n\t\tSet the width and height both to 48\u201d.\n\t\tSet the thickness to 0.5\u201d (adjust if you\u2019re using thicker plywood).\n\t\tSet the \u201cZ Zero\u201d to the bottom.\n\t\tSet the \u201cXY Origin Position\u201d to the bottom, left corner.\n\t\tTurn off \u201cOrigin Offset\u201d.\n\t\tTurn off \u201cData Scaling\u201d.\n\t\tClick the \u201cOK\u201d button.", "step_imgs": ["https://cdn.instructables.com/FT4/6JDX/H9K2FL6P/FT46JDXH9K2FL6P.LARGE.jpg"], "step_title": "Step 2: Create a New Drawing"}, {"step": 3, "steps_text": "\n          Start by selecting the \u201cDraw Star\u201d tool (see image 1 in this step for the location of this tool).\u00a0I placed the star high enough to allow later stretching its bottom leg significantly downwards without falling out of the drawing space.\n\u00a0 \u00a0 \u00a0\u00a0\nSet the \u201cDraw Star\u201d tool\u2019s fields (see image 2 for where each field can be found):\n\n\t\tSet the \u201cNumber of Points\u201d = 8\n\t\tSet the \u201cCenter Point\u201d to:\n\t\t\n\t\t\t\t\u00a0X = 13\n\t\t\t\t\u00a0Y = 34\n\t\tSet the \u201cOuter Radius\u201d = 12\n\t\tSet the \u201cInner Radius Percentage\u201d = 50\n\t\tClick the \u201cCreate\u201d button.\n\t\tClick the \u201cClose\u201d button.\n\u00a0\nYour drawing should currently look like image 3 of this step.", "step_imgs": ["https://cdn.instructables.com/FVB/C5ZM/H9G191R7/FVBC5ZMH9G191R7.LARGE.jpg", "https://cdn.instructables.com/FQU/JI17/H9K2FL77/FQUJI17H9K2FL77.LARGE.jpg", "https://cdn.instructables.com/FY4/WFDJ/H9G191R8/FY4WFDJH9G191R8.LARGE.jpg"], "step_title": "Step 3: Start With a Simple 8-Point Star"}, {"step": 4, "steps_text": "\n          Notice that all the points of this star are the same length.\u00a0 The goal is to have the four legs that are 45 degrees off of vertical to be slightly shorter and the bottom leg to be much longer.\u00a0 Placing two basic shapes precisely on the drawing will simplify changing the lengths of the star\u2019s legs.\nStart by selecting the \u201cDraw Rectangle\" tool - please don\u2019t close it until instructed to (image 1 of this step shows where that tool is located, image 2 shows where to fill in the values listed below):\n\t\tSet the \u201cAnchor Point\u201d to the upper left corner to:\n\t\t\n\t\t\t\t\u00a0 \u00a0 \u00a0X = 1\n\t\t\t\t\u00a0 \u00a0 \u00a0Y= 34\n\t\tSet \u201cCorner Type\u201d to \u201cSquare\u201d.\n\t\tSet \u201cSize\u201d to:\n\t\t\n\t\t\t\t\u00a0 \u00a0 \u00a0Width (X) = 12\n\t\t\t\t\u00a0 \u00a0 \u00a0Height (Y) = 24\n\t\tClick the \u201cCreate\u201d button.NOTE: Leave the Draw Rectangle tool open.\nImage 3 of this step shows the results of adding that rectangle to the drawing.\nDraw a second (and smaller) rectangle while the Draw Rectangle tool is open. \u00a0Image 4 shows the settings described below:\n\u2022 Change the \u201cAnchor Point\u201d to the center.NOTE: Be certain you change the anchor point or the square will be in the wrong location for the next steps.\n\t\tSet the \u201cX\u201d and \u201cY\u201d for the \u201cAnchor Point\u201d to:\n\t\t\n\t\t\t\tX = 13\n\t\t\t\tY = 34\n\t\tThe \u201cCorner Type\u201d should remain \u201cSquare\u201d.\n\t\tChange the \u201cSize\u201d to:\n\t\t\n\t\t\t\tWidth (X) = 14\n\t\t\t\tHeight (Y) = 14\n\t\tClick the \u201cCreate\u201d button.\n\t\tClick the \u201cClose\u201d button (the Draw Rectangle tool is no longer needed).\nImage 5 shows the expected results from adding the second rectangle.\n        ", "step_imgs": ["https://cdn.instructables.com/FL2/DQ13/H9G1729X/FL2DQ13H9G1729X.LARGE.jpg", "https://cdn.instructables.com/FWF/5GAE/H9G1729Y/FWF5GAEH9G1729Y.LARGE.jpg", "https://cdn.instructables.com/F5H/EW91/H9K2FLAN/F5HEW91H9K2FLAN.LARGE.jpg", "https://cdn.instructables.com/FSX/0V8Q/H9K2FLAY/FSX0V8QH9K2FLAY.LARGE.jpg", "https://cdn.instructables.com/F9Y/8OF7/H9G172A7/F9Y8OF7H9G172A7.LARGE.jpg"], "step_title": "Step 4: Add Guides to Simplify Adjusting the Star's Points"}, {"step": 5, "steps_text": "\n          A few moves with the Node-Editing tool will shrink four legs and stretch the bottom leg. \u00a0\nStart by selecting the \u201cNode Editing\u201d tool (image 1 in this step shows the tool's location).\n\t\tClick on the star in your drawing to select it (see image 2 which shows the nodes on the star after it was selected).\n\t\tDrag the first star point inward to the closest corner of the square to shorten that star leg (see image 3, the new location is shown in blue during the drag).\u00a0The square that was drawn earlier as a guide gives a convenient \u201csnapping\u201d point for the cursor so the resizing is quick & easy.\n\t\tDrag the other three points inward that need to be shortened (see image 4).\n\t\tDrag the bottom point on the star straight down to the bottom-right corner of the large rectangle (see image 5 which shows the bottom leg's new position in blue as it's being dragged downwards).\n\t\tClick on the \u201cSelection Mode\u201d tool (see image 6 to see the tool's location).\n\t\tUse the \u201cSelection Mode\u201d tool to select & delete both the rectangle and the square that were used to guide resizing the star's legs.\nYour drawing should currently look like image 6.NOTE: Now is a good time to save your drawing.", "step_imgs": ["https://cdn.instructables.com/FFT/T5VX/H9K2FLBX/FFTT5VXH9K2FLBX.LARGE.jpg", "https://cdn.instructables.com/FUO/2I3T/H9G0SSWL/FUO2I3TH9G0SSWL.LARGE.jpg", "https://cdn.instructables.com/FJJ/C6Q1/H9G172BH/FJJC6Q1H9G172BH.LARGE.jpg", "https://cdn.instructables.com/FTL/QTMY/H9G172BX/FTLQTMYH9G172BX.LARGE.jpg", "https://cdn.instructables.com/FU2/M33M/H9G172K1/FU2M33MH9G172K1.LARGE.jpg", "https://cdn.instructables.com/F7R/PGHN/H9G172KK/F7RPGHNH9G172KK.LARGE.jpg", "https://cdn.instructables.com/F9P/HC87/H9G10Q6R/F9PHC87H9G10Q6R.LARGE.jpg"], "step_title": "Step 5: Use the Guides to Adjust the Points"}, {"step": 6, "steps_text": "\n          The \u201cCopy object along vectors\u201d tool will speed up laying out most of the holes for the lights,. To use that tool, two smaller copies of the star\u2019s outline will be created, scaled down, and used as inputs to that tool. This will leave an area near the center hole-free. That hole-free area will be filled in by a later step.\nFirst, create one of the two vectors that will be used to copy holes along:\n\t\tSelect the outline of the star.\n\t\tPress CTRL-C to copy it to the clipboard.\n\t\tPress CTRL-V to paste a copy into the drawing.\nSelect the \u201cSet Selected Objects Size\u201d tool (see image 1 for the location of this tool and image 2 for where to enter the settings spelled out below).\n\t\tSet the \u201cAnchor\u201d point to the center.\n\t\tVerify that \u201cLink XY\u201d is checked.\n\t\tSet Width (X) = 18 (VCarve will set \u201cHeight (Y)\u201d since \u201cLink XY\u201d is checked.)\n\t\tClick the \u201cApply\u201d button.\n\t\tClick the \u201cClose\u201d button.\nYour drawing should now look like image 3.\nVerify the new, smaller star outline is selected.\nPick the \u201cMove Selected Objects\u201d tool (see image 4 for this tool's location and image 5 for its settings).\n\n\t\tSet \u201cType of Move\u201d to \u201cRelative\u201d.\n\t\tLeave X = 0\n\t\tSet Y = 1.5\n\t\tClick the \"Apply\" button.\n\t\tClick the \"Close\" button.\nThe smaller star should now be centered within the original star and should look like image 6.\nWe need one more, even smaller, copy of the star's original outline before we can layout the holes for lights. Just repeat the steps above using smaller values for the resizing tool and a slightly larger value for the move tool:\n\t\tSelect the outline of the star.\n\t\tPress CTRL-C to copy it to the clipboard.\n\t\tPress CTRL-V to paste a copy into the drawing.\nSelect the \u201cSet Selected Objects Size\u201d tool (see image 1 for the location of this tool and image 7 for the settings).\n\t\tSet the \u201cAnchor\u201d point to the center.\n\t\tVerify that \u201cLink XY\u201d is checked.\n\t\tSet Width (X) = 12\n\t\tClick the \u201cApply\u201d button.\n\t\tClick the \u201cClose\u201d button.\nYour drawing should now look like image 8.\nVerify the new, smaller star outline is selected.\nPick the \u201cMove Selected Objects\u201d tool (see image 4 for this tool's location and image 9 for this tool's settings).\n\t\tSet \u201cType of Move\u201d to \u201cRelative\u201d\n\t\tLeave X = 0\n\t\tSet Y = 3\n\t\tClick the \u201cApply\u201d button.\nThe smallest star should now be properly centered within the original star and should look like image 10.\n\t\tClick the \u201cClose\u201d button.", "step_imgs": ["https://cdn.instructables.com/FGT/MNST/H9G0ZMCQ/FGTMNSTH9G0ZMCQ.LARGE.jpg", "https://cdn.instructables.com/FQV/T2NG/H9G1926E/FQVT2NGH9G1926E.LARGE.jpg", "https://cdn.instructables.com/FWA/XJDS/H9G0SKF6/FWAXJDSH9G0SKF6.LARGE.jpg", "https://cdn.instructables.com/F43/FAOX/H9G0WAUH/F43FAOXH9G0WAUH.LARGE.jpg", "https://cdn.instructables.com/F3L/2O21/H9K2FNSF/F3L2O21H9K2FNSF.LARGE.jpg", "https://cdn.instructables.com/F3F/F1UH/H9G1762M/F3FF1UHH9G1762M.LARGE.jpg", "https://cdn.instructables.com/FCO/SOA5/H9G17636/FCOSOA5H9G17636.LARGE.jpg", "https://cdn.instructables.com/FBV/YSE4/H9G12I4K/FBVYSE4H9G12I4K.LARGE.jpg", "https://cdn.instructables.com/F4M/U71L/H9G0SKFC/F4MU71LH9G0SKFC.LARGE.jpg", "https://cdn.instructables.com/FPN/0VVY/H9G12I4U/FPN0VVYH9G12I4U.LARGE.jpg"], "step_title": "Step 6: Make Two Paths for Quick Hole Layout"}, {"step": 7, "steps_text": "\n          With the two smaller star paths in place, VCarve is ready to quickly create most of the holes for the lights:\u00a0\nSelect the \u201cCopy Objects Along Vector\u201d tool (see image 1 for this tool's location).\n\t\tSelect only the two smaller star paths created earlier.\n\t\tClick \u201cCopy Circles\u201d within the \u201cCopy Along Vectors\u201d tool settings window (image 2).\n\t\tSet \u201cDiameter\u201d = 0.47\u201d\u00a0(If you use different lights, you may need a different sized hole.)\n\t\tSelect \"Distance between copies\" (instead of \"Number of copies\").\n\t\tSet \u201cDistance between copies\u201d = 1.4\u201d\n\t\tVerify \u201cAlign vectors to curve\u201d is unchecked.\n\t\tVerify \u201cCreate copies on a new layer\u201d is unchecked.\n\t\tClick the \u201cCopy\u201d button.\n\t\tClick the \u201cClose\u201d button.\nYour drawing should now look like image 3.\nThe two small copies of the star's outline are no longer needed. \u00a0To remove them, pick the \u201cSelection Mode\u201d tool, then select and delete ONLY the two smaller star paths that were used to guide placing the light holes.NOTE: The overlapping holes will be fixed in a later step.\nYour drawing should currently look like image 4.\nChanging the value for\u00a0\u201cDistance between copies\u201d will move the holes closer together (smaller values) or further apart (larger values). If the holes are closer together, more holes will be placed along the paths fed into the\u00a0\u201cCopy Objects Along Vector\u201d tool. Fewer holes will be created if the holes are spaced further apart.\nWhen creating your own designs, don't forget to adjust that spacing value to quickly produce more (or fewer) holes.\n        ", "step_imgs": ["https://cdn.instructables.com/FF6/EXH0/H9G19EG0/FF6EXH0H9G19EG0.LARGE.jpg", "https://cdn.instructables.com/FTR/XWSI/H9G0LLMK/FTRXWSIH9G0LLMK.LARGE.jpg", "https://cdn.instructables.com/FKE/SPB3/H9K2FP72/FKESPB3H9K2FP72.LARGE.jpg", "https://cdn.instructables.com/F0S/2XVJ/H9K2FP8P/F0S2XVJH9K2FP8P.LARGE.jpg"], "step_title": "Step 7: Time to Lay Out Some Holes!"}, {"step": 8, "steps_text": "\n          There should be 107 light-holes in the drawing at this time.\u00a0 To verify that number, press CTRL-A to select everything in the drawing.\u00a0\nIn the bottom, right hand corner of VCarve\u2019s window, when one or more items have been selected, three fields of text appear that show the selection\u2019s width (\u201cW:\u201d), height (\u201cH:\u201d), and how many items are selected (\u201cS:\u201d). For the drawing\u2019s current state, it should show \u201cS:108\u201d which includes the 107 holes plus the outline of the star.\nImage 1 shows what this should look like along the bottom right corner of VCarve's drawing window.\nI used two strands with 60 lights/strand so I need 120 holes for lights. \u00a0Since there are currently only 107 holes for light, the drawing needs another 13 holes. Those holes will be used to fill\u00a0the gap in the center. Part of the gap will be filled in by this step and the rest will be filled in by the next step.\u00a0Both this step and the next step use the same VCarve tool, but with slightly different settings.\nOne of VCarve's fancier tools will be used to fill that gap.\nThat tool requires one spare light-hole to be created at a known location. First, create the spare hole, then feed that hole to the \"Copy objects in a linear or circular array\u201d tool.\nPick the \u201cDraw Circle\u201d tool (see image 2 for this tool's location and image 3 for its settings).\n\t\tSet the \u201cCenter Point\u201d to:\n\t\t\n\t\t\t\tX = 6\n\t\t\t\tY = 24\n\t\tSelect \u201cDiameter\u201d\n\t\tSet \u201cDiameter\u201d to:\n\t\t\n\t\t\t\tD = 0.47\u201d\n\t\tClick the \u201cCreate\u201d button.\n\t\tClick the \u201cClose\u201d button.\nSelect the hole that was just created in the drawing.\nPick the \u201cCopy objects in a linear or circular array\u201d tool (see image 4\u00a0for this tool's location and image 5 for its settings).\n\n\t\tSelect \u201cCircular Array\u201d (about half way down the tool's settings window).\n\t\t\n\t\t\t\tSet its \u201cRotation Center\u201d to:\n\t\t\t\t\n\t\t\t\t\t\tX = 4.5\n\t\t\t\t\t\tY = 22.5\n\t\t\t\t\t\tSet \u201cNumber of items\u201d = 8\n\t\tSelect \u201cTotal Angle\"\n\t\t\n\t\t\t\tSet \u201cTotal Angle\u201d = 360\n\t\tClick the \u201cCopy\u201d Button.\n\t\tClick the \u201cClose\u201d Button.\nTo move the newly created ring of 8 holes into the center of the star, verify the new holes are selected, then:\nPick \"Move Selected Objects\" tool (image 7 shows the location of this tool and image 8 shows its settings).\n\n\t\tSet the \u201cAnchor\u201d point to center.\n\t\tSet \"Type of Move\" to Absolute.\n\t\tSet \"X Position\" to 13\n\t\tSet \"Y Position\" to 34\n\t\tClick the \u201cApply\u201d button.\n\t\tClick the \u201cClose\u201d button.\nYour drawing should now look like image 9. The small gap at the very center will be filled in by the next step.", "step_imgs": ["https://cdn.instructables.com/FRL/Y4DU/H9G17643/FRLY4DUH9G17643.LARGE.jpg", "https://cdn.instructables.com/FWB/QDFR/H9G0SVMT/FWBQDFRH9G0SVMT.LARGE.jpg", "https://cdn.instructables.com/FM9/DVTJ/H9G19EHX/FM9DVTJH9G19EHX.LARGE.jpg", "https://cdn.instructables.com/FYK/4H78/H9G17653/FYK4H78H9G17653.LARGE.jpg", "https://cdn.instructables.com/FSW/85B2/H9G0SVNZ/FSW85B2H9G0SVNZ.LARGE.jpg", "https://cdn.instructables.com/F8D/RUPI/H9G10QIP/F8DRUPIH9G10QIP.LARGE.jpg", "https://cdn.instructables.com/FAC/9F7G/H9K2FPTW/FAC9F7GH9K2FPTW.LARGE.jpg", "https://cdn.instructables.com/F74/I37J/H9G12IFZ/F74I37JH9G12IFZ.LARGE.jpg", "https://cdn.instructables.com/FSB/8X74/H9G176Q2/FSB8X74H9G176Q2.LARGE.jpg"], "step_title": "Step 8: Fill in the Gap (Part 1)"}, {"step": 9, "steps_text": "\n          Selecting everything in the drawing should show that there are now 115 holes (the selection counter will show 116 because the star\u2019s outline is also selected).\u00a0\nThat means, five more holes need to be created which should nicely fill the little bit of gap that still exists at the star's center. Just like the prior step, a spare light hole needs to be created, then fed to the\u00a0\u201cCopy objects in a linear or circular array\u201d tool.\nPick the \u201cDraw Circle\u201d tool (image 1 shows the tool's location and image 2 shows its settings).\n\n\t\tSet the \u201cCenter Point\u201d to:\n\t\t\n\t\t\t\tX = 6\n\t\t\t\tY = 24\n\t\tSelect \u201cDiameter\u201d\n\t\tSet \u201cDiameter\u201d to:\n\t\t\n\t\t\t\tD = 0.47\u201d\n\t\tClick the \u201cCreate\u201d button.\n\t\tClick the \u201cClose\u201d button.\nSelect the hole that was just created in the drawing.\nPick the \u201cCopy objects in a linear or circular array\u201d tool (see image 3 for this tool's location and image 4 for its settings).\n\t\tSelect \u201cCircular Array\u201d (about half way down the tool's settings window).\n\t\t\u00a0 Set its \u201cRotation Center\u201d to:\n\t\t\n\t\t\t\t\u00a0 X = 5.5\n\t\t\t\t\u00a0 Y = 23.5\n\t\t\t\t\u00a0 Set \u201cNumber of items\u201d = 5\n\t\tSelect \u201cTotal Angle\"\n\t\tSet \u201cTotal Angle\u201d = 360\n\t\tClick the \u201cCopy\u201d Button.\n\t\tClick the \u201cClose\u201d Button.\nTo move the newly created ring of 5 holes into the center of the star, verify the new holes are selected, then pick \"Move Selected Objects\" tool (image 5 shows the location of this tool and image 6 shows its settings).\n\n\t\tSet the \u201cAnchor\u201d point to center.\n\t\tSet \"Type of Move\" to Absolute.\n\t\tSet \"X Position\" to 13\n\t\tSet \"Y Position\" to 34\n\t\tClick the \u201cApply\u201d button.\n\t\tClick the \u201cClose\u201d button.\nYour drawing should look like image 7. \u00a0Now would be a good time to save your progress again.", "step_imgs": ["https://cdn.instructables.com/FA5/58VN/H9G12IG7/FA558VNH9G12IG7.LARGE.jpg", "https://cdn.instructables.com/F2J/8YQT/H9G12IG8/F2J8YQTH9G12IG8.LARGE.jpg", "https://cdn.instructables.com/FYK/4H78/H9G17653/FYK4H78H9G17653.LARGE.jpg", "https://cdn.instructables.com/FB7/TXC3/H9G12IGI/FB7TXC3H9G12IGI.LARGE.jpg", "https://cdn.instructables.com/FG0/8AV1/H9G19F21/FG08AV1H9G19F21.LARGE.jpg", "https://cdn.instructables.com/F74/I37J/H9G12IFZ/F74I37JH9G12IFZ.LARGE.jpg", "https://cdn.instructables.com/FX1/IGY2/H9G176R4/FX1IGY2H9G176R4.LARGE.jpg"], "step_title": "Step 9: Fill in the Gap (Part 2)"}, {"step": 10, "steps_text": "There are a few holes overlapping other holes. \u00a0To fix that, simply drag each overlapping hole somewhere else in the drawing (within the outline of the star). For example, drag one down to the empty space near the bottom of the longest leg.\nTry to keep at least a quarter of an inch between the edges of the star's outline and the closest edge of each hole. \u00a0Otherwise, the outer edge of the star may be easily broken after the holes are drilled.\nMove any holes that appear too close to another hole to somewhere that looks like it could use a hole of its own. Try to leave at least a half inch of solid material between holes (and separate any holes that don\u2019t follow that suggestion).", "step_imgs": [], "step_title": "Step 10: Fine Tune Hole Locations"}, {"step": 11, "steps_text": "\n          I prefer to create two tool paths for projects like this one.\u00a0 The first path will cut all of the holes for lights and is described in this step.\u00a0The second path will cut the star's outline and will be described in the next step.\nThe fit of your lights should be tested on a few sample holes drilled into scraps. If you use different lights, make sure to test-fit your holes before cutting the star\u2019s outline!\nVCarve has a drilling function built in but I'm intentionally avoiding that tool. \u00a0It would let me easily drill the holes using a traditional drill bit, but then I'd have to change to an end mill in order to cut the star's outline. Changing bits means resetting the Z-axis' zero point which eats time (needlessly in this case).\nWhen drilling holes larger than my end mill, I find it quick & easy to just let the end mill make the holes. A drill bit likely makes more precise diameter holes, but for this project, precision isn't critical enough to warrant shuffling bits back and forth.\nTo create the tool path for the 120 light-holes, the \"Toolpaths\" panel will need to be open. That panel lurks along the upper right corner of the drawing behind a tab labeled, \"Toolspaths\". \u00a0See image 1 for the location of this panel's tab when that panel is closed.\nIf the Toolpaths panel is not already open, click on the \u201cToolpaths\u201d tab. \u00a0Then, click on the sideways pushpin icon in the panel's upper right corner to keep that panel from automatically closing.\n\t\tPress CTRL-A to select everything in your drawing.\n\t\tSHIFT-click on the star\u2019s outline to deselect it (leaving ONLY the 120 light holes selected).NOTE: My end mills are rated for plunging - if yours are NOT, you may need a longer ramp. I could skip the ramp completely but prefer keeping it in when sharing project settings in case somebody uses my settings with a bit that is NOT rated for plunging.\nIn the Toolpaths panel, click on the \u201cCreate Profile Toolpath\u201d operation (image 2 shows this tool's location within the Toolpaths panel and\u00a0Image 3 shows the settings used):\n\t\tSet \"Start Depth (D)\" to 0.\n\t\tSet \u201cCut Depth (C)\u201d to 0.02 DEEPER than your material's thickness (0.52\" since I'm using half inch thick material).\u00a0This ensures the bit will cut cleanly all the way through if the table is slightly uneven. This REQUIRES using your own backing board because the bit WILL cut into the backing board.\u00a0 \u00a0\u00a0\n\t\tPick the bit you'll be using, set its RPMs, and set its feed rate (I'm using a .25\" end mill, 15K RPM, 4 inches/sec).\n\t\tSet \u201cPasses\u201d = 2 (if you use thicker material, increase the number of passes).\n\t\tSet \"Machine Vectors\u2026\" to Inside/Left.\n\t\tSet \u201cDirection\u201d to \u201cClimb\u201d.\n\t\tNo tabs!\n\t\tClick on the \u201cRamps\u201d tab:\n\t\t\n\t\t\t\tCheck the \"Add ramps to toolpath\" box.\n\t\t\t\tClick the \u201cSmooth\u201d button.\n\t\t\t\tSet \u201cDistance\u201d to 0.5\u201d.\n\t\tName this tool path:\n\t\t\n\t\t\t\tI used, \u201cHoles .25in end mill, 4in sec, 15K rpm\u201d.\n\t\tClick the \u201cCalculate\" button.NOTE: A warning dialog should pop up advising you're going to cut thru the material.\u00a0 This is intentional and it\u2019s why I noted earlier that you\u2019ll need to have your own backing board under the piece you\u2019re cutting into your star.\n\t\tClick the \u201cOK\u201d button to dismiss the warning dialog.\nAfter VCarve calculates the toolpath, it should switch the main drawing area to show a \u201c3D View\u201d similar to image 4.\nMany problems that will show up during cutting can be spotted by using VCarve's \"Preview\" capability. I highly recommend always previewing, and studying closely, all new toolpaths.\nTo see the results of \"cutting\" this toolpath,\u00a0click the \u201cPreview Toolpath\u201d button in the Toolpaths panel (image 5 shows that button highlighted in blue).\nImage 6 shows what the preview should look like after \"drilling\" the 120 holes for lights.\nAfter studying the preview of the hole-drilling toolpath, click the \u201cClose\u201d button at the bottom of the Preview panel.\nSwitch the main window back to the drawing area before going to the next step. \u00a0To do that, click on the tab along the upper left edge of the drawing area to see the drawing instead of the toolpath preview.NOTE: \u00a0The tab will have the name of your file showing.\u00a0For the screen shots in this Instructable, my file name was \u201cwalkthru 1\u201d.", "step_imgs": ["https://cdn.instructables.com/FBN/Q02B/H9G12IGU/FBNQ02BH9G12IGU.LARGE.jpg", "https://cdn.instructables.com/FHO/BKOA/H9K2FPUR/FHOBKOAH9K2FPUR.LARGE.jpg", "https://cdn.instructables.com/F8P/6SBS/H9G10QJ3/F8P6SBSH9G10QJ3.LARGE.jpg", "https://cdn.instructables.com/FOE/YA32/H9G19F6I/FOEYA32H9G19F6I.LARGE.jpg", "https://cdn.instructables.com/FSV/PCCF/H9G0SVOD/FSVPCCFH9G0SVOD.LARGE.jpg", "https://cdn.instructables.com/FKN/IFPQ/H9G176UI/FKNIFPQH9G176UI.LARGE.jpg"], "step_title": "Step 11: Create a Toolpath to Drill the Holes"}, {"step": 12, "steps_text": "\n          To create the toolpath for cutting the star\u2019s outline, click on only the outline of the star in the drawing area.\nClick on \u201cCreate Profile Toolpath\u201d in the Toolpaths panel (image 1 shows its location and image 2 shows its settings).\n\t\tSet \"Start Depth (D)\" to 0.\n\t\tSet \u201cCut Depth (C)\u201d to 0.02 DEEPER than your material's thickness (0.52\" since I'm using half inch thick material).\u00a0This ensures the bit will cut cleanly all the way through if the table is slightly uneven.\u00a0This REQUIRES using your own backing board because the bit WILL cut into the backing board.\n\t\tPick the bit you'll be using, set its RPMs, and set its feed rate (I'm using a .25\" end mill, 15K RPM, 4 inches/sec).\n\t\tSet \u201cPasses\u201d = 2 (if you use thicker material, increase the number of passes).\n\t\tSet \"Machine Vectors\u2026\" to Outside/Right.\u00a0(this is different from the prior step)\n\t\tSet \u201cDirection\u201d to \u201cClimb\u201d.NOTE: This toolpath requires tabs! Cutting is faster using 3D tabs, but I find the default size for those a bit fragile. I like my 3D tabs a little beefier. To increase the size of the 3D tabs:Under \u201cTabs\u201d, check the \u201cAdds tabs to Toolpath\u201d box.Set \u201cLength\u201d = 0.75\u201dSet \u201cThickness\u201d = 0.2\u201dClick the \u201cCreate 3D tabs\u201d box.\n\t\u00a0\n\t\tClick the \"Edit Tabs\" button:\n\t\t\n\t\t\t\tManually place\u00a0two tabs along the long lower leg (one on each side).\n\t\t\t\tManually place a tab along the top edge of each horizontal leg.\n\t\t\t\tThat\u2019s a total of 4 tabs.\n\t\t\t\tClick on the \"Close\" button to get back to the 2D Profile Toolpath panel.\n\t\u00a0\n\t\tClick on the \u201cRamps\u201d tab:\n\t\t\n\t\t\t\tCheck the \"Add ramps to toolpath\" box.\n\t\t\t\tClick the \u201cSmooth\u201d button.\n\t\t\t\tSet \u201cDistance\u201d to 0.5 inchesNOTE: My end mills are rated for plunging - if yours are NOT, you may need a longer ramp. I could skip the ramp completely but prefer keeping it in when sharing project settings in case somebody uses my settings with a bit that is NOT rated for plunging.\n\t\u2022 Name this tool path. \u00a0I used, \u201cStar .25in end mill, 4in sec, 15K rpm\u201d.\n\t\u2022 Click the \u201cCalculate\" button.NOTE: A warning dialog should pop up advising you're going to cut thru the material.\u00a0 This is intentional and it\u2019s why I noted earlier that you\u2019ll need to have your own backing board under the piece you\u2019re cutting into your star.\n\t* Click the \u201cOK\u201d button to dismiss the warning dialog.\n\t\u00a0\n\tAfter VCarve calculates the toolpath, it should switch the main drawing area to show a \u201c3D View\u201d similar to image 3.\n\tMany problems that will show up during cutting can be spotted by using VCarve's \"Preview\" capability. I highly recommend always previewing, and studying closely, all new toolpaths.\n\tTo see the results of \"cutting\" this toolpath, click the \u201cPreview Toolpath\u201d button in the Toolpaths panel (image 4 shows that button highlighted in blue).\n\tImage 5 shows what the preview should look like after \"cutting\" the outline of the star. If you look closely, the four tabs I described earlier are visible along the star's outline.\n\tWhen you're done studying the preview, click on the \"Close\" button at the bottom of the \"Toolpaths\" panel. \u00a0It's OK to leave the Preview showing in the main part of VCarve's screen.", "step_imgs": ["https://cdn.instructables.com/FHO/BKOA/H9K2FPUR/FHOBKOAH9K2FPUR.LARGE.jpg", "https://cdn.instructables.com/FLM/LYDL/H9G0SVOE/FLMLYDLH9G0SVOE.LARGE.jpg", "https://cdn.instructables.com/FDE/FE64/H9K2FPX4/FDEFE64H9K2FPX4.LARGE.jpg", "https://cdn.instructables.com/FEW/IUCG/H9G176ZU/FEWIUCGH9G176ZU.LARGE.jpg", "https://cdn.instructables.com/F2O/PG5Q/H9G12ILM/F2OPG5QH9G12ILM.LARGE.jpg"], "step_title": "Step 12: Create a Toolpath to Cut the Star's Outline"}, {"step": 13, "steps_text": "\n          In order to get the ShopBot to actually cut the toolpaths I just generated, VCarve needs to be told to export them.\nIn the Toolpaths panel\u2019s \u201cToolpath List\u201d, select the \u201cHoles\u201d toolpath (see image 1).\nIn that same panel, click on the \u201cSave Toolpath\u201d tool (shown along the bottom of image 1). This changes the contents of the Toolpaths panel to look like image 2.\n\t\tVerify that the toolpath for making your holes is the only thing selected in the Toolpath List.\n\t\tUncheck the \u201cOutput all visible toolpaths to one file\u201d box (this will allow VCarve to create a file that only cuts the holes for lights).\n\t\tSelect the proper \u201cPost Processor\u201d from the popup menu.\u00a0For TechShop San Jose, I use \u201cShopBot Arc (inch) w/speed(*.sbp)\u201d.\n\t\tClick the \u201cSave Toolpath(s)\u201d button.\n\t\t\n\t\t\t\tThe default file name VCarve suggest will be the same as the toolpath\u2019s name.\n\t\t\t\tAdd a version number at the end of the name if you want to experiment with different settings, bits, speeds\u2026\n\t\tSave the toolpath to disk by clicking on the \"Save\" button.NOTE: Do not close this panel yet.\nClick on the other toolpath you created (the one that cuts the outline of the star).\n\t\tVerify the \"Post Process\" is still correct for your target machine.\n\t\tClick the \u201cSave Toolpath(s)\u201d button.\n\t\tClick on the \"Save\" button to save the toolpath to disk.\n\t\tClick the \u201cClose\u201d button at the bottom of the \u201cToolpaths List\u201d panel.", "step_imgs": ["https://cdn.instructables.com/FXQ/Y7A8/H9K2FPX7/FXQY7A8H9K2FPX7.LARGE.jpg", "https://cdn.instructables.com/FR2/V6RH/H9G0SVOH/FR2V6RHH9G0SVOH.LARGE.jpg"], "step_title": "Step 13: Save the Toolpaths"}, {"step": 14, "steps_text": "In order to use the new toolpaths on a ShopBot, we need to get them onto the computer attached to the ShopBot. \u00a0Drag the tool path files onto a thumb drive, use sneakernet to get your thumb drive over to the ShopBot's computer, then copy your files from the thumb drive onto the ShopBot's computer.\nPlace your backer board onto the ShopBot's table and place your exterior grade plywood on top of your backer board.\nSecure your plywood and backer board to the table.\nI won't go into full details on how to use the toolpaths on the ShopBot. \u00a0TechShop requires members to pass a safety & basic use class before they can use a ShopBot. \u00a0So, anybody trying to do this project should already know how to load and cut these toolpaths.\nImage 1 shows my plywood on the ShopBot's table just after the 120 holes for lights were cut.\nImage 2 shows my plywood on the ShopBot's table just after the outline of the star was cut.\nMy total cutting time was less than 12 minutes if I recall correctly.", "step_imgs": ["https://cdn.instructables.com/FZ9/EK9B/H9K2FPXS/FZ9EK9BH9K2FPXS.LARGE.jpg", "https://cdn.instructables.com/F50/M3IT/H9G17745/F50M3ITH9G17745.LARGE.jpg"], "step_title": "Step 14: Put Your Toolpaths on a Thumb Drive & Get Ready to Cut"}, {"step": 15, "steps_text": "Cut the tabs to release the star from the rest of the plywood sheet. \u00a0I use a laminate trimmer with a flush cutting bit to quickly remove the leftover bits of the tabs.\nMake a quick pass or two along the edges and faces of the star with a palm (or orbital) sander using 180-220 grit.\nI used TechShop's paint booth and a can of spray paint for this project. \u00a0The holes in the star gave me plenty of places to suspend the star during painting. \u00a0The paint booth quickly took care of the overspray and the fumes.\nLet one side dry to the touch before repositioning the star to paint the other side. \u00a0I used different holes to hang the star by each time I repositioned it. \u00a0That prevented the heavy wire holding the star in place from leaving unpainted shadows.", "step_imgs": [], "step_title": "Step 15: Cleanup & Paint"}, {"step": 16, "steps_text": "The strands I bought are supposed to twinkle. \u00a0When I plugged them in, I discovered that only some of the bulbs twinkle while at least half stay on full time.\nTest your lights before you stuff them into the holes, then use your knowledge of which lights twinkle and which ones stay on full time to guide which lights go into which holes.\nI found that the wire between lights was easier to manage if I didn't try to put the next bulb in a hole adjacent to where I'd just placed the prior bulb.\nInstead, I placed the next bulb about as far away as I could from the prior bulb...bouncing back and forth, side to side, like a peg-jumping game. \u00a0Just try not to leave unfilled holes in places you can't hop back to easily.\nIf you want to secure the wires to the back of your star, there are wiring staplers readily available at Target, Lowes, etc...I found mine in the Christmas decoration aisles at Target. \u00a0The staples include a plastic sleeve that prevents the staple from quickly rubbing through the wire's insulation. \u00a0\nTarget listed it as, \u201cHoliday Light Tacker with Staples\u201d. It was about $7 on clearance and its Store Item Number (DPCI) is 051-19-0601.", "step_imgs": ["https://cdn.instructables.com/FV0/92L6/H9G191MN/FV092L6H9G191MN.LARGE.jpg"], "step_title": "Step 16: Stuff the Lights"}, {"step": 17, "steps_text": "I'll likely attach my star to my fence using a couple of screws through the front, carefully avoiding the wires in the back...\nThere are plenty of other options, most of which are more elegant than my plan and all of which are beyond the scope of this instructable.", "step_imgs": [], "step_title": "Step 17: Mounting Your Star"}], "channel": "No channel to show"}, {"category": "No category to show", "description": "The utensil drawer in my kitchen has long been an annoyance. I have a generic organizer that doesn't fit in the drawer well and it definitely  isn't tall enough. It's an annoyance that's easy to ignore, but I  decided to fix it. In the process I organized a few drawers. It revolutionized the junk drawer. No longer do I spend minutes searching for an item. While I considered plastic, I opted for 1/4\" MDF.Supplies: \u2022 1/4\" MDF\u2022 wood glue\u2022 clear spray paint Tools: \u2022 Table saw, with crosscut sled\u2022 Router with 1/4\" flute\u2022 Band saw\u2022 French curve, optional\u2022 Ruler\u2022 TapeCut List: This is subjective based on your drawer. My drawer was 11\"x19\" \u2022 (1) 11\"x19\"\u2022 (2) 19\"x4\" - (2) 1/4\" dado cuts\u2022 (2) 10.5\"x3.75\" - (4) 1/4\" dado cuts\u2022 (4) 9\"x4\"Cost:\u2022 I already had scrap MDF on hand. If you need MDF, you can get a 2'x4' piece from a big box store for $8.00.Safety Concerns:  \u2022 Always use caution with power tools.\u2022 I would not attempt to cut pieces this small on a table saw without a crosscut sled.\u2022 I wear a respirator when tooling wood. I don't want to breathe in tiny wood particles, especially MDF. \u2022 Paint in a well ventilated area and wear a respirator", "title": "Build a Drawer Organizer", "url": "https://www.instructables.com/id/Build-a-Drawer-Organizer/", "section": "home", "steps": [{"step": 1, "steps_text": "I built the organizer to fill the entire drawer and to be as tall as the drawer. I sized this to the silverware I have, but I did make it slightly  larger. I don't know the standard silverware size, if such a thing  exits, but I also don't plan on upgrading silverware anytime soon.I cut the pieces on a table saw and when the pieces fit on my sled, I used that.I used a router to cut the dados. I used a divider as a guide, holding it in place by hand and lining up the pieces so I could do a cut through both pieces. My router bit  didn't cut quite wide enough for the MDF to slot in. I made my cut, then  placed a piece of paper folded (3) sheets thick on the guide and cut  again. This made the slot the perfect width for the MDF. I settled on (3) sheets thick by starting with (1) and working my way up until the MDF fit the slot.I cut a swoop into the center dividers because you cant' reach into the center spaces with them being so narrow and tall. The lowest point is 5/8\", the rest I  just did what 'looks good.' I used a flexible ruler to draw the  radii. The curve was cut out with a band saw with all (4) dividers taped together. I then sanded the  edges.The side runners and bottom did need an 1/8\"  trimmed off to fit in the drawer. You may have seen an extra dado on one of the side runners. Measuring twice doesn't always work when you've  written down the wrong dimension. Luckily I was off far enough that I  could just cut another dado and not have to worry about filling the  slot/creating an extra large slot.I don't have to glue this, and decided not to. It holds together perfectly fine, constricted by the drawer. Having it able to break down  also makes future clean up easier. I did clear coat it to facilitate future clean up, though it's unlikely I will clean it that often.I liked this one so much, I built a second for a different drawer.", "step_imgs": ["https://cdn.instructables.com/FXM/AR2P/JFUAGEZ7/FXMAR2PJFUAGEZ7.LARGE.jpg", "https://cdn.instructables.com/FJ2/A2SM/JFUAGEZ6/FJ2A2SMJFUAGEZ6.LARGE.jpg", "https://cdn.instructables.com/FLK/TNYN/JFUAGEZ8/FLKTNYNJFUAGEZ8.LARGE.jpg", "https://cdn.instructables.com/F31/CX7D/JFUAGEZ9/F31CX7DJFUAGEZ9.LARGE.jpg", "https://cdn.instructables.com/FOU/OF62/JFUAGEZQ/FOUOF62JFUAGEZQ.LARGE.jpg", "https://cdn.instructables.com/FWI/CK5G/JFUAGF1L/FWICK5GJFUAGF1L.LARGE.jpg", "https://cdn.instructables.com/FL4/XIM6/JFUAGF0N/FL4XIM6JFUAGF0N.LARGE.jpg", "https://cdn.instructables.com/FL1/8EXM/JFUAGF1O/FL18EXMJFUAGF1O.LARGE.jpg", "https://cdn.instructables.com/F7S/NUJQ/JFUAGF1P/F7SNUJQJFUAGF1P.LARGE.jpg", "https://cdn.instructables.com/F0N/9K9X/JFUAGF27/F0N9K9XJFUAGF27.LARGE.jpg"], "step_title": "Step 1: "}], "channel": "No channel to show"}, {"category": "technology", "description": "AIM:\u00a0\u00a0 To compute the Total Harmonic Distortion (THD) generated by a rectifier feeding a Three phase RL load. APPARATUS REQUIRED: Personal computer with MATLAB software and Plotly. NECESSITY OF SIMULATION :\u00a0Simulation is the imitation of the operation of a real-world process or system over time. The act of simulating something first requires that a model be developed.\u00a0 Thus we can analyze the harmonic that will be generated by the rectifier and thus design the circuit. Thus the difficulty of implementation of hardware and analyzing is avoided. The best design obtained from simulation can then be used to develop the hardware.", "title": "Harmonic Analysis (THD) of a Rectifier Using MATLAB and Plotly", "url": "https://www.instructables.com/id/Harmonic-analysis-THD-of-a-Rectifier-feeding-Three/", "section": "technology", "steps": [{"step": 1, "steps_text": "RECTIFIER : A rectifier is an electrical device that converts alternating current (AC), which periodically reverses direction, to direct current (DC), which flows in only one direction. The process is known as rectification. The three voltage sources are given to six pulse bridge rectifier. The AC is converted to DC signal by the rectifier. At the output side the RL load is connected. The harmonics produced by the rectifier is to be evaluated. TOTAL HARMONIC DISTORTION (THD) : The total harmonic distortion, or THD, of a signal is a measurement of the harmonic distortion present and is defined as the ratio of the sum of the powers of all harmonic components to the power of the fundamental frequency.THD is a measurement of the extent of that distortion. The THD is defined as the root mean square (RMS) value of the total harmonics of the signal, divide by the RMS value of its fundamental signal.\u00a0 The formula to calcuate THD is given below. where Vi is the RMS voltage of ith harmonic and i = 1 is the fundamental frequency", "step_imgs": ["https://cdn.instructables.com/FX6/M7I0/HT2UYOLF/FX6M7I0HT2UYOLF.LARGE.jpg", "https://cdn.instructables.com/FEJ/3S8Q/HT3DZLV6/FEJ3S8QHT3DZLV6.LARGE.jpg"], "step_title": "Step 1: Theory"}, {"step": 2, "steps_text": "1) Open the MATLAB software. 2) Click on FIle -> New -> Model This will open a model and the blocks can be added to the sheet. 3) With the help of Simulink library icon different blocks can be selected and placed on the sheet. The blocks are connected by the connecting arrow.\u00a0 4) The model is saved with '.m' extension.", "step_imgs": ["https://cdn.instructables.com/FD3/6R5I/HT3DZMZX/FD36R5IHT3DZMZX.LARGE.jpg", "https://cdn.instructables.com/F39/D582/HT3DZLR6/F39D582HT3DZLR6.LARGE.jpg", "https://cdn.instructables.com/FTO/HNO0/HT3DZLRJ/FTOHNO0HT3DZLRJ.LARGE.jpg"], "step_title": "Step 2: MATLAB Implementation"}, {"step": 3, "steps_text": "1) The final model is shown below. It is saved as 'threephase.m'.\u00a0 2) The parameters of each block is shown. The load is designed for: Active Power = 40000 W Frequency = 50 Hz Inductive Reactive Power = 50.19 var 3) In each scope Save data to work space is given so that the data is available to be given to Plotly. 4) The model is Run by the arrow button.", "step_imgs": ["https://cdn.instructables.com/FUG/DUA2/HT2UYOIM/FUGDUA2HT2UYOIM.LARGE.jpg", "https://cdn.instructables.com/FBM/MXKG/HT279LPH/FBMMXKGHT279LPH.LARGE.jpg", "https://cdn.instructables.com/F9T/CBGT/HT2UYOIN/F9TCBGTHT2UYOIN.LARGE.jpg", "https://cdn.instructables.com/F06/V8FH/HT3DZLS0/F06V8FHHT3DZLS0.LARGE.jpg"], "step_title": "Step 3: MATLAB Model"}, {"step": 4, "steps_text": "From the scope the waveform can be viewed. 1) Input Current waveform from Thee phase source 2) input pure sinusoidal input voltage 3) Rectified three phase Output voltage\u00a0", "step_imgs": ["https://cdn.instructables.com/F0F/JQT3/HT3DZLSH/F0FJQT3HT3DZLSH.LARGE.jpg", "https://cdn.instructables.com/FF5/4QLT/HT3DZLSG/FF54QLTHT3DZLSG.LARGE.jpg", "https://cdn.instructables.com/FEI/3HI2/HT3DZLSF/FEI3HI2HT3DZLSF.LARGE.jpg"], "step_title": "Step 4: Scope Output"}, {"step": 5, "steps_text": "Click on Power Gui block -> FFT Analysis The total harmonic distortion will be calculated and displayed. Result :\u00a0 Harmonics analysis for the given Rectifier feeding RL load is carried out using MATLAB. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 THD = 80.13 %", "step_imgs": ["https://cdn.instructables.com/F29/XLZE/HT279MHZ/F29XLZEHT279MHZ.LARGE.jpg", "https://cdn.instructables.com/FEW/S3HX/HT3DZLTN/FEWS3HXHT3DZLTN.LARGE.jpg"], "step_title": "Step 5: Analysis of THD"}, {"step": 6, "steps_text": "1) In the main page of Matlab in the work space the scope data are available. 2) Get the data from scope. 3) Save it to Excel sheet.", "step_imgs": ["https://cdn.instructables.com/FMD/LKRZ/HT3DZLWU/FMDLKRZHT3DZLWU.LARGE.jpg", "https://cdn.instructables.com/FOR/LG6M/HT3DZLWT/FORLG6MHT3DZLWT.LARGE.jpg", "https://cdn.instructables.com/FKJ/3JOB/HT3DZLWS/FKJ3JOBHT3DZLWS.LARGE.jpg"], "step_title": "Step 6: Save the Values to Excel Sheet"}, {"step": 7, "steps_text": "plotly is an online collaborative data analysis and graphing tool. It can be accessed by the link given below. https://plot.ly/ Wit the help of plotly I have represented the result obtained from Matlab in which way I can analyze more efficiently. \u00a0Sign in and\u00a0Create an account 1) Import data to your account with help of import tab.\u00a0 2) click on the file name and it will be opened. You can view the imported data.", "step_imgs": ["https://cdn.instructables.com/F7Y/KRG5/HT3DZLYJ/F7YKRG5HT3DZLYJ.LARGE.jpg", "https://cdn.instructables.com/FPT/SN9T/HT3DZLYG/FPTSN9THT3DZLYG.LARGE.jpg", "https://cdn.instructables.com/F9O/4NI2/HT3DZLYK/F9O4NI2HT3DZLYK.LARGE.jpg"], "step_title": "Step 7: Starting With Plotly"}, {"step": 8, "steps_text": "1) Open one excel sheet and click on Make a plot -> Line plot 2) Chose the x and y axis 3) The plot will be available", "step_imgs": ["https://cdn.instructables.com/F2K/9H1J/HT3DZLZE/F2K9H1JHT3DZLZE.LARGE.jpg", "https://cdn.instructables.com/FRA/E7A3/HT3DZLZD/FRAE7A3HT3DZLZD.LARGE.jpg", "https://cdn.instructables.com/F05/H1YI/HT3DZLZC/F05H1YIHT3DZLZC.LARGE.jpg"], "step_title": "Step 8: Make a Plot"}, {"step": 9, "steps_text": "1) Click on Traces and select new axis/ subplot 2)Select New Y axis -> Right 3) import the second file and select x and y axis. Insert to -> Tab 5 -> Plot 4) A graph with two Y axis is obtained. Thus both the Input current and voltage waveform is analyzed. The difference with matlab and plotly I found in plotly that when you move the pointer the data of the volatge and current at that instant of time is available. It was very useful for analysis.", "step_imgs": ["https://cdn.instructables.com/F1I/AR5S/HT3DZM0M/F1IAR5SHT3DZM0M.LARGE.jpg", "https://cdn.instructables.com/FA1/TS0Y/HT3DZM0K/FA1TS0YHT3DZM0K.LARGE.jpg", "https://cdn.instructables.com/FTS/3JKR/HT3DZM0J/FTS3JKRHT3DZM0J.LARGE.jpg", "https://cdn.instructables.com/FXQ/ODF1/HT3DZM1R/FXQODF1HT3DZM1R.LARGE.jpg"], "step_title": "Step 9: To Make Plot With Two Y Axis"}, {"step": 10, "steps_text": "1) To create graph on same axis then select subplot -> stacked", "step_imgs": ["https://cdn.instructables.com/FBB/TKS0/HT3DZM4P/FBBTKS0HT3DZM4P.LARGE.jpg", "https://cdn.instructables.com/FZY/JKUL/HT3DZM4O/FZYJKULHT3DZM4O.LARGE.jpg"], "step_title": "Step 10: To Make Subplot Stacked Vertically"}, {"step": 11, "steps_text": "1) The data of THD is imported. The x and y axis is selected and data is represented in Bar graph. 2) A Fit linear plot is also used to represent.", "step_imgs": ["https://cdn.instructables.com/FHN/WY0D/HT3DZNA9/FHNWY0DHT3DZNA9.LARGE.jpg", "https://cdn.instructables.com/FSS/W4FS/HT3DZNA3/FSSW4FSHT3DZNA3.LARGE.jpg", "https://cdn.instructables.com/FOC/CH5H/HT3DZNDE/FOCCH5HHT3DZNDE.LARGE.jpg"], "step_title": "Step 11: THD"}, {"step": 12, "steps_text": "Final output plot : I have represented the Input waveform in different ways. Both stacked vertically and Two Y axis. The rectified output is displayed. Thd value is also displayed.  With help of Plotly more Information can be displayed. :)Hope this was helpful. Do vote for me for the contest if you found it helpful.", "step_imgs": ["https://cdn.instructables.com/FS6/WHYL/HT3DZM9E/FS6WHYLHT3DZM9E.LARGE.jpg", "https://cdn.instructables.com/F1S/9RP1/HT3DZM7J/F1S9RP1HT3DZM7J.LARGE.jpg", "https://cdn.instructables.com/FAL/QQRV/HT3DZM6K/FALQQRVHT3DZM6K.LARGE.jpg", "https://cdn.instructables.com/FEF/062U/HT3DZNEB/FEF062UHT3DZNEB.LARGE.jpg"], "step_title": "Step 12: Final Plot With Plotly"}], "channel": "Software"}, {"category": "technology", "description": "##This is the most clicked, popular link in Google for VHDL implementation of CORDIC ALGORITHM to generate sine and cosine wave## At present time, many hardware efficient algorithms exist, but these are not well known due to the dominance of software systems over the many years. CORDIC is such an algorithm which is nothing but a set of shift and add logics used for computing a wide range of functions including certain trigonometric, hyperbolic, linear and logarithmic functions. Thus by just using simple shifters and adders we can design a hardware with less complexity but power of DSP using cordic algorithm . This is the algorithm used in calculators etc.", "title": "Cordic Algorithm Using VHDL", "url": "https://www.instructables.com/id/Cordic-Algorithm-Using-VHDL/", "section": "technology", "steps": [{"step": 1, "steps_text": "Here the cordic algorithm is implemented using VHDL to generate a sine wave and cose wave . It can output sine and cosine of input angle at great precision. The code is synthesizable on FPGA. Modelsim is used to simulate the design and the test bench .", "step_imgs": [], "step_title": "Step 1: VHDL and Modelsim"}, {"step": 2, "steps_text": "---- Guidelines ----Binary scaling technique is used to represent floating point numbers. Please go thru the attached docs before you code.Go thruSimulating cordic_v4.vhd - The Design -The input is angle in 32 bits + sign bit ; it can process any angle from 0 to +/-360 degree with input precision of 0.000000000233 degree. When giving input -> MSB is the sign bit and the rest 32 bits represent magnitude .-The output of the design is its sine and cos value in 16 bits + sign bit .ie; with precision 0.00001526. Please note that the output is displayed in 2's compliment form if the respective sine or cos value is negative.Simulating testb.vhd - Test Bench For The Design(1) Input angles and pull reset ='0'. After two steps of simulation pull reset to '1' and \" run all \".(2) In simulation window set the radix of sin and cos signals as decimal and format > Analog ( automatic ).(3) Zoom out to see the waveform properly.", "step_imgs": ["https://cdn.instructables.com/FM3/T68N/IO0GDUZO/FM3T68NIO0GDUZO.LARGE.jpg"], "step_title": "Step 2: VHDL Code for the Design and the Test Bench"}, {"step": 3, "steps_text": "(1) cordic_v4.vhd - Design .(2) testb.vhd - Test bench for the design .(3) Document on how to force angle inputs and convert the binary results.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Files Attached"}, {"step": 4, "steps_text": "Limitation of the above implementation is- slow, lower clock frequency of operation because of doing computations in a single clock cycle.Mini-Cordic IP Core - 16 Bit - Pipelined combinational logic to multiple cycles.- Faster - FPGA proven design synthesised upto 100 Mhz clock.- More area optimised , Lesser hardware.- Load and Status signals added.Only downside is lesser resolution compared to the previous one.Files Attached:1) mini cordic main vhdl file2) mini cordic test bench3) Mini Cordic IP Core manual4) Doc on how to force angles and convert results-----Designers-----Mitu Raj and Roshanfor queries, contact : iammituraj@gmail.com###Total downloads : 103 as of till Mar-12-2018### ", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Mini-Cordic IP Core - 16 Bit "}], "channel": "Electronics"}, {"category": "technology", "description": "1- Arduino UNO", "title": "Plot Sin-wave by Using Arduino", "url": "https://www.instructables.com/id/Plot-Sin-wave-by-Using-Arduino/", "section": "technology", "steps": [], "channel": "Arduino"}, {"category": "technology", "description": "We will create a Verilog project for the Digilent Zybo to create a 1 Kilohertz sine wave on the output pins of a Digilent Pmod R2R. This project is intended as a introduction to production of sine waves using an FPGA, a critical step in starting a number of more complex projects, such as driving audio hardware and other analog circuits. We will also use a new feature of Vivado 2016.2, Add Module in the IP Integrator, which makes prototyping of complex projects relatively easy, as we will be able to skip the step of writing an HDL wrapper file and easily see how our modules are connected together and interact.The project is provided, build-able through a TCL script. If you only want the source code, the HDL (hardware descriptive language) files can be found under src/hdl. In order to use the IP Integrator and generate a bitstream file, the project will need to be built through Vivado's TCL console. A good tutorial for this process can be found in this Instructable. Downloading and building this project is not required though, as we will walk through what is required for you to create the project yourself.", "title": "Digilent Pmod R2R Sine Wave Generator", "url": "https://www.instructables.com/id/Digilent-Pmod-R2R-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "Materials Requirements ListInstalled version of Vivado 2016.2 --Earlier versions will not work, as a new feature in the IPI, \"Add Module\", will be used, though you may still be able to follow along and write a custom HDL wrapper. A Digilent Zybo (or other compatible Digilent FPGA).Your Digilent PmodR2R. A master XDC file for your Digilent board -- available through the board's page on the Digilent Wiki.. A Python environment.Functional DescriptionThe PmodR2R allows us to output voltages in a range between its ground and VDD levels. We pass the R2R 8 bits of input, ranging from 0 to 0xFF (255 in hexadecimal). It then outputs a voltage corresponding to our input, passing a zero means it will output ground, passing 0xFF means it will output 3.3V, the typical supply voltage for the Pmod headers on Digilent boards.In order to produce a 3.3V zero-to-peak sine wave, we will need to repeatedly count through a single sin wave scaled to the range 0 to 0xFF. The easiest way to do this in Verilog will be to create a lookup table, basically just an array, filled with the correct values in order. We would then count through the array, outputting each value in order. Since we also want to control the frequency of our sine wave, we will need a way to control the speed at which we count through our sine wave. The easiest way to do this is to only increment our counter every so often, which we can achieve by enabling it only when another counter hits a maximum value. We will talk about how to implement this in Verilog later.This design will give us essentially two variables we can use to control the speed and resolution of our sine wave in our lookup table size and maximum count of our \"clock divider\" counter. Depending on the selected values, we are placing a cap on the frequencies available at the R2R output, and the higher we decide to place this cap the worse the resolution of our signal will be. With the selected target frequency of 1KHz, we will be able to ignore this tradeoff and produce a reasonable result. We will discuss the selection of these parameters later.", "step_imgs": [], "step_title": "Step 1: Project Overview"}, {"step": 2, "steps_text": "After loading up Vivado, in order to get the project set up, follow these steps:Select \"Create New Project\". Select \"Next\", add a name for your project, without spaces, and select \"Next\". Make Sure \"RTL Project\" and \"Do not specify sources at this time\" are selected. Select \"Next\". Select Boards, and find and select your board's part file. Select \"Next\". Select \"Finish\".With this Vivado will have created a new empty project for you.", "step_imgs": ["https://cdn.instructables.com/F4R/0CPQ/IR3ZSZNK/F4R0CPQIR3ZSZNK.LARGE.jpg", "https://cdn.instructables.com/F9F/BCVY/IR3ZSZNL/F9FBCVYIR3ZSZNL.LARGE.jpg", "https://cdn.instructables.com/F5P/LJ1M/IR3ZSZNW/F5PLJ1MIR3ZSZNW.LARGE.jpg", "https://cdn.instructables.com/FSV/7JJC/IR3ZSZO4/FSV7JJCIR3ZSZO4.LARGE.jpg", "https://cdn.instructables.com/FOG/N3K2/IR3ZSZO5/FOGN3K2IR3ZSZO5.LARGE.jpg", "https://cdn.instructables.com/FSA/UEA3/IR3ZSZOS/FSAUEA3IR3ZSZOS.LARGE.jpg"], "step_title": "Step 2: Creating the Project"}, {"step": 3, "steps_text": "Before we can start writing our HDL code, we need to create the files. In order to do this, follow these steps:In the Project Manager \"Sources\" subwindow, right click on \"Design Sources\" and select \"Add Sources\". Select \"Add or create design sources\" and click Next. Select \"Create File\". Set file type as Verilog, file name as counter, and file location as . Repeat step 4 for another file named lut. The Define Module window will pop up, we can immediately click OK, then Yes at the prompt that will pop up.You have just created two new files with empty module templates, so next we will add HDL code to turn them into functional blocks for later use.We need three components to be able to produce a digital sine wave. A lookup table will allow us to convert a counter output to a digital sin wave -- just like indexing into an array. We will need one counter to generate the lookup table address, and a second counter to control the speed of the first counter.Our counter needs several features. First, it needs to be able to increment an output bus, so we will add a clock source and an output register. We need to be able to control how often this happens, so we will add an enable pin. We also want to be able to configure the size and maximum value of the count register differently for different counters, so we will add width and max value parameters. We also want an output representing that the counter is at it's maximum value, this will allow us to only increment our second counter when the first counter completes a rollover loop -- counting all of the way through it's range and resetting itself -- I will refer to this register as \"tc\", for \"terminal count\". The following code defines the counter module and it's ports:`timescale 1ns / 1ps\n\nmodule counter (\n\tinput clk,\n\tinput rst,\n\tinput en,\n\toutput reg [DATA_WIDTH-1:0] data,\n\toutput reg tc\n);\nparameter DATA_WIDTH=8;\nparameter DATA_MAX=255;\n\n//functional code goes here\n\nendmodule\nWhile we are required to give the two parameters default values, we will be able to change them for each counter later.The functional description described can be achieved with two \"always blocks\". The first always block will set the tc register whenever the data bus changes. The tc block should not be clocked, so that we can use it in our counter logic, without worrying about accidental \"off by one\" errors. The second always block will be clocked, whenever a clock edge occurs, it will increment or reset the counter from maximum, as long as enable is high, otherwise, it will hold it's current value. It should also trigger on resets, so that it will be set low as soon as the reset button is pushed.always@(data)\n\tif (data == DATA_MAX)\n\t\ttc = 1'b1;\n\telse\n\t\ttc = 1'b0;\n\nalways@(posedge clk, posedge rst)\n\tif (rst == 1'b1)\n\t\tdata <= 'b0;\n\telse if (en == 1'b0)\n\t\tdata <= data;\n\telse if (tc == 1'b1)\n\t\tdata <= 'b0;\n\telse\n\t\tdata <= data + 1'b1;\tThe approach toward building a lookup table is similar to that of the counter. It will need clock and address inputs, and an output data register. We also add a 256 byte block RAM by declaring a two dimensional register array.`timescale 1ns / 1ps\nmodule lut(\n\tinput clk,\n\tinput [ADDRESS_WIDTH-1:0] addr,\n\toutput reg [DATA_WIDTH-1:0] data\n);\nparameter ADDRESS_WIDTH=8;\nparameter DATA_WIDTH=8;\nparameter FILENAME=\"sin.hex\";\n\nreg [DATA_WIDTH-1:0] mem [2**ADDRESS_WIDTH-1:0];\n\n//functional code goes here\n\nendmoduleThe functional code for our lookup table is fairly simple:initial $readmemh(FILENAME, mem);\nalways@(posedge clk)\n\tdata <= mem[addr];The initial read memory statement will load our file into our block ram as the FPGA is programmed. The always block will just set the data register to the value stored in blockram at our address.", "step_imgs": ["https://cdn.instructables.com/FPA/XDJR/IR3ZSZ0B/FPAXDJRIR3ZSZ0B.LARGE.jpg", "https://cdn.instructables.com/FDQ/9RJ7/IR3ZSZ23/FDQ9RJ7IR3ZSZ23.LARGE.jpg", "https://cdn.instructables.com/FD7/6N5K/IR3ZSZ2H/FD76N5KIR3ZSZ2H.LARGE.jpg", "https://cdn.instructables.com/FZ3/DBIY/IR3ZSZ2I/FZ3DBIYIR3ZSZ2I.LARGE.jpg", "https://cdn.instructables.com/FFV/B0JT/IR3ZSZ3W/FFVB0JTIR3ZSZ3W.LARGE.jpg", "https://cdn.instructables.com/F5H/RG0Z/IR3ZSZ80/F5HRG0ZIR3ZSZ80.LARGE.jpg", "https://cdn.instructables.com/FTP/KS74/IR3ZSZ81/FTPKS74IR3ZSZ81.LARGE.jpg", "https://cdn.instructables.com/FIM/SN58/IR3ZSZ82/FIMSN58IR3ZSZ82.LARGE.jpg", "https://cdn.instructables.com/FS0/38N4/IR3ZSZ9E/FS038N4IR3ZSZ9E.LARGE.jpg"], "step_title": "Step 3: HDL Counter and Lookup Table"}, {"step": 4, "steps_text": "For us to initialize the memory in our lookup table, we used readmemh, however we are still missing the file to be read using that function. Since we want to initialize every memory address, not skipping any cells, this file will follow a simple format, the data for each memory address will be stored on its own line, in ascending order by address. The data will be in hexadecimal format, so a line representing \"for this address, output = 3.3V\" will read \"FF\", since the PmodR2R will output the supply voltage when all of the lines on its data bus are high.In order to automatically generate the file we will load into our lookup table, we can use Python.and it's built in math library. Since Python's math library's sin function takes radians as input and outputs a floating point number between -1 and 1, some scaling and conversion will be in order to write a hexadecimal integer string between 0 and FF to our file. We will count through our memory space, for each index, we will get a radian value between 0 and 2 pi. That radian value will be used with the sin function to get a float between 0 and 1, which will then be converted to an integer between 0 and 255. That integer will be converted to a hexadecimal string. In Python, these strings are generated with a leading \"0x\", so we will strip off the first two charactersimport math\nfilename = \"sin.hex\"\nf = open(filename, \"w\")\nmem_len = 256\nfor i in range(mem_len):\n\tradians = math.pi * 2.0 * i / mem_len # get how far through the file we are, convert to radians\n\tfvalue = (math.sin(radians) + 1.0) / 2.0 # get sin value, in range 0.0-1.0\n\tivalue = int(255 * fvalue) # convert from float to int, range from 0-0xFF\n\ts = hex(ivalue)[2:] # convert int calue to hexadecimal string and strip the leading \"0x\"\n\tf.write(s + \"\\n\") # write to file\nf.close()\tIn order to run this code, follow these steps:Create a new file called singen.py somewhere on your computer.  Copy the source into said file and save.  Open a console window, navigate to the directory that contains the .py file.  Call \"python singen.py\", or \"py singen.py\", depending on your python installation.The script will have now created a new file named sin.hex in the directory containing singen.py. You can now add this .hex file to your Vivado project.", "step_imgs": ["https://cdn.instructables.com/FR0/WZWN/IR3ZSXXI/FR0WZWNIR3ZSXXI.LARGE.jpg", "https://cdn.instructables.com/FJH/9QWV/IR3ZSXXQ/FJH9QWVIR3ZSXXQ.LARGE.jpg", "https://cdn.instructables.com/F5R/2H1A/IR3ZSXYO/F5R2H1AIR3ZSXYO.LARGE.jpg", "https://cdn.instructables.com/FWG/6QB4/IR3ZSXYW/FWG6QB4IR3ZSXYW.LARGE.jpg", "https://cdn.instructables.com/FLS/RK1Y/IR3ZSXZM/FLSRK1YIR3ZSXZM.LARGE.jpg", "https://cdn.instructables.com/FSM/B3TN/IR3ZSXZN/FSMB3TNIR3ZSXZN.LARGE.jpg"], "step_title": "Step 4: Look-Up Table Initialization File"}, {"step": 5, "steps_text": "Now for the fancy part. Create a new block design using the Flow Navigator under IP Integrator. Ensure that Design Name contains no spaces, that Directory is  and that the source set is Design Sources.With this block design created we can now draw our project design. Right click within the Diagram, and select \"Add Module\". This is a new feature to Vivado 2016.2, and lets us convert any sources we may have written into IP Cores automatically. We can add a module by just selecting it from the list of sources that pops up, and clicking OK. Use this method to add two counters and a lookup table. We should now connect these blocks together, and to input and output ports. Select one of the clk pins on one of the three blocks, and select Make External. You can now draw connections from each of the other clock pins to the new clock port. Do the same for the rst pins, so that each are tied to the same input. Tie the enable pin of counter_1 to the terminal count pin of the counter_0, and counter_1's data bus to the address bus of the lookup table. Make the lookup table's data bus external. Lastly, add a constant block, using \"Add IP\" and searching for \"constant\". Tie this constant block's output to the enable input of the counter_0. This constant block will ensure that counter_0 will always be runningNow that the design is drawn out, we need to go in and edit each block's parameters. This can be done by double clicking on the block in question, or right clicking the block, and selecting \"Customize Block\". We will be using the default values for the counter_1 data width and maximum count, and both the lookup table data width and address width. The maximum count for counter_0 depends on which board you are using. Since we are targeting 1KHz for the full sequence of counter_1, which only counts when counter_0 finishes its own sequence, we should use the following formula to determine our maximum count:T_c0 = f_base_clk / (f_target * T_c1)For the Digilent Zybo, our base clock frequency is 125MHz - a value which can be found in the board's reference manual on the Digilent Wiki, and which will likely be different for other FPGA boards - so with a target frequency of 1KHz and a lookup table size of 256 addresses, we get a counter_0 period of 488.28 clock cycles per address increment. Since this needs to be an integer, and our counter resets to zero, we will round down to get a maximum count of 488. To get counter_0's data width, we can to take the log base 2 of the maximum and round it up, telling us we need at least 9 bits to properly represent every value in the range 0 to 488. Customize counter_0 to fill in these values. Lastly, make sure that the constant block controlling counter_0's enable pin has width 1 and value 1.", "step_imgs": ["https://cdn.instructables.com/FFW/LFOU/IR3ZSWBY/FFWLFOUIR3ZSWBY.LARGE.jpg", "https://cdn.instructables.com/FO5/PPGL/IR3ZSWCW/FO5PPGLIR3ZSWCW.LARGE.jpg", "https://cdn.instructables.com/FC8/NCMS/IR3ZSWCX/FC8NCMSIR3ZSWCX.LARGE.jpg", "https://cdn.instructables.com/F0L/ZLRF/IR3ZSWDM/F0LZLRFIR3ZSWDM.LARGE.jpg", "https://cdn.instructables.com/FY0/5ZG6/IR3ZSWFI/FY05ZG6IR3ZSWFI.LARGE.jpg", "https://cdn.instructables.com/FV5/2M0H/IR3ZSWFK/FV52M0HIR3ZSWFK.LARGE.jpg", "https://cdn.instructables.com/FLB/L7UB/IR3ZSWFL/FLBL7UBIR3ZSWFL.LARGE.jpg", "https://cdn.instructables.com/FP0/16GQ/IR3ZSWFS/FP016GQIR3ZSWFS.LARGE.jpg", "https://cdn.instructables.com/FFY/XJUJ/IR3ZSWGX/FFYXJUJIR3ZSWGX.LARGE.jpg", "https://cdn.instructables.com/F8U/Q5YD/IR3ZSWH0/F8UQ5YDIR3ZSWH0.LARGE.jpg", "https://cdn.instructables.com/FAR/PQQZ/IR3ZSWHA/FARPQQZIR3ZSWHA.LARGE.jpg", "https://cdn.instructables.com/FSJ/MCA7/IR3ZSWHG/FSJMCA7IR3ZSWHG.LARGE.jpg", "https://cdn.instructables.com/F96/SXC9/IR3ZSWHH/F96SXC9IR3ZSWHH.LARGE.jpg", "https://cdn.instructables.com/FVZ/G7NJ/IR3ZSWHO/FVZG7NJIR3ZSWHO.LARGE.jpg", "https://cdn.instructables.com/F3B/O3KK/IR3ZSWHR/F3BO3KKIR3ZSWHR.LARGE.jpg", "https://cdn.instructables.com/FIJ/0VMK/IR3ZSWI2/FIJ0VMKIR3ZSWI2.LARGE.jpg"], "step_title": "Step 5: The Block Design"}, {"step": 6, "steps_text": "In order for Vivado to understand how our designs input and output ports are connected to the input and output pins of the boards FPGA, we need to add an XDC (Xilinx Design Constraint) file to our project. The easiest way to do this is to find and download the Master XDC for your board. The wiki page for your board on the Digilent Wiki should contain a link to this file on the sidebar under Design Resources. This file can be included in your project in the same way as adding a design source. Follow these steps:Right click on Constraints in the Sources subwindow. Select \"Add Sources\".Make sure \"Add or create constraints\" is selected. Click Next.Click \"Add Files\", navigate to your Master XDC, select it, and click Open.Click Finish.Once downloaded and included in your project, several changes will need to be made to this XDC file. Start by uncommenting the system clock signal, one button, and all eight signals for one of the Pmod headers. The system clock should be the first signal declared at the top of the file, while the others can be found using Finds (Ctrl-F) for \"btn\" and \"pmod\". If your board has a dedicated reset button (for example, \"cpu_resetn\" on the Nexys Video), use that instead of one of the normal buttons. As for the Pmod header, choose any that isn't intended for input to an onboard XADC. For each of these signals, replace the name in the get_ports call with the name you used in the Block Design, clk, rst, and data, while leaving the bus index alone.", "step_imgs": ["https://cdn.instructables.com/FWB/SZDB/IR3ZSW0X/FWBSZDBIR3ZSW0X.LARGE.jpg", "https://cdn.instructables.com/F3G/EBI0/IR3ZSW13/F3GEBI0IR3ZSW13.LARGE.jpg", "https://cdn.instructables.com/FEQ/PAID/IR3ZSW14/FEQPAIDIR3ZSW14.LARGE.jpg", "https://cdn.instructables.com/FSU/R21K/IR3ZSW1A/FSUR21KIR3ZSW1A.LARGE.jpg", "https://cdn.instructables.com/FBO/TYDG/IR3ZSW1F/FBOTYDGIR3ZSW1F.LARGE.jpg", "https://cdn.instructables.com/FCV/5MRV/IR3ZSW29/FCV5MRVIR3ZSW29.LARGE.jpg", "https://cdn.instructables.com/F7D/TA6A/IR3ZSW3T/F7DTA6AIR3ZSW3T.LARGE.jpg"], "step_title": "Step 6: Adding an XDC"}, {"step": 7, "steps_text": "In order to generate the .bit file required for programming your Digilent FPGA board, follow the following steps:In your block design, press F6 or right click anywhere and select \"Validate Design\". The design should pass validation with no errors if everything was done correctly.Under the Sources subwindow, select Sources from the tab menu. Right click on your block design and select \"Create HDL Wrapper\". Make sure the \"Let Vivado manage...\" option is selected and click OK.Make sure your new wrapper -- under Design Sources -- is bold in the sources window, if not, right click it and select \"Set as Top\".In the Flow Navigator, select \"Generate Bitstream\" under \"Program and Debug\". Select Yes when asked whether to launch synthesis and implementation.Vivado will now automatically generate the file used to program your FPGA. It might take a while, but once done, a window called \"Bitstream Generation Completed\" will pop up. Select \"Open Hardware Manager\" and move on to Step 8.", "step_imgs": ["https://cdn.instructables.com/F9A/1E1O/IR3ZSV4B/F9A1E1OIR3ZSV4B.LARGE.jpg", "https://cdn.instructables.com/FMR/0RJN/IR3ZSV4C/FMR0RJNIR3ZSV4C.LARGE.jpg", "https://cdn.instructables.com/F0U/2WMI/IR3ZSV5H/F0U2WMIIR3ZSV5H.LARGE.jpg", "https://cdn.instructables.com/FED/XEFF/IR3ZSV6L/FEDXEFFIR3ZSV6L.LARGE.jpg", "https://cdn.instructables.com/FJ7/8ESK/IR3ZSV6X/FJ78ESKIR3ZSV6X.LARGE.jpg", "https://cdn.instructables.com/FCP/TZ2U/IR3ZSV7Z/FCPTZ2UIR3ZSV7Z.LARGE.jpg", "https://cdn.instructables.com/FTZ/XCXB/IR3ZSV9Z/FTZXCXBIR3ZSV9Z.LARGE.jpg", "https://cdn.instructables.com/F0H/PQ3M/IR3ZSVB2/F0HPQ3MIR3ZSVB2.LARGE.jpg"], "step_title": "Step 7: Generating the Bit File"}, {"step": 8, "steps_text": "The Digilent Wiki has tutorials for most FPGA boards for how to program a bit file in a variety of ways. The following is going to be the easiest for seeing if our application works. In order to use Vivado's Hardware Manager to program your FPGA, follow these steps:Plug your board's programming port into a USB port of your PC.Attach your PmodR2R to whichever Pmod port you tied the lookup table data lines to in your XDC file. In the provided project for Zybo, this is the JE header.Power your board on, if necessary.In the Vivado hardware Manager, clock \"Open Target\" and \"Auto Connect\".Click \"Program Device\" and then then the device number that pops up.Ensure that the project's bitstream file is selected in the Program Device window. If not, click the \"...\" to the right of that field, navigate to and select /proj/.runs/impl_1/.bit.Click Program.In order to confirm that the project is now working, you can first check status LEDs to see if your board was programmed, then plug your Digilent Analog Discovery (or other oscilloscope) channel one ports into the R2R output ports. I used a six pin male to male connector snapped down to two pins for this, but a couple of small wires will work equally well. Watch the pretty sine wave go!", "step_imgs": ["https://cdn.instructables.com/FH2/6D2X/IR3ZST8U/FH26D2XIR3ZST8U.LARGE.jpg", "https://cdn.instructables.com/F37/0JDC/IR3ZST8Z/F370JDCIR3ZST8Z.LARGE.jpg", "https://cdn.instructables.com/FT4/JD66/IR3ZST9V/FT4JD66IR3ZST9V.LARGE.jpg", "https://cdn.instructables.com/FC7/POUK/IR3ZSTCT/FC7POUKIR3ZSTCT.LARGE.jpg", "https://cdn.instructables.com/F6L/WMM2/IR3ZSTKD/F6LWMM2IR3ZSTKD.LARGE.jpg"], "step_title": "Step 8: Programming the FPGA and Verifying Results"}, {"step": 9, "steps_text": "The following is a list of potential extensions of this project:Adding support for higher frequency waves, even up to the audio range, to control an analog speaker.Adding support for frequency selection, through switch inputs, a lookup table, and making the counter maximum parameter an input bus.Modifying the Python script to generate different types of waves, potentially including smaller amplitudes.Adding several lookup tables with differently shaped wave forms, with data buses multiplexed into the output bus.Adding a processor to the project in order to allow more complex control algorithms (might be able to use an AXI GPIO IP core to provide a simple interface to custom logic).Each of these ideas come with necessary complications, but could make for interesting projects.The \"Add Module\" feature is also very interesting, as it makes it much easier to translate from a functional description to a working prototype. A block diagram makes it much easier to comprehend what a design is actually doing than attempting to understand the same design written in Verilog or VHDL.", "step_imgs": [], "step_title": "Step 9: Additional Applications"}], "channel": "Electronics"}, {"category": "technology", "description": "We will create a Verilog project for the Digilent Zybo to create a 1 Kilohertz sine wave on the output pins of a Digilent Pmod R2R. This project is intended as a introduction to production of sine waves using an FPGA, a critical step in starting a number of more complex projects, such as driving audio hardware and other analog circuits. We will also use a new feature of Vivado 2016.2, Add Module in the IP Integrator, which makes prototyping of complex projects relatively easy, as we will be able to skip the step of writing an HDL wrapper file and easily see how our modules are connected together and interact.The project is provided, build-able through a TCL script. If you only want the source code, the HDL (hardware descriptive language) files can be found under src/hdl. In order to use the IP Integrator and generate a bitstream file, the project will need to be built through Vivado's TCL console. A good tutorial for this process can be found in this Instructable. Downloading and building this project is not required though, as we will walk through what is required for you to create the project yourself.", "title": "Digilent Pmod R2R Sine Wave Generator", "url": "https://www.instructables.com/id/Digilent-Pmod-R2R-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "Materials Requirements ListInstalled version of Vivado 2016.2 --Earlier versions will not work, as a new feature in the IPI, \"Add Module\", will be used, though you may still be able to follow along and write a custom HDL wrapper. A Digilent Zybo (or other compatible Digilent FPGA).Your Digilent PmodR2R. A master XDC file for your Digilent board -- available through the board's page on the Digilent Wiki.. A Python environment.Functional DescriptionThe PmodR2R allows us to output voltages in a range between its ground and VDD levels. We pass the R2R 8 bits of input, ranging from 0 to 0xFF (255 in hexadecimal). It then outputs a voltage corresponding to our input, passing a zero means it will output ground, passing 0xFF means it will output 3.3V, the typical supply voltage for the Pmod headers on Digilent boards.In order to produce a 3.3V zero-to-peak sine wave, we will need to repeatedly count through a single sin wave scaled to the range 0 to 0xFF. The easiest way to do this in Verilog will be to create a lookup table, basically just an array, filled with the correct values in order. We would then count through the array, outputting each value in order. Since we also want to control the frequency of our sine wave, we will need a way to control the speed at which we count through our sine wave. The easiest way to do this is to only increment our counter every so often, which we can achieve by enabling it only when another counter hits a maximum value. We will talk about how to implement this in Verilog later.This design will give us essentially two variables we can use to control the speed and resolution of our sine wave in our lookup table size and maximum count of our \"clock divider\" counter. Depending on the selected values, we are placing a cap on the frequencies available at the R2R output, and the higher we decide to place this cap the worse the resolution of our signal will be. With the selected target frequency of 1KHz, we will be able to ignore this tradeoff and produce a reasonable result. We will discuss the selection of these parameters later.", "step_imgs": [], "step_title": "Step 1: Project Overview"}, {"step": 2, "steps_text": "After loading up Vivado, in order to get the project set up, follow these steps:Select \"Create New Project\". Select \"Next\", add a name for your project, without spaces, and select \"Next\". Make Sure \"RTL Project\" and \"Do not specify sources at this time\" are selected. Select \"Next\". Select Boards, and find and select your board's part file. Select \"Next\". Select \"Finish\".With this Vivado will have created a new empty project for you.", "step_imgs": ["https://cdn.instructables.com/F4R/0CPQ/IR3ZSZNK/F4R0CPQIR3ZSZNK.LARGE.jpg", "https://cdn.instructables.com/F9F/BCVY/IR3ZSZNL/F9FBCVYIR3ZSZNL.LARGE.jpg", "https://cdn.instructables.com/F5P/LJ1M/IR3ZSZNW/F5PLJ1MIR3ZSZNW.LARGE.jpg", "https://cdn.instructables.com/FSV/7JJC/IR3ZSZO4/FSV7JJCIR3ZSZO4.LARGE.jpg", "https://cdn.instructables.com/FOG/N3K2/IR3ZSZO5/FOGN3K2IR3ZSZO5.LARGE.jpg", "https://cdn.instructables.com/FSA/UEA3/IR3ZSZOS/FSAUEA3IR3ZSZOS.LARGE.jpg"], "step_title": "Step 2: Creating the Project"}, {"step": 3, "steps_text": "Before we can start writing our HDL code, we need to create the files. In order to do this, follow these steps:In the Project Manager \"Sources\" subwindow, right click on \"Design Sources\" and select \"Add Sources\". Select \"Add or create design sources\" and click Next. Select \"Create File\". Set file type as Verilog, file name as counter, and file location as . Repeat step 4 for another file named lut. The Define Module window will pop up, we can immediately click OK, then Yes at the prompt that will pop up.You have just created two new files with empty module templates, so next we will add HDL code to turn them into functional blocks for later use.We need three components to be able to produce a digital sine wave. A lookup table will allow us to convert a counter output to a digital sin wave -- just like indexing into an array. We will need one counter to generate the lookup table address, and a second counter to control the speed of the first counter.Our counter needs several features. First, it needs to be able to increment an output bus, so we will add a clock source and an output register. We need to be able to control how often this happens, so we will add an enable pin. We also want to be able to configure the size and maximum value of the count register differently for different counters, so we will add width and max value parameters. We also want an output representing that the counter is at it's maximum value, this will allow us to only increment our second counter when the first counter completes a rollover loop -- counting all of the way through it's range and resetting itself -- I will refer to this register as \"tc\", for \"terminal count\". The following code defines the counter module and it's ports:`timescale 1ns / 1ps\n\nmodule counter (\n\tinput clk,\n\tinput rst,\n\tinput en,\n\toutput reg [DATA_WIDTH-1:0] data,\n\toutput reg tc\n);\nparameter DATA_WIDTH=8;\nparameter DATA_MAX=255;\n\n//functional code goes here\n\nendmodule\nWhile we are required to give the two parameters default values, we will be able to change them for each counter later.The functional description described can be achieved with two \"always blocks\". The first always block will set the tc register whenever the data bus changes. The tc block should not be clocked, so that we can use it in our counter logic, without worrying about accidental \"off by one\" errors. The second always block will be clocked, whenever a clock edge occurs, it will increment or reset the counter from maximum, as long as enable is high, otherwise, it will hold it's current value. It should also trigger on resets, so that it will be set low as soon as the reset button is pushed.always@(data)\n\tif (data == DATA_MAX)\n\t\ttc = 1'b1;\n\telse\n\t\ttc = 1'b0;\n\nalways@(posedge clk, posedge rst)\n\tif (rst == 1'b1)\n\t\tdata <= 'b0;\n\telse if (en == 1'b0)\n\t\tdata <= data;\n\telse if (tc == 1'b1)\n\t\tdata <= 'b0;\n\telse\n\t\tdata <= data + 1'b1;\tThe approach toward building a lookup table is similar to that of the counter. It will need clock and address inputs, and an output data register. We also add a 256 byte block RAM by declaring a two dimensional register array.`timescale 1ns / 1ps\nmodule lut(\n\tinput clk,\n\tinput [ADDRESS_WIDTH-1:0] addr,\n\toutput reg [DATA_WIDTH-1:0] data\n);\nparameter ADDRESS_WIDTH=8;\nparameter DATA_WIDTH=8;\nparameter FILENAME=\"sin.hex\";\n\nreg [DATA_WIDTH-1:0] mem [2**ADDRESS_WIDTH-1:0];\n\n//functional code goes here\n\nendmoduleThe functional code for our lookup table is fairly simple:initial $readmemh(FILENAME, mem);\nalways@(posedge clk)\n\tdata <= mem[addr];The initial read memory statement will load our file into our block ram as the FPGA is programmed. The always block will just set the data register to the value stored in blockram at our address.", "step_imgs": ["https://cdn.instructables.com/FPA/XDJR/IR3ZSZ0B/FPAXDJRIR3ZSZ0B.LARGE.jpg", "https://cdn.instructables.com/FDQ/9RJ7/IR3ZSZ23/FDQ9RJ7IR3ZSZ23.LARGE.jpg", "https://cdn.instructables.com/FD7/6N5K/IR3ZSZ2H/FD76N5KIR3ZSZ2H.LARGE.jpg", "https://cdn.instructables.com/FZ3/DBIY/IR3ZSZ2I/FZ3DBIYIR3ZSZ2I.LARGE.jpg", "https://cdn.instructables.com/FFV/B0JT/IR3ZSZ3W/FFVB0JTIR3ZSZ3W.LARGE.jpg", "https://cdn.instructables.com/F5H/RG0Z/IR3ZSZ80/F5HRG0ZIR3ZSZ80.LARGE.jpg", "https://cdn.instructables.com/FTP/KS74/IR3ZSZ81/FTPKS74IR3ZSZ81.LARGE.jpg", "https://cdn.instructables.com/FIM/SN58/IR3ZSZ82/FIMSN58IR3ZSZ82.LARGE.jpg", "https://cdn.instructables.com/FS0/38N4/IR3ZSZ9E/FS038N4IR3ZSZ9E.LARGE.jpg"], "step_title": "Step 3: HDL Counter and Lookup Table"}, {"step": 4, "steps_text": "For us to initialize the memory in our lookup table, we used readmemh, however we are still missing the file to be read using that function. Since we want to initialize every memory address, not skipping any cells, this file will follow a simple format, the data for each memory address will be stored on its own line, in ascending order by address. The data will be in hexadecimal format, so a line representing \"for this address, output = 3.3V\" will read \"FF\", since the PmodR2R will output the supply voltage when all of the lines on its data bus are high.In order to automatically generate the file we will load into our lookup table, we can use Python.and it's built in math library. Since Python's math library's sin function takes radians as input and outputs a floating point number between -1 and 1, some scaling and conversion will be in order to write a hexadecimal integer string between 0 and FF to our file. We will count through our memory space, for each index, we will get a radian value between 0 and 2 pi. That radian value will be used with the sin function to get a float between 0 and 1, which will then be converted to an integer between 0 and 255. That integer will be converted to a hexadecimal string. In Python, these strings are generated with a leading \"0x\", so we will strip off the first two charactersimport math\nfilename = \"sin.hex\"\nf = open(filename, \"w\")\nmem_len = 256\nfor i in range(mem_len):\n\tradians = math.pi * 2.0 * i / mem_len # get how far through the file we are, convert to radians\n\tfvalue = (math.sin(radians) + 1.0) / 2.0 # get sin value, in range 0.0-1.0\n\tivalue = int(255 * fvalue) # convert from float to int, range from 0-0xFF\n\ts = hex(ivalue)[2:] # convert int calue to hexadecimal string and strip the leading \"0x\"\n\tf.write(s + \"\\n\") # write to file\nf.close()\tIn order to run this code, follow these steps:Create a new file called singen.py somewhere on your computer.  Copy the source into said file and save.  Open a console window, navigate to the directory that contains the .py file.  Call \"python singen.py\", or \"py singen.py\", depending on your python installation.The script will have now created a new file named sin.hex in the directory containing singen.py. You can now add this .hex file to your Vivado project.", "step_imgs": ["https://cdn.instructables.com/FR0/WZWN/IR3ZSXXI/FR0WZWNIR3ZSXXI.LARGE.jpg", "https://cdn.instructables.com/FJH/9QWV/IR3ZSXXQ/FJH9QWVIR3ZSXXQ.LARGE.jpg", "https://cdn.instructables.com/F5R/2H1A/IR3ZSXYO/F5R2H1AIR3ZSXYO.LARGE.jpg", "https://cdn.instructables.com/FWG/6QB4/IR3ZSXYW/FWG6QB4IR3ZSXYW.LARGE.jpg", "https://cdn.instructables.com/FLS/RK1Y/IR3ZSXZM/FLSRK1YIR3ZSXZM.LARGE.jpg", "https://cdn.instructables.com/FSM/B3TN/IR3ZSXZN/FSMB3TNIR3ZSXZN.LARGE.jpg"], "step_title": "Step 4: Look-Up Table Initialization File"}, {"step": 5, "steps_text": "Now for the fancy part. Create a new block design using the Flow Navigator under IP Integrator. Ensure that Design Name contains no spaces, that Directory is  and that the source set is Design Sources.With this block design created we can now draw our project design. Right click within the Diagram, and select \"Add Module\". This is a new feature to Vivado 2016.2, and lets us convert any sources we may have written into IP Cores automatically. We can add a module by just selecting it from the list of sources that pops up, and clicking OK. Use this method to add two counters and a lookup table. We should now connect these blocks together, and to input and output ports. Select one of the clk pins on one of the three blocks, and select Make External. You can now draw connections from each of the other clock pins to the new clock port. Do the same for the rst pins, so that each are tied to the same input. Tie the enable pin of counter_1 to the terminal count pin of the counter_0, and counter_1's data bus to the address bus of the lookup table. Make the lookup table's data bus external. Lastly, add a constant block, using \"Add IP\" and searching for \"constant\". Tie this constant block's output to the enable input of the counter_0. This constant block will ensure that counter_0 will always be runningNow that the design is drawn out, we need to go in and edit each block's parameters. This can be done by double clicking on the block in question, or right clicking the block, and selecting \"Customize Block\". We will be using the default values for the counter_1 data width and maximum count, and both the lookup table data width and address width. The maximum count for counter_0 depends on which board you are using. Since we are targeting 1KHz for the full sequence of counter_1, which only counts when counter_0 finishes its own sequence, we should use the following formula to determine our maximum count:T_c0 = f_base_clk / (f_target * T_c1)For the Digilent Zybo, our base clock frequency is 125MHz - a value which can be found in the board's reference manual on the Digilent Wiki, and which will likely be different for other FPGA boards - so with a target frequency of 1KHz and a lookup table size of 256 addresses, we get a counter_0 period of 488.28 clock cycles per address increment. Since this needs to be an integer, and our counter resets to zero, we will round down to get a maximum count of 488. To get counter_0's data width, we can to take the log base 2 of the maximum and round it up, telling us we need at least 9 bits to properly represent every value in the range 0 to 488. Customize counter_0 to fill in these values. Lastly, make sure that the constant block controlling counter_0's enable pin has width 1 and value 1.", "step_imgs": ["https://cdn.instructables.com/FFW/LFOU/IR3ZSWBY/FFWLFOUIR3ZSWBY.LARGE.jpg", "https://cdn.instructables.com/FO5/PPGL/IR3ZSWCW/FO5PPGLIR3ZSWCW.LARGE.jpg", "https://cdn.instructables.com/FC8/NCMS/IR3ZSWCX/FC8NCMSIR3ZSWCX.LARGE.jpg", "https://cdn.instructables.com/F0L/ZLRF/IR3ZSWDM/F0LZLRFIR3ZSWDM.LARGE.jpg", "https://cdn.instructables.com/FY0/5ZG6/IR3ZSWFI/FY05ZG6IR3ZSWFI.LARGE.jpg", "https://cdn.instructables.com/FV5/2M0H/IR3ZSWFK/FV52M0HIR3ZSWFK.LARGE.jpg", "https://cdn.instructables.com/FLB/L7UB/IR3ZSWFL/FLBL7UBIR3ZSWFL.LARGE.jpg", "https://cdn.instructables.com/FP0/16GQ/IR3ZSWFS/FP016GQIR3ZSWFS.LARGE.jpg", "https://cdn.instructables.com/FFY/XJUJ/IR3ZSWGX/FFYXJUJIR3ZSWGX.LARGE.jpg", "https://cdn.instructables.com/F8U/Q5YD/IR3ZSWH0/F8UQ5YDIR3ZSWH0.LARGE.jpg", "https://cdn.instructables.com/FAR/PQQZ/IR3ZSWHA/FARPQQZIR3ZSWHA.LARGE.jpg", "https://cdn.instructables.com/FSJ/MCA7/IR3ZSWHG/FSJMCA7IR3ZSWHG.LARGE.jpg", "https://cdn.instructables.com/F96/SXC9/IR3ZSWHH/F96SXC9IR3ZSWHH.LARGE.jpg", "https://cdn.instructables.com/FVZ/G7NJ/IR3ZSWHO/FVZG7NJIR3ZSWHO.LARGE.jpg", "https://cdn.instructables.com/F3B/O3KK/IR3ZSWHR/F3BO3KKIR3ZSWHR.LARGE.jpg", "https://cdn.instructables.com/FIJ/0VMK/IR3ZSWI2/FIJ0VMKIR3ZSWI2.LARGE.jpg"], "step_title": "Step 5: The Block Design"}, {"step": 6, "steps_text": "In order for Vivado to understand how our designs input and output ports are connected to the input and output pins of the boards FPGA, we need to add an XDC (Xilinx Design Constraint) file to our project. The easiest way to do this is to find and download the Master XDC for your board. The wiki page for your board on the Digilent Wiki should contain a link to this file on the sidebar under Design Resources. This file can be included in your project in the same way as adding a design source. Follow these steps:Right click on Constraints in the Sources subwindow. Select \"Add Sources\".Make sure \"Add or create constraints\" is selected. Click Next.Click \"Add Files\", navigate to your Master XDC, select it, and click Open.Click Finish.Once downloaded and included in your project, several changes will need to be made to this XDC file. Start by uncommenting the system clock signal, one button, and all eight signals for one of the Pmod headers. The system clock should be the first signal declared at the top of the file, while the others can be found using Finds (Ctrl-F) for \"btn\" and \"pmod\". If your board has a dedicated reset button (for example, \"cpu_resetn\" on the Nexys Video), use that instead of one of the normal buttons. As for the Pmod header, choose any that isn't intended for input to an onboard XADC. For each of these signals, replace the name in the get_ports call with the name you used in the Block Design, clk, rst, and data, while leaving the bus index alone.", "step_imgs": ["https://cdn.instructables.com/FWB/SZDB/IR3ZSW0X/FWBSZDBIR3ZSW0X.LARGE.jpg", "https://cdn.instructables.com/F3G/EBI0/IR3ZSW13/F3GEBI0IR3ZSW13.LARGE.jpg", "https://cdn.instructables.com/FEQ/PAID/IR3ZSW14/FEQPAIDIR3ZSW14.LARGE.jpg", "https://cdn.instructables.com/FSU/R21K/IR3ZSW1A/FSUR21KIR3ZSW1A.LARGE.jpg", "https://cdn.instructables.com/FBO/TYDG/IR3ZSW1F/FBOTYDGIR3ZSW1F.LARGE.jpg", "https://cdn.instructables.com/FCV/5MRV/IR3ZSW29/FCV5MRVIR3ZSW29.LARGE.jpg", "https://cdn.instructables.com/F7D/TA6A/IR3ZSW3T/F7DTA6AIR3ZSW3T.LARGE.jpg"], "step_title": "Step 6: Adding an XDC"}, {"step": 7, "steps_text": "In order to generate the .bit file required for programming your Digilent FPGA board, follow the following steps:In your block design, press F6 or right click anywhere and select \"Validate Design\". The design should pass validation with no errors if everything was done correctly.Under the Sources subwindow, select Sources from the tab menu. Right click on your block design and select \"Create HDL Wrapper\". Make sure the \"Let Vivado manage...\" option is selected and click OK.Make sure your new wrapper -- under Design Sources -- is bold in the sources window, if not, right click it and select \"Set as Top\".In the Flow Navigator, select \"Generate Bitstream\" under \"Program and Debug\". Select Yes when asked whether to launch synthesis and implementation.Vivado will now automatically generate the file used to program your FPGA. It might take a while, but once done, a window called \"Bitstream Generation Completed\" will pop up. Select \"Open Hardware Manager\" and move on to Step 8.", "step_imgs": ["https://cdn.instructables.com/F9A/1E1O/IR3ZSV4B/F9A1E1OIR3ZSV4B.LARGE.jpg", "https://cdn.instructables.com/FMR/0RJN/IR3ZSV4C/FMR0RJNIR3ZSV4C.LARGE.jpg", "https://cdn.instructables.com/F0U/2WMI/IR3ZSV5H/F0U2WMIIR3ZSV5H.LARGE.jpg", "https://cdn.instructables.com/FED/XEFF/IR3ZSV6L/FEDXEFFIR3ZSV6L.LARGE.jpg", "https://cdn.instructables.com/FJ7/8ESK/IR3ZSV6X/FJ78ESKIR3ZSV6X.LARGE.jpg", "https://cdn.instructables.com/FCP/TZ2U/IR3ZSV7Z/FCPTZ2UIR3ZSV7Z.LARGE.jpg", "https://cdn.instructables.com/FTZ/XCXB/IR3ZSV9Z/FTZXCXBIR3ZSV9Z.LARGE.jpg", "https://cdn.instructables.com/F0H/PQ3M/IR3ZSVB2/F0HPQ3MIR3ZSVB2.LARGE.jpg"], "step_title": "Step 7: Generating the Bit File"}, {"step": 8, "steps_text": "The Digilent Wiki has tutorials for most FPGA boards for how to program a bit file in a variety of ways. The following is going to be the easiest for seeing if our application works. In order to use Vivado's Hardware Manager to program your FPGA, follow these steps:Plug your board's programming port into a USB port of your PC.Attach your PmodR2R to whichever Pmod port you tied the lookup table data lines to in your XDC file. In the provided project for Zybo, this is the JE header.Power your board on, if necessary.In the Vivado hardware Manager, clock \"Open Target\" and \"Auto Connect\".Click \"Program Device\" and then then the device number that pops up.Ensure that the project's bitstream file is selected in the Program Device window. If not, click the \"...\" to the right of that field, navigate to and select /proj/.runs/impl_1/.bit.Click Program.In order to confirm that the project is now working, you can first check status LEDs to see if your board was programmed, then plug your Digilent Analog Discovery (or other oscilloscope) channel one ports into the R2R output ports. I used a six pin male to male connector snapped down to two pins for this, but a couple of small wires will work equally well. Watch the pretty sine wave go!", "step_imgs": ["https://cdn.instructables.com/FH2/6D2X/IR3ZST8U/FH26D2XIR3ZST8U.LARGE.jpg", "https://cdn.instructables.com/F37/0JDC/IR3ZST8Z/F370JDCIR3ZST8Z.LARGE.jpg", "https://cdn.instructables.com/FT4/JD66/IR3ZST9V/FT4JD66IR3ZST9V.LARGE.jpg", "https://cdn.instructables.com/FC7/POUK/IR3ZSTCT/FC7POUKIR3ZSTCT.LARGE.jpg", "https://cdn.instructables.com/F6L/WMM2/IR3ZSTKD/F6LWMM2IR3ZSTKD.LARGE.jpg"], "step_title": "Step 8: Programming the FPGA and Verifying Results"}, {"step": 9, "steps_text": "The following is a list of potential extensions of this project:Adding support for higher frequency waves, even up to the audio range, to control an analog speaker.Adding support for frequency selection, through switch inputs, a lookup table, and making the counter maximum parameter an input bus.Modifying the Python script to generate different types of waves, potentially including smaller amplitudes.Adding several lookup tables with differently shaped wave forms, with data buses multiplexed into the output bus.Adding a processor to the project in order to allow more complex control algorithms (might be able to use an AXI GPIO IP core to provide a simple interface to custom logic).Each of these ideas come with necessary complications, but could make for interesting projects.The \"Add Module\" feature is also very interesting, as it makes it much easier to translate from a functional description to a working prototype. A block diagram makes it much easier to comprehend what a design is actually doing than attempting to understand the same design written in Verilog or VHDL.", "step_imgs": [], "step_title": "Step 9: Additional Applications"}], "channel": "Electronics"}, {"category": "technology", "description": "If you've looked into driving RGB LED strips from your raspberry pi, you may have found it to be more effort than you were willing to put in to it.  Either you had to build a driver from scratch with transistors, or you needed to modify the circuitry of a mini amplifier to make sure it didn't blow up your Pi.Well, now you don't have to - there's a plug and play solution, thanks to a fortuitous discovery about a particular model of RGB LED amplifier.This is the kind you DON'T want: very cheap, highly tempting mini amplifiers, such as https://www.amazon.com/FAVOLCANO-Amplifier-Control...They have a fatal flaw - the +12V input pin is connected to the +12V output pin.  Connect it to your Pi and you'll blow up the Pi.This is the kind you DO want: slightly more expensive and larger: https://www.amazon.com/TSSS-Repeater-Signal-Amplif...  (Cost - $5.75!)These ones do NOT connect the input and output 12V pins and are safe to drive directly from the +5V pin on the Pi and the GPIO output pins.  (Though just to be sure in case there's ever a new design using the same packaging, check that for yourself with an Ohm meter)", "title": "Easiest RGB LED Strip With Raspberry Pi!", "url": "https://www.instructables.com/id/Easiest-RGB-LED-Strip-With-Raspberry-Pi/", "section": "technology", "steps": [{"step": 1, "steps_text": "Connect the +5V pin of your Pi to the +12V input of the amp with a male-female jumper lead.Connect 3 GPIO pins (GPIO 4,5,6 are a good choice) to the R, G & B inputs of the amp with three male-female jumper leads.The amp will come with two short connectors for the LED strips.  Use one to connect to your LED strip. They'll have color-coded wires - red, green and blue plus one other for the power line.  (Black, in my case)", "step_imgs": ["https://cdn.instructables.com/FN0/AY3F/IZYGHJ3W/FN0AY3FIZYGHJ3W.LARGE.jpg", "https://cdn.instructables.com/FBI/UFY3/IZYGHJ9N/FBIUFY3IZYGHJ9N.LARGE.jpg", "https://cdn.instructables.com/F4R/5OIN/IZYGHJ8Y/F4R5OINIZYGHJ8Y.LARGE.jpg"], "step_title": "Step 1: Connecting Is Trivial!"}, {"step": 2, "steps_text": "You will need the \"pigpiod\" system on your pi in order to take advantage of software PWM so that you can drive the LED strips at different intensities.  \"sudo apt-get install pigpiod\" if it isn't already installed.Go to https://www.raspberrypi.org/forums/viewtopic.php?f... to see how to configure your Pi so that pigpiod starts when you power up.Here's a shell script that will let you set the LED strip to an arbitrary color:#!/bin/bash\nif [[ \"$1\" == \"on\" ]] ; then\n  pigs pwm 23 0 pwm 24 0 pwm 25 0\nelse\n  if [[ \"$1\" == \"off\" ]] ; then\n    pigs pwm 23 255 pwm 24 255 pwm 25 255\n  else\n    # trying to compensate for eye's log response to brightness\n#   tmpR=`echo 'scale=4; (e(l(2) * (((100 - '$1') * 8) / 100))-0.01)' | bc -l`\n#   tmpG=`echo 'scale=4; (e(l(2) * (((100 - '$2') * 8) / 100))-0.01)' | bc -l`\n#   tmpB=`echo 'scale=4; (e(l(2) * (((100 - '$3') * 8) / 100))-0.01)' | bc -l`\n\n    # but simple linear seems to work better :-(\n    tmpR=`echo 'scale=4; ((100-'$1')*255/100)' | bc -l`\n    tmpG=`echo 'scale=4; ((100-'$2')*255/100)' | bc -l`\n    tmpB=`echo 'scale=4; ((100-'$3')*255/100)' | bc -l`\n\n    # convert to integer\n    tmpR=`echo 'scale=0; ('$tmpR'/1)' | bc -l`\n    tmpG=`echo 'scale=0; ('$tmpG'/1)' | bc -l`\n    tmpB=`echo 'scale=0; ('$tmpB'/1)' | bc -l`\n\n    # echo \"RGB: \"$tmpR $tmpG $tmpB\n    pigs pwm 23 $tmpR pwm 24 $tmpG pwm 25 $tmpB\n  fi\nfi\nCall it \"ledstrip\" and use it like this:  ledstrip 50 50 0The 3 parameters are the values of R, G & B in a range of 0 to 100.That's it.  Easiest LED strip project ever!", "step_imgs": ["https://cdn.instructables.com/FIX/3DEW/IZYGHJ2U/FIX3DEWIZYGHJ2U.LARGE.jpg"], "step_title": "Step 2: Now Test It..."}], "channel": "LEDs"}, {"category": "technology", "description": "this program is to calculate frequency transform on arduino with batter control over parameters.it is solved using desecrate fouriior transform. this is not FFT . FFT is algorithm used to solve DFT with smaller time.", "title": "Arduino: Frequency Transform (DFT)", "url": "https://www.instructables.com/id/Arduino-Frequency-Transform-DFT/", "section": "technology", "steps": [{"step": 1, "steps_text": "Given program for frequency transform provides great control over output you required. this program evaluates  frequency range given by user at given input for data-set. In figure a data set made of two frequencies named f2 and f5 given which need to be tested. f2 and f5 are random names for two frequency, higher number for relatively higher frequency. here smaller frequency f2 has higher amplitude and f5 has smaller amplitude. It can be shown mathematically that -summation of multiplication of two harmonic data-set having different frequency tends to zero(higher number of data can lead to batter result). In our case If these two multiplication frequency has same (or very close) frequency that sum of multiplication is nonzero number where amplitude depends on amplitude of data.to detect specific frequency given data-set can be multiplied by various test frequencies and result can give component of that frequency in data.", "step_imgs": ["https://cdn.instructables.com/FJA/9DU9/IRTDSFSS/FJA9DU9IRTDSFSS.LARGE.jpg", "https://cdn.instructables.com/FH5/BLKE/IRTDSFT3/FH5BLKEIRTDSFT3.LARGE.jpg"], "step_title": "Step 1: How It Works(concept):"}, {"step": 2, "steps_text": "for that given data (f2+f5) one by one f1 to f6 is multiplies and value of sum is noted down. that final sum represents content of that frequency. rest (non-matching) of frequency should be ideally zero but it is not possible in real case. to make sum zero it is required to have infinite size of data-sets.as can be shown in figure f1 to f6 trial frequency and its multiplication with data set at every point is shown. in second figure summation of that multiplication at each frequency is plotted. two peaks at 1 and 5 is identifiable.so using same approach for a random data we can evaluate for so many frequency and analyze frequency content of data.", "step_imgs": ["https://cdn.instructables.com/FEI/7SPZ/IRTK24BE/FEI7SPZIRTK24BE.LARGE.jpg", "https://cdn.instructables.com/FMR/HODT/IRTK24BH/FMRHODTIRTK24BH.LARGE.jpg"], "step_title": "Step 2: How It Works(in Code):"}, {"step": 3, "steps_text": "for an example lets use this code to find DFT of square wave.first paste attached code(dft function) after loop as shown image.8 TERMS THAT NEEDS TO BE SPECIFY an array of which dft need to be taken   size of an array   time interval between 2 reading in array in milliSECONDS   lower value of frequency range in Hz   upper value of frequency range in Hz   size of steps for frequency range   repeatation of a signal(minimum 1) higher number batter accuracy but increased solution time  window function:0 for no window1 for flat-top window 2 for hann window 3 for hamming window (if you do not have any idea about selecting window keep default 3)  example:       dft(a,8,0.5,0,30,0.5,10,3);       here a is an array of size 8 element to be checked for 0 Hz to 30 Hz with 0.5 step (0,0.5,1,1.5, ... ,29,29.5,30)       10 repeatation and hamming windowhere it is possible to use bigger sized array as much as arduino can handle.", "step_imgs": ["https://cdn.instructables.com/F7L/ANCH/IRTK266Z/F7LANCHIRTK266Z.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Using Code for Frequency Analysing:"}, {"step": 4, "steps_text": "if you comment out  Serial.print(f);Serial.print(\"\\t\");from code serial plotter will give nature of frequency spectrum an if not Serial monitor would give frequency with its amplitude.", "step_imgs": ["https://cdn.instructables.com/F0B/KNJ6/IRU3FIQS/F0BKNJ6IRU3FIQS.LARGE.jpg", "https://cdn.instructables.com/F0R/0A3Z/IRU3FIV6/F0R0A3ZIRU3FIV6.LARGE.jpg"], "step_title": "Step 4: Output:"}, {"step": 5, "steps_text": "in figure, frequency of sine wave is measured using different setting.", "step_imgs": ["https://cdn.instructables.com/FNU/G3R9/IRU3FJ64/FNUG3R9IRU3FJ64.LARGE.jpg"], "step_title": "Step 5: Checking Various Window and Sample Sizes:"}, {"step": 6, "steps_text": "in figure transform of data using SciLab and arduino is compared.", "step_imgs": ["https://cdn.instructables.com/F7H/HATX/IRUG9FUQ/F7HHATXIRUG9FUQ.LARGE.jpg"], "step_title": "Step 6: Example:"}], "channel": "Arduino"}, {"category": "technology", "description": "This instructable describes in detail the steps required to create an Arduino-based ECG simulator. An ECG simulator replicates the cardiac waveform that can be measured by attaching three electrodes (RA, LA, RL) to the patient's chest. This ECG signal is only a few millivolts in amplitude. The finished project is shown in the first photograph below.\nThe project was built using an Adafruit Menta kit plus a few additional parts. The Menta kit includes a Arduino ATMega328P microprocessor with 32K of Flash memory and 2K of RAM memory plus an Altoids-type metal case which has enough room to fit a small numeric display, a potentiometer to adjust the heart rate, and three banana receptacles for the patient leads.\nThe waveform was created by first doing a screen capture of a suitable waveform image from the Internet. This picture file was then digitized using the open source Engauge program from Sourceforge. The resulting text file was further processed by a custom Python program that used linear interpolation to space the samples 1.0 millisecond apart followed by formatting the digitized table into a C Language array construct that could be pasted into the Arduino sketch.\nTo output an analog waveform on the Arduino Menta, an inexpensive Microchip 12-bit digital-to-analog converter was soldered to the Menta prototyping area. A simple resistive voltage divider was employed to attenuate the D/A signal to the required millivolt levels.\nThe resulting signal from the Adafruit Menta was then connected to a Texas Instruments ADS1293EVM Evaluation Module which itself demonstrates the operation of their ADS1293 ECG front-end chip (a single integrated circuit that implements all the signal processing normally found in the front end of an ECG heart monitor).\nThe TI software that shipped with the Demonstration Kit was used to display the incoming ECG signal from the ECG simulator which agreed closely with the shape and amplitude of the ECG waveform captured from the Internet document.\nWhile this project was directed solely at generating an ECG signal, the methodology could be used to create just about any waveform you can draw or extract from a document!\nThe project also shows just how useful the Adafruit Menta kit can be when used as a starting point for a custom, one-off embedded micro-controller design. I needed an ECG simulator and was able to build it for about $60 in parts.\nIf you would like to view the full tutorial (pdf) of the project, which goes into much more detail about the techniques and procedures used to replicate the ECG waveform, click on this link:https://github.com/lynchzilla/ECG_Simulator_Documents\nThis will bring up the summary GitHub repository (second figure above) which has only the detailed tutorial (pdf) and the Arduino sketch (ino). Just click on the ZIP button to download these two files (about 136 megabytes).\nIf you would like to have everything about the project including the Libra Office document and all drawings, click on the following link (about 242 megabytes):https://github.com/lynchzilla/ecg_simulator\u00a0", "title": "ECG Simulator", "url": "https://www.instructables.com/id/ECG-Simulator/", "section": "technology", "steps": [{"step": 1, "steps_text": "Twenty six years ago, I was in charge of of software development for the world's first color heart monitor, the Mennen Medical Horizon 2000. The CRT display for this instrument was the first to make use of color for alarm conditions, alerts, and so forth.\nThe Horizon 2000 patient monitor had two Motorola 68000 microprocessor circuit boards, one for signal collection and one for the\ngraphics display and soft-menu system. I wrote the software for the signal collection board and my astute and industrious office mate, Linda, wrote the software for the board supporting the menus and displays. In a design feature rarely seen today, the 68000 boards communicated via a shared, arbitrated dual-port RAM memory.\nWhile developing software for the heart monitor, one indispensable tool I used was a \u201cECG simulator\u201d. This was a device that created a reasonable facsimile of an ECG signal (that waveform you see on all medical shows). These units were usually battery-powered and the heart monitor's ECG leads were connected to the simulator rather than a patient (or yourself).\nThese ECG simulators can be bought on Ebay for a couple hundred dollars. An ECG simulator can be very sophisticated, displaying not only the standard \u201cnormal sinus rhythm ECG\u201d but the abnormal waveforms as well (arrhythmia,\ntachycardia, and so forth).", "step_imgs": ["https://cdn.instructables.com/F24/WMNZ/HD4VLVDP/F24WMNZHD4VLVDP.LARGE.jpg", "https://cdn.instructables.com/FFE/2MUL/HD4VLVDF/FFE2MULHD4VLVDF.LARGE.jpg"], "step_title": "Step 1: Background"}, {"step": 2, "steps_text": "As I near retirement, I'm interested in building a heart monitor for myself, you know all DIY and open source. These days you can get the entire analog front-end for an ECG monitor as an inexpensive integrated circuit from Texas Instruments. The ADS1293 device supports four ECG leads and does all the A/D conversion and signal processing. You can communicate through a simple SPI interface and this should make it straightforward to \u201cisolate\u201d the ADS1293 from the rest of the heart monitor using, for example, Analog Devices transformer-based digital isolators.\nTo learn all about the TI ADS1293 ECG front-end chip, I purchased a $99 evaluation board from TI. The ECG leads are wired through a 9-pin D-connector and a USB cable connects this board to the PC and TI supplies a sophisticated Windows application that lets you modify all the chip's control registers, view the signals, and so forth. The first step in learning about any sophisticated chip is to get a data sheet and an evaluation board.", "step_imgs": ["https://cdn.instructables.com/FTZ/GNIJ/HD4VLVHD/FTZGNIJHD4VLVHD.LARGE.jpg"], "step_title": "Step 2: TI ADS1293 Single Chip Heart Monitor"}, {"step": 3, "steps_text": "Now we get to the heart of the matter; to use this TI evaluation board there must be an ECG signal.\nWhy not just hook yourself up with some ECG leads and those conductive pads they use in hospitals? First, Texas Instruments would totally freak out since there are no protection circuits on this evaluation board. By this I mean the isolation circuitry, the Zener diodes, the neon-lamps, current-limiting resistors normally used to protect the patient are not present on this board. Second,\nsuch a scheme would be cumbersome and inconvenient.\nObviously I could buy a used ECG simulator, but that wouldn't be any fun. How about building one from scratch?\nI looked at possible solution platforms and a nice starting point is Adafruit's Menta kit. The Menta is a Arduino board with an Atmel\nATMega328P 8-bit microprocessor with 32k of Flash memory and 2k of RAM. Notice that Lady Ada designed it to fit into a metal Altoids-style case.\nUnfortunately the ATMega328P does not have a D/A (digital-to-analog) converter which will be needed to generate the analog ECG waveform. The Menta with the case is $35.00, delivered as a kit.\nLooking at the Menta and applying a little arm chair engineering, we'll need to fit three banana receptacles on the top to attach the three ECG leads, a pot with a knob to adjust the heart rate, and a small 4-digit 7-segment numeric display to show the dialed-in heart rate.\nThe Menta has a breadboard area which can be used to fit a small D/A converter chip. A resistor voltage divider network will attenuate the 5 volt ECG signal from the D/A converter down to a couple of millivolts, which is the amplitude of a human ECG signal detected via chest electrodes.\nThe Menta can be powered via a cheap 9-volt Wall Wart using the power connector on the left.\nProgramming is accomplished using an inexpensive FTDI Friend board ($14.75 from Adafruit) using your computer's USB port. Becky Stern, an Adafruit employee and New York City artist, has a very nice introductory video about the Menta here:http://www.youtube.com/watch?v=opuD2h4puSk&feature=player_embedded", "step_imgs": ["https://cdn.instructables.com/FL1/O4YN/HD4VLVI4/FL1O4YNHD4VLVI4.LARGE.jpg"], "step_title": "Step 3: Need a ECG Simulator"}, {"step": 4, "steps_text": "A block diagram showing the basic components of the Menta ECG Simulator is shown here:", "step_imgs": ["https://cdn.instructables.com/FXD/EUA9/HD4VLVJD/FXDEUA9HD4VLVJD.LARGE.jpg"], "step_title": "Step 4: Block Diagram of Adafruit Menta ECG Simulator"}, {"step": 5, "steps_text": "The $35.00 Adafruit Menta is a kit that you must assemble. In the spirit of and even better than Heathkit, Adafruit has a detailed tutorial on their web site that shows how to assemble the Menta. In my case, it took less than an hour to solder the kit together.\nI actually bought two kits, one for the ECG Simulator and one for bread boarding (where I fitted the headers for the I/O ports).\nFor the D/A converter, I selected the Microchip MCP4921 single channel D/A chip, which communicates via the SPI interface. The\nresolution of the MCP4921 is 12-bits; it takes two sequential SPI 8-bit transmissions to send the 12 bits plus four configuration bits.\nThe D/A converter will operate at a rate of 1000 updates per second, or in other words 1.0 millisecond per sample. The D/A signal will be updated as part of an on-board Timer2 interrupt handler. The execution time to update the D/A via the SPI interface is only 63 microseconds (author's measurement).\nNot long after I acquired the Microchip D/A chip, Adafruit offered a dual channel D/A device on a breakout board for $4.95. I'm sure that this device would be also perfect for this application. The Microchip MCP4921 can be ordered from Digikey for $2.36. The pin layout for the MCP4921 is given below.\nFor the 4 digit heart rate display, I considered three possible solutions. In the photograph, the top device is the Adafruit 0.56\" 4-Digit 7-Segment Display w/I2C Backpack for $9.95. This display's onboard controller makes it easy to communicate via SPI and the numbers are large and bright. However, you can see from the figure that it's a bit too big for the Menta cover.\nThe middle device is the Adafruit Monochrome 1.3\" 128x64 OLED graphic display for $24.50. It's small and thin and the interface is SPI so it looked like a good choice. It proved unsuitable because the interface is write-only so you can't read back the internal graphic RAM. This means that Adafruit's software driver had to maintain a complete copy of the display's graphic RAM on the ATMega328P chip. Worse yet, the driver Adafruit prepared writes the entire graphic RAM for any command, even if you only wanted to change one pixel. I measured the execution time to update the entire graphic RAM and it was longer than the expected D/A sample period of 1.00 msec. Reluctantly I set this one aside for future projects.\nThe bottom display device is the Sparkfun COM-09764 7-Segment Serial Display \u2013 Blue for $12.95. It also has a controller that makes it work with a simple SPI interface. Note that the size looks appropriate for the Menta cover, so the Sparkfun display was best for this project.\nFor the pot to adjust the heart rate, I found the typical pot available from Radio Shack (and Adafruit) to be too thick for the Menta case. Searching the Jameco catalog, I found a pot intended for circuit board mounting that is somewhat thinner.\nThe Jameco pot is the bottom one in the picture. This is the Panel Control - 22MM-ST-CP 3 (part number: 1998141) for $3.39. The metal clip can be popped off to give a much thinner profile (this is a 5k pot).\nI also purchased a knob from Jameco, this is Knob \u00bc\" Shaft, Metal, Round, Silver for $0.99 (part number: 162481).\nThe banana receptacles, resistors, and capacitors are stock items at Radio Shack.", "step_imgs": ["https://cdn.instructables.com/FAD/OCB8/HD4VLVJT/FADOCB8HD4VLVJT.LARGE.jpg", "https://cdn.instructables.com/FOB/MKW4/HD4VLVK1/FOBMKW4HD4VLVK1.LARGE.jpg", "https://cdn.instructables.com/FZM/B06L/HD4VLVK7/FZMB06LHD4VLVK7.LARGE.jpg"], "step_title": "Step 5: Acquiring the Parts"}, {"step": 6, "steps_text": "Here is the bill of materials for the ECG Simulator project.", "step_imgs": ["https://cdn.instructables.com/FJ1/B65D/HD4VLVLB/FJ1B65DHD4VLVLB.LARGE.jpg"], "step_title": "Step 6: Bill of Materials"}, {"step": 7, "steps_text": "Below is the final schematic for the Menta ECG Simulator project. LadyAda's Eagle schematic for the Menta was used as a starting point and I simply added the parts required to complete the project. I did not attempt to make a custom circuit board from this schematic since the intent is to simply solder the D/A converter, etc. directly to the breadboard area of the Menta", "step_imgs": ["https://cdn.instructables.com/FOD/BWGO/HD4VLVMB/FODBWGOHD4VLVMB.LARGE.jpg"], "step_title": "Step 7: ECG Simulator Schematic"}, {"step": 8, "steps_text": "The figure below shows the wiring of the Menta ECG Simulator. All wiring is routed on the top (component) side of the Menta circuit board and most soldering is on the bottom side of the board. Solder joints are identified as small black circles. I elected to simply solder the MCP-4921 D/A converter chip directly to the board, but one could easily substitute an 8-pin IC socket instead.", "step_imgs": ["https://cdn.instructables.com/FNG/SM42/HD4VLVMW/FNGSM42HD4VLVMW.LARGE.jpg"], "step_title": "Step 8: Menta ECG Simulator Wiring Diagram"}, {"step": 9, "steps_text": "The figure below shows the completed ECG Simulator prior to installation into the Altoids case.\nI added a couple of stake pins for ground and the output of the D/A converter so operation could be verified with an oscilloscope. Since the banana jacks for the ECG leads have to be bolted onto the case, they can't be soldered to the green outputs from the voltage divider at this point.\nThe Adafruit Menta is specifically designed for the type of build you see here. The I/O ports and power/ground access points are all doubled up, all holes are plated-through, and all pads are tinned for easy soldering. If you can build a circuit with a breadboard, you can build a one-off prototype with the Adafruit Menta!", "step_imgs": ["https://cdn.instructables.com/FNV/D3OP/HD4VLVPT/FNVD3OPHD4VLVPT.LARGE.jpg"], "step_title": "Step 9: Wiring the Menta ECG Simulator Board"}, {"step": 10, "steps_text": "Rather than trying to measure and locate the circuit board mounting holes on the bottom of the Altoids metal case, it's a lot easier to drop the Menta board into the case and use a center punch to mark the holes, as shown below. A center punch uses a spring-loaded pin to dimple the metal surface and thus provides a good starting point for a drill bit.\nThe next photo below shows the dimples created by the center punch's spring-loaded pin driver, ready for the\ndrill press.\nNow the circuit board holes can be drilled with a desk-top drill press. The Adafruit Menta holes measured 7/64\u201d diameter so a 1/8\u201d drill bit seemed suitable. The next photo shows the drill press in action. The resulting holes on the bottom side of the Altoids tin have ragged \u201cburrs\u201d after drilling so these can be ground down using a Dremel MotoTool with a flat grinding wheel.\nThe final photograph below shows the completed circuit board mounting holes.", "step_imgs": ["https://cdn.instructables.com/FHM/XSC3/HD8Z1BDL/FHMXSC3HD8Z1BDL.LARGE.jpg", "https://cdn.instructables.com/FOF/KSBB/HD8Z1BDN/FOFKSBBHD8Z1BDN.LARGE.jpg", "https://cdn.instructables.com/FLO/QXD4/HD8Z1BDO/FLOQXD4HD8Z1BDO.LARGE.jpg", "https://cdn.instructables.com/FE6/S1G4/HD8Z1BDP/FE6S1G4HD8Z1BDP.LARGE.jpg", "https://cdn.instructables.com/FV8/MNEJ/HD8Z1BDQ/FV8MNEJHD8Z1BDQ.LARGE.jpg"], "step_title": "Step 10: Drilling the Menta Mounting Holes"}, {"step": 11, "steps_text": "Phil at Jumper One created an excellent tutorial\u00a0 concerning making nice front panels at home.http://jumperone.com/2013/01/how-to-make-diy-front-panel/\nBased on Phil's suggestions, the first thing to do is design a front panel layout that locates all the holes, etc. A good drawing tool to use is Inkscape, an open source and free vector-based drawing system. Inkscape can be downloaded from here:http://www.inkscape.org/download/\nI purchased \u201cThe Book of Inkscape\u201d by Dmitry Kirsanof (one of the current developers of Inkscape) and spent a couple of days learning just enough to create some pretty fancy drawings. The photo below illustrates an Inkscape-created stick-on label for the front panel.\nThe second photo below shows a dimensional drilling diagram of the front panel (the top cover of the Altoids tin) which locates the holes for the banana jacks, potentiometer, and the 7-segment display cut-out. The design takes into account the underneath sizes of the banana jacks, display, and potentiometer so that these parts don't interfere with each other (the underneath outlines are shown as dashed lines).", "step_imgs": ["https://cdn.instructables.com/FTA/PDCU/HCV9CKT1/FTAPDCUHCV9CKT1.LARGE.jpg", "https://cdn.instructables.com/FP8/40WZ/HCV984LM/FP840WZHCV984LM.LARGE.jpg"], "step_title": "Step 11: Design the Front Panel"}, {"step": 12, "steps_text": "Print out the front panel label on ordinary printing paper. Cut out the outline with scissors, then use a hobbyist razor knife and a straight edge to cut out the rectangular hole for the 7-segment display.\nUsing masking tape, carefully affix the drilling template to the Altoids case front cover as shown in the first photo below. Using a \u201cmagic marker and a straight edge, outline the 7-segment display rectangle as shown in first photo. As illustrated in the second photo, center punch the three banana jack holes, the rate potentiometer hole, and a hole in the center of the 7-segment display rectangle (for an opening to get the nibbling tool started). This will be used to \u201cnibble\u201d the rectangular outline for the display. The third photo shows the Altoids front cover ready for drilling and nibbling.\nWhile these holes can be drilled with a hand-held electric drill, a desk-top drill press is more suitable for this task. The fourth photo shows a banana jack hole being drilled. A large hole (11/32\u201d) should be drilled in the center of the 7-segment display rectangle to serve as an entry point for the Radio Shack nibbling tool (shown in the fifth photo).\nStep drills, as shown in the sixth photo, are extremely useful in widening holes and removing burrs. These can be acquired from\nAmazon or eBay. Normally they don't need a pilot hole if a spring-loaded center punch is used to locate the hole. The ones the author procured have \u201cflats\u201d on the shaft that eliminate drill chuck slippage.\nThe Radio Shack nibbler tool, shown earlier, chops a tiny 7/32\u201d x 1/16\u201d rectangular bite out of the metal it is cutting. Basically you insert the cutting tip down into the pilot hole and start nibbling away as shown inin the seventh photo. If you are careful, a fairly decent cut can be achieved. I cleaned up the final cut with a flat file and then ensured that the 7-segment display will fit tightly through the opening. The finished product is shown in the eighth photo below.", "step_imgs": ["https://cdn.instructables.com/FJG/32Z1/HD8Z1BIC/FJG32Z1HD8Z1BIC.LARGE.jpg", "https://cdn.instructables.com/FEG/OALB/HD8Z1BID/FEGOALBHD8Z1BID.LARGE.jpg", "https://cdn.instructables.com/F6E/YGY8/HD8Z1BIE/F6EYGY8HD8Z1BIE.LARGE.jpg", "https://cdn.instructables.com/FOD/7SXB/HD8Z1BIF/FOD7SXBHD8Z1BIF.LARGE.jpg", "https://cdn.instructables.com/FNS/U0Q4/HD8Z1BIH/FNSU0Q4HD8Z1BIH.LARGE.jpg", "https://cdn.instructables.com/FGW/J835/HD8Z1BII/FGWJ835HD8Z1BII.LARGE.jpg", "https://cdn.instructables.com/FVU/TAI1/HD8Z1BIN/FVUTAI1HD8Z1BIN.LARGE.jpg", "https://cdn.instructables.com/FCS/6CZ1/HD8Z1BIO/FCS6CZ1HD8Z1BIO.LARGE.jpg"], "step_title": "Step 12: Drill the Front Panel"}, {"step": 13, "steps_text": "The last bit of drilling is to provide the access for the power connector. The first photo shows the drilling diagram; a 5/16\u201d hole was drilled and the Radio Shack nibbler was used to form a 1/2\u201d rectangular cutout. If the banana jacks are defined as the top, then this power access port would be located bottom left.\nThe second and third photos show two different drill bits being used.\nAfter doing some nibbling, the square hole was cleaned up with a hand file (fourth photo). The finished product is shown in the fifth photo.", "step_imgs": ["https://cdn.instructables.com/FWX/HN6O/HD8Z1BLA/FWXHN6OHD8Z1BLA.LARGE.jpg", "https://cdn.instructables.com/FR1/26US/HD8Z1BLB/FR126USHD8Z1BLB.LARGE.jpg", "https://cdn.instructables.com/F8Q/HWUN/HD8Z1BLC/F8QHWUNHD8Z1BLC.LARGE.jpg", "https://cdn.instructables.com/FJ5/KYY6/HD8Z1BLD/FJ5KYY6HD8Z1BLD.LARGE.jpg", "https://cdn.instructables.com/FFI/HSOR/HD8Z1BLF/FFIHSORHD8Z1BLF.LARGE.jpg"], "step_title": "Step 13: Cutting the Power Access Port"}, {"step": 14, "steps_text": "While I had considered using Press-Type lettering and a clear lacquer top coat to mark the top of the Altoids tin, a much better solution is to print the label on white label stock and then cover that with single-sided clear plastic laminating sheet. These items are available from Amazon as shown below.\n\"Avery\u00ae White Full-Sheet Labels for Inkjet Printers with TrueBlock(TM) Technology, 8-1/2 inches x 11 inches, Pack of 25 (8165)\"\nOffice Product; $9.98\n\"Scotch\u00ae Laminating Sheets LS854SS-10, 9 Inches x 12 Inches, Letter Size, Single Sided\" Office Product; $7.97\nOn the Avery 8165 label stock, print out the front panel label as shown on the left in the first photo below. Using sharp scissors, carefully cut out the label outline. The holes for the banana jacks, potentiometer, and display rectangle can be cut freehand using a sharp hobbyist knife and a straightedge.\nLikewise, the label can serve as a template to mark and cut out the clear plastic laminate sheet using the Scotch LS854SS-10 laminating sheets, as shown on the right in in the first photo.\nRemove the paper backing from the laminating sheet (right in the first photo below) and apply it to the top of the label (left in same photo). Using a sharp hobbyist knife, cut out the holes and the rectangular cutout for the display again. Now we have a stick-on label with a laminated plastic sheet that will protect the lettering for a long time (and look very nice too).\nTo actually stick the label on the case, I temporarily installed one banana jack and potentiometer using masking tape to help register the label (you only get one try at this). Remove the bottom paper backing from the label and stick it on the Altoids tin. This procedure is illustrated in the second photo.\nThe third photo below shows the Altoids tin with the label attached. Any little mismatches or anomalies around the holes will be covered by the hardware when the banana jacks and potentiometer are installed.", "step_imgs": ["https://cdn.instructables.com/FXO/JQUG/HD8Z1BMX/FXOJQUGHD8Z1BMX.LARGE.jpg", "https://cdn.instructables.com/FJK/Q4QK/HD8Z1BMY/FJKQ4QKHD8Z1BMY.LARGE.jpg", "https://cdn.instructables.com/F00/LR1W/HD8Z1BMZ/F00LR1WHD8Z1BMZ.LARGE.jpg"], "step_title": "Step 14: Create and Attach the Front Panel"}, {"step": 15, "steps_text": "The inside bottom of the Altoids tin has to be insulated prior to mounting the Menta circuit board. While the Scotch single-sided laminating sheets would be satisfactory, I elected to use heavier plastic stock that is used as front and back covers for report binding. Using the label as a template, the resulting plastic label can be marked for the four mounting holes and then these holes can be cut\nout using a razor knife. This plastic insulating insert is shown on the right in the photo below. Just remember to install this insulating sheet before dropping the Menta circuit board into the case.", "step_imgs": ["https://cdn.instructables.com/FGS/03X6/HD8Z1BNM/FGS03X6HD8Z1BNM.LARGE.jpg"], "step_title": "Step 15: Insulating the Altoids Tin Bottom"}, {"step": 16, "steps_text": "While the Sparkfun display is a very nice product, it appears that it was designed for bread boarding only. There is no obvious way to mount it in the Altoids case. I elected to epoxy \u201cwings\u201d to the sides of the display and then epoxy this assembly to the case (from underneath).\nI used some 1.8\u201d x 3.2mm ABS square rod cut to 1 1/2\u201d for the wings. This stock can be procured from http://www.hobbylinc.com/\nPLS90351 Square Rod ABS 1/8 (5) $4.59\nBefore attempting to epoxy this rectangular bar stock to the display, it's wise to roughen two adjacent edges with a file before gluing. This is a two-step process; first two \u201cwings\u201d are epoxied to the sides of the display (as shown in the first photo), and then this assembly is epoxied to the to the Altoids case from underneath (second photo).", "step_imgs": ["https://cdn.instructables.com/FZY/MX28/HD8Z1BNX/FZYMX28HD8Z1BNX.LARGE.jpg", "https://cdn.instructables.com/F6U/UA63/HD8Z1BNZ/F6UUA63HD8Z1BNZ.LARGE.jpg"], "step_title": "Step 16: Installing the 7-Segment Display"}, {"step": 17, "steps_text": "The stock Radio Shack banana jack is too long and would contact the Menta circuit board if installed unmodified. Basically it has to be shortened.\nDisassemble the stock banana jack and grip the bottom part (the plastic threaded part that will bolt to the case) with vice grip pliers. Be sure to leave the washer and threaded nut on the bottom assembly because they will be used to \u201crestore\u201d the plastic threads after cutting through. Just backing the threaded nut off after cutting cleans up the threads damaged by the cutting tool.\nI used a Dremel MotoTool with a cut-off wheel to cut through the plastic threads. Try to leave two or three threads on the bottom part. The first photo below shows the bottom part of the banana jack being shortened. As you can see, the nut is still installed so you can back it off after cutting and thereby restore the threads.The second photo shows the result of shortening the banana jacks. The stock Radio Shack part is shown for reference.\nThe banana jack metal post has to be shortened too. Leaving one nut threaded as shown in the third photo, use a Dremel MotoTool cut-off wheel to cut the post, leaving three or four threads.\nThe last photo shows the modified banana jacks (with the original for comparison). There's just enough threads in the post to back the nut away enough to loop and attach the ECG wires from the circuit board.", "step_imgs": ["https://cdn.instructables.com/FI4/MZ9X/HD8Z1BOJ/FI4MZ9XHD8Z1BOJ.LARGE.jpg", "https://cdn.instructables.com/FIX/NEH0/HD8Z1BOK/FIXNEH0HD8Z1BOK.LARGE.jpg", "https://cdn.instructables.com/FM4/4FYQ/HD8Z1BOL/FM44FYQHD8Z1BOL.LARGE.jpg", "https://cdn.instructables.com/F65/XH15/HD8Z1BOM/F65XH15HD8Z1BOM.LARGE.jpg"], "step_title": "Step 17: The Banana Jacks Need Some Surgery"}, {"step": 18, "steps_text": "For the circuit board mounting hardware, I used M3 x 8mm machine screws, M3 flat washers, and a M3 hex nut. These fit the mounting holes nicely.\nTo insulate the bottom of the circuit board from the metal case, I cut a rectangular piece of thin plastic using the Menta board as a template. Plastic report covers work well for this purpose. An Exacto knife can be used to make cut-outs for the machine screws if a paper hole punch is not available.Please, please, please don't forget the plastic insulating sheet placed below the circuit board. If you forget this, the Menta board will short circuit!", "step_imgs": ["https://cdn.instructables.com/FZV/6PNK/HD8Z1BP8/FZV6PNKHD8Z1BP8.LARGE.jpg"], "step_title": "Step 18: Install the Menta Circuit Board"}, {"step": 19, "steps_text": "The last step in assembly is to mechanically mount the banana jacks and the potentiometer, as shown in the photo below. I simply formed a small loop at the end of the ECG wires and anchored this over the threaded post with the nuts supplied with the banana jack.\nYou might notice that I used a plug to connect to the Sparkfun 7-segment display. This is a Jameco product:\nJameco 70755 .100\u201d (2.54 mm) female straight header receptacle 8-contacts $0.55\nTo provide adequate clearance, I bent the header pins soldered to the Sparkfun board 90 degrees. The potentiometer is fastened with a nut and a knob is attached and anchored with a tiny allen wrench.", "step_imgs": ["https://cdn.instructables.com/F5U/04X1/HD8Z1BPG/F5U04X1HD8Z1BPG.LARGE.jpg"], "step_title": "Step 19: Install the Banana Jacks and the Potentiometer"}, {"step": 20, "steps_text": "Before closing the Altoids case, make sure that the Adafruit Menta circuit board's PWR_SEL jumper is set for external power (not USB driven). The power jumper is to the left of the Reset button, as shown in the first photo below. To select the external power via the jack, set the jumper to the right as shown.\nThe second photo shows the completed Adafruit Menta ECG Simulator. The ECG Simulator can be powered by just about any wall wart (DC power supply) you have around (for example, a 12 volt 500 ma supply). Now all we need is some software!", "step_imgs": ["https://cdn.instructables.com/FDR/UJHN/HD8Z1BPQ/FDRUJHNHD8Z1BPQ.LARGE.jpg", "https://cdn.instructables.com/FVE/A91J/HD8Z1BPR/FVEA91JHD8Z1BPR.LARGE.jpg"], "step_title": "Step 20: The Completed Hardware"}, {"step": 21, "steps_text": "To get started, we need a suitable ECG waveform to digitize. The obvious thing to do is to find a waveform on the Internet and do a screen capture (convert it into a jpeg image file). A very good screen capture utility is MWSnap; it's free and easy to use. If you are running Windows 7 or 8, there's a nice accessory called the \u201csnipping tool\u201d that can do the same job. You'll find it in the start\nmenu under \u201caccessories\u201d.\nThe waveform selected, shown in the first figure below, is from an Army Flight Medical Training Course on Understanding ECG Waveforms.\u00a0http://www.scribd.com/doc/6072532/ECG-Interpretation\nThis waveform was chosen for three reasons, it was relatively uncluttered, had both axes labeled numerically, and being a government document there should be no copyright violation in using it. I used the MWSnap screen capture utility to grab this image and create a jpeg file. The jpeg image was then converted to black-and-white and sharpened via the open source Picasa photo editor from Google.", "step_imgs": ["https://cdn.instructables.com/FKT/4YZI/HD7TZTFG/FKT4YZIHD7TZTFG.LARGE.jpg"], "step_title": "Step 21: Source of the ECG Signal"}, {"step": 22, "steps_text": "The screen captured ECG waveform was named \u201cSampledECGWaveform.jpg\u201d and stored in my c:\\temp\\ folder. The typical heart waveform is composed of the P-wave, the QRS complex (you know, the \u201cba-bump\u201d part of your heart beat), and the T-wave.\nOn the horizontal time axis, major grid lines are at 0.200 seconds and the smallest grid divisions are 0.040 seconds. On the vertical amplitude axis, the major divisions are 1.0 millivolts and the smallest vertical divisions are 0.200 millivolts. After the last data point of the T-wave, the ECG waveform is quiescent until the next PQRST complex. That quiescent period (holding a constant sample) can be altered to vary the heart rate.\nNormal heart rate for most people is 60 beats per minute or, in other words, the R-Wave peaks are one second apart. Now it's true that as the heart rate really speeds up, the QRS waveform compresses somewhat, but we will simplify the simulator by outputting the same QRS part followed by a variable quiescent part.\nThe other thing to know is that the amplitude of the ECG as measured by attached electrodes on the skin is just a couple of millivolts. The next step is to digitize the waveform with the given time and amplitude axes using the Open Source digitizer program Engauge.\nThe first figure shows the Enguage digitizer program being used to pick data points off the ECG waveform. Each little blue tick mark is a mouse click. Obviously, the more points one clicks, the better the rendition of the waveform will be.\nWhen digitization is finished, a text file is created showing the (x, y) data points that were entered via Enguage (see the second figure below).\nThere are a couple of problems with this text file. First, the data points are not evenly spaced at 1.0 millisecond intervals (our target sample rate) and second, it's possible that some data points are out-of-sequence (you accidentally clicked a data point to the left of the previous data point).\nTo fix these problems and to scale the waveform points to a 12-bit D/A converter (0 .. 4095) and the time interval to 1.000 msec, a Python program was written to do these modifications (linear interpolation, sorting, and a lot of formatting) and to eventually massage the data into a perfectly legal const C array structure with an initializer (see the third figure below). This text file can be cut-and-pasted into the Arduino sketch.\nThe Python program is too complex for an Instructable, but you can download the Python program from the project repository on GitHub. Details on this repository are given at the beginning of this Instructable.\nThe C language Array structure with initializer only stores the PQRST part of the ECG waveform. The quiescent part is not stored; rather the D/A converter will \"hold\" a single value during the quiescent period. Modifying the number of samples emitted during the quiescent period effectively controls the heart rate. The fourth figure gives details about this feature.", "step_imgs": ["https://cdn.instructables.com/FBT/8Y3F/HD4VFUL3/FBT8Y3FHD4VFUL3.LARGE.jpg", "https://cdn.instructables.com/FO0/UAOU/HD7TZTGL/FO0UAOUHD7TZTGL.LARGE.jpg", "https://cdn.instructables.com/FK4/COLN/HD4VFUKF/FK4COLNHD4VFUKF.LARGE.jpg", "https://cdn.instructables.com/F3M/L67S/HD4VFUKT/F3ML67SHD4VFUKT.LARGE.jpg"], "step_title": "Step 22: Digitize and Convert the Waveform to a C Array Structure"}, {"step": 23, "steps_text": "While the Arduino script required to implement the ECG waveform generation is not difficult, it is a little more involved than the \u201cblink an LED\u201d introductory examples one may encounter. Here are some of the issues one must think about before entering the first line of code.Waveform as a C-language Array\nThis project has two important criteria concerning the waveform. The sample rate will be 1000 times a second (1 millisecond per sample); this was chosen for good waveform fidelity. The scale for this waveform should be 0 to 4095 (to make full-scale use of a 12-bit unipolar D/A converter).\nThe waveform should reside in EPROM, easily satisfied by using a const C-array with an initializer in the following form:\nconst short y_data[] = {\n939, 940, 941, 942, 944, 945, 946, 947, 951, 956,\n962, 967, 973, 978, 983, 989, 994, 1000, 1005, 1015\n};\nBy declaring the waveform array as a const array, it is assembled in the 32k EPROM rather than the more precious 2k of RAM which will be needed for variables, etc.Waveform Updated as a Timer2 Interrupt\nThe waveform will be output at an update rate of 1000 samples per second. To do this, Timer2 will be used to count out a one millisecond period and then trigger a Timer2 interrupt. Within the interrupt routine, the next sample will be moved from the stored waveform array and sent to the D/A converter via the SPI interface. The Timer2 is restarted and this continues ad-infinitum (forever).Heart Rate Displayed every 50 Milliseconds\nEvery 50th entry to the Timer2 interrupt routine, the heart rate selected by the user via the potentiometer will be sent to the 4-digit numeric display (again using the SPI interface). Both the D/A and the 4-digit display are updated within the Timer2 interrupt routine. Since they are serialized (one after the other), there will be no contention on the SPI interface bus.Heart Rate Pot Read in the Background Loop\nThe Arduino background loop is where the analog voltage (0 to 5 volts) set by the pot is read using an analog input. This value will be used to specify the number of samples in the \u201cquiescent period\u201d of the waveform, specifically that flat-line period after the T-wave that continues to the start of the next PQRS complex. This \u201cquiescent period\u201d value will be written to a variable that will be read by the Timer2 interrupt routine.", "step_imgs": [], "step_title": "Step 23: Arduino Software Development"}, {"step": 24, "steps_text": "// ***************************************************************************************************\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ECG SIMULATOR\n//\n//\u00a0 Purpose: simulate the normal sinus rhythm ECG signal (3-leads RA,LA,RL)\n//\n//\u00a0 Background:\n//\n//\u00a0 In normal electrocardiography (ECG or EKG if you're German), three leads make up the\n//\u00a0 Einthoven's triangle. Two leads are taped to the right and left side of the chest above\n//\u00a0 the heart (RA = right arm, LA = left arm) and one lead is taped to the lower chest, typically\n//\u00a0 on the right hip (RL = right leg).\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0 It's important to know that these ECG signals are millivolts in amplitude. This can be achieved by\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0 feeding the D/A converter through a voltage divider to get to the millivolt levels.\n//\n//\u00a0\n//\u00a0 The ECG signal:\n//\n//\u00a0 I found a suitable ECG waveform from the internet. Here is how I converted a picture from my\n//\u00a0 monitor screen to a C language array of A/D values, each spaced 1.00 msec apart.\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 A. Screen shot of waveform using the free screen capture program MWSNAP\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 http://www.mirekw.com/winfreeware/mwsnap.html\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 B. Digitize the jpeg waveform using the free digitizing program ENGAUGE\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 http://digitizer.sourceforge.net/\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 C: I wrote a Python program to convert the rather irregular samples from ENGAUGE\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 to an array of values spaced 1.0 milliseconds apart using linear interpolation.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Then I created a text file where these data points were part of a C language array\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 construct; that is, the data points are C initializers.\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 D: Cut-and-paste from the text file the C data array with initializers into the\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Arduino sketch below.\n//\u00a0\n//\n//\u00a0 Arduino Resources:\u00a0\u00a0\n//\n//\u00a0\u00a0\u00a0 Digital Output # 9\u00a0 - chip select the 7-segment display SPI port (low to select)\n//\u00a0\u00a0\u00a0 Digital Output # 10 - chip select for D/A converter\u00a0 (low to select)\n//\u00a0\u00a0\u00a0 Digital Output # 11 - SDI data to the D/A converter\u00a0 (SPI interface)\n//\u00a0\u00a0\u00a0 Digital Output # 13 - SCK clock to the D/A converter (SPI interface)\n//\u00a0\n//\u00a0\u00a0\u00a0 Analog Input\u00a0\u00a0 # 0\u00a0 - center wiper pin of 5k ohm pot (heart rate adjust)\n//\n//\u00a0\u00a0\u00a0 I followed the Timer2 setup as outlined by Sebastian Wallin\n//\u00a0\u00a0\u00a0 http://popdevelop.com/2010/04/mastering-timer-interrupts-on-the-arduino/\n//\n//\u00a0\u00a0\u00a0 I set up the SPI interface according to the excellent instructions of Australian John Boxall,\n//\u00a0\u00a0\u00a0 whose wonderful website has many excellent Arduino tutorials:\n//\u00a0\u00a0\u00a0 http://tronixstuff.wordpress.com/\n//\n//\u00a0 Programmer:\u00a0 James P Lynch\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 lynch007@gmail.com\n//\u00a0\n// ***************************************************************************************************\n#include \"SPI.h\" \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // supports the SPI interface to the D/A converter and 7-segment display\n#include <Wire.h>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // need the Wire library\n// various constants used by the waveform generator\n#define INIT \u00a0 \u00a0 \u00a0 \u00a0 \u00a00\n#define IDLE \u00a0 \u00a0 \u00a0 \u00a01\n#define QRS \u00a0 \u00a0 \u00a0 \u00a0 2\n#define FOUR\u00a0\u00a0\u00a0\u00a0\u00a0 4\n#define THREE \u00a0 \u00a03\n#define TWO \u00a0 \u00a0 \u00a0 \u00a0 2\n#define ONE \u00a0 \u00a0 \u00a0 \u00a0 1\n// *******************************************************************************************\n//\u00a0\u00a0 y_data[543] - digitized ecg waveform, sampled at 1.0 msec\n//\n//\u00a0\u00a0 Waveform is scaled for a 12-bit D/A converter (0 .. 4096)\n//\n//\u00a0\u00a0 A 60 beat/min ECG would require this waveform (543 samples) plus 457 samples\n//\u00a0\u00a0 of the first y_data[0] value of 939.\n//\n// *********************************************************************************************\nconst short\u00a0 y_data[] = {\n939, 940, 941, 942, 944, 945, 946, 947, 951, 956,\n962, 967, 973, 978, 983, 989, 994, 1000, 1005, 1015,\n1024, 1034, 1043, 1053, 1062, 1075, 1087, 1100, 1112, 1121,\n1126, 1131, 1136, 1141, 1146, 1151, 1156, 1164, 1172, 1179,\n1187, 1194, 1202, 1209, 1216, 1222, 1229, 1235, 1241, 1248,\n1254, 1260, 1264, 1268, 1271, 1275, 1279, 1283, 1287, 1286,\n1284, 1281, 1279, 1276, 1274, 1271, 1268, 1266, 1263, 1261,\n1258, 1256, 1253, 1251, 1246, 1242, 1237, 1232, 1227, 1222,\n1218, 1215, 1211, 1207, 1203, 1199, 1195, 1191, 1184, 1178,\n1171, 1165, 1159, 1152, 1146, 1141, 1136, 1130, 1125, 1120,\n1115, 1110, 1103, 1096, 1088, 1080, 1073, 1065, 1057, 1049,\n1040, 1030, 1021, 1012, 1004, 995, 987, 982, 978, 974,\n970, 966, 963, 959, 955, 952, 949, 945, 942, 939,\n938, 939, 940, 941, 943, 944, 945, 946, 946, 946,\n946, 946, 946, 946, 946, 947, 950, 952, 954, 956,\n958, 960, 962, 964, 965, 965, 965, 965, 965, 965,\n963, 960, 957, 954, 951, 947, 944, 941, 938, 932,\n926, 920, 913, 907, 901, 894, 885, 865, 820, 733,\n606, 555, 507, 632, 697, 752, 807, 896, 977, 1023,\n1069, 1127, 1237, 1347, 1457, 2085, 2246, 2474, 2549, 2595,\n2641, 2695, 3083, 3135, 3187, 3217, 3315, 3403, 3492, 3581,\n3804, 3847, 3890, 3798, 3443, 3453, 3297, 3053, 2819, 2810,\n2225, 2258, 1892, 1734, 1625, 998, 903, 355, 376, 203,\n30, 33, 61, 90, 119, 160, 238, 275, 292, 309,\n325, 343, 371, 399, 429, 484, 542, 602, 652, 703,\n758, 802, 838, 856, 875, 895, 917, 938, 967, 1016,\n1035, 1041, 1047, 1054, 1060, 1066, 1066, 1064, 1061, 1058,\n1056, 1053, 1051, 1048, 1046, 1043, 1041, 1038, 1035, 1033,\n1030, 1028, 1025, 1022, 1019, 1017, 1014, 1011, 1008, 1006,\n1003, 1001, 999, 998, 996, 994, 993, 991, 990, 988,\n986, 985, 983, 981, 978, 976, 973, 971, 968, 966,\n963, 963, 963, 963, 963, 963, 963, 963, 963, 963,\n963, 963, 963, 963, 963, 963, 963, 963, 963, 963,\n964, 965, 966, 967, 968, 969, 970, 971, 972, 974,\n976, 978, 980, 983, 985, 987, 989, 991, 993, 995,\n997, 999, 1002, 1006, 1011, 1015, 1019, 1023, 1028, 1032,\n1036, 1040, 1045, 1050, 1055, 1059, 1064, 1069, 1076, 1082,\n1088, 1095, 1101, 1107, 1114, 1120, 1126, 1132, 1141, 1149,\n1158, 1166, 1173, 1178, 1183, 1188, 1193, 1198, 1203, 1208,\n1214, 1221, 1227, 1233, 1240, 1246, 1250, 1254, 1259, 1263,\n1269, 1278, 1286, 1294, 1303, 1309, 1315, 1322, 1328, 1334,\n1341, 1343, 1345, 1347, 1349, 1351, 1353, 1355, 1357, 1359,\n1359, 1359, 1359, 1359, 1358, 1356, 1354, 1352, 1350, 1347,\n1345, 1343, 1341, 1339, 1336, 1334, 1332, 1329, 1327, 1324,\n1322, 1320, 1317, 1315, 1312, 1307, 1301, 1294, 1288, 1281,\n1275, 1270, 1265, 1260, 1256, 1251, 1246, 1240, 1233, 1227,\n1221, 1214, 1208, 1201, 1194, 1186, 1178, 1170, 1162, 1154,\n1148, 1144, 1140, 1136, 1131, 1127, 1123, 1118, 1114, 1107,\n1099, 1090, 1082, 1074, 1069, 1064, 1058, 1053, 1048, 1043,\n1038, 1034, 1029, 1025, 1021, 1017, 1013, 1009, 1005, 1001,\n997, 994, 990, 991, 992, 994, 996, 997, 999, 998,\n997, 996, 995, 994, 993, 991, 990, 989, 989, 989,\n989, 989, 989, 989, 988, 986, 984, 983, 981, 980,\n982, 984, 986, 988, 990, 993, 995, 997, 999, 1002,\n1005, 1008, 1012};\n// global variables used by the program\nunsigned int\u00a0 NumSamples = sizeof(y_data) / 2; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// number of elements in y_data[] above\nunsigned int\u00a0 QRSCount = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// running QRS period msec count\nunsigned int\u00a0 IdleCount = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// running Idle period msec count\nunsigned long IdlePeriod = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// idle period is adjusted by pot to set heart rate\nunsigned int\u00a0 State = INIT; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // states are INIT, QRS, and IDLE\nunsigned int\u00a0 DisplayCount = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // counts 50 msec to update the 7-segment display\nunsigned int\u00a0 tcnt2; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Timer2 reload value, globally available\nfloat\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BeatsPerMinute; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // floating point representation of the heart rate\nunsigned int\u00a0 Bpm; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // integer version of heart rate (times 10)\nunsigned int\u00a0 BpmLow; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// lowest heart rate allowed (x10)\nunsigned int\u00a0 BpmHigh; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // highest heart rate allowed (x10)\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Value; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // place holder for analog input 0\nunsigned long BpmValues[32] = {0, 0, 0, 0, 0, 0, 0, 0, \u00a0 \u00a0 // holds 32 last analog pot readings\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00, 0, 0, 0, 0, 0, 0, 0, \u00a0 \u00a0 // for use in filtering out display jitter\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00, 0, 0, 0, 0, 0, 0, 0, \u00a0 \u00a0 // for use in filtering out display jitter\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00, 0, 0, 0, 0, 0, 0, 0}; \u00a0 \u00a0// for use in filtering out display jitter\nunsigned long BpmAverage = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// used in a simple averaging filter\nunsigned char Index = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // used in a simple averaging filter\u00a0\nunsigned int\u00a0 DisplayValue = 0; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // filtered Beats Per Minute sent to display\nvoid setup()\u00a0\u00a0 {\n\u00a0\n\u00a0 // Configure the output ports (1 msec intrerrupt indicator and D/A SPI support)\n\u00a0 pinMode(9, OUTPUT);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // 7-segment display chip select\u00a0\u00a0 (low to select chip)\n\u00a0 pinMode(10, OUTPUT);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // D/A converter chip select\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (low to select chip)\n\u00a0 pinMode(11, OUTPUT);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // SDI data\n\u00a0 pinMode(13, OUTPUT);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // SCK clock\n\u00a0 // initial state of SPI interface\n\u00a0 SPI.begin(); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// wake up the SPI bus.\n\u00a0 SPI.setDataMode(0); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// mode: CPHA=0, data captured on clock's rising edge (low-to-high)\n\u00a0 SPI.setClockDivider(SPI_CLOCK_DIV64); \u00a0 \u00a0// system clock / 64\n\u00a0 SPI.setBitOrder(MSBFIRST); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// bit 7 clocks out first\n\u00a0\n\u00a0 // establish the heart rate range allowed\n\u00a0 // BpmLow\u00a0 = 300 (30 bpm x 10)\n\u00a0 // BpmHigh = (60.0 / (NumSamples * 0.001)) * 10\u00a0 = (60.0 / .543) * 10 = 1104\u00a0 (110.49 x 10)\n\u00a0 BpmLow = 300;\n\u00a0 BpmHigh = (60.0 / ((float)NumSamples * 0.001)) * 10;\n\u00a0 // First disable the timer overflow interrupt while we're configuring\n\u00a0 TIMSK2 &= ~(1<<TOIE2);\n\u00a0 // Configure timer2 in normal mode (pure counting, no PWM etc.)\n\u00a0 TCCR2A &= ~((1<<WGM21) | (1<<WGM20));\n\u00a0 TCCR2B &= ~(1<<WGM22);\n\u00a0 // Select clock source: internal I/O clock\u00a0\u00a0\n\u00a0 ASSR &= ~(1<<AS2);\n\u00a0 // Disable Compare Match A interrupt enable (only want overflow)\u00a0\u00a0\n\u00a0 TIMSK2 &= ~(1<<OCIE2A);\n\u00a0 // Now configure the prescaler to CPU clock divided by 128\u00a0\u00a0\n\u00a0 TCCR2B |= (1<<CS22)\u00a0 | (1<<CS20); // Set bits\n\u00a0 TCCR2B &= ~(1<<CS21);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Clear bit\n\u00a0 // We need to calculate a proper value to load the timer counter.\n\u00a0 // The following loads the value 131 into the Timer 2 counter register\n\u00a0 // The math behind this is:\n\u00a0 // (CPU frequency) / (prescaler value) = 125000 Hz = 8us.\n\u00a0 // (desired period) / 8us = 125.\n\u00a0 // MAX(uint8) + 1 - 125 = 131;\n\u00a0 //\n\u00a0 // Save value globally for later reload in ISR\u00a0 /\n\u00a0 tcnt2 = 131;\n\u00a0 // Finally load end enable the timer\u00a0\u00a0\n\u00a0 TCNT2 = tcnt2;\n\u00a0 TIMSK2 |= (1<<TOIE2);\n}\nvoid loop() {\n\u00a0 // read from the heart rate pot (Analog Input 0)\u00a0\n\u00a0 Value = analogRead(0);\n\u00a0 // map the Analog Input 0 range (0 .. 1023) to the Bpm range (300 .. 1104)\n\u00a0 Bpm = map(Value, 0, 1023, BpmLow, BpmHigh);\n\u00a0 // To lessen the jitter or bounce in the display's least significant digit,\n\u00a0 // a moving average filter (32 values) will smooth it out.\n\u00a0 BpmValues[Index++] = Bpm;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // add latest sample to eight element array\n\u00a0 if (Index == 32) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// handle wrap-around\n\u00a0\u00a0\u00a0 Index = 0;\n\u00a0 }\n\u00a0 BpmAverage = 0;\n\u00a0 for (int\u00a0 i = 0;\u00a0 i < 32; i++) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // summation of all values in the array\n\u00a0\u00a0\u00a0 BpmAverage += BpmValues[i];\n\u00a0 }\n\u00a0 BpmAverage >>= 5; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Divide by 32 to get average\n\u00a0\n\u00a0 // now update the 4-digit display - format: XXX.X\n\u00a0 // since update is a multi-byte transfer, disable interrupts until it's done\n\u00a0 noInterrupts();\n\u00a0 DisplayValue = BpmAverage;\n\u00a0 interrupts();\u00a0\n\u00a0\n\u00a0 // given the pot value (beats per minute) read in, calculate the IdlePeriod (msec)\n\u00a0 // this value is used by the Timer2 1.0 msec interrupt service routine\n\u00a0 BeatsPerMinute = (float)Bpm / 10.0;\n\u00a0 noInterrupts();\n\u00a0 IdlePeriod = (unsigned int)((float)60000.0 / BeatsPerMinute) - (float)NumSamples;\n\u00a0 interrupts();\n\u00a0\n\u00a0 delay(20);\n}\n// ********************************************************************************\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Timer2 Interrupt Service Routine\n//\n// Interrupt Service Routine (ISR) for Timer2 overflow at 1.000 msec.\n//\n//\n// The Timer2 interrupt function is used to send the 16-bit waveform point\n// to the Microchip MCP4921 D/A converter using the SPI interface.\n//\n// The Timer2 interrupt function is also used to send the current heart rate\n// as read from the potentiometer every 50 Timer2 interrupts to the 7-segment display.\n//\n// The pot is read and the heart rate is calculated in the background loop.\n// By running both SPI peripherals at interrupt level, we \"serialize\" them and avoid\n// corruption by one SPI transmission being interrupted by the other.\n//\n// A state machime is implemented to accomplish this. It's states are:\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INIT -\u00a0\u00a0\u00a0 basically clears the counters and sets the state to QRS.\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 QRS\u00a0 -\u00a0\u00a0\u00a0 outputs the next ECG waveform data point every 1.0 msec\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 there are 543 of these QRS complex data points.\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 IDLE -\u00a0\u00a0\u00a0 variable period after the QRS part.\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0D/A holds first ECG value (939) for all of the IDLE period.\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Idle period varies to allow adjustment of the basic heart rate;\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a value of zero msec for the idle period gives 110.4 beats per min\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0while the maximum idle period of 457 msec gives 30.0 bpm.\n//\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Note that the IDLE period is calculated in the main background\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0loop by reading a pot and converting its range to one suitable\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for the background period. The interrupt routine reads this\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0value to determine when to stop the IDLE period.\n//\n// The transmission of the next data point to the D/A converter via SPI takes\n// about 63 microseconds (that includes two SPI byte transmissions).\n//\n// The transmission of the heart rate digits to the Sparkfun 7-segment display\n// takes about 350 usec (it is only transmitted every 50 Timer2 interrupts)\n//\n// ********************************************************************************\nISR(TIMER2_OVF_vect) {\n\u00a0\n\u00a0 \u00a0 // Reload the timer\u00a0\u00a0\n\u00a0 \u00a0 TCNT2 = tcnt2;\n\u00a0 \u00a0\n\u00a0 \u00a0 // state machine\n\u00a0 \u00a0 switch (State) {\n\u00a0 \u00a0\n\u00a0 \u00a0 case INIT:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // zero the QRS and IDLE counters\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 QRSCount = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IdleCount = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 DisplayCount = 0;\n\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // set next state to QRS\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 State = QRS;\n\u00a0 \u00a0 break;\n\u00a0\n\u00a0 \u00a0 case QRS:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // output the next sample in the QRS waveform to the D/A converter\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 DTOA_Send(y_data[QRSCount]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // advance sample counter and check for end\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 QRSCount++;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (QRSCount >= NumSamples) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // start IDLE period and output first sample to DTOA\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 QRSCount = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 DTOA_Send(y_data[0]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 State = IDLE;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 break;\n\u00a0\n\u00a0 \u00a0 case IDLE:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // since D/A converter will hold the previous value written, all we have\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // to do is determine how long the IDLE period should be.\n\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // advance idle counter and check for end\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IdleCount++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // the IdlePeriod is calculated in the main loop (from a pot)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (IdleCount >= IdlePeriod) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IdleCount = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 State = QRS;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0\n\u00a0 \u00a0 break;\n\u00a0\n\u00a0 \u00a0 default:\n\u00a0 \u00a0 break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // output to the 7-segment display every 50 msec\n\u00a0 \u00a0 DisplayCount++;\n\u00a0 \u00a0 if (DisplayCount >= 50) {\n\u00a0 \u00a0 \u00a0 \u00a0 DisplayCount = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 Display7Seg_Send(DisplayValue);\n\u00a0 \u00a0 \u00a0}\n}\u00a0\n// ***************************************************************************************************\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 void\u00a0 DTOA_Send(unsigned short)\n//\n//\u00a0 Purpose: send 12-bit D/A value to Microchip MCP4921 D/A converter ( 0 .. 4096 )\n//\n//\n//\u00a0 Input:\u00a0\u00a0\u00a0 DtoAValue - 12-bit D/A value ( 0 .. 4096 )\n//\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 The DtoAValue is prepended with the A/B, BUF, GA, and SHDN bits before transmission.\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 WRITE COMMAND\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |-----------|-----------|-----------|-------------|--------------------------------------------------------------------------------|\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\u00a0 A/B \u00a0 \u00a0 \u00a0 |\u00a0\u00a0 BUF \u00a0 |\u00a0 GA \u00a0 \u00a0 \u00a0 \u00a0| SHDN \u00a0 \u00a0 | D11 D10 D09 D08 D07 D06 D05 D04 D03 D02 D01 D00\u00a0 |\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0|\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |setting: \u00a0|setting :|setting: |Setting: \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0DtoAValue\u00a0\u00a0 (12 bits) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 |\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\u00a0\u00a0 0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0|\u00a0\u00a0 0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0|\u00a0\u00a0 1 \u00a0 \u00a0 \u00a0 \u00a0|\u00a0\u00a0 1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 |\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | DAC-A\u00a0 |unbuffer |\u00a0\u00a0 1x \u00a0 \u00a0 \u00a0|power-on| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0( 0 .. 4096\u00a0 will output as 0 volts .. 5 volts ) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0|\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |-----------|------------|----------|-------------|--------------------------------------------------------------------------------|\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 15 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 14 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a013 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a012 \u00a0 \u00a0 \u00a0 11 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00\n//\u00a0 To D/A\u00a0\u00a0\u00a0 <======================================================================================\n//\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Note:\u00a0 WriteCommand is clocked out with bit 15 first!\n//\n//\n//\u00a0 Returns:\u00a0 nothing\n//\n//\n//\u00a0 I/O Resources:\u00a0 Digital Pin 9\u00a0 = chip select (low to select chip)\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Digital Pin 13 = SPI Clock\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Digital Pin 11 = SPI Data\n//\n//\u00a0 Note: by grounding the LDAC* pin in the hardware hook-up, the SPI data will be clocked into the\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 D/A converter latches when the chip select rises at the end-of-transfer.\n//\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 This routine takes 63 usec using an Adafruit Menta\n// ***************************************************************************************************\nvoid\u00a0 DTOA_Send(unsigned short DtoAValue) {\n\u00a0\n\u00a0 byte\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Data = 0;\n\u00a0 // select the D/A chip (low)\n\u00a0 digitalWrite(10, 0);\u00a0\u00a0\u00a0 // chip select low\n\u00a0\n\u00a0 // send the high byte first 0011xxxx\n\u00a0 Data = highByte(DtoAValue);\n\u00a0 Data = 0b00001111 & Data;\n\u00a0 Data = 0b00110000 | Data;\n\u00a0 SPI.transfer(Data);\n\u00a0\n\u00a0 // send the low byte next xxxxxxxx\n\u00a0 Data = lowByte(DtoAValue);\n\u00a0 SPI.transfer(Data);\n\u00a0 // all done, de-select the chip (this updates the D/A with the new value)\n\u00a0 digitalWrite(10, 1);\u00a0\u00a0\u00a0 // chip select high\n}\n// ***************************************************************************************************\n//\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 void\u00a0 Display7Seg_Send(char *)\n//\n//\u00a0 Purpose: send 4 digits to SparkFun Serial 7-Segment Display (requires 4 SPI writes)\n//\n//\u00a0 Input:\u00a0\u00a0\u00a0 value -\u00a0 unsigned int version of BeatsPerMinute\n//\n//\u00a0 Returns:\u00a0 nothing\n//\n//\u00a0 I/O Resources:\u00a0 Digital Pin 10 = chip select (low to select chip)\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Digital Pin 13 = SPI Clock\n// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Digital Pin 11 = SPI Data\n//\n//\u00a0 Note:\u00a0 this routine takes 350 usec using an Adafruit Menta\n// ***************************************************************************************************\nvoid\u00a0 Display7Seg_Send(unsigned int\u00a0 HeartRate) {\n\u00a0 uint8_t\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 digit1, digit2, digit3, digit4;\n\u00a0 unsigned int\u00a0 value;\n\u00a0\n\u00a0 // convert to four digits (set leading zeros to blanks; 0x78 is the blank character)\n\u00a0 value = HeartRate;\n\u00a0 digit1 = value / 1000;\n\u00a0 value -= digit1 * 1000;\n\u00a0 if (digit1 == 0) digit1 = 0x78;\n\u00a0 digit2 = value / 100;\n\u00a0 value -= digit2 * 100;\n\u00a0 if ((digit1 == 0x78) && (digit2 == 0)) digit2 = 0x78;\n\u00a0 digit3 = value / 10;\n\u00a0 value -= digit3 * 10;\n\u00a0 if ((digit1 == 0x78) && (digit2 == 0x78) && (digit3 == 0)) digit3 = 0x78;\n\u00a0 digit4 = value;\n\u00a0 digitalWrite(9, LOW);\u00a0\u00a0\u00a0 // select the Sparkfun 7-seg display\n\u00a0 SPI.transfer(0x76);\u00a0\u00a0\u00a0\u00a0\u00a0 // reset display\n\u00a0 SPI.transfer(0x7A);\u00a0\u00a0\u00a0\u00a0\u00a0 // brightness command\n\u00a0 SPI.transfer(0x00);\u00a0\u00a0\u00a0\u00a0\u00a0 // 0 = bright,\u00a0 255 = dim\n\u00a0 SPI.transfer(digit1);\u00a0\u00a0\u00a0 // Thousands Digit\n\u00a0 SPI.transfer(digit2);\u00a0\u00a0\u00a0 // Hundreds Digit\n\u00a0 SPI.transfer(digit3);\u00a0\u00a0\u00a0 // Tens Digit\n\u00a0 SPI.transfer(digit4);\u00a0\u00a0\u00a0 // Ones Digit\n\u00a0 SPI.transfer(0x77);\u00a0\u00a0\u00a0\u00a0\u00a0 // set decimal points command\n\u00a0 SPI.transfer(0x04);\u00a0\u00a0\u00a0\u00a0\u00a0 // turn on dec pt between digits 3 and 4\n\u00a0 digitalWrite(9, HIGH);\u00a0\u00a0 // release Sparkfun 7-seg display\n}", "step_imgs": [], "step_title": "Step 24: ECG Simulator - Arduino Sketch"}, {"step": 25, "steps_text": "To test the ECG simulator, the Texas Instruments ADS1293EVM evaluation board was connected to\u00a0the Menta ECG Simulator via the banana jacks and the supplied TI Windows software was used to look at the\u00a0received signal on my desktop computer (I'm running Windows 8). The test setup is shown in the first figure below.\nIn the interest of honest reporting, heart monitors employ a lot of filtering to clean up the ECG signal.\u00a0I set up the TI software digital filters to do the same thing. The second figure below shows the Texas Instruments\u00a0software displaying the ECG signal from the simulator. The second channel in the TI software was not connected with this test setup.\nThe third figure shows the original ECG signal screen-captured from the Army document. As you can see,\u00a0the generated ECG signal is a close match to the original.\nNote that the signal is just a couple of\u00a0millivolts.\u00a0With the Rate Adjustment pot, you can vary the rate from 30 bpm to 110 bpm.", "step_imgs": ["https://cdn.instructables.com/FLT/X2OB/HD7U0N91/FLTX2OBHD7U0N91.LARGE.jpg", "https://cdn.instructables.com/F0D/NRM6/HD7U0N92/F0DNRM6HD7U0N92.LARGE.jpg", "https://cdn.instructables.com/F6F/5I46/HD7U0N93/F6F5I46HD7U0N93.LARGE.jpg"], "step_title": "Step 25: Test Results"}, {"step": 26, "steps_text": "My goal with this project was to design and fabricate a 3-lead ECG simulator that would allow me to\u00a0study the Texas Instruments ADS1293 ECG Front-end chip. Using the Adafruit Menta kit as a\u00a0starting point, the simulator was built for just over $60 in parts. There was no intention to\u00a0manufacture this device, it was essentially a \u201cone-off\u201d design.\nThe software effort was a bit more complicated since I decided to start from a page in an Army\u00a0medical document on the Internet. The sample waveform was screen-captured using MWSnap,\u00a0digitized by the Sourceforge Enguage tool, and then manipulated by a custom Python program to\u00a0create a C language array structure with initializer that can be \u201cpasted\u201d into the Arduino sketch.\nThe Arduino sketch is modestly complicated, using a Timer2 interrupt to precisely time the waveform\u00a0samples at one millisecond intervals and some SPI driver code to update the D/A converter and the\u00a04-digit display.\nThere are two conclusions: the 8-bit Arduino micro-controller is a perfect fit for this application and\u00a0the Adafruit Menta is a wonderful platform for building things.\nIt bears repeating that the strategies I outlined in this tutorial to generate the ECG waveform can be\u00a0utilized to create any waveform that you might see in a book or on the Internet.", "step_imgs": [], "step_title": "Step 26: Conclusions"}, {"step": 27, "steps_text": "Jim Lynch lives in Grand Island, New York and\u00a0is a software developer for Control\u00a0Techniques, a subsidiary of Emerson Electric.\u00a0\nHe develops embedded software for the\u00a0company\u2019s industrial drives (high power motor\u00a0controllers) which are sold all over the world.\nMr. Lynch has previously worked for Mennen\u00a0Medical, Calspan Corporation, and the Boeing\u00a0Company. He has a BSEE from Ohio\nUniversity and a MSEE from State University\u00a0of New York at Buffalo.\nJim is a single father and has two grown\u00a0children and four grandchildren who now live\u00a0in Florida and Nevada.\nHe has two brothers, one is a Viet Nam veteran in Hollywood, Florida and the other is the Bishop\u00a0of St. Petersburg, also in Florida. Jim enjoys playing the guitar, woodworking, and going to the\u00a0movies.\nLynch can be reached via e-mail at: \u00a0 \u00a0lynch007@gmail.com", "step_imgs": ["https://cdn.instructables.com/F9D/KQEZ/HD7U0NAG/F9DKQEZHD7U0NAG.LARGE.jpg"], "step_title": "Step 27: About the Author"}], "channel": "Electronics"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "This is the MAX300100 breakout board that reads heart rate or pulse oximetry. The chip has an integrated optical sensor that derives its reading from emitting two wavelength of light from the two LED\u2019s then measures the absorbance of pulsing blood through a photodetector. The signal is processed by a low noise analog signal processing unit and communicated to the Microcontroller through the i2C Interface.The MAX30100 operates from 1.8v and 3.3v voltage input and can be powered down through software with negligible standby current, permitting the power supply to remain connected at all times. The device is suitable for wearable devices like smart watch, medical monitoring equipment\u2019s, fitness assistant and smart suits. Required Components Arduino Microcontroller, ESP8266 (Arduino IDE Integrated), Teensy MCU (TeensyDuino Integrated),Buzzer / Alarm (Optional)LCD / OLED i2C Display (Optional)Solder Less BreadboardJumper Wire", "title": "How to Wire MAX30100 Heart Rate Monitor With Arduino Microcontroller", "url": "https://www.instructables.com/id/How-to-Wire-MAX30100-Heart-Rate-Monitor-With-Ardui/", "section": "technology", "steps": [{"step": 1, "steps_text": "#include  #include #include #include #include #include #include #define REPORTING_PERIOD_MS 500 /* PulseOximeter is the higher level interface to the sensor That offers: > Beat Reporting > Heart Pulse Rate Calculation > SP02 OXIDATION LEVEL Calculation */ PulseOximeter pox; const int numReadings=10; float filterweight=0.5; uint32_t tsLastReport = 0; uint32_t last_beat=0; int readIndex=0; int average_beat=0; int average_SpO2=0; bool calculation_complete=false; bool calculating=false; bool initialized=false; byte beat=0; void onBeatDetected() //Calls back when pulse is detected { viewBeat(); last_beat=millis(); } void viewBeat() { if (beat==0) { Serial.print(\"_\"); beat=1; } else { Serial.print(\"^\"); beat=0; } } void initial_display() { if (not initialized) { viewBeat(); Serial.print(\"14CORE | MAX30100 Pulse Oximeter Test\"); Serial.println(\"--------------------------------------\"); Serial.println(\"Place place your finger on the sensor\"); Serial.println(\"--------------------------------------\"); ; initialized=true; } } void display_calculating(int j){ viewBeat(); Serial.println(\"Measuring\"); for (int i=0;i<=j;i++) { Serial.print(\". \"); } } void display_values() { Serial.print(average_beat); Serial.print(\"| Bpm \"); Serial.print(\"| SpO2 \"); Serial.print(average_SpO2); Serial.print(\"%\"); } void calculate_average(int beat, int SpO2) { if (readIndex==numReadings) { calculation_complete=true; calculating=false; initialized=false; readIndex=0; display_values(); } if (not calculation_complete and beat>30 and beat<220 and SpO2>50) { average_beat = filterweight * (beat) + (1 - filterweight ) * average_beat; average_SpO2 = filterweight * (SpO2) + (1 - filterweight ) * average_SpO2; readIndex++; display_calculating(readIndex); } } void setup() { Serial.begin(115200); pox.begin(); pox.setOnBeatDetectedCallback(onBeatDetected); } // Make it sure that you need to call update as fast as possible void loop() { pox.update(); if ((millis() - tsLastReport > REPORTING_PERIOD_MS) and (not calculation_complete)) { calculate_average(pox.getHeartRate(),pox.getSpO2()); tsLastReport = millis(); } if ((millis()-last_beat>10000)) { calculation_complete=false; average_beat=0; average_SpO2=0; initial_display(); } } ", "step_imgs": ["https://cdn.instructables.com/FPX/GIET/J02QNDH4/FPXGIETJ02QNDH4.LARGE.jpg"], "step_title": "Step 1: Source Code"}, {"step": 2, "steps_text": "http://www.14core.com/wiring-the-max30100-heart-ra...Downloads Source Code | Txt File Download the MAX30100 Code Libraries | Zip Download the MAX30100 Datasheet | Pdf", "step_imgs": [], "step_title": "Step 2: Download Codes"}], "channel": "Arduino"}, {"category": "technology", "description": "A project a long time in development, while the physical design is relatively simple, the method of control is a bit more complicated and required the development of suitable software and techniques. This project is based around a 20\" diameter diffused acrylic lamp cover that was purchased from a building materials recycling company. It either hung or was mounted on a pole and contained a high wattage mercury bulb(it seems). It was already separated in two pieces, top half(hemisphere) and bottom half(hemisphere) with the mounting hardware. The acrylic bottom is held onto the metal base with a metal flange that bolts together from the outside and clamps the bottom hemisphere between them. The resolution is 68 x 24 with a total of 1238 pixels worth of LPD8806 LED strip was used, while using flat LED strip caused some problems, there really isn't many other options that wouldn't require some serious design and manufacturing. Which for a single shot, DIY project like this, isn't an option.While several variations of LED spheres can be found on the internet, they either have a rotor with LEDs on it that spins quickly to produce the effect or are made in sections of injection molded parts, which would is very costly and complicated. While this design took a lot of tools to complete, the cost, overall complexity of the system is low, along with being quite sturdy.Since the completed project doesn't really have a sharp display with some variations in LED spacing and positions. It is more suitable for abstract patterns and colors, rather than detailed content. But can do text scrolls and other effects well enough.See the webpage at: http://www.nledshop.com/projects/spherematrix/", "title": "Spherical LED Matrix - Sphere Shaped LED Screen From LED Pixel Strip", "url": "https://www.instructables.com/id/Spherical-LED-Matrix-Sphere-Shaped-LED-Screen-From/", "section": "technology", "steps": [{"step": 1, "steps_text": "Hardware Supplies:Diffused acrylic globe with base, in two hemispheres -  Found a 20\" sphere  from an industrial light at a salvage/reuse yard.1/8\" aluminum bar, 3/4\" or 1\"       Heavy gauge metal strapping, 20ga or thicker       Threaded Rod       Bolts, Washers and Lock Washers for the threaded rod       LED Pixel Strip, choice of chipsets and densities, used here is LPD8806       Base plate, 8\" disc, something strong like marine grade plywood or aluminum(Optional) Matte Black Vinyl Cut strips with cutouts for LEDsElectronics:LED Pixel Strip - WS2801, LPD8806, APA102(best), WS2812B(not recommended), used here is LPD8806       LED Controller - Used here is a modified NLED Pixel Controller Ion(USB), Or Pixel Controller Mini,  Pixel Controller Micro, Pixel Controller Electron(USB) 4 Conductor Ribbon Cable, 22 AWG16 AWG Power Wire, 2 colors       2 Conductor stranded wire, red and black22AWG solid strand, 2 colorsTools:Soldering Iron and Supplies       Misc Pliers       Tin Snips, to cut the metal strapping       Power drill and bits       Hacksaw, sawzall with metal blade for cutting aluminum bar       Pop Rivet with 1/8\" x 0.25\" rivets       Table Saw for dado cuts on base plate    Ring Roller - Gear Driven Ring Roller, Harbor Freight Tools SKU: 36790Software: Covered in Step 9", "step_imgs": ["https://cdn.instructables.com/FX1/93P2/IT22NW40/FX193P2IT22NW40.LARGE.jpg", "https://cdn.instructables.com/FTH/EZCL/I9IBQ5HO/FTHEZCLI9IBQ5HO.LARGE.jpg"], "step_title": "Step 1: Tools and Supplies"}, {"step": 2, "steps_text": "By far the hardest part, anything round is difficult to do by hand. And even more difficult to plan. The idea was to have the support structure for the LEDs 1\" away from the acrylic shell. The distance was chosen through experimentation. Since the LED strip wants to be flat, it was assumed that forcing it into a round shape would cause the LEDs on the strip to not all point in the correct direction, varying slightly. The 1\" distance was a compromise between a sharp pixel and hiding the misdirected LEDs. Overall a good choice as it ended up with pretty good resolution and hides the imperfections from the LED placement.Started with completely taking it apart and measuring.       Laid it out in CAD(or Adobe Illustrator or something)", "step_imgs": ["https://cdn.instructables.com/FO8/ROJY/I3H5QI3U/FO8ROJYI3H5QI3U.LARGE.jpg", "https://cdn.instructables.com/F0G/SJDH/ICP0Y5T5/F0GSJDHICP0Y5T5.LARGE.jpg", "https://cdn.instructables.com/FU3/K3X6/ICP0Y5T4/FU3K3X6ICP0Y5T4.LARGE.jpg"], "step_title": "Step 2: Layout and Planning"}, {"step": 3, "steps_text": "Base Plate:Used a scrap piece of marine grade plywood that was big enough to cut a 8\" diameter disc from.         Find the center for the disc and drill a hole just large enough for the threaded rod.         Cut a perpendicular dados using the center hole as the center. The dados were as wide as the aluminum bar. Which was 3/4\", and 1/8\" deep, same as the aluminum bar. The tighter the fit the better.         Using the removed flange(that mounts the bottom acrylic shell to the base, marked and drilled the mounting holes. And drilled two 7/8\" holes to run the wires for data and power out through the bottom into the base.Center Support Rod:The threaded rod was left long for now but all the bolts and washers were installed. To keep it together each bolt has a lock washer and the inside has 2 bolts for each side that are tightened into each for extra hold. Wide washers are used to help stabilize it.Vertical Support Bars: It helped for this step to have a wooden disc/template the same diameter as the support structure, which is 18\" in this case. Since the ring rollers aren't precise or consistent and its hard to tell when its the right size, its easiest to have something to compare to. Although after completing this project, it would be best to only use one instead of the two shown, as the thickness caused some issues because they intersect at the top. Which also meant they weren't the same and were slightly different to try and make up for it.Calculated the circumference of a 18\" diameter circle and cut two lengths of 1/8\" x 3/4\" aluminum bar.         Marked the center and drilled a hole, same size as the threaded rod.         Used some scrap bar to get the ring roller close to the right diameter, then rolled the support bar into full circles.         Checked them against the template and adjusted.         Hardest assembly part is to find where to bend the aluminum bar to flatten the bottom for mounting to the base plate and flange. Used the center hole as the top reference, the wooden disc/template, a straight edge and a measuring tape(like for sewing, since it has to bend to measure the round object precisely)         With the top center marked and already knowing the distance from the top of the support bar to the base plate, the straight edge was used to mark the bar, then measured(with the tape) from the top center hole, and adjustments made, since both marks should be an equal distance from the top center hole.         Hammered the aluminum bar flat at the marks, careful not to distort the rest of the shape.", "step_imgs": ["https://cdn.instructables.com/F4R/53WQ/I3H5QJ2T/F4R53WQI3H5QJ2T.LARGE.jpg", "https://cdn.instructables.com/FZY/WWOT/I3H5QJ2V/FZYWWOTI3H5QJ2V.LARGE.jpg", "https://cdn.instructables.com/FG7/Z3C7/I3H5QJ9D/FG7Z3C7I3H5QJ9D.LARGE.jpg", "https://cdn.instructables.com/FPR/CMOV/I3H5QJQJ/FPRCMOVI3H5QJQJ.LARGE.jpg"], "step_title": "Step 3: Part Assemblies"}, {"step": 4, "steps_text": "Vertical Support Bars: It helped for this step to have a wooden disc/template the same diameter as the support structure, which is 18\" in this case. Since the ring rollers aren't precise or consistent and its hard to tell when its the right size, its easiest to have something to compare to. Although after completing this project, it would be best to only use one instead of the two shown, as the thickness caused some issues because they intersect at the top. Which also meant they weren't the same and were slightly different to try and make up for it.Calculated the circumference of a 18\" diameter circle and cut two lengths of 1/8\" x 3/4\" aluminum bar.         Marked the center and drilled a hole, same size as the threaded rod.        Used some scrap bar to get the ring roller close to the right diameter, then rolled the support bar into full circles.Checked them against the template and adjusted.        Hardest assembly part is to find where to bend the aluminum bar to flatten the bottom for mounting to the base plate and flange. Used the center hole as the top reference, the wooden disc/template, a straight edge and a measuring tape(like for sewing, since it has to bend to measure the round object precisely)        With the top center marked and already knowing the distance from the top of the support bar to the base plate, the straight edge was used to mark the bar, then measured(with the tape) from the top center hole, and adjustments made, since both marks should be an equal distance from the top center hole.Hammered the aluminum bar flat at the marks, careful not to distort the rest of the shape.Equator Support:Rolled from 1\" aluminium bar, trial and error to make it fit good inside both lateral supports.        Installed the base plate with the vertical supports and center support rod into the bottom of the acrylic shell.        Used the acrylic shell(which is exactly half the sphere) to find the exact position for the equator support. Clamped and marked both the equator support and vertical support for drilling and riveting.        Cut it to length so the ends sat flush together with the seam behind a vertical support. Each side got a pop rivet.       Left it installed til after the metal strapping was installed, so all the rivet holes could be marked then drilled.", "step_imgs": ["https://cdn.instructables.com/FYZ/G257/I3H5QJAL/FYZG257I3H5QJAL.LARGE.jpg", "https://cdn.instructables.com/FDF/2AQ8/I3H5QKX3/FDF2AQ8I3H5QKX3.LARGE.jpg", "https://cdn.instructables.com/FEE/KBMC/I3H5QMC2/FEEKBMCI3H5QMC2.LARGE.jpg", "https://cdn.instructables.com/F6B/7B3Z/I3H5QMC4/F6B7B3ZI3H5QMC4.LARGE.jpg", "https://cdn.instructables.com/FVF/75G3/I3H5QMCQ/FVF75G3I3H5QMCQ.LARGE.jpg", "https://cdn.instructables.com/F68/SNE4/I3H5QNEM/F68SNE4I3H5QNEM.LARGE.jpg"], "step_title": "Step 4: Part Assemblies(Cont.)"}, {"step": 5, "steps_text": "Used for the rest of the support structure was perforated metal strapping, for hanging pipes and other construction uses. The standard stuff found at hardware stores is too thin at 28 gauge, but 20 gauge was found online(eBay/Zoro.com)The strapping was still too thin to put through the ring roller, but it unrolled fairly well so it was formed by hand, using the wooden disc/template of the right size.        It was cut to length with enough extra to bend and screw it down, and the center of it placed onto the the threaded rod.        The first one as trial and error to get it correct, by using the equator as a guide the diameter was figured out and the bottom of was bent to line up with the base plate.        Then the holes in the strapping were counted and used as a measurement to make the rest the straps the same as the first. There are 6 pieces of the strapping but if this was done again, and one of the vertical support bars were removed, there would have been 7.       The metal strapping was positioned(as best as possible) and screwed to the base plate using self tapping hex headed screws.       Lastly the metal strapping was pop riveted to the equator support.", "step_imgs": ["https://cdn.instructables.com/FQY/KEKW/I3H5QPI6/FQYKEKWI3H5QPI6.LARGE.jpg", "https://cdn.instructables.com/FC7/S9AV/I3H5QPJL/FC7S9AVI3H5QPJL.LARGE.jpg", "https://cdn.instructables.com/F8X/BHD3/I3H5QRV0/F8XBHD3I3H5QRV0.LARGE.jpg", "https://cdn.instructables.com/FUG/BTIN/I3H5QPJM/FUGBTINI3H5QPJM.LARGE.jpg"], "step_title": "Step 5: Finalize Support Structure"}, {"step": 6, "steps_text": "The type of LED strip was chosen over other types for a few reasons.  See Pixel Chipset ComparisonPixel density, used here is 48 LEDs/Meter LPD8806. Other choices were 32 LEDs/Meter(WS2801), which was not enough. Or 60 LEDs/Meter(WS2812B) which was way too many. The rows should be the same distance apart as the pixels are on the strip, so the total amount of pixels can quickly get pretty big with the higher density strips.        Control and Data Rate, LPD8806 can accept data really quick over other options which allows higher frame rates. The control scheme is really simple, but unfortunately only has 7-bit color.        Cost and Availability, already had it in stock and its on the lower end cost wise vs the other chipsets.        Drawback is the 7-bit color and the strip is cuttable every 2 LEDs rather than every 1 like some types.Installation: Layout a control plan, where the first LED will be, the direction the strip will go and where the last LED is etc.(see attached image of patch for details)        Pick a direction and always run the LED strip the same direction(left to right or whatever)        Started on the equator, pulled the LED strip off the spool and cut it to length after it was applied. Didn't always make a full rotation, so there was a small gap left.        Using the same spacing as the LEDs, the next row up was applied and cut to length. Made it as straight as possible.        The middle rows are pretty flat and easy to mount as the rows went up higher and got more distorted the best method was to carefully bend/pinch the LED strip on the seams to make it sort of accordion. The change of the shape allows it to conform better to the shape of the sphere. But to much broke a few pads that had to be soldered back together.        As the LED strip was placed, the occasional zip tie was used to keep the LED strip in position since the adhesive was not going to help very much other than initial positioning. The LED strip didn't quite match up with the holes in the metal strapping, if built again a way would have to be found to make the holes match up with the LED spacing, as it would have made it a lot easier.        But at the very top top that method won't work, and LED strip rings had to be made for each row. Using single sections of LED strip and solid strand wire. Then taped to prevent shorts, but shrink tube should have been used.", "step_imgs": ["https://cdn.instructables.com/F74/4I6F/I3H5QU3H/F744I6FI3H5QU3H.LARGE.jpg", "https://cdn.instructables.com/F94/3FDJ/I3H5QTP2/F943FDJI3H5QTP2.LARGE.jpg", "https://cdn.instructables.com/FP9/UVZJ/I3H5QUAJ/FP9UVZJI3H5QUAJ.LARGE.jpg", "https://cdn.instructables.com/FZA/NVIW/I3H5QUDA/FZANVIWI3H5QUDA.LARGE.jpg", "https://cdn.instructables.com/F4D/YXHW/I3H5QTM8/F4DYXHWI3H5QTM8.LARGE.jpg", "https://cdn.instructables.com/F9J/AAXE/I3H5QTNJ/F9JAAXEI3H5QTNJ.LARGE.jpg", "https://cdn.instructables.com/F50/1WTY/I3H5QWZD/F501WTYI3H5QWZD.LARGE.jpg"], "step_title": "Step 6: LED Strip Installation"}, {"step": 7, "steps_text": "Wire It Up:With the layout plan ready, start wiring. This sphere is divided into two sections, top and bottom hemispheres. This leaves the option controlling them as one string or in two strings. The top half is considered the first string, so it has JST-SM connector on its DATAOUT, that DATAOUT can be connected to the bottom hemispheres DATAIN to make it one string, or the top and bottom DATAIN can be connected separately.          First cover the aluminum bar, where all the connections will be made, with electrical tape to prevent shorts.         Used solid strand to connect in series all the +5v and GND connections on the LED strip. (White and green wire, meant to use green for all the grounds)         Then used some 2-conductor twisted wire to connect the DAT and CLKs in series(red and black wire, also should have been different colors, but that is what was available)         Last some 4-conductor ribbon cable with JST-SM connectors was soldered to the data in of both strips and the data out of the top strip. The wires were made long enough to go out the bottom of the sphere into the base where the controller and power supply will be.Power Wires: The LED strip can't handle all the current that will run through them, which causes numerous problems(heat, voltage drop, etc) So a few direct connections to the power supply is required. This matrix is calculated to use up to 75 Amps at 5 volts, so it will need some solid power connections.Used some solid strand to snake a +5v and GND wire to every row on the opposite side of the sphere from the data connections. Stripped the insulation back, without cutting the wire and soldered it down to the proper pads. So it is all one piece of wire with solder points along it. Not a great method as the insulation can melt/burn and cause poor solder joints if one is not careful.         Then ran 3 pairs of 16 AWG stranded wire(heavy gauge red and black wire) out the bottom, that will connect directly to the power supply.", "step_imgs": ["https://cdn.instructables.com/FP8/Y5Q3/I3H5R8LB/FP8Y5Q3I3H5R8LB.LARGE.jpg", "https://cdn.instructables.com/F3H/R5FS/I3H5R8LC/F3HR5FSI3H5R8LC.LARGE.jpg", "https://cdn.instructables.com/FX1/LOGC/I3H5R8LD/FX1LOGCI3H5R8LD.LARGE.jpg", "https://cdn.instructables.com/F4F/SS4J/I3H5R8R7/F4FSS4JI3H5R8R7.LARGE.jpg", "https://cdn.instructables.com/FGL/R3KP/I3H5R8R8/FGLR3KPI3H5R8R8.LARGE.jpg"], "step_title": "Step 7: LED Strip Wiring"}, {"step": 8, "steps_text": "The base holds the controller, power supply, wires and connection jacks. A lamp reflector(domed sheet metal) from a halogen floor lamp was used as a lid.   3\" aluminum bar was ring rolled to fit inside the lid and form the outer wall.   The ring rolled outer wall was dry fit, marked for the AC socket(with merged power switch and fuse), XLR in/out,  USB jack, and a hole for the button.   Made the cut outs and holes on the outer wall. Test fit everything and made some adjustments with a file.    A 3/4\" thick plywood base plate was made with blocks added to hold the outer wall in place.   With the lid on, 4 holes were drilled through the lid into the base plate.   The base plate, lid and ring rolled outer wall were all primed then painted flat black.   4x T-nuts were installed into the base plate from the bottom.   Built brackets out of metal strapping for the power supply, and secured onto the base plate.   The lid was secured to the bottom of the sphere's bottom mounting bracket using pop rivets.   Wired up all the power wires, data wires, A.C. wires.(Some connections happen on next step)   Cut 4x bolts to length to fit through the lid into the base plate. Tapered the bolt ends with a grinder then re-tapped so they would be easier to insert.", "step_imgs": ["https://cdn.instructables.com/F2U/M5DH/I9IBOHCV/F2UM5DHI9IBOHCV.LARGE.jpg", "https://cdn.instructables.com/FD1/AZBT/I9IBOHEA/FD1AZBTI9IBOHEA.LARGE.jpg", "https://cdn.instructables.com/F59/U9ZL/IEV86T39/F59U9ZLIEV86T39.LARGE.jpg", "https://cdn.instructables.com/FFZ/0B57/I9IBOHEB/FFZ0B57I9IBOHEB.LARGE.jpg", "https://cdn.instructables.com/FX6/OA7E/I9IBOHHA/FX6OA7EI9IBOHHA.LARGE.jpg", "https://cdn.instructables.com/F94/WHT2/IEV86T3Z/F94WHT2IEV86T3Z.LARGE.jpg", "https://cdn.instructables.com/F7I/DZK2/I9IBOHIU/F7IDZK2I9IBOHIU.LARGE.jpg", "https://cdn.instructables.com/FBH/HCN6/I9IBOHH7/FBHHCN6I9IBOHH7.LARGE.jpg", "https://cdn.instructables.com/FLU/DYP3/IEV86RXU/FLUDYP3IEV86RXU.LARGE.jpg", "https://cdn.instructables.com/FMW/IXFE/I9IBOHH9/FMWIXFEI9IBOHH9.LARGE.jpg", "https://cdn.instructables.com/F6I/XZ8N/I9IBQ5HZ/F6IXZ8NI9IBQ5HZ.LARGE.jpg", "https://cdn.instructables.com/FX8/CSXW/I9IBOHIW/FX8CSXWI9IBOHIW.LARGE.jpg"], "step_title": "Step 8: Base and Power Supply"}, {"step": 9, "steps_text": "Choose A Controller:Lots of options out there, very much depends on what you want to do and how you want to do it.  With 1238 pixels that is 3714 channels of data or 8 DMX universes.The selected controller should be compatible with the software that will be used. Commonly 8-N-1 Serial over USB or an adapter is supported. Or Art-Net based solutions.Future NLED controllers will support video playback from an SD card for stand-alone video. In addition to expanding support to thousands of pixels. Recommended for most pixel types and configurations is a NLED Pixel Controller Mini or Pixel Controller Micro, as they support over 1024 pixels(at least 1238x of LPD8806, higher pixel amounts may be supported at varying baud rates and frame rates) and accepts a standard 8-N-1 serial signal(over RS-485 or TTL) at baud rates up to 1Mega baud(1,000,000, 4 times faster than DMX).For more advanced functionality and native USB control, the Pixel Controller Ion or Pixel Controller Electron could be used in conjunction with the Mass Control firmware.The choice for this project was a Pixel Controller Ion with special firmware. It supports both RS-485(differential serial) or USB for interfacing from the software.Arduino:This project would be easy enough to code for an Arduino, would only need to collect the serial bytes, frame it, and send it out the SPI bus to the LPD8806. Light Pollution: After some power up tests and some adjustments to the patch file, it was found that since the interior is all open that there as a a lot of light pollution causing washed out colors and for the support structure to produce shadows on the acrylic sphere. This effect was expected, but not so much of it. So a solution was found to use black vinyl strips, same as vehicle and window decals, as wide as the LED spacing with holes cut out for the LEDs. Vinyl is naturally glossy, so the strips, while still on their backing paper, were sanded with 320-400 grit stand paper to make them matte. They were applied over the entire support structure. Made a huge difference in image quality.", "step_imgs": ["https://cdn.instructables.com/FBL/VEIM/I9IBQ5HP/FBLVEIMI9IBQ5HP.LARGE.jpg", "https://cdn.instructables.com/FTH/EZCL/I9IBQ5HO/FTHEZCLI9IBQ5HO.LARGE.jpg", "https://cdn.instructables.com/FY9/875C/I9IBQ5HS/FY9875CI9IBQ5HS.LARGE.jpg", "https://cdn.instructables.com/FX2/UF3Y/I9IBQ5I4/FX2UF3YI9IBQ5I4.LARGE.jpg", "https://cdn.instructables.com/FVJ/2E33/ICP0Y5BE/FVJ2E33ICP0Y5BE.LARGE.jpg"], "step_title": "Step 9: LED Pixel Controller"}, {"step": 10, "steps_text": "Software Options:NLED Matrix: http://www.nledshop.com/nledmatrix/Free, Open Source, Modifiable. Processing 3.0Serial/TCP/UDP/WiFi communication methods.Patch / Mapping support for odd-shaped matrices.MOV and AVI movie file support. Webcam/Capture capable, use third-party visualizers like MilkdropNot fully developed and buggy. May be revamped in the future.Glediator(Recommended): http://www.solderlab.de/Free and refined.Many generated content options.No MOV or AVI support.Stable and easily configurable.No native advanced pixel mapping / patching, but can be through application.Jinx: http://www.live-leds.de/downloads/Free and refined.AVI movie file support.Many generated content options.Webcam/Capture capableNo native advanced pixel mapping / patching, but can be through application.Both Glediator and Jinx can support Patching / Mapping for odd-shaped matrices via another software application NLED Live Patcher.MADRIX could also be used with the proper controller.Used here and developed for projects such as this is NLED Matrix, it is free, open source, and versatile. It supports single color, RGB, and RGBW(in the future) LED matrices. With a simple(and customizable) control protocol, that can interface with serial(COM ports) UDP, and TCP communication. Since the LEDs are laid out in a non-rectangular arrangement, the software has to be told what order/position the LEDs are arranged in so it can send out the data in the correct order. This is called pixel patching or mapping, and not many software applications support it. A project like this can not be controlled without pixel mapping / patching. The NLED Matrix Patcher software can be used to create custom and unique coordinate files that are used to pixel patch or pixel map. NLED Matrix supports the coordinate patch file, and other third-party software, such as Glediator, can support pixel patching/mapping using the software application NLED Live Patcher. NLED Live Patcher intercepts a virtual serial port(via com0com or similar) and using the coordinate patch file, it reorganizes the data and sends it out to a physical port.NLED Matrix Patcher(Free and Open Source) - Used to create coordinate patch/map files of any size, shape, and non-contiguous matrices.NLED Live Patcher(Free and Open Source) - Intercepts serial data streams using virtual serial ports and applies a patch/map coordinate file and retransmits to the physical serial port(USB or otherwise). Plan to add TCP/UDP and Art-Net to compatibility to future releases.Content: Odd shapes and low resolutions(this is 68x24) makes it difficult to use most videos and footage. The process of shrinking a video source down causes the end result to be washed out with no detail or contrast. Most of the content would have to be made specifically for the sphere. The software applications can create generated content such as text, falling blocks, color effects, and similar. The feeds they create are scaled to the matrix size and are usually a good choice for content.Otherwise videos could be made in Adobe After Effects or similar software that can create graphic effects. The created video should match the matrix size(example, 68x24 pixels in size)", "step_imgs": ["https://cdn.instructables.com/F3C/QD7Z/ICP0Y5Y9/F3CQD7ZICP0Y5Y9.LARGE.jpg", "https://cdn.instructables.com/FRY/N6D6/ICP0Y5BC/FRYN6D6ICP0Y5BC.LARGE.jpg", "https://cdn.instructables.com/FM0/TQD1/IT22NW3Z/FM0TQD1IT22NW3Z.LARGE.jpg", "https://cdn.instructables.com/FX1/93P2/IT22NW40/FX193P2IT22NW40.LARGE.jpg"], "step_title": "Step 10: Software and Content"}, {"step": 11, "steps_text": "Find updates and more information on the project's webpage at http://www.nledshop.com/projects/spherematrix/Thanks for reading, please visit our store for Made In The USA LED Controllers and LED Products at www.NLEDshop.com. And checkout our available Free Software.Or find more projects that utilize NLED products on our Instructables Profile or the Projects Page on our website. Subscribe on YouTube to get notified of new videos and projects.Please Contact Us with any questions, comments, bug reports or if you have an idea for a product or feature.NLED is available for embedded programming, firmware design, hardware design, product design, and consultation. Please Contact Us to discuss your project.", "step_imgs": ["https://cdn.instructables.com/FBL/VEIM/I9IBQ5HP/FBLVEIMI9IBQ5HP.LARGE.jpg", "https://cdn.instructables.com/FTH/EZCL/I9IBQ5HO/FTHEZCLI9IBQ5HO.LARGE.jpg", "https://cdn.instructables.com/FQ0/RWT7/ICP0Y65S/FQ0RWT7ICP0Y65S.LARGE.jpg"], "step_title": "Step 11: Usage and Final Thoughts"}], "channel": "LEDs"}, {"category": "technology", "description": "This is a step by step walk through of how to set-up and use Quartus software and upload it to the Altera Cyclone FPGA. \u00a0Done as a primer for my school's(Ivy Tech CC) Digital Fundementals EECT122 course. \u00a0This will cover in great detail the exact method to setup the software, your design and upload it to the FPGA(Field Programmable Gate Array) board. \u00a0", "title": "The Altera FPGA and Quartus II Software", "url": "https://www.instructables.com/id/The-Altera-FPGA-and-Quartus-II-software/", "section": "technology", "steps": [{"step": 1, "steps_text": "Double click the Quartus Icon on the desktop. \u00a0", "step_imgs": ["https://cdn.instructables.com/FKW/84SN/H8CVFPEF/FKW84SNH8CVFPEF.LARGE.jpg"], "step_title": "Step 1: Open Quartus"}, {"step": 2, "steps_text": "Once Quartus opens you will see this screen. \u00a0Go to the New Project Wizard located in the File tab. \u00a0\nCreate a parent folder on your flash drive. \u00a0 You want this on your flash drive because anything saved on the colleges hard-drives may not be there next class. \u00a0\nCreate a parent folder where you want to keep all of your Labs! \u00a0i.e. \u00a0G:\\Joe_Schmo_jumpdrive\\EECT122\\Next:\nCreate a child folder this particular lab will be stored. \u00a0i.e. \u00a0G:\\Joe_Schmo\\EECT122\\Lab_1-1\\\n\u00a0You can do this either in windows explorer or directly in the program Quartus.\u00a0IMPORTANT!!!!:\nVERY IMPORTANT!!!!!!!!!:\nFor quartus to work right, your build files(.bdf/.vhd/.etc) need to be in a folder(your child folder) that has the same name as the projects. \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FAH/RWTI/H8CVFPEV/FAHRWTIH8CVFPEV.LARGE.jpg", "https://cdn.instructables.com/FNP/MAXD/H8CVFPF9/FNPMAXDH8CVFPF9.LARGE.jpg"], "step_title": "Step 2: Folders"}, {"step": 3, "steps_text": "Wizards are great aren't they? \u00a0This one guides you through the initial setup of your project. \u00a0After selecting the appropriate name of your parent folder and creating an appropriate child folder, it's time to name your project. \u00a0You want to call it \"I rock Ivy Tech EE\" I know. \u00a0But if you do that and it doesn't match the child folder you've create, the software will get really confuses later on. \u00a0Just name your project the EXACT same thing as the child folder. \u00a0In the picture below it is \"tutorial.\" \u00a0And so EVERY different type of file in this project will get named \"tutorial.\" \u00a0\ntutorial.bdf\ntutorial.vdl\nturorial.etc\nAfter that's done, click next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FE9/RL8D/H8CVFPFV/FE9RL8DH8CVFPFV.LARGE.jpg"], "step_title": "Step 3: New Project Wizard"}, {"step": 4, "steps_text": "Do you want to add files. \u00a0Well for our purposes NO. \u00a0Click next without hitting anything. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB7/BRVM/H8CVFPG5/FB7BRVMH8CVFPG5.LARGE.jpg"], "step_title": "Step 4: Add Files"}, {"step": 5, "steps_text": "In this class we are using the Cyclone II\u00a0EP2C20F484C7.", "step_imgs": ["https://cdn.instructables.com/FQB/FTAD/H8CVFPGT/FQBFTADH8CVFPGT.LARGE.jpg", "https://cdn.instructables.com/F1F/3FXP/H8CVFPGU/F1F3FXPH8CVFPGU.LARGE.jpg"], "step_title": "Step 5: Select the Right Board"}, {"step": 6, "steps_text": "You don't need any tools. \u00a0Hit next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FPI/C7FF/H8CVFPH7/FPIC7FFH8CVFPH7.LARGE.jpg"], "step_title": "Step 6: EDA Tools?"}, {"step": 7, "steps_text": "Everything look right?\u00a0\nWell hit finish and lets get started programming a FPGA. \u00a0", "step_imgs": ["https://cdn.instructables.com/F3W/KF8M/H8CVFPHE/F3WKF8MH8CVFPHE.LARGE.jpg"], "step_title": "Step 7: Finish Your Set Up"}, {"step": 8, "steps_text": "We will now begin to enter gates and create a schematic \"program\" to be executed on the hardware\u00a0development\u00a0board. \u00a0\nGo to the\u00a0FILE\u00a0tab and hit New.\u00a0 Here you will have the option to create many different types of files. \u00a0 For this tutorial we will be creating a Block Diagram/Schematic File.", "step_imgs": ["https://cdn.instructables.com/FQ0/2DCU/HCB8CRRW/FQ02DCUHCB8CRRW.LARGE.jpg", "https://cdn.instructables.com/FC2/5C7S/HCB8CRFI/FC25C7SHCB8CRFI.LARGE.jpg", "https://cdn.instructables.com/F6E/LG63/HCB8CRFS/F6ELG63HCB8CRFS.LARGE.jpg"], "step_title": "Step 8: Block Diagram/ Schematic"}, {"step": 9, "steps_text": "It is highly recommended that you save the file at this time. \u00a0 Remember, this file name \" *.bdf \" must be the same name as the folder that was created earlier on. \u00a0Steps 1 though 8 go about created other files that are needed for everything to work properly and if this \".DBF\" (Diagram-Block) file does not live in that same folder, it won't work right.\nSo for this example I saved it as \"G:\\tutorial.bdf", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg"], "step_title": "Step 9: Save the File"}, {"step": 10, "steps_text": "Now the fun part begins. \u00a0 This is where we create the schematic. \u00a0 On the left of this new window are various tools you can use to add logic gates and other parts to complete your project. \u00a0You are able to turns wires into buses, add text, zoom in and out, and many other things through the buttons on the left. \u00a0\nThe third picture in this series shows a diagram of a 4 bit comparator that was created rather quickly. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB2/UL4S/HCB8CRGC/FB2UL4SHCB8CRGC.LARGE.jpg", "https://cdn.instructables.com/FOA/0JLY/HCB8CRGD/FOA0JLYHCB8CRGD.LARGE.jpg", "https://cdn.instructables.com/FJW/TGRK/HCB8CRGE/FJWTGRKHCB8CRGE.LARGE.jpg"], "step_title": "Step 10: Create a Schematic"}, {"step": 11, "steps_text": "Just like written code, schematic diagrams must be compiled into machine code for it to be used. \u00a0 Also like writing programming language, this is where you get error and must debug things. \u00a0The error messages provided by Quartus tend to be much more useful than other messages from IDE compilers. \u00a0\nUp at the top tool bar,\u00a0 the button that looks like play button will start the compilation.\nYou can also navigate to the \"Processing Tab\" and hit \"Start Compilation\".", "step_imgs": ["https://cdn.instructables.com/FVT/XKAL/HCB8CRH7/FVTXKALHCB8CRH7.LARGE.jpg", "https://cdn.instructables.com/FWF/N9HQ/HCB8CRH8/FWFN9HQHCB8CRH8.LARGE.jpg"], "step_title": "Step 11: Start Compilation"}, {"step": 12, "steps_text": "If you are successful your screen will look similar to image 2. \u00a0\nYou must save the compiled BDF before proceeding to create a Vector Waveform. \u00a0", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FCB/55SG/HCB8CRJ8/FCB55SGHCB8CRJ8.LARGE.jpg"], "step_title": "Step 12: Save"}, {"step": 13, "steps_text": "So you've wired some virtual chips together and it works. \u00a0Now it's time to see what the output actually is and determine if it's what was expected. \u00a0To do that we are going to use a Vector Waveform file.\u00a0\nUnder the File tab, \u00a0select New,\u00a0and then\u00a0Vector Waveform file.\nThis screen should look familiar, it is the same place where we created the Block Diagram file.", "step_imgs": ["https://cdn.instructables.com/FRC/JNHU/HCB8CRM7/FRCJNHUHCB8CRM7.LARGE.jpg", "https://cdn.instructables.com/FKR/YN1J/HCB8CRM4/FKRYN1JHCB8CRM4.LARGE.jpg", "https://cdn.instructables.com/FG4/78CR/HCB8CRO9/FG478CRHCB8CRO9.LARGE.jpg"], "step_title": "Step 13: Vector Waveforms"}, {"step": 14, "steps_text": "Once\u00a0again, \u00a0Immediately\u00a0after creating the new vector waveform file, \u00a0Re-save it with the SAME name as the parent folder. \u00a0\nSo for this tutorial it is saved as \"G:\\Joe_Schmo\\EECT122\\Lab_1-1\\tutorial\\tutorial.VCF\"", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FRU/QLMT/HCB8CROS/FRUQLMTHCB8CROS.LARGE.jpg"], "step_title": "Step 14: SAVE"}, {"step": 15, "steps_text": "Typically, this window pops up with a total time to analyse the output of your circuit of 20 nanoseconds. \u00a0That is a little short on time. \u00a0We will change this by navigating to the Edit tab, and selecting End Time.\nIn this class, 16 micro-seconds will be a nice time frame to work with. \u00a0Some labs might specify a different time, this is where you change that. \u00a0", "step_imgs": ["https://cdn.instructables.com/FES/YV1V/HCB8CRPH/FESYV1VHCB8CRPH.LARGE.jpg", "https://cdn.instructables.com/FMG/77OD/HCB8CRPI/FMG77ODHCB8CRPI.LARGE.jpg"], "step_title": "Step 15: Setting Up the Waveform File-End Time"}, {"step": 16, "steps_text": "The grid size doesn't automatically change. \u00a0So want to change it. \u00a0 Under the Edit tab, click Grid Size.\u00a0\nInside the dialogue window, edit the boxes and double check that you have selected the right scale(nano, micro, milli).\u00a0\nAfter the settings are correct, \u00a0Use the keyboard shortcut and press CTRL W to view the entire timeline. \u00a0It should look like picture 3. \u00a0", "step_imgs": ["https://cdn.instructables.com/F0G/HX5G/HCB8CRQ6/F0GHX5GHCB8CRQ6.LARGE.jpg", "https://cdn.instructables.com/FAC/EY6R/HCB8CRQ7/FACEY6RHCB8CRQ7.LARGE.jpg"], "step_title": "Step 16: Setting Up the Waveform File-Edit Grid Size"}, {"step": 17, "steps_text": "Now that the vector file is configured properly we need to import or link to the inputs and outputs created in our Schematic file. \u00a0\nRight click on the left panel. \u00a0Scroll down to INSERT and over to INSERT NODE OR BUS.\nThis will bring up a new window with several options. \u00a0Underneath the cancel button, is a button called NODE FINDER. \u00a0Press that button and leave the other options alone. \u00a0\nThis brings up a new window called NODE FINDER. \u00a0\n----At the top middle, scroll down and select \"Pins: All\" \u00a0\n----next, over to the right is a button that says list. \u00a0It searches for the pins in your schematic. \u00a0Hit that button.\n----Once pins are in the left tab, we need to select them. \u00a0This can be done individually if needed with the single arrow button, \u00a0or all pins at once with the double arrow button. \u00a0\n-----Lastly, Click OK in the \"Node Finder\" window and also OK in the \"Insert Node or Bus\" window.", "step_imgs": ["https://cdn.instructables.com/FL8/63GB/HCB8CRQP/FL863GBHCB8CRQP.LARGE.jpg", "https://cdn.instructables.com/FKM/CEQY/HCB8CRQQ/FKMCEQYHCB8CRQQ.LARGE.jpg", "https://cdn.instructables.com/FC4/NJ18/HCB8CRQR/FC4NJ18HCB8CRQR.LARGE.jpg", "https://cdn.instructables.com/FWK/ZH6J/HCB8CRQS/FWKZH6JHCB8CRQS.LARGE.jpg", "https://cdn.instructables.com/FAD/X7ZA/HCB8CRQT/FADX7ZAHCB8CRQT.LARGE.jpg", "https://cdn.instructables.com/FOD/1EU2/HCB8CRQU/FOD1EU2HCB8CRQU.LARGE.jpg"], "step_title": "Step 17: Add Inputs and Outputs"}, {"step": 18, "steps_text": "This simulation will run your circuit and easily allow you to change the inputs.\u00a0 This was our whole goal.\nThe first two pictures show my comparator circuit will no inputs.\u00a0 Both data streams here A and B have no data, thus they are equal and the \"W\" output goes high.\u00a0\nThe next few pictures will show how to change the input and what happens to the output \"W\" when the two data streams are not equal.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/F4C/FG76/HCB8L7UF/F4CFG76HCB8L7UF.LARGE.jpg", "https://cdn.instructables.com/FO2/JCVU/HCB8CWGU/FO2JCVUHCB8CWGU.LARGE.jpg"], "step_title": "Step 18: Simulating"}, {"step": 19, "steps_text": "\n\t\tRight click the input on the left hand column.\n\t\tScroll down to Value and over to Count value or some other value(Like Clock).\n\t\tShown is \"count value.\" I will use Hex for this purpose\n\t\tThis brings up a pop-up with option for how much to count by and when to count by.\u00a0 (Change time and value)\n\t\tDo the same thing for the \"B\" data stream.\n\t\tNo highlight a few clock cycles and you can manually change them by right clicking on the highlighted area and selecting the value.\u00a0\n\t\tNotice in this last picture that the two data stream are now no longer equal.\u00a0\n\t\tAnd the result is a low where the two data streams do not match up.\u00a0", "step_imgs": ["https://cdn.instructables.com/FMO/WXAL/HCB8IMD7/FMOWXALHCB8IMD7.LARGE.jpg", "https://cdn.instructables.com/F9D/600Y/HCB8U7EE/F9D600YHCB8U7EE.LARGE.jpg", "https://cdn.instructables.com/FFB/QZRF/HCB8TO1W/FFBQZRFHCB8TO1W.LARGE.jpg", "https://cdn.instructables.com/FP9/SQHS/HCB8TO1V/FP9SQHSHCB8TO1V.LARGE.jpg", "https://cdn.instructables.com/FLJ/P1QM/HCB8L7UR/FLJP1QMHCB8L7UR.LARGE.jpg", "https://cdn.instructables.com/F0D/QYXY/HCB8REEN/F0DQYXYHCB8REEN.LARGE.jpg", "https://cdn.instructables.com/FTH/MJZ2/HCB8REE6/FTHMJZ2HCB8REE6.LARGE.jpg", "https://cdn.instructables.com/F91/38E2/HCB8U7EY/F9138E2HCB8U7EY.LARGE.jpg"], "step_title": "Step 19: Changing the Input of the Circuit."}, {"step": 20, "steps_text": "\n          We have now created and function circuit with virtual gates and now we want to see it in real life.\u00a0\n\n\t\tFirst thing is to assign to the pins on the Alterra board that we are going to use.\u00a0 For this example we need 8 input pins and one output indicator. The DOC attached to this step has the Alterra pin assignments.\u00a0", "step_imgs": ["https://cdn.instructables.com/FCY/AWBM/HCB8F2OU/FCYAWBMHCB8F2OU.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 20: Download to Board"}, {"step": 21, "steps_text": "Go to the Assignments tab and down to Pin Planner.\nThis brings up a new window.\u00a0 Go ahead and maximize it.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FW0/1XMR/HCB8U7H2/FW01XMRHCB8U7H2.LARGE.jpg", "https://cdn.instructables.com/F3M/ZNXI/HCB8REO3/F3MZNXIHCB8REO3.LARGE.jpg", "https://cdn.instructables.com/FD0/TQJZ/HCB883H1/FD0TQJZHCB883H1.LARGE.jpg"], "step_title": "Step 21: Pin Planner"}, {"step": 22, "steps_text": "In this pin assignment window, you can select the individual pins by clicking in the location field and typing or searching for the correct pins.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FLN/4246/HCJODIEP/FLN4246HCJODIEP.LARGE.jpg", "https://cdn.instructables.com/F0C/TNVE/HCJNWL54/F0CTNVEHCJNWL54.LARGE.jpg"], "step_title": "Step 22: Pin Planner 2"}, {"step": 23, "steps_text": "This last step is the easy one.\u00a0\nGo to TOOLS and down to Programmer.\nThis will bring up a new window;\u00a0 check to make sure it says Blaster and click Start.\u00a0\nCongrats you're Done.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FQE/55Q9/HCRVR3SW/FQE55Q9HCRVR3SW.LARGE.jpg", "https://cdn.instructables.com/F2X/5RL4/HCJNWL5E/F2X5RL4HCJNWL5E.LARGE.jpg"], "step_title": "Step 23: Get It on the Board"}], "channel": "Software"}, {"category": "technology", "description": "This is a step by step walk through of how to set-up and use Quartus software and upload it to the Altera Cyclone FPGA. \u00a0Done as a primer for my school's(Ivy Tech CC) Digital Fundementals EECT122 course. \u00a0This will cover in great detail the exact method to setup the software, your design and upload it to the FPGA(Field Programmable Gate Array) board. \u00a0", "title": "The Altera FPGA and Quartus II Software", "url": "https://www.instructables.com/id/The-Altera-FPGA-and-Quartus-II-software/", "section": "technology", "steps": [{"step": 1, "steps_text": "Double click the Quartus Icon on the desktop. \u00a0", "step_imgs": ["https://cdn.instructables.com/FKW/84SN/H8CVFPEF/FKW84SNH8CVFPEF.LARGE.jpg"], "step_title": "Step 1: Open Quartus"}, {"step": 2, "steps_text": "Once Quartus opens you will see this screen. \u00a0Go to the New Project Wizard located in the File tab. \u00a0\nCreate a parent folder on your flash drive. \u00a0 You want this on your flash drive because anything saved on the colleges hard-drives may not be there next class. \u00a0\nCreate a parent folder where you want to keep all of your Labs! \u00a0i.e. \u00a0G:\\Joe_Schmo_jumpdrive\\EECT122\\Next:\nCreate a child folder this particular lab will be stored. \u00a0i.e. \u00a0G:\\Joe_Schmo\\EECT122\\Lab_1-1\\\n\u00a0You can do this either in windows explorer or directly in the program Quartus.\u00a0IMPORTANT!!!!:\nVERY IMPORTANT!!!!!!!!!:\nFor quartus to work right, your build files(.bdf/.vhd/.etc) need to be in a folder(your child folder) that has the same name as the projects. \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FAH/RWTI/H8CVFPEV/FAHRWTIH8CVFPEV.LARGE.jpg", "https://cdn.instructables.com/FNP/MAXD/H8CVFPF9/FNPMAXDH8CVFPF9.LARGE.jpg"], "step_title": "Step 2: Folders"}, {"step": 3, "steps_text": "Wizards are great aren't they? \u00a0This one guides you through the initial setup of your project. \u00a0After selecting the appropriate name of your parent folder and creating an appropriate child folder, it's time to name your project. \u00a0You want to call it \"I rock Ivy Tech EE\" I know. \u00a0But if you do that and it doesn't match the child folder you've create, the software will get really confuses later on. \u00a0Just name your project the EXACT same thing as the child folder. \u00a0In the picture below it is \"tutorial.\" \u00a0And so EVERY different type of file in this project will get named \"tutorial.\" \u00a0\ntutorial.bdf\ntutorial.vdl\nturorial.etc\nAfter that's done, click next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FE9/RL8D/H8CVFPFV/FE9RL8DH8CVFPFV.LARGE.jpg"], "step_title": "Step 3: New Project Wizard"}, {"step": 4, "steps_text": "Do you want to add files. \u00a0Well for our purposes NO. \u00a0Click next without hitting anything. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB7/BRVM/H8CVFPG5/FB7BRVMH8CVFPG5.LARGE.jpg"], "step_title": "Step 4: Add Files"}, {"step": 5, "steps_text": "In this class we are using the Cyclone II\u00a0EP2C20F484C7.", "step_imgs": ["https://cdn.instructables.com/FQB/FTAD/H8CVFPGT/FQBFTADH8CVFPGT.LARGE.jpg", "https://cdn.instructables.com/F1F/3FXP/H8CVFPGU/F1F3FXPH8CVFPGU.LARGE.jpg"], "step_title": "Step 5: Select the Right Board"}, {"step": 6, "steps_text": "You don't need any tools. \u00a0Hit next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FPI/C7FF/H8CVFPH7/FPIC7FFH8CVFPH7.LARGE.jpg"], "step_title": "Step 6: EDA Tools?"}, {"step": 7, "steps_text": "Everything look right?\u00a0\nWell hit finish and lets get started programming a FPGA. \u00a0", "step_imgs": ["https://cdn.instructables.com/F3W/KF8M/H8CVFPHE/F3WKF8MH8CVFPHE.LARGE.jpg"], "step_title": "Step 7: Finish Your Set Up"}, {"step": 8, "steps_text": "We will now begin to enter gates and create a schematic \"program\" to be executed on the hardware\u00a0development\u00a0board. \u00a0\nGo to the\u00a0FILE\u00a0tab and hit New.\u00a0 Here you will have the option to create many different types of files. \u00a0 For this tutorial we will be creating a Block Diagram/Schematic File.", "step_imgs": ["https://cdn.instructables.com/FQ0/2DCU/HCB8CRRW/FQ02DCUHCB8CRRW.LARGE.jpg", "https://cdn.instructables.com/FC2/5C7S/HCB8CRFI/FC25C7SHCB8CRFI.LARGE.jpg", "https://cdn.instructables.com/F6E/LG63/HCB8CRFS/F6ELG63HCB8CRFS.LARGE.jpg"], "step_title": "Step 8: Block Diagram/ Schematic"}, {"step": 9, "steps_text": "It is highly recommended that you save the file at this time. \u00a0 Remember, this file name \" *.bdf \" must be the same name as the folder that was created earlier on. \u00a0Steps 1 though 8 go about created other files that are needed for everything to work properly and if this \".DBF\" (Diagram-Block) file does not live in that same folder, it won't work right.\nSo for this example I saved it as \"G:\\tutorial.bdf", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg"], "step_title": "Step 9: Save the File"}, {"step": 10, "steps_text": "Now the fun part begins. \u00a0 This is where we create the schematic. \u00a0 On the left of this new window are various tools you can use to add logic gates and other parts to complete your project. \u00a0You are able to turns wires into buses, add text, zoom in and out, and many other things through the buttons on the left. \u00a0\nThe third picture in this series shows a diagram of a 4 bit comparator that was created rather quickly. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB2/UL4S/HCB8CRGC/FB2UL4SHCB8CRGC.LARGE.jpg", "https://cdn.instructables.com/FOA/0JLY/HCB8CRGD/FOA0JLYHCB8CRGD.LARGE.jpg", "https://cdn.instructables.com/FJW/TGRK/HCB8CRGE/FJWTGRKHCB8CRGE.LARGE.jpg"], "step_title": "Step 10: Create a Schematic"}, {"step": 11, "steps_text": "Just like written code, schematic diagrams must be compiled into machine code for it to be used. \u00a0 Also like writing programming language, this is where you get error and must debug things. \u00a0The error messages provided by Quartus tend to be much more useful than other messages from IDE compilers. \u00a0\nUp at the top tool bar,\u00a0 the button that looks like play button will start the compilation.\nYou can also navigate to the \"Processing Tab\" and hit \"Start Compilation\".", "step_imgs": ["https://cdn.instructables.com/FVT/XKAL/HCB8CRH7/FVTXKALHCB8CRH7.LARGE.jpg", "https://cdn.instructables.com/FWF/N9HQ/HCB8CRH8/FWFN9HQHCB8CRH8.LARGE.jpg"], "step_title": "Step 11: Start Compilation"}, {"step": 12, "steps_text": "If you are successful your screen will look similar to image 2. \u00a0\nYou must save the compiled BDF before proceeding to create a Vector Waveform. \u00a0", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FCB/55SG/HCB8CRJ8/FCB55SGHCB8CRJ8.LARGE.jpg"], "step_title": "Step 12: Save"}, {"step": 13, "steps_text": "So you've wired some virtual chips together and it works. \u00a0Now it's time to see what the output actually is and determine if it's what was expected. \u00a0To do that we are going to use a Vector Waveform file.\u00a0\nUnder the File tab, \u00a0select New,\u00a0and then\u00a0Vector Waveform file.\nThis screen should look familiar, it is the same place where we created the Block Diagram file.", "step_imgs": ["https://cdn.instructables.com/FRC/JNHU/HCB8CRM7/FRCJNHUHCB8CRM7.LARGE.jpg", "https://cdn.instructables.com/FKR/YN1J/HCB8CRM4/FKRYN1JHCB8CRM4.LARGE.jpg", "https://cdn.instructables.com/FG4/78CR/HCB8CRO9/FG478CRHCB8CRO9.LARGE.jpg"], "step_title": "Step 13: Vector Waveforms"}, {"step": 14, "steps_text": "Once\u00a0again, \u00a0Immediately\u00a0after creating the new vector waveform file, \u00a0Re-save it with the SAME name as the parent folder. \u00a0\nSo for this tutorial it is saved as \"G:\\Joe_Schmo\\EECT122\\Lab_1-1\\tutorial\\tutorial.VCF\"", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FRU/QLMT/HCB8CROS/FRUQLMTHCB8CROS.LARGE.jpg"], "step_title": "Step 14: SAVE"}, {"step": 15, "steps_text": "Typically, this window pops up with a total time to analyse the output of your circuit of 20 nanoseconds. \u00a0That is a little short on time. \u00a0We will change this by navigating to the Edit tab, and selecting End Time.\nIn this class, 16 micro-seconds will be a nice time frame to work with. \u00a0Some labs might specify a different time, this is where you change that. \u00a0", "step_imgs": ["https://cdn.instructables.com/FES/YV1V/HCB8CRPH/FESYV1VHCB8CRPH.LARGE.jpg", "https://cdn.instructables.com/FMG/77OD/HCB8CRPI/FMG77ODHCB8CRPI.LARGE.jpg"], "step_title": "Step 15: Setting Up the Waveform File-End Time"}, {"step": 16, "steps_text": "The grid size doesn't automatically change. \u00a0So want to change it. \u00a0 Under the Edit tab, click Grid Size.\u00a0\nInside the dialogue window, edit the boxes and double check that you have selected the right scale(nano, micro, milli).\u00a0\nAfter the settings are correct, \u00a0Use the keyboard shortcut and press CTRL W to view the entire timeline. \u00a0It should look like picture 3. \u00a0", "step_imgs": ["https://cdn.instructables.com/F0G/HX5G/HCB8CRQ6/F0GHX5GHCB8CRQ6.LARGE.jpg", "https://cdn.instructables.com/FAC/EY6R/HCB8CRQ7/FACEY6RHCB8CRQ7.LARGE.jpg"], "step_title": "Step 16: Setting Up the Waveform File-Edit Grid Size"}, {"step": 17, "steps_text": "Now that the vector file is configured properly we need to import or link to the inputs and outputs created in our Schematic file. \u00a0\nRight click on the left panel. \u00a0Scroll down to INSERT and over to INSERT NODE OR BUS.\nThis will bring up a new window with several options. \u00a0Underneath the cancel button, is a button called NODE FINDER. \u00a0Press that button and leave the other options alone. \u00a0\nThis brings up a new window called NODE FINDER. \u00a0\n----At the top middle, scroll down and select \"Pins: All\" \u00a0\n----next, over to the right is a button that says list. \u00a0It searches for the pins in your schematic. \u00a0Hit that button.\n----Once pins are in the left tab, we need to select them. \u00a0This can be done individually if needed with the single arrow button, \u00a0or all pins at once with the double arrow button. \u00a0\n-----Lastly, Click OK in the \"Node Finder\" window and also OK in the \"Insert Node or Bus\" window.", "step_imgs": ["https://cdn.instructables.com/FL8/63GB/HCB8CRQP/FL863GBHCB8CRQP.LARGE.jpg", "https://cdn.instructables.com/FKM/CEQY/HCB8CRQQ/FKMCEQYHCB8CRQQ.LARGE.jpg", "https://cdn.instructables.com/FC4/NJ18/HCB8CRQR/FC4NJ18HCB8CRQR.LARGE.jpg", "https://cdn.instructables.com/FWK/ZH6J/HCB8CRQS/FWKZH6JHCB8CRQS.LARGE.jpg", "https://cdn.instructables.com/FAD/X7ZA/HCB8CRQT/FADX7ZAHCB8CRQT.LARGE.jpg", "https://cdn.instructables.com/FOD/1EU2/HCB8CRQU/FOD1EU2HCB8CRQU.LARGE.jpg"], "step_title": "Step 17: Add Inputs and Outputs"}, {"step": 18, "steps_text": "This simulation will run your circuit and easily allow you to change the inputs.\u00a0 This was our whole goal.\nThe first two pictures show my comparator circuit will no inputs.\u00a0 Both data streams here A and B have no data, thus they are equal and the \"W\" output goes high.\u00a0\nThe next few pictures will show how to change the input and what happens to the output \"W\" when the two data streams are not equal.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/F4C/FG76/HCB8L7UF/F4CFG76HCB8L7UF.LARGE.jpg", "https://cdn.instructables.com/FO2/JCVU/HCB8CWGU/FO2JCVUHCB8CWGU.LARGE.jpg"], "step_title": "Step 18: Simulating"}, {"step": 19, "steps_text": "\n\t\tRight click the input on the left hand column.\n\t\tScroll down to Value and over to Count value or some other value(Like Clock).\n\t\tShown is \"count value.\" I will use Hex for this purpose\n\t\tThis brings up a pop-up with option for how much to count by and when to count by.\u00a0 (Change time and value)\n\t\tDo the same thing for the \"B\" data stream.\n\t\tNo highlight a few clock cycles and you can manually change them by right clicking on the highlighted area and selecting the value.\u00a0\n\t\tNotice in this last picture that the two data stream are now no longer equal.\u00a0\n\t\tAnd the result is a low where the two data streams do not match up.\u00a0", "step_imgs": ["https://cdn.instructables.com/FMO/WXAL/HCB8IMD7/FMOWXALHCB8IMD7.LARGE.jpg", "https://cdn.instructables.com/F9D/600Y/HCB8U7EE/F9D600YHCB8U7EE.LARGE.jpg", "https://cdn.instructables.com/FFB/QZRF/HCB8TO1W/FFBQZRFHCB8TO1W.LARGE.jpg", "https://cdn.instructables.com/FP9/SQHS/HCB8TO1V/FP9SQHSHCB8TO1V.LARGE.jpg", "https://cdn.instructables.com/FLJ/P1QM/HCB8L7UR/FLJP1QMHCB8L7UR.LARGE.jpg", "https://cdn.instructables.com/F0D/QYXY/HCB8REEN/F0DQYXYHCB8REEN.LARGE.jpg", "https://cdn.instructables.com/FTH/MJZ2/HCB8REE6/FTHMJZ2HCB8REE6.LARGE.jpg", "https://cdn.instructables.com/F91/38E2/HCB8U7EY/F9138E2HCB8U7EY.LARGE.jpg"], "step_title": "Step 19: Changing the Input of the Circuit."}, {"step": 20, "steps_text": "\n          We have now created and function circuit with virtual gates and now we want to see it in real life.\u00a0\n\n\t\tFirst thing is to assign to the pins on the Alterra board that we are going to use.\u00a0 For this example we need 8 input pins and one output indicator. The DOC attached to this step has the Alterra pin assignments.\u00a0", "step_imgs": ["https://cdn.instructables.com/FCY/AWBM/HCB8F2OU/FCYAWBMHCB8F2OU.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 20: Download to Board"}, {"step": 21, "steps_text": "Go to the Assignments tab and down to Pin Planner.\nThis brings up a new window.\u00a0 Go ahead and maximize it.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FW0/1XMR/HCB8U7H2/FW01XMRHCB8U7H2.LARGE.jpg", "https://cdn.instructables.com/F3M/ZNXI/HCB8REO3/F3MZNXIHCB8REO3.LARGE.jpg", "https://cdn.instructables.com/FD0/TQJZ/HCB883H1/FD0TQJZHCB883H1.LARGE.jpg"], "step_title": "Step 21: Pin Planner"}, {"step": 22, "steps_text": "In this pin assignment window, you can select the individual pins by clicking in the location field and typing or searching for the correct pins.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FLN/4246/HCJODIEP/FLN4246HCJODIEP.LARGE.jpg", "https://cdn.instructables.com/F0C/TNVE/HCJNWL54/F0CTNVEHCJNWL54.LARGE.jpg"], "step_title": "Step 22: Pin Planner 2"}, {"step": 23, "steps_text": "This last step is the easy one.\u00a0\nGo to TOOLS and down to Programmer.\nThis will bring up a new window;\u00a0 check to make sure it says Blaster and click Start.\u00a0\nCongrats you're Done.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FQE/55Q9/HCRVR3SW/FQE55Q9HCRVR3SW.LARGE.jpg", "https://cdn.instructables.com/F2X/5RL4/HCJNWL5E/F2X5RL4HCJNWL5E.LARGE.jpg"], "step_title": "Step 23: Get It on the Board"}], "channel": "Software"}, {"category": "technology", "description": "FIRMWARE UPDATE!! - 10/2/2015 - See last step for detailsPresented here is an Arduino-based \"Blue Box\".  It produces the \"traditional\" Blue Box 2600Hz tone and MF (multi-frequency) tones, but does much more! It also produces 12  tone signalling systems used by phone phreaks to hack other more exotic system in the US and overseas, including early pre-cellular mobile telephone systems from the 50s, 60s, and 70s,The box has 12 non-volatile tone sequence storage memories that can store and play back up to 32 tones each. Each memory saves the tone mode as well. All operating parameters, such as tone duration, volume level, backlight status, reminder beep status, and current tone mode are saved to non-volatile EEPROM memory automatically and are restored when the box is powered up. EEPROM errors are automatically detected and corrected when the box is powered on.An optional LCD provides full information of the operating status of the box and enhances the appearance and user-friendliness of the unit.This box features sine-wave tone generation using PWM wave-table lookup techniques. It sounds much better than generating the tones using the two-pin square wave output techniques utilized by the standard Arduino \"Tone\" library.I designed this new blue box, as I was out of the PCB boards for my older PIC_based blue box design and was looking for a way for others to easily construct a blue box for use with my ProjectMF system, using inexpensive and commonly available parts. This design is easily the most full-featured and technically sophisticated blue box design available. I am a telecommunications and software engineer and took great pains to be sure all of the tone modes are accurately represented. The code has been thoroughly debugged and well-tested.The following modes are supported. Note that ALL of these modes are obsolete (well, not DTMF!) and no longer work on \"real\" public telephone systems, except for private systems (like ProjectMF) set up for historical purposes. They are included to preserve the sounds of these old tone signalling systems:MF (R1) - The 2600Hz/Multi-frequencysystem that ran Ma Bell's long distance network back in the dayDTMF (Touch-Tone, Autovon) - Used on almost every land line phone. A-B-C-D keys used to set call priority on the old Autovon military phone system.CCITT #5 (C5, SS5) - Same MF tones as R1 (with a few additional tone pairs for special routing), but uses a different tone sequence for international trunk clear/seize.CCITT #4 (C4, SS4) - Unusual 4-bits/digit tone encoding. Used in the UK and other European countries.2600 Dial Pulse - Same method used by Joybubbles (Joe Engressia), Captain Crunch (John Draper), and Bill from New York (Bill Acker) to whistle free calls.Pay Phone Modes  - Simulates both US and Canadian nickel/dime/quarter payphone coin drop tones (Red Box). Also simulates US pay phone remote operator control tones (Green Box) and 2600Hz prefix control flash.R2 (MFC) - Unique forward multi-frequency tone pairs, 2280Hz clear/seize tone, as used in the UK. Replaced the older AC1/AC9 UK dial pulse systems.AC1- Old UK tone dial pulse trunk signalling, as used by very early UK telephone \"enthusiasts\".AC9 - Newer UK dial pulse trunk signalling, as used by early UK telephone \"enthusiasts\".MTS (Mobile Telephone Service) - Pre-cellular, pre-IMTS mobile phone service tone signalling and dialingIMTS ANI (Improved Mobile Telephone Service ANI ) - Newer pre-cellular mobile authentication spoofingIMTS Digit Dialing - Improved Mobile Telephone Service (pre-cellular) digit dialing,", "title": "Arduino 12-mode Blue Box - Introduction", "url": "https://www.instructables.com/id/Arduino-12-mode-Blue-Box-Introduction/", "section": "technology", "steps": [{"step": 1, "steps_text": "The blue box is an electronic device that simulates a telephone operator's dialing console. It functions by replicating the tones used to switch long-distance calls and using them to route the user's own call, bypassing the normal switching mechanism. The most typical use of a blue box was to place free telephone calls. The blue box no longer works in most western nations, as modern switching systems are now digital and no longer use the in-band signaling which the blue box emulates. Instead, signaling occurs on an out-of-band channel which cannot be accessed from the line the caller is using (called Common Channel Interoffice Signaling (CCIS)).A blue box generates the tones that controlled the old long-distance telephone network. Typically blue boxes are handheld electronic devices with buttons or a keypad like a Touch-Tone phone, but they can also be implemented in software on a computer. Blue boxes typically have an external speaker that emits the tones, and it gets held up to the mouthpiece of a telephone to make a call with the blue box. See the Wikipedia article and Phil Lapsley's excellent new book \"Exploding the Phone\" for more details about blue boxes and the early phone phreaks - the original hackers.In the US, the operation of a blue box was/is simple, using the MF/R1 signalling system: First, the user places a long distance telephone call, usually to an 800 number or some other non-supervising phone number. For the most part, anything going beyond 50 miles would go over a trunk type susceptible to this technique. When the call starts to ring, the caller uses the blue box to send a 2600 Hz tone. The 2600 Hz is a supervisory signal, because it indicates the status of a trunk; on hook (tone) or off-hook (no tone). By playing this tone, you are convincing the far end of the connection that you've hung up and it should wait. When the tone stops, the trunk will go off-hook and on-hook (known as a supervision flash), making a \"Ka-Cheep\" noise, followed by silence. This is the far end of the connection signaling to the near end that it is now waiting for MF routing digits. Once the far end sends the supervision flash, the user would use the blue box to dial a \"Key Pulse\" or \"KP\", the tone that starts a routing digit sequence, followed by either a telephone number or one of the numerous special codes that were used internally by the telephone company, then finished up with a \"Start\" or \"ST\" tone. At this point, the far end of the connection would route the call the way you told it, while the users end would think you were still ringing at the original number.Even though this is all obsolete, it is again made possible by a set of modifications and patches made to the open-source Asterisk PBX server. It allows users to dial into the system via a variety of access methods, including the regular public switched telephone network and SIP. The user is presented with a ringing line. The ringing can be disconnected and the trunk seized by playing a 2600 tone into the line. Thereafter, the call can be diverted to another number or to a series of internal recordings and functions that reside on the server/switch by playing MF or multi-frequency tones into the line. This is all perfectly legal, as the system is totally private. It is really more than a simulation. The call is going over a trunk group of 24 SF/MF trunks, although both sides of the trunks are terminated on the same PC. The hardware that makes this possible is two extra dedicated Ethernet cards on the PC running T1 over Ethernet protocol over a loopback Ethernet cable. Your incoming call gets looped over one of the 24 trunks before terminating back on the same switch, so you have 2600 and MF control.I have maintained a public ProjectMF system for over 7 years now. At last old-timers, aspiring phone phreaks, and the curious can experience the clandestine thrill of blue boxing their own calls! I have extended Phiber's original patches to add to the realism and reliability of the system. Lots of the old tricks are possible, including trunk \"stacking\",as illustrated in one of the Phonetrips recordings. Access is at +1-630-485-2995.", "step_imgs": ["https://cdn.instructables.com/F9Q/8XUR/I1YU6HXE/F9Q8XURI1YU6HXE.LARGE.jpg"], "step_title": "Step 1: Background Information"}, {"step": 2, "steps_text": "YouTube video at: http://youtu.be/_KHAGNpQo-c", "step_imgs": ["https://cdn.instructables.com/FKK/JQVV/I28WASSL/FKKJQVVI28WASSL.LARGE.jpg"], "step_title": "Step 2: Arduino Blue Box Operation Overview"}, {"step": 3, "steps_text": "YouTube video at: http://youtu.be/tK45aoz0oD4", "step_imgs": [], "step_title": "Step 3: Blue Box Construction Details"}, {"step": 4, "steps_text": "YouTube video at: http://youtu.be/HLnmIA7fzJs", "step_imgs": [], "step_title": "Step 4: Blue Box Manual and Software Configuration"}, {"step": 5, "steps_text": "Download link for latest Arduino software and documentation:  Download Link, or download the software, libraries and documentation package in a convenient .zip file directly from Instructables at the end of this step.Note that the hardware and code are designed to work only with the newer Arduino Leonardo architecture boards that use the Atmega 32U4 chip. Older Arduino Uno-style boards will not work.The Blue Box uses standard Arduino IDE libraries, plus some customized libraries that are included in the software distribution compressed .zip files. These libraries must be installed before attempting to configure and compile the software.The software must be configured by un-commenting the correct \"#define\" statements at the beginning of the code, to match the hardware configuration used. See the manual for details.Additional videos that highlight the operation of the various modes are on my YouTube channel at: https://www.youtube.com/user/df9999999999/videosFIRMWARE UPDATE!! - 10/2/2015I added a minor change to the sine wave table definition that was preventing the code from compiling with the newer Arduino IDEs. The sine table is stored in program memory. Newest IDEs require the \"const\" keyword before the table array definition.The .zip file found here as well as at the download link now contains this change. No other code changes, so the version remains the same.", "step_imgs": ["https://cdn.instructables.com/FGN/9O7G/I28W940R/FGN9O7GI28W940R.LARGE.jpg", "https://cdn.instructables.com/FSP/FPJ5/I28W9417/FSPFPJ5I28W9417.LARGE.jpg", "https://cdn.instructables.com/F79/S9D9/I28W9424/F79S9D9I28W9424.LARGE.jpg", "https://cdn.instructables.com/FYT/WB2L/I28W942H/FYTWB2LI28W942H.LARGE.jpg", "https://cdn.instructables.com/FCK/WEMH/I28W9433/FCKWEMHI28W9433.LARGE.jpg", "https://cdn.instructables.com/FBV/083E/I28W943V/FBV083EI28W943V.LARGE.jpg", "https://cdn.instructables.com/FT1/P99F/I28W945R/FT1P99FI28W945R.LARGE.jpg", "https://cdn.instructables.com/FZK/VO03/I28WA1E5/FZKVO03I28WA1E5.LARGE.jpg", "https://cdn.instructables.com/F9Q/8CVB/I28W946D/F9Q8CVBI28W946D.LARGE.jpg", "https://cdn.instructables.com/FKT/WUJZ/I28W93XR/FKTWUJZI28W93XR.LARGE.jpg", "https://cdn.instructables.com/FTK/MXYI/I28W93YI/FTKMXYII28W93YI.LARGE.jpg", "https://cdn.instructables.com/FH2/JUDV/I28W93ZW/FH2JUDVI28W93ZW.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 5: Software and Construction Documentation Download Links"}], "channel": "Arduino"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "technology", "description": "Spectrum analyzers are simple to use tools that take rather complex measurements and make it easier to understand what your electronic doo-dad is doing. Almost all electronic systems generate some form of electrical noise from the movement of electrons along the electrical pathways inside. Many are also susceptible to outside interference when an external frequency is intercepted. The spectrum analyzer on the Analog Discovery 2 can help you pinpoint both internal and external trouble spots to help fine tune your device for more efficient performance.To complete this Instructable, you will need:-Analog Discovery 2*-Waveforms 2015 software- a computer with USB port to run the software*You may also use the original Analog Discovery or the Electronics Explorer Board with Waveforms 2015. There are some slight differences in functionality between the AD1, AD2, and EEBoard, but nothing that will prevent you from following along if you have one of the other tools.", "title": "Using the Spectrum Analyzer With the Analog Discovery 2", "url": "https://www.instructables.com/id/Using-the-Spectrum-Analyzer-With-the-Analog-Discov/", "section": "technology", "steps": [{"step": 1, "steps_text": "First, a quick physics review. We call the physical movement or flow of electrons from one location to another \"current\". This flow of electrons induces an electromagnetic field around the wire carrying the flow. ANY motion of ANY quantity of electrons will generate this field, though it makes sense that with more flow, you get a larger and stronger EM field. If the flow of electrons remains perfectly constant with absolutely no change, then the size, shape, and strength of the EM field will not change either. If the flow of current in the wire changes its direction back and forth according to a regular cycle, the EM field characteristics will also follow this pattern, most notably its polarity (think which way N and S point). As the EM field changes, energy is radiated out in all directions from the wire carrying the current. This radiated energy can be picked up and measured, and at this point the process is reversed and the intercepted EM energy actually induces a current in a wire, which can then be utilized for work.(Image by Christophe Dang Ngoc Chan Cdang at fr.wikipedia [GFDL (http://www.gnu.org/copyleft/fdl.html) or CC-BY-SA-3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons)This is the driving force behind how ALL wireless communication systems work. A small circuit generates a small current that rapidly changes direction based on a very precise base frequency. The information that is being sent out is also stored inside of this base current frequency in the form of small variations in frequency or amplitude. As the current travels through the wire, the EM energy is produced and radiated through a transmitting antenna, with all of the small variations related to the information still intact. The radiated EM energy is then intercepted by a receiving antenna. The resulting current that is induced in the internal circuitry is then filtered to remove the base frequency and extract the usable data.Ideally your antenna will only pick up the exact signal that it is intended to pick up. But we don't live in an ideal world, and stray, random signals are all around us and inside of our electronic devices. As I said, every single device that is wireless either transmits or receives EM radiation. But remember that even if your device isn't designed to be wireless, it still has small currents running all through it, each one generating its own small amount of EM radiation signals. Most of these signals go unnoticed and have no noticeable effect on the physical world for various reasons. But sometimes they do, and the results can vary from obnoxious to disastrous.On the obnoxious side, it's just simple interference. Imagine your parents buy and wrap an RC car and place it under the Christmas tree. For some unknown reason, it has batteries installed and is turned on while still in the package. At least twice a day for the two weeks leading up to Christmas morning, you get short random bursts of noise that sounds like a small motor coming from under the tree. It turns out the antenna is picking up stray EM radiation and it is just the right frequency and contains just the right information to make the motor spin up for a second or two. However on the disastrous side, a strong EM pulse, like from a high altitude nuclear explosion, can generate such a strong EM field over such a wide range of frequencies that nearly every wire and copper trace in nearly every electronic device within the effective radius will have so much current induced on it that your device is quite literally cooked on the spot. And it will never work again without replacing every single electronic component.You would have a very hard time protecting your circuitry from a large EM pulse, but it is possible to keep the random, everyday signals from causing problems. (An example: Most of your electronic cables can double as very effective antennas, so they are often internally shielded from EM radiation that could interfere with the electronics they connect to.) This is where the spectrum analyzer comes in handy. You can see where you are getting the strongest stray signals for your area of application, and at that point you either protect against them with your circuit design, or determine that they are inconsequential and ignore them. You can also use the spectrum analyzer to break down signals and see what fundamental frequencies are making up that single signal you are hearing or receiving. Since this is an easier example to demonstrate, let's break down some simple signals.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 1: Why Is There Interference?"}, {"step": 2, "steps_text": "You are most likely familiar with looking at signals on an oscilloscope image, which plots the magnitude of the signal on the y-axis (vertical) and the time on the x-axis (horizontal). With these plots, we see that as time passes, the strength of the signal changes. This should be no surprise.1 kHz sine wave.Another way to visualize a plot is in the frequency domain. We still have magnitude on the y-axis, but instead of time, we plot frequencies on the x-axis. Now we can see how the magnitude of a signal changes with the frequency of that signal, regardless of when in time we find ourselves interacting with that signal.The spectrum analyzer simply reads every single frequency within the data acquisition window. It starts at the lowest frequency, reads the signal strength at that frequency, displays the value on the graph, then moves up just a little bit to the next frequency. It does this many, many, many times a second, so all you see is a constantly fluctuating image, with spikes where you have a stronger signal at that frequency. The number of samples it takes per second, the resolution of the data read, the span of the acquisition window, etc. are all variables that can be adjusted on the go so that you get the clearest data.", "step_imgs": ["/assets/img/pixel.png"], "step_title": "Step 2: What Does the Spectrum Analyzer Do?"}, {"step": 3, "steps_text": "To use the spectrum analyzer with the AD2, you will need both the AD2 and the Waveforms software. (If you need some help with installing Waveforms or calibrating your AD2, check out this I'ble collection.)Plug in the AD2 and open Waveforms. Open the spectrum analyzer by clicking on the \"Spectrum\" tab on the left side of the window, toward the bottom.The spectrum analyzer window will pop open.I could go over all of the tools and options now, but it will be much easier to do that with some kind of data in the window so you can actually see what is going on, so let's get a signal in first. Go back to the Waveforms main welcome window and click on the \"Wavegen\" button. This opens the waveform generator window.The default setting should be a sine wave with 1 kHz frequency and 1V amplitude. This will work just fine for now.We need to connect the waveform generator to the spectrum analyzer. Attach the wire harness to the AD2 and using the included pins, find the \"1+\" (orange with no white stripe), \"1-\" (orange with a white stripe), \"W1\" (yellow with not stripe), and any one of the black GND wires. Connect \"1+\" to \"W1\" and connect \"1-\" to GND. This connects the positive lead for channel 1 of the analyzer with channel 1 of the waveform generator. The negative lead for channel 1 of the analyzer connects to system ground so that the analyzer has a relative 0V reference point.With the wires connected, turn on the waveform generator by clicking \"Run\" at the top of the window. Go to the analyzer window and click \"Run\" as well. Without changing any default settings, you should see something like this:The image is constantly jumping around because the analyzer is constantly getting random amplitude readings at all of the frequencies between your lower and upper frequency limits. Also, the frequency we chose by default is difficult to see in this image. So let's make some adjustments so we can see it better.The first thing I like to do is remove data that is not useful. On the right side of the window, you will see two boxes that correspond to the two analyzer channels. Since we are only using channel 1 at this point, click on the little check mark in the top left corner of the channel 2 box. This will remove the channel 2 readout from the window and we are left with only channel 1.Next, at the top of the analyzer window you will see a small green arrow at the right hand side of the screen. Click this arrow and you will have some various options.You can set the lower and upper window limits manually by entering in values into the \"Start\" and \"Stop\" boxes. You can also use the \"Center\" and \"Span\" boxes. We already know that we have a 1 kHz signal, so let's leave 0 Hz in the start box and put in 5 kHz in the stop box. You should see something like this:You can also adjust the window size by deciding on what frequency you want the window image to be centered on, and then giving the window a span, or width. The span is divided in two, and then that resulting value is added or subtracted from your center frequency to give you your window max/min values respectively. Since we are looking at a 1 kHz signal, put 1 kHz in the center box and make your span 1 kHz. This will make the window center on 1 kHz and the x-axis scale will go from 500 Hz to 1.5 kHz.You will also notice that the image doesn't appear to \"run\" as fast now. Go back up to the top of the window and click on the BINs drop-down arrow. By choosing a smaller value, you change the number of frequency BINs you are using. (Basically it divides up the window into that many slices and takes a sample at each one. It then just draws a straight line between each data point.) This will automatically adjust the sample rate as well as your resolution. The image will now run faster, but you don't have as much data to work with. Make adjustments as you see fit.Ok, so now we have a pretty good view of what is going on. We can see that we have a solid spike at 1 kHz, and a ton of smaller spikes in the rest of the window. When we look at the magnitude axis (vertical) we see that it is set on decibels (dB). This is a very common way to measure signal strength. Most of the noise is centered right around -70dB, which is an extremely low value. This indicates that the noise is exactly that, just background noise in the system, but it is so low that it shouldn't have any effect on the system. It comes from transient signals generated by whatever interfering signals are around you, as mentioned previously. If we were in the radio frequency range with an antenna attached, you could pick up the background radio noise of space.Now let's have some fun with this. One of the unique things about signals is that anything other than a pure sine wave is actually composed of multiple sine waves of various frequencies, all of which are integer multiples of the base frequency. They also vary widely in magnitude, with the base frequency having the highest magnitude. This idea was first posited by Joseph Fourier and the idea became known as the Fourier Transform.We can see this breakdown of a simple square wave using the spectrum analyzer. Go back to your waveform generator window and click on the box to choose the type of signal. It should say sine, but when you click on it, you will get a bunch of different options. Click on \"square\" and set the frequency to 20 kHz.Go back to the analyzer window. Set your center frequency to 20 kHz and span to 40 kHz. You will see a very clear spike at 20 kHz and then a bunch of noise. This makes sense since the square wave frequency is at 20 kHz.Now let's expand our view and see what's really going on. Set your center to 500 kHz and your span to 1 MHz. You should see something like this:Now let's see what frequencies are the strongest. You should be able to tell from the image, but if you play with your window start and stop values or the span value, you will see signal peaks at various places that won't be apparent with a different resolution. To see exactly which frequencies are strongest, click on \"view\" at the top of the window and then choose \"components\". A small side window will pop up showing all of the strongest frequencies that can be seen in the current window. By adjusting the window max/min values, these readings will change. Which frequency is the strongest? Does that make sense?You can change the number of components displayed by clicking on the small gear in the component window and changing the value in the option box. If you click on the \"stop\" button at the top while the component window is open, you can click on any of the frequency values and a vertical red line will appear in the window at that frequency.Click on \"run\" again and let the analyzer do its thing. If you look all the way to the right side of the screen, you will see the little box that gives you trace options. Click on the drop down menu beneath \"type\" and you will see several options. My favorite is \"peak hold continuous\" so click on that and see what happens in the window. This can be helpful to remove the noise and capture small peaks that are not noise but still rather weak and can be lost in the noise.Now that we've looked at a square wave and most of the core analyzer options, let's take a look at how some other signals break down. Go back to your waveform generator and try the same type of wave at different frequencies. Then choose different wave types at the same frequency. See where you have similarities and differences. I've included a couple below. 20 kHz triangle, 1V peak20 kHz ramp up, 1V peakNow just for fun, let's see how random the noise generator is. Click on the \"noise\" option for wave type. If you want to hear it, make the frequency below about 15 kHz and plug some headphones into the audio jack on the AD2. (It would be a good idea to set the magnitude of the waveform at about 200 mV peak or less to keep from damaging your ear. Also, you are only using one channel, so you will only hear it out of one ear. This is normal.) Go back to your analyzer and set your window so that your base frequency is within the window. I chose a 5 kHz signal for the following image:Not so random, is it? If you are familiar with computer programming, or even randomness in general, you know that it is extremely difficult to generate truly random results. Humans simply can't do it, and neither can computers. What is being generated here is a very set pattern of various magnitudes of nearly every frequency in the entire spectrum (zoom out with your start/stop values to see). But the pattern is close enough to random that we perceive it as such.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Using the AD2 and Spectrum Analyzer"}, {"step": 4, "steps_text": "You can use a spectrum analyzer to analyze any type of signal that you can convert to electrical impulses. Connect the analyzer channel to the output of a microphone circuit and sing a single note, or play one on an instrument (any of you ever use a guitar tuner? Guess how that works). It's not one single frequency, is it? My favorite example of this is a YouTube video by Anna-Maria Hefele (see below or direct link here). She sings a constant fundamental tone, and by shaping her mouth she can filter and amplify the overtones that are always present in the sound, but are normally too weak to hear on their own when compared to the fundamental. In this way she can sing multiple notes at the same time. In the video she uses an audio spectrum analyzer to give a frequency breakdown of her voice to show the overtones present.If you are getting unwanted, anomalous behavior in a circuit, you can connect the spectrum analyzer to different places in your circuit and see what frequencies are interfering and where. Most electronics already filter out the 50-60 Hz signal that leaches into them from the AC power from the wall. The generators at the power plant turn at that rate, and that frequency moves all the way down the line and into your device. But it often shows up in home built circuits, usually related to the power supply. By adding a capacitor across the power rails you can filter it out.Fluorescent lights flicker at twice the frequency of the AC power supply, so in North America it's about 120 Hz. This EM energy can be picked up by the right type of antenna, intentionally or not, and may cause interference. Also, as mentioned before, cell phone, television, & WiFi networks, as well as devices like portable radios, all generate signals that can cause interference.Hopefully you will use your AD2 and spectrum analyzer to investigate some cool things. There are more options and capabilities, so I will let you discover that.As always, thanks for reading. If you have questions, please ask them in the comments below, though PM's are always welcome as well. You just never know when someone else has the same question and that way we can all learn and help each other get better. Have fun building!Also, please check out the Digilent blog where I contribute from time to time.", "step_imgs": [], "step_title": "Step 4: Further Investigation"}], "channel": "Tools"}, {"category": "outside", "description": "by tonytran2015 (Melbourne, Australia). When you are outdoor, you often need to work out the distances to  various objects around you so that you can plan your activities and know  exactly where you are on your map to be in control of your trip, to  make your plan to get back to safety, or to inform your rescuers of your  exact position. However the challenge arises you have to make angle and  distance measurements but neither can nor should employ any instrument,  such as when hiking, when riding a motor-bike, or when on a touring  bus. In such cases measuring angles with bare hands is the only method  left. (Accurate measurement of angles allows determination of distances  in survival situations.)The method is described here and it uses the edges of the index and  middle fingers as parallel guide lines for measuring angles. (Measuring  posture must be correct to keep the viewing angles separating them  nearly constant.)", "title": "Measuring Angles and Distances for Outdoor Survival.", "url": "https://www.instructables.com/id/Measuring-Angles-and-Distances-for-Outdoor-Surviva/", "section": "outside", "steps": [{"step": 1, "steps_text": "Figure: Basic arm posture for angle measurement. The two outer edges of the measuring fingers form the marks on a scale of 0 to 10 for measuring vertical angular separations. The fraction of (10/200)rad in this figure is only for an angle of 3 degrees, the denominator will be different for other values of the angle.This measurement uses the basic posture for angle measurements. User has his face and chest facing the object to be measured. His shoulders are kept level, one of his arms stretched out, to have its measuring fingers precisely in front and on the symmetry plane of the torso.The index and middle fingers of that hand are curled. The two outermost joints of each of these fingers are kept horizontal, straight and at right angle to his line of view. The edges of those finger extremities form three regularly spaced parallel guide lines to make a scale for measuring angles. The two outer edges are separated by an unchanged angle depending only on the bone structure of the user. This angle is constant over a long time for each individual and can be used to measure any angular separation. It can be easily measured by comparing it with the diameter of the Moon. It is usually between 2 and 5 degrees (which is 4 to 10 diameters of the Moon; each diameter sustains half a degree). The user must know how to find out the value for his own body structure:1 finger has nearly 1.5 degree width in frontal measurement (for most people),2 adjacent fingers have nearly 3 degree width in frontal measurement (for most people).User  can also have those index and middle fingers pointing in any direction  from 1 to 7 o'clock to measure any non-vertical angular  separation.  When  the object in view is not level with eye level,  the user can raise or  lower his stretched arm, tilt his head and bend  his upper torso to keep  the distance from the measuring hand to the  eyes constant. By raising  and lowering the arm, the aiming line can  reach an elevation of 80  degrees and a depression of 90 degrees. Measurement  of overhead  angles is more difficult and has reduced distance from  eyes to hand.  The resulting angle must consequently be increased by some percentage to  compensate for that. To  have consistent results, all other  measuring postures should be  immediately alternated with the basic  posture to check for the constancy  of the distance from eyes to hand.", "step_imgs": ["https://cdn.instructables.com/FEM/Q528/IRXT4VAZ/FEMQ528IRXT4VAZ.LARGE.jpg"], "step_title": "Step 1: Frontal Measurement of Angular Separation at Eyes Level (Basic Posture)."}, {"step": 2, "steps_text": "Figure: The two outer edges of the measuring fingers form the marks at 0, 5 and 10 on a scale of 0 to 10 for measuring angular separations; the scale is oriented horizontally in this illustration. The fraction of (10/200)rad in this illustration is only for an angle of 3 degrees, the denominator will be different for other values of the angle.The angle between the outer edges of the two fingers is next converted into a gradient (or slope) value which is more useful.3 degrees is nearly equal to a slope of  0.0523 (= tan (3 degree) = 3*0.01745) which is next written as 1/19.12 = 10/191.2 # 10/200 (You can use 10/191 but rounding the ratio to 10/200 make field calculations much faster.).The separation angle of 3 degree has thus been converted into an angle of (10/200) radian (see the step on Units for angle measurement).Similarly,  the separation angle of 4 degree is converted into an angle of (10/150) radian. Each user has to determine the value for his  own individual angle which is determined by his body structure, convert  it into a fraction of one radian with a nominator of 10 and remember his own denominator value. The denominator may be any rounded numbers between 100 and 400. The two outer edges of the measuring fingers thus form a scale from 0 to 10 for measuring angles. Angles are measured against the nominator of the fraction for the angle between the outer edges of the two fingers.Readers may skip to Units for measuring angles on first reading.", "step_imgs": ["https://cdn.instructables.com/FRD/SKF1/IPZPIKCF/FRDSKF1IPZPIKCF.LARGE.jpg"], "step_title": "Step 2: Conversion of the Angle Into Fractions of Radian or Mil."}, {"step": 3, "steps_text": "This is used when it is not practical to assume the basic posture, such as when standing on a tight spot. User has one of his shoulder facing the object to be measured, his two shoulders in line with the object , the arm nearer to the object fully stretched out, its index and middle fingers placed between his eyes and the object. This is for measuring angle over the shoulder. The parallel guide lines formed by the fingers are now separated by a smaller angle. The angular separation of the guide lines is now reduced by about 25%.", "step_imgs": [], "step_title": "Step 3: Measurement Over the Shoulder."}, {"step": 4, "steps_text": "This is used when it is not practical to assume the basic posture, such as when standing on a tight spot. User has his measuring arm stretched out, pointing to the object. The user can raise or lower his stretched arm and tilt his head and upper torso to keep the distance from the measuring hand to the eyes constant. By raising and lowering the arm, the aiming line can be reach elevation of 60 degrees and depression of 90 degrees. The angular separation of the guide lines is now reduced by about 20%.", "step_imgs": [], "step_title": "Step 4: Measurement at 45 Degrees to Your Shoulder Line."}, {"step": 5, "steps_text": "The angle for a full circle is divided into 360 degrees, or 2X(3.14159) radians. As it is not convenient to use any compass scale in radians, the US military compasses use their scales in mils. A full circle is divided into 6400mils, so       6400mil = 360degree = 2*3.14rad,       1 rad = 1019mil # 1000mil (This is a convenient conversion formula).Quick reference values for angle measurement:An equilateral triangle has 3 equal angles of 60\u00b0.1 degree angle is equal to (2*3.14159/360)rad # (1/60)rad # a slope of (1/60).6 degree angle is equal to (2*3.14159/60)rad # (1/10)rad # a slope of (1/10).10 degree angle is equal to (2*3.14159/36)rad # (1/6)rad # a slope of (1/6).The diameter of the Moon varies between 0.5degree and 0.55degree. It can be taken to be 1/2 degree and is used to conveniently calibrate the angular spacing of your index and middle fingers.", "step_imgs": [], "step_title": "Step 5: Units for Angle Measurement."}, {"step": 6, "steps_text": "Figure: A distinctive building with known dimension can be used to estimate your distance to it.Objects of known sizes such as your companion and his survival walking stick or of standardized sizes such as train track widths, street signs, car lengths or of very similar sizes such as fully grown plants and animals can be used to estimate your distances to their nearby objects. Your distance to it is given by the simple formula:(inverse of angle in radian) * (size of object) = (distance to object).A numerical example will be given in Application 6.", "step_imgs": ["https://cdn.instructables.com/F0L/EDJG/IPOC4MOA/F0LEDJGIPOC4MOA.LARGE.jpg"], "step_title": "Step 6: Application 1- Estimating Distance to an Object of Known Size on the Ground."}, {"step": 7, "steps_text": "Figure: A straight road of constant width. The arrows on the right correspond to the distance to the intersection, 1/2 and 1/4 of it.(Estimating distance to an intersection along a straight road of constant width.)The width of the road must be constant in this application. You first find an observation point higher than the surface of the road to observe the width of the road with SAFETY and ease. Measure the angular width of the road at the intersection. The point on the road where the angular width is double that is at half the distance. The point on the road where the angular width is double that new width is again at half of that new distance. Use the method repeatedly to obtain 1/2, 1/4, 1/8, 1/16 of the unknown distance, until the last one in the sequences can be accurately estimated by any other method such as comparison to your height. Note that suitable adjustment should be made for the height of your observation point.", "step_imgs": ["https://cdn.instructables.com/F5I/1OH1/IPOC4MMO/F5I1OH1IPOC4MMO.LARGE.jpg"], "step_title": "Step 7: Application 2- Estimating Distance to an Intersection Along a Road of Constant Width."}, {"step": 8, "steps_text": "Figure: A straight yellow line to an object of unknown distance, which is placed at the smallest arrow on the line. Your observation point is at the center of the bottom edge of the figure. The arrows on the right correspond to the distance to the object, 1/2 and 1/4 of it.You should choose an observation point on one side and away from the line. Imagine a parallel hand rail at your eye level on top of that line. The hand rail runs from your eye to the intersection of that line and the horizon. Use the method of the preceding section to repeatedly divide the distance into half until the last one so obtained can be accurately estimated by any other method such as comparison to your height.", "step_imgs": ["https://cdn.instructables.com/FC6/F8HL/IPOC4MMR/FC6F8HLIPOC4MMR.LARGE.jpg"], "step_title": "Step 8: Application 3- Estimating Distance to a Point Along a Straight Line on the Ground."}, {"step": 9, "steps_text": "Figure 1: A pole of unknown distance from the observer who is at the short base of the triangle drawn by the dotted line. Top inset: The  pole seems to move against the distant background when the observer  moves at right angle to the line of view. Figure 2: On the scale 0-5-10  formed by the edges of your two measuring finger, the pole seems to move  by a value of 17. Figure 3: A movement at an oblique angle can be made and the traverse is obtained  from the projection of this angle onto the normal to the line of view.Measuring distance to a ground object by traversing horizontally is also known as measurement by parallax angle.Notice the position of the object on the distant (far) skyline (or low clouds). Traverse 10 parade paces (7.5m) in a direction at right angle to the line of view. Observe the relative horizontal displacement of the impression of the object on the distant sky line and measure this angular displacement.  (If at night, observe the relative horizontal displacement of the  object against the low elevation stars and measure this angular displacement.)(inverse of angle in radian) * (traverse) = (distance to object).When it is not practical to move at right angle to the line of view, a movement at an oblique angle can be made and the traverse is obtained from the projection of this angle onto the normal to the line of view. (The result will be more accurate when the traverse and the angle are determined more accurately such as when using a tape measure and an accurate sighting compass.)Example:1. The distance to a transmission tower may be known if the you can walk around it in a circle and measure the length of the circle.      Distance = (Length of circle)/(2*3.14)When the whole circle cannot be made, part of it (a circular arc) can be used instead and the distance is given byDistance = (Length of arc)*(360degrees/(angle of arc in degrees))/(2*3.14) or      Distance = (Length of arc)*(6.28318radians/(angle of arc in radians))/(2*3.14)or      Distance = (Length of arc)*(1radian/(angle of arc in radians))2. If the direction to the transmission tower changes by 5 degrees (=5*0.0174 radian) after you have traversed 7.5m, as in Figure 1, the distance will be(1/(5*0.0174))*(7.5m) = 86m.The value of 5 degrees was supposed to be obtained by an accurate angle measuring  device and is equal to the angle of the arc. The value of 5 degrees is only an example, you have to use whatever value given by your angle measuring device.3. Since the transmission tower appears to move against the distant skyline when you traverse 7.5m, as in Figure 1, the angle of this movement relative to the distant skyline can also be used to work out your distance to the tower without using any measurement device as in the following.We first assume the ratio measuring the angle between the outer edges of your two measuring  fingers to be 10/200 (This is the ratio for most people). On the scale of 0-5-10 formed by the edges of your two measuring fingers, the transmission tower seems to move by a value of 17 units (which is a rough value of 5degrees (=0.087radian) read on a scale of (1/200)radian per unit) against the distance skyline (Figure 2). With this reading of 17, the distance to the tower can be worked out to be(1/(200/17))*(7.5m) = 88m, So, the distance has been worked out in a simple way with an error of about 5%,  using only your bare hands.4. If you are on moving along a track at 30\u00b0 angle to the line of view, you don't have to leave it only to make a traverse at right angle to the line of view. Just keep moving along the track for about 15m, the transmission tower will move against the sky line by some angle. The traverse distance is now    15m*cos(90\u00b0-30\u00b0)=7.5m.Other calculations remain the same.", "step_imgs": ["https://cdn.instructables.com/FMX/UUZI/IPOC4MMW/FMXUUZIIPOC4MMW.LARGE.jpg", "https://cdn.instructables.com/F7X/F15T/IPZPIKO5/F7XF15TIPZPIKO5.LARGE.jpg", "https://cdn.instructables.com/FTG/ABOU/IQ0TV3GT/FTGABOUIQ0TV3GT.LARGE.jpg"], "step_title": "Step 9: Application 4- Measuring Distance to a Ground Object by Traversing Horizontally."}, {"step": 10, "steps_text": "Figure: A tree of unknown distance to observer. Inset: The horizon seems to follow the observer and moves against the tree when he stands up and crouches down.Measuring distance to a ground object by traversing vertically.Notice the position of the object on the distant (far) skyline (or low clouds). Crouch down and stand up to move your eyes at right angle to the line of view. Crouching reduce your eye level by half your height. Observe the relative vertical displacement of the impression of the object on the distant sky line and measure this angular displacement.      (inverse of angle in radian) * (change in height) = (distance to object).", "step_imgs": ["https://cdn.instructables.com/FGX/BM48/IPOC4MMS/FGXBM48IPOC4MMS.LARGE.jpg"], "step_title": "Step 10: Application 5- Measuring Distance to a Ground Object by Traversing Vertically."}, {"step": 11, "steps_text": "Figure 1: The tall, distinctive building of step 6 is used as a landmark for navigation around the city. Figure 2: The location of the landmark on a map with distance scales. Notes on the map: The map data are used under Open License from Open Street Map, the data are owned by Open Street Map Contributors. Use the known size of the distinguishable parts of the landmark for estimating of its distance (as given in preceding section). The direction of the landmark from the observation point gives the direction of the observation point relative to the landmark.Example:The landmark building is observed to be in the direction of 0\u00b0 to 10\u00b0 (North) of the observation point.Measurement of the top segment of the landmark building by using the scale 0-10 of the method in step 1 gives a value of 6. The angle thus is (6/10)*(10/200)rad = (6/200)rad. The top segment (from the helipad to the top) of this building has a height of 71m (from data provided on the internet). Therefore its distance from the observation point is   (200/6)*71m = 2400m (10% accuracy).The observation point is thus on the thick faint red arc drawn on the map and in the direction  180\u00b0-190\u00b0 (South) of the landmark.So the observation point should be somewhere close to the Southern end of a bridge on the map. This method for positioning is found to be quite good for this example as the actual observation point is right on the South end of that bridge.", "step_imgs": ["https://cdn.instructables.com/FVS/3ABK/IPOC4NBE/FVS3ABKIPOC4NBE.LARGE.jpg", "https://cdn.instructables.com/FG3/XG3S/IPPANO3H/FG3XG3SIPPANO3H.LARGE.jpg"], "step_title": "Step 11: Application 6- Locating Your Position on a Map Relative to a Tall Land Mark."}, {"step": 12, "steps_text": "At the moment of seeing the cause, such as a firework, an explosion, you should start counting \"one thousand and one, one thousand and two, one thousand and three, . .\" . Your \"one\" , \"two\",  \"three\" will correspond to 1second, 2seconds, 3seconds after the  flashing. The sound will come against  the your counting to give the time for the sound to come to you. It gives your  distance from the source of the sound.1 second corresponds to 340m,  2 second, 680m, 3 second, 1020m, . . .10 second, 3400m.Estimating distances to thunder storms.    When you are outdoor in the wilderness, it is vital to avoid lightning strikes. Lightning strikes occurs when there is discharge to  the ground by electrically highly charged clouds. Highly charged clouds usually discharge among themselves creating lightning flash. At  the moment of flashing you should start counting \"one thousand and one, one  thousand and two, one thousand and three, . . \"  to determine your distance to the lightning discharge. When  the lightning strikes is closer than 2000m (that is when any thunder arrives  within 6 seconds of its flash) you should think about your safety and  your plan to avoid lightning strikes.", "step_imgs": [], "step_title": "Step 12: Estimating Distance by the Speed of Sound."}], "channel": "Survival"}, {"category": "outside", "description": "Table of Contents:What you'll need  What does a Rabbit Box Trap do?  ContractRough SketchsGetting Started: Wood BoardsPVC Pipe and ParacordBill of MaterialsPutting It All TogetherFinished ProjectReflection", "title": "Rabbit Box Trap", "url": "https://www.instructables.com/id/Rabbit-Box-Trap/", "section": "outside", "steps": [{"step": 1, "steps_text": "2 1\"x 6\"x 6' boards (can be any wood type)  1 piece of 1/2\"x 36\" PVC pipe  1 pack of 1/8\"x 50' paracord  1 25 count pack of flat, Philips-head wood screws (any brand)  1 regular paint brush  1 quart can of clear wood sealant (any brand)  1 quart can of forest green paint (any brand)", "step_imgs": [], "step_title": "Step 1: What You'll Need:"}, {"step": 2, "steps_text": "A rabbit box trap is simply what it sounds like, a box that traps rabbits. The trap is simply a box with a trigger system that uses the weight of a suspended trapdoor to enclose the rabbit inside the box once the rabbit bumps the trigger system. This box trap is better than some of the other types of rabbit traps because it does not cause physical harm to the animal, and can be used numerous ways besides hunting and trapping. You can use a box trap for educational purposes, by catching the rabbit and using it to teach people about wild rabbits, or for research purposes, since the trap does not alter or harm the rabbit in any way.", "step_imgs": [], "step_title": "Step 2: What Does a Rabbit Box Trap Do?"}, {"step": 3, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FDW/NYI5/J20P2ZPE/FDWNYI5J20P2ZPE.LARGE.jpg"], "step_title": "Step 3: Contract"}, {"step": 4, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FNP/4B9A/J20P2ZPD/FNP4B9AJ20P2ZPD.LARGE.jpg"], "step_title": "Step 4: Rough Sketches"}, {"step": 5, "steps_text": "The most important piece to the box trap trap is the wood, so make sure your boards are relatively free of knots or splits. If bowed, strategically cut and select sections for certain parts of the box.*IMPORTANT: always double check measurements, no one is perfect so it is important to have correct measurements to not waste material.Use T-square to mark a straight line across the width of the boards about 1/2\" from each end of the boards, and cut the boards along these lines. (Doing this ensures that the ends of the board will be square, making measurements more consistent)  Measure 20\" from the end of the board and make a mark, and use the T-square to mark a straight line along the width of the board at the mark. Then cut the board along this line. (Repeat this step 2 more times, and go ahead and label the front, rear, top, and bottom of each 20\" board)  Measure 17 3/4\" from the end of the board and make a mark, and use the T-square to mark a straight line along the width of the board. Then cut the board along this line. (Use a pencil and mark this piece as the top of the box, and go ahead and label the front and rear of the board) Top Box BoardOnce the the top piece is cut, measure to find the true center of the board (as board width may range from 5 1/2\" to 6 1/2\"). When center is found, use T-square to draw a line of center along the whole length of the board.  Next, measure from the rear of the board along the centerline 4\" and make a mark.  Then take the board and use a drill press (or hand-held drill if you do not have access to a drill press) and use a 1\" speed bore bit to drill a 1\" hole on your all the way through. (Make sure you have backing to prevent blowback and clamp down your piece before you drill)  Once done, measure  from the back of the board along the centerline and make a mark. Then use a T-square to draw a line across the width of the board at the mark. Then measure along the line from the centerline 3/8\" on both sides and make a mark.  Then take the board and use a 9/64\" drill bit and pre-drill holes on the marks you just made.  Once done, then measure 3/8\" from each side of the board and make a mark. Then use a T-square to mark a straight line along the whole length of the board. Then measure from the front of the board along the lines and make marks at 1\", 9\", and 18\".  Then take the board and use a 9/64\" drill bit and pre-drill holes on the marks.  Once finished, take your top board and measure 1 1/4\" from the sides in the center on the rear of the board and make marks.  Then take the board and use a 9/64\" drill bit and drill 1/2\" into the board.Side BoardsDesignate two of the 20\" boards to be side boards.  After you designate the 2 boards, turn the boards up on their sides (where they will have the 1\" side on the worktable) and designate a top and bottom of both boards.  Once you designate the top, measure 5/8\", 3\", 11\", 18\" from the front and in the center of the top, and mark your marks.  After your marks are made, take a 9/64\" drill bit and drill 1/2\" into the board.  Once you're done with the top of the boards, do the same steps on the bottom of the boards but make your marks at 5/8\", 6 1/2\", 13 1/2\", and 19 3/8\". After you make your marks on the bottom, take a 9/64\" drill bit and drill 1/2\" into the board.   Once you're done with the bottom of the board, go to the rear and measure *** from the top along the centerline of the rear, and then make your marks.  After making your marks, use the 9/64\" drill bit and drill 1/2\" into the board.Bottom BoardMeasure 3/8\" from both sides of the board, and use the T-square to draw a line along the the whole length of the board on both sides.  Once you've drawn the lines, measure 5/8\", 6 1/2\", 13 1/2\", and 19 3/8\" from the front of the board along the lines, and make your marks. After your marks are made, use the 9/64\" drill bit and drill through the board.  Then measure 1 1/4\" from the sides in the center on the rear of the board and make your marks.  After you make your marks, use the 9/64\" drill bit and drill 1/2\" into the board.  Once you've drilled the holes, measure 1 1/4\" and 2 1/4\" from the front of the board use a T-square to draw lines across the width of the board at both measurements.  Then measure 1\" from the sides to make a rectangle 4\" x 1\"  After making the rectangle, take a wood router and rout out the rectangle 1/2\" deep.  Once done routing, use a wood chisel to clean out and get rid of access wood.Back of the BoxTake left over board and cut 6\" wide x 8\" tall rectangle. Measure 3/8\" off of the sides and top and bottom of the board and use a T-square to draw lines along the marks. Then measure 1 1/4\" from each side on the top and the bottom and make marks. Next, take a 9/64\" drill bit and drill through the board on the marks After you're done drilling, measure 4\" down from the top of the back along the side lines and make a mark. Then take a 9/64\" drill bit and drill through the board on the marks.TrapdoorTake left over board and cut out a 7 1/2\" long x 4\" wide rectangle. Then measure 3/8\" from the top and use a T-square to draw a line across the width of the trapdoor. Next, measure 2\" from one of the sides along the line and make a mark. Then take a 9/64\" drill bit and drill through the board.Support ArmTake left over board and cut out a 9\" long x 1 1/4\" wide rectangle. Use a compass on one end and make a curve with the vertex 1/2\" from the top. Then use a band saw to cut out the curve. Next, on the bottom of the support arm measure 1/4\" from the sides and make your marks. Then, take a 9/64\" drill bit and drill into the arm 1/2\"Trigger StickFor the trigger stick, take a board and cut a 5 1/2\" long x 1/2\" wide strip. Then measure about 1 1/2\" from the top and make a mark. Next measure, 1 3/8\" below that mark and make another mark. On the lower mark, cut into the strip 1/4\", then cut from the upper mark down to the end of the 1/4\" cut, making a notch. Next, on the backside of the trigger stick measure 3/8\" from the top a make a mark. Then use a 7/32\" drill bit and drill through the stick.", "step_imgs": ["https://cdn.instructables.com/F9C/WER6/J1WW8ACA/F9CWER6J1WW8ACA.LARGE.jpg", "https://cdn.instructables.com/FY0/IEAE/J1WW8ADC/FY0IEAEJ1WW8ADC.LARGE.jpg", "https://cdn.instructables.com/F7N/26CT/J1WW8AB9/F7N26CTJ1WW8AB9.LARGE.jpg", "https://cdn.instructables.com/FZ7/PJQJ/J1WW8AFG/FZ7PJQJJ1WW8AFG.LARGE.jpg", "https://cdn.instructables.com/FVC/3MQ4/J1WW8AFH/FVC3MQ4J1WW8AFH.LARGE.jpg", "https://cdn.instructables.com/FZ6/EEDS/J20P2Y14/FZ6EEDSJ20P2Y14.LARGE.jpg"], "step_title": "Step 5: Getting Started: Wood Boards"}, {"step": 6, "steps_text": "PVC PipeMeasure 15 inches from one end of the pipe and make a mark.Next, use a hacksaw and cut the PVC on your mark.Once cut, measure 1/2\" from each end and make marks that are aligned.Then take a 7/32 drill bit and drill straight through the pipeParacordCut and trim as needed.", "step_imgs": [], "step_title": "Step 6: PVC Pipe and Paracord"}, {"step": 7, "steps_text": "2 1\"x 6\"x 6' boards (can be any wood type, but pine is what I used)$22.88 ($11.44 for each board)1 piece of 1/2\"x 36\" PVC pipe$2.981 pack of 1/8\"x 50' paracord$3.981 25 count pack of flat, Philips-head wood screws (any brand)$1.94 (approximately $0.08 a screw)1 regular paint brush$6.951 quart can of clear wood sealant (any brand)$21.471 quart can of forest green paint (any brand)$24.79SUBTOTAL: $84.99TOTAL: $90.94", "step_imgs": [], "step_title": "Step 7: Bill of Materials"}, {"step": 8, "steps_text": "Take the bottom and the two side boards and make sure the pre-drilled holes align by using an ice pick or thin screwdriver.  Once the holes are aligned, take one wood screw at a time and carefully screw the boards together.  After you screw the bottom and side boards together, take the front trapdoor guide bar and make sure the pre-drilled holes align on the front of the top of the side boards using the ice pick or thin screwdriver  Once the holes are aligned, carefully screw the guide bar down.  After your guide bar is attached, take your support arm and position it on the top board, aligning it with the two holes you pre-drilled.  Once aligned, carefully screw together the support arm and the top board together.  After the top board and support arm are screwed together, take the top board (with the support arm facing up) and align its pre-drilled holes with the pre-drilled holes in the top of the side boards.  Once aligned, carefully screw the top board to the side boards.  After screwing together the top and the side boards, take the back of the box and align its pre-drilled holes with the pre-drilled holes on the rear of the top, side, and bottom boards.  Once aligned, carefully screw the back of the box to the rear of the top, side, and bottom boards. Then take sand paper or palm sander and completely sand the box. Once done sanding the box, take clear wood sealant and apply coats of sealant as needed to lessen the likelihood of wood rot. While the sealant dries, you can chose to paint/camouflage your PVC balance arm or leave it plain. Next, take the PVC pipe and feed paracord through the pre-drilled holes and tie a knot on the top side. Then take the trigger stick and trapdoor and feed the paracord through the pre-drilled holes. Next, adjust the paracord length to match your mark on your trap door to the top of the top board and make a knot. Then adjust the paracord length to so that trigger stick is set in the trigger hole while the trapdoor is raised up. Once done, adjust PVC balance arm to make sure trapdoor can fall straight into routed groove in bottom board. GO TRAP YOU A RABBIT!!!", "step_imgs": ["https://cdn.instructables.com/F60/F0XE/J20P2ZP7/F60F0XEJ20P2ZP7.LARGE.jpg", "https://cdn.instructables.com/F22/9OFS/J20P2ZPF/F229OFSJ20P2ZPF.LARGE.jpg", "https://cdn.instructables.com/FNN/Z1RE/J1WW8ADB/FNNZ1REJ1WW8ADB.LARGE.jpg", "https://cdn.instructables.com/FQF/TNBH/J20P2ZP6/FQFTNBHJ20P2ZP6.LARGE.jpg", "https://cdn.instructables.com/FL0/6BS3/J1WW8AEF/FL06BS3J1WW8AEF.LARGE.jpg", "https://cdn.instructables.com/FEM/TFRY/J20P2ZDO/FEMTFRYJ20P2ZDO.LARGE.jpg", "https://cdn.instructables.com/FDZ/I4O0/J20P2ZPG/FDZI4O0J20P2ZPG.LARGE.jpg", "https://cdn.instructables.com/FEX/0O9W/J20P2ZPI/FEX0O9WJ20P2ZPI.LARGE.jpg", "https://cdn.instructables.com/FGL/LU3M/J20P2ZPH/FGLLU3MJ20P2ZPH.LARGE.jpg", "https://cdn.instructables.com/FN5/RHPJ/J20P2ZPJ/FN5RHPJJ20P2ZPJ.LARGE.jpg", "https://cdn.instructables.com/F25/RTVA/J20P2ZPK/F25RTVAJ20P2ZPK.LARGE.jpg", "https://cdn.instructables.com/FYB/7B5L/J20P2YXH/FYB7B5LJ20P2YXH.LARGE.jpg", "https://cdn.instructables.com/F3P/TIT5/J20P2ZP5/F3PTIT5J20P2ZP5.LARGE.jpg", "https://cdn.instructables.com/F2C/BTRW/J20P2ZPB/F2CBTRWJ20P2ZPB.LARGE.jpg"], "step_title": "Step 8: Putting It All Together"}, {"step": 9, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FK3/CHX6/J20P2ZP8/FK3CHX6J20P2ZP8.LARGE.jpg", "https://cdn.instructables.com/F29/J7HS/J20P2ZP9/F29J7HSJ20P2ZP9.LARGE.jpg", "https://cdn.instructables.com/FMR/UFP2/J20P2ZPA/FMRUFP2J20P2ZPA.LARGE.jpg", "https://cdn.instructables.com/F2K/9U6J/J20P2ZPC/F2K9U6JJ20P2ZPC.LARGE.jpg"], "step_title": "Step 9: Finished Product"}, {"step": 10, "steps_text": "This project taught me a lot of new skills, and advanced some old ones. From learning how to use a router for the first time, to bettering my skills with a drill press, this project has really taught me a lot. One of the best things its helped refine for me personally is my ability to think critically and on my feet for myself, but has also refined my ability to humble and ask for help when I need it. Without these newly learned and refined skills, this project would not have gone as well as smoothly as it did.However, there are a few skills that this particular project didn't require me to learn, but I would eventually like to learn. The first is how to use the wood lathe well, and be able to make and form complicated crafts. The second is how to weld, specifically stick welding. With my father being a welder the majority of my childhood, I have seen what a wonderful skill welding is and the creative potential that is opened up by being able to weld well. The third skill I wish I could have also learned is how to master working with a drill press. What I mean by that is I want to learn how to make bit speed adjustments and be able to do general maintenance on the press. One thing I felt I excelled at with this project is my sanding skills, whether with a handheld strip or with a belt sander. This is probably the skill I have the most experience with out of all the skills I've learned. I've been refining my sanding skills ever since I was a little boy when I was too small to help my dad and pawpaw with the paw tools. A lot of people may laugh because they think sanding is easy, when in reality it's not. It takes practice to get a good rhythm, proper pressure, and general wood knowledge to understand which sheet of sandpaper to use. It really is an art, just like painting, because it is a finishing process and in my opinion is the most fun finishing process out of any of them.One thing I could have done different for my project is use wood for the balance arm instead of PVC, and use bailing twine instead of paracord. There is no structural difference in all four, but the wood and bailing twine would possibly look more natural to a rabbit and not raise as many red flags in the wild.The things I could have done better in this project is making sure I am consistent with the drill press to produce identical holes. The more identical the holes are, the easier putting the box together is, and for my project there were a few holes that didn't line up too well, so I had to take a hand drill and fix the problem by pre-drilling new holes or using the bit to widen the holes.I enjoyed everything about this project , but the one thing I didn't like was screwing together all the pieces. The reason is because I was afraid that boards would split upon screwing them together. But other than that, I loved every aspect of making my project.", "step_imgs": [], "step_title": "Step 10: Reflection"}], "channel": "Hunting"}, {"category": "outside", "description": "  This is how to make a hollow wooden kiteboard from marine plywood. The design and construction of this board has been simplified as much as possible to facilitate quick, cheap construction with out specialised tools.  The board consists of three layers of wood laminated together to form the core of the board. The centre lamination is not solid in order to reduce the weight of the board without compromising the strength too much.  This style of board is known as a directional , it is designed to be ridden in one direction only and must be gybed or tacked similar to a windsurf board in order to go in the opposite direction. This requires practice and is not best suited to a beginner. The benefits of this style of board is that it does not require any design compromises, you can have huge fin area at one end (for pointing up wind and loading up for jump)s and plenty of nose rocker in the other end for riding in choppy or surf conditions.", "title": "Hollow Wooden Kitesurfboard", "url": "https://www.instructables.com/id/Hollow-wooden-kitesurfboard/", "section": "outside", "steps": [{"step": 1, "steps_text": "Materials required:1 8' x 4' sheet of 6mm thick marine plywood 250ml of epoxy resin4 x stainless steel self tapping screw for attaching footstraps4 x stainless steel washers 4 x Future Fins Fin boxes (side type)4 x Future fins 2 x FootstrapsNotes: Marine plywood is preferred but good external construction plywood will work fineEpoxy resin is used to join the laminations together as well as seal the board from the elements as an alternative the laminations may be glued with water proof polyurethane glue as this is easier to use (1 part) and the ply can be sealed with varnish once the board is finished instead Future fins are preferred over FCS  as they are stronger and easier to install correctlyFootstraps any hard ware is optional as the board may be waxed and ridden like a surfboard instead.Tools required:HandsawBlock planeRasp Sand PaperDrill3mm Drill bit12mm Drill bitMeasuring tape Notes:A handsaw is better for cutting plywood than a powered saw as it tends to cut a smoother less wandering line and does not splinter the wood as much.", "step_imgs": ["https://cdn.instructables.com/FBK/R016/HS18H3FS/FBKR016HS18H3FS.LARGE.jpg"], "step_title": "Step 1: Acquire Your Tools and Materials"}, {"step": 2, "steps_text": "Lay out the sheet of plywood .Draw a centreline for the board,  150cm long  24cm from the edge of the longest edge of the plywood (this ensure the grain of the outside layer of wood is running in the correct direction).This centreline is the most important reference mark for all subsequent measurements so make sure it is very clear.Clearly mark the tail width(28cm)  at one end (14cm either side of the centre line).Clearly mark the widest point (48cm wide, 24cm either side of the centre line) of the board (measured from the tail this shouldbe +/- 95-100cm from the tail) .Draw one side of the template connecting the tail, wide point and nose in  a nice flowing curve , use a flexible piece of timber to get a smooth curve.To ensure the board is symmetrical you can now meaure more offset points and transfer to the other side of the centre line to create a mirror image.Mark the fin locations as per attached photo.Mark the foot strap mount holes as per the attached photo", "step_imgs": ["https://cdn.instructables.com/FMF/AWWI/HS18H3GI/FMFAWWIHS18H3GI.LARGE.jpg"], "step_title": "Step 2: Draw Out the Template"}, {"step": 3, "steps_text": "Once the outline has been drawn out on the sheet of plywood it is time to cut it out.This first cut out will be the bottom lamination of the board, its important to cut this accurately as it will be used as the template for cutting out the middle and top sheets.Cutting a large sheet of plywood can be difficult if you do not have a large work bench, I found it easiest to cut out with the wood resting on the ground and use a small wooden block to support the panel immediately adjacent to where I was cutting.I cut out the template using a handsaw, this is less prone to wandering (cuts straighter) and does not splinter the wood as much as a jigsaw. However it does not like to follow tight curves and it is necessary to make multiple angled cuts then smooth off with a hand plane later .Ensure that you cut \"oversize\" as it is easy to plane back the wood to the line after the rough cut has been performed.Once the rough cut has been made use the block plane and sand paper to fine tune the outline .", "step_imgs": ["https://cdn.instructables.com/F08/U1UM/HS18H3GR/F08U1UMHS18H3GR.LARGE.jpg"], "step_title": "Step 3: Cut Out the Template"}, {"step": 4, "steps_text": "Use the bottom lamination as the master template for cutting out the top and centre laminations.The centre lamination is not one continuous panel and is made up of multiple segments that will be glued together when the board is laminated.As can be seen in the picture I ve left the tail area solid as this is where the fins and rear footstraps will be installed , ive also left it solid under the area where the front footstarp will be installed.If you were concerned about the weight of the board you could easily further reduce the amount of timber in the centre lamination as most of the stress is taken by the top and bottom sheets. One option would be to drill out weight saving holes in the timber to make a honey comb effect (too much trouble for me!)", "step_imgs": ["https://cdn.instructables.com/FFY/ETU0/HS18H3GD/FFYETU0HS18H3GD.LARGE.jpg"], "step_title": "Step 4: Cut Out Top and Centre Laminations"}, {"step": 5, "steps_text": "Before mixing any glue its important to prepare the area that you intend to do the gluing and assemble all the required materials. You will need a flat hard surface to glue the board on (im using a concrete slab in the picture). Lay down some plastic sheeting to capture any excess glue. Acquire the wooden blocking necessary to raise the nose end by 90mm and the tail end by 30mm and lay in position.Gather a bunch of weighting material with which to press the laminations together and form the rocker of the board while the glue sets (im using gym weights but bags of sand or buckets of water will work as well.Also do a trial fit up and any final trimming before the glue gets near the work. its a good idea to mark up exactly where the centre lamination will sit on the bottom lamination to allow accurate glue/epoxy placement.Lay down the bottom lamination resting on the wooden blocking (tip of nose raise 90mm , tail of board raised 30mm).Apply glue /epoxy to the bottom lamination.Lay down the middle lamination segments and apply lots of glue / epoxy to the top surface of them as well as the butt joints between pieces.Lay down the top lamination.If you have some clamps it is a good idea to install a few of these around the nose end of the board to hold the pieces in place while the weights are applied (see photo). Only install clamps on one end as the sheets must be able to slide relative to each other when the weights are applied and the board forms a curve.Stack up the weights on the board, concentrate most of the weight over the planned footstrap positions, this ensurethe correct distribution of rocker between the nose and tail. Apply sufficient weight to the board such that the belly of the board is pressed hard against the ground.With all of the weight applied walk around the outside of the board and check that the sheets have not been displaced side ways, a tap with a hammer is easiestto adjust any misalignment.Allow glue to set for 24hr before removing weights.", "step_imgs": ["https://cdn.instructables.com/F0J/VWO3/HS18H3G1/F0JVWO3HS18H3G1.LARGE.jpg"], "step_title": "Step 5: Glue the Laminations Together"}, {"step": 6, "steps_text": "Once the laminations are glued together remove all of the weights.You will find that the sheets will not be perfectly aligned due to slippage while gluing and it will be necessary to do some tidying up of the outline using the block plane to achieve a smooth template outline.To avoid errors sneaking in use the bottom sheet as the reference point and trim back the middle and top lamination to match the bottom sheet.Once the outline is fair it is necessary to shape the rails of the board. This is best achieved using the block plane and sand paper.for a directional board you will want hard turned down rails for the back 13 rd of the board , shape the front 1/3rd of the board as 50/50 rails and then transition between the two for the middle 1/3rd of the board . See my hand drawn illustration of rail shape on the plan.", "step_imgs": ["https://cdn.instructables.com/FRP/QHHH/HS18H3GP/FRPQHHHHS18H3GP.LARGE.jpg"], "step_title": "Step 6: Final Shaping"}, {"step": 7, "steps_text": "On wooden surfboards (which are thicker than kiteboards) ive made the recess for the fin box would be chiselled out from one side only however as a kite board is a lot thinner and plywood is a pain to chisel its easier to just cut the hole for the fin box completely through the board.Mark the centre line location of the fin boxes (see hand drawn plan in step 1) .Use a 3mm drill bit to drill multiple holes through the board along the planned line.Use a 12mm drill bit and open up the 3mm half way from one side then all the way from the other (yhis avoids too much splintering of the plywood).Work the drill bit against the sides of the holes to create a slot.Use a hole saw and are raps to tidy up the slot that has been created.Install the fin box into the slot (on th bottom side of the board) and draw around the top flange of the fin box.Use a chisel to create a recess to receive the top flange of the fin box so that it sits flush when installed.", "step_imgs": ["https://cdn.instructables.com/FP0/SKSI/HS18H3FM/FP0SKSIHS18H3FM.LARGE.jpg"], "step_title": "Step 7: Cut Out the Holes to Receive the Fin Boxes"}, {"step": 8, "steps_text": "Refering to the Hand drawn plan in step 1, mark the position of the footstrap holes.Using a 3mm drill bit drill the holes to receive the self tapping screws for receiving the footstraps.Only drill 2/3rd of the way through the board.Use a countersink bit to tidy up the top of the hole and prevent splintering the timber when the screw is installed.", "step_imgs": [], "step_title": "Step 8: Drill Hole for Footstraps."}, {"step": 9, "steps_text": "Before sealing the board with epoxy or varnish you can decorate the board.My daughter used water based kids poster paint to draw up a nice surfing dogs picture for me.", "step_imgs": ["https://cdn.instructables.com/FB6/48C6/HS18H3F9/FB648C6HS18H3F9.LARGE.jpg"], "step_title": "Step 9: Decorate the Board"}, {"step": 10, "steps_text": "Mix up some epoxy and roll it on the bottom of the board to seal the wood.Concentrate on getting good coverage in the slots for the fin boxes, footstrap holes and around the rails.With the epoxy still wet install the fin boxes and push firmly n place.Allow to dry then repeat for the top side of the board.Pour some excess epoxy in the gaps around the fin boxes to seal up the slot.", "step_imgs": ["https://cdn.instructables.com/F1J/WDRQ/HS18H3FD/F1JWDRQHS18H3FD.LARGE.jpg"], "step_title": "Step 10: Epoxy/seal the Board"}], "channel": "Water"}, {"category": "costumes", "description": "Introduction\r\nIt is often difficult to find a costume for events such as a Halloween costume party.\u00a0If you look for a costume in a store, it will be very expensive. The solution to this problem is to create your own costume. This Instructable offers a creative and simple costume design. The costume will be made out of cardboard only with no fasteners, so it can be taken apart and the pieces can be stacked. This allows the costume to be easily stored. It is also eco-friendly, because the only material is cardboard. This was a school project for\u00a0a Problem Solving and Design Course, and all of these factors had to be taken into account. This costume is a good way to save money and still have a creative costume.Design Brief\r\nA costume can be designed and instructed at a cheap price, and also be environmentally friendly. Design\u00a0a hermit crab\u00a0costume using cardboard and slotted construction that can be made for middle school aged children and is safe. Make a the design a flat pack, meaning it can be taken apart and stacked with only flat peices. This allows for the costume to be stored easily. Create the costume to be used for Halloween.Specifications\r\nThis costumes specifications include:\r\n- The only material that may be used is cardboard.\u00a0\r\n- Pieces must be assembled using slotted construction.\r\n- No adhesives of fasteners are permitted for use.\r\n- Parametrics and ergonomics must be considered, because the costumes are being designed for children of age 10-13.\r\n- A flat pack must be created with the pieces of the costumes, meaning all pieces must be flat so they can be stacked on each other.\r\n- Any costumes must be safe for age range.Limitations\r\nThis costume is limited to:\r\n-\u00a0The costumes are being designed for children of ages 10-13, therefore correct measurements must be made based on the average size of children in that age group.\r\n- A costume cannot limit a child\u2019s peripheral vision, mobility, and it must have proper ventilation. -The costumes must be safe enough so a child can use it with little supervision.\r\n-The costume must be visually appropriate and have a marine theme.MaterialsSupply ListS1: Single-ply Cardboard (two 32\" X 45\" X 5\" television boxes), Quantity: 4, Size: 20\" X 30\" (based on the average size of a 10-13 year-old.)Tools and Equipment ListT1: Cutting Mat, Use: To cut cardboard on.T2: Utility Knife, Use: To cut cardboard.T3: Ruler, Use: To measure pieces.T4: Pencil, Use: To score cardboard.", "title": "How to Make a Cardboard Hermit Crab Costume", "url": "https://www.instructables.com/id/How-to-Make-a-Cardboard-Hermit-Crab-Costume/", "section": "costumes", "steps": [{"step": 1, "steps_text": "All cutting done on a cutting mat (T1) and all measuring done with a ruler (T3).\r\n1. Measure and score a 20\u201d X 30\u201d rectangular piece of cardboard (S1) using a ruler (T3) and pencil (T4).\r\n2. Score a curvature with a pencil (T4) from the top right corner to the bottom right corner of the cardboard (S1) indenting 2\u201d in the center of the curve.\r\n3. Score an 8\u201d vertical line from the bottom left corner of the cardboard (S1) with a pencil (T4) and then begin a wide, even curvature until the mark reaches the top right corner of the cardboard (S1).\r\n4. Score a 16\u201d long curvature (Slot A) with a pencil (T4) conforming to the shape of the mark made in Step 3 that is 2\u201d to the right of the mark and 2\u201d above the bottom edge of the cardboard (S1).\r\n5. Score a 4\u201d long curvature (Slot B) with a pencil (T4) conforming to the shape of the mark made in Step 3 that is in the top right corner 2\u201d to the left of the mark made in Step 2 and 2\u201d below the mark made in Step 3 on the cardboard (S1).\r\n6. Score a 16\u201d long curvature (Slot C) with a pencil (T4) conforming to the shape of the mark made in Step 2 that is 2\u201d to the left of that mark and 2\u201d above the bottom edge of the cardboard (S1).\r\n7. Cut out the organic, triangular shape, and cut along all other scores made for slots with a utility knife (T2).", "step_imgs": ["https://cdn.instructables.com/FLS/MPUD/GIWZLGVY/FLSMPUDGIWZLGVY.LARGE.jpg"], "step_title": "Step 1: Part P1: Backside"}, {"step": 2, "steps_text": "All cutting done on a cutting mat (T1) and all measuring done with a ruler (T3).\r\n1. Measure and score a 20\u201d X 30\u201d rectangular piece of cardboard (S1) using a ruler (T3) and pencil (T4).\r\n2. Score two 9\u201d X 14\u201d rectangles with a pencil (T4) on the 20\u201d X 30\u201d piece of cardboard (S1).\r\n3. Cut out the 9\u201d X 14\u201d rectangles with a utility knife (T2) along the marks made.", "step_imgs": ["https://cdn.instructables.com/FLZ/UE70/GIWZLH1F/FLZUE70GIWZLH1F.LARGE.jpg"], "step_title": "Step 2: Part P2: Side Slot Pieces"}, {"step": 3, "steps_text": "All cutting done on a cutting mat (T1) and all measuring done with a ruler (T3).\r\n1. Measure and score a 20\u201d X 30\u201d rectangular piece of cardboard (S1) using a ruler (T3) and pencil (T4).\r\n2. Score one 9\u201d X 3\u201d rectangle with a pencil (T4) on the 20\u201d X 30\u201d piece of cardboard (S1).\r\n3. Cut out the 9\u201d X 3\u201d rectangle with a utility knife (T2) along the marks made.", "step_imgs": ["https://cdn.instructables.com/FYR/INYW/GIWZLH1R/FYRINYWGIWZLH1R.LARGE.jpg"], "step_title": "Step 3: Part P3: Top Slot Piece"}, {"step": 4, "steps_text": "All cutting done on a cutting mat (T1) and all measuring done with a ruler (T3).\r\n1. Repeat all steps for P1.\r\n2. Score six 1\u201d lines (Slot G) with a pencil (T4) that are 1\u201d apart from each other, and 2\u201d above the bottom side of the cardboard (S1), with the first line to the left being 4\u201d right of the left mark, and the last line being 4\u201d right of the right mark.", "step_imgs": ["https://cdn.instructables.com/FJM/8A61/GIWZLH40/FJM8A61GIWZLH40.LARGE.jpg"], "step_title": "Step 4: Part P4: Frontside"}, {"step": 5, "steps_text": "All cutting done on a cutting mat (T1) and all measuring done with a ruler (T3).\r\n1. Measure and score a 20\u201d X 30\u201d rectangular piece of cardboard (S1) using a ruler (T3) and pencil (T4).\r\n2. Score six 1\u201d X 4\u201d rectangles with a pencil (T4) on the 20\u201d X 30\u201d piece of cardboard (S1).\r\n3. Score an organic curvature of the legs according to the working drawings with a pencil (T4) (ATT: Orthographic View).\r\n4. Cut out along all marks made with a utility knife (T2).", "step_imgs": ["https://cdn.instructables.com/FTJ/3DTY/GIWZLH63/FTJ3DTYGIWZLH63.LARGE.jpg"], "step_title": "Step 5: Part P5: Legs"}, {"step": 6, "steps_text": "Part P1: Backside, Quantity: 1Part P2: Side Slot Piece, Quantity: 2Part P3: Top Slot Piece, Quantity: 1Part P4: Frontside, Quantity: 1Part P5: Legs, Quantity: 6\r\n*If necessary, increase the scale shown on the Orthographic View (1 in. = 8 in.). The scale is relative to the size of an average 10-13 year-old. Pieces can also be cut to the size of your body, if you do not want to measure them. ", "step_imgs": ["https://cdn.instructables.com/FVV/BYIQ/GIWZLMD1/FVVBYIQGIWZLMD1.LARGE.jpg"], "step_title": "Step 6: Part List (ATT: Orthographic View)"}, {"step": 7, "steps_text": "Refer to this drawing to complete the 8 assembly steps.", "step_imgs": ["https://cdn.instructables.com/F8R/MP03/GIWZLMDN/F8RMP03GIWZLMDN.LARGE.jpg"], "step_title": "Step 7: Steps for Assembly (ATT: Exploded View)"}, {"step": 8, "steps_text": "1. Curve a Top Slot Piece (P3) to conform with the shape of Slot A on the Backside (P1).", "step_imgs": ["https://cdn.instructables.com/F34/BNGQ/GIYWWE3C/F34BNGQGIYWWE3C.LARGE.jpg"], "step_title": "Step 8: Assembly Step 1"}, {"step": 9, "steps_text": "2. Insert a Top Slot Piece (P3) into Slot A on the Backside (P1) with the shorter side of 3\u201d on the Top Slot Piece (P3) being inserted into the slot.", "step_imgs": ["https://cdn.instructables.com/FKO/H9DE/GIYWWE3O/FKOH9DEGIYWWE3O.LARGE.jpg"], "step_title": "Step 9: Assembly Step 2"}, {"step": 10, "steps_text": "3. Curve a Side Slot Piece (P2) to conform with the shape of Slot B on the Backside (P1).", "step_imgs": ["https://cdn.instructables.com/FBN/CW1U/GIYWWE3X/FBNCW1UGIYWWE3X.LARGE.jpg"], "step_title": "Step 10: Assembly Step 3"}, {"step": 11, "steps_text": "4. Insert a Side Slot Piece (P2) into Slot B on the Backside (P1) with the longer side of 14\u201d on the Side Slot Piece (P2) being inserted into the slot.", "step_imgs": ["https://cdn.instructables.com/FXS/67Z8/GIYWWE43/FXS67Z8GIYWWE43.LARGE.jpg"], "step_title": "Step 11: Assembly Step 4"}, {"step": 12, "steps_text": "5. Curve a Side Slot Piece (P2) to conform with the shape of Slot C on the Backside (P1).", "step_imgs": ["https://cdn.instructables.com/F6E/SMJD/GIYWWE4D/F6ESMJDGIYWWE4D.LARGE.jpg"], "step_title": "Step 12: Assembly Step 5"}, {"step": 13, "steps_text": "6. Insert a Side Slot Piece (P2) into Slot C on the Backside (P1) with the longer side of 14\u201d on the Side Slot Piece (P2) being inserted into the slot.", "step_imgs": ["https://cdn.instructables.com/FEA/J1MK/GIYWWE4S/FEAJ1MKGIYWWE4S.LARGE.jpg"], "step_title": "Step 13: Assembly Step 6"}, {"step": 14, "steps_text": "7. Insert the Top Slot Piece (P3) protruding from Slot A on the Backside (P1) into Slot D on the Frontside (P4). Insert the Side Slot Piece (P2) protruding from Slot B on the Backside (P1) into Slot E on the Frontside (P4). Insert the Side Slot Piece (P2) protruding from Slot C on the Backside (P1) into Slot F on the Frontside (P4).", "step_imgs": ["https://cdn.instructables.com/FLX/OCJZ/GIYWWE54/FLXOCJZGIYWWE54.LARGE.jpg"], "step_title": "Step 14: Assembly Step 7"}, {"step": 15, "steps_text": "8. Fold the six Legs (P5) 1\u201d below the top edge to create Tab A. Insert Tab A on the Legs (P5) into Slot G on the Frontside (P4).", "step_imgs": ["https://cdn.instructables.com/F2H/Z2NE/GIYWWE5M/F2HZ2NEGIYWWE5M.LARGE.jpg"], "step_title": "Step 15: Assembly Step 8"}, {"step": 16, "steps_text": "If desired, you can paint the pieces to resemble a real hermit crab shell. Keep in mind that if you paint one side of a piece of cardboard, it will warp. To avoid this, paint both sides of all pieces, so they stay rigid. ", "step_imgs": [], "step_title": "Step 16: Painting the Costume"}, {"step": 17, "steps_text": "When worn, the costume is on your upper body. Your head should protrude from the gap between the Top Slot Piece (P3) and a Side Slot Piece (P2). Your arms should protrude from the gaps between the Top Slot Piece (P3) and the Side Slot Pieces (P2).", "step_imgs": [], "step_title": "Step 17: Wearing the Costume"}, {"step": 18, "steps_text": "Have fun wearing your cardboard Hermit Crab costume!", "step_imgs": [], "step_title": "Step 18: Enjoy!"}], "channel": "Animals"}, {"category": "costumes", "description": "My grandson is a mine craft fan, and for his 7th birthday, he was \"dreaming\" of having  a real minecraft armour stand to put his minecraft helmet on.  (from a school \u201cdress up\u201d)", "title": "Life-Sized Minecraft Armour Stand", "url": "https://www.instructables.com/id/Life-Sized-Minecraft-Armour-Stand/", "section": "costumes", "steps": [{"step": 1, "steps_text": "The model was scaled to 1200 mm high from online photos and was constructed of  plywood and pine, made into hollow tubes to minimise the weight but to maintain strength, with a base large enough to resist tipping.The wooden construction is straightforward , except to say that the pine inserts in the end of each vertical tube need to be accurately made as a push-fit into the tubes. The painting takes some time!", "step_imgs": ["https://cdn.instructables.com/FCA/DTUH/JDKKMU46/FCADTUHJDKKMU46.LARGE.jpg"], "step_title": "Step 1: Making the Full-size Minecraft Armour Stand."}, {"step": 2, "steps_text": "3mm plywood at least 900 mm x 900 mm for the tube sides6mm plywood x 600 x 450 for the base2.5 metres x 80mm x 15mm radiata pine for tube sides900 mm x 120mm x 15mm radiata pine for larger horizontal tube 9 x 79mm  x 55mm  x 20mm radiata pine for tube ends1 x 74mm x 50mm x 20 mm radiata pine for base of the top tube.2 pieces 38 x 38 x 500mm radiata pine for the base2 pieces 38 x 38 x 370mm radiata pine for the base1 x 38 x 80 x 420mm radiata pine for the cross piece in the base15mm panel pinsPVA wood glueWood fillerPrimer/Undercoat to cover whole model 3 x 250 ml sample pots of grey paint (Dulux colours):Dieskau (GR12), Stepney (GR11) Silkwort (GR12)3 x 250ml sample pots of brown paint (Taubmans colours):Turtle Tan (T10 8E-2),  Bran Muffin (T10 8F-1), Brown Basket (T10 8F-2)250 ml Clear satin acrylic (if desired)Green or blue masking tape4 stick on rubber feet (if required)7 x 30mm 10g woodscrews2 x 50mm 8g woodscrews", "step_imgs": [], "step_title": "Step 2: Materials:"}, {"step": 3, "steps_text": "Essential Tools: Set squarePencilSawHammerTape measureScrewdriverDrill and bits to make the screw holes & countersink them.Paint brushes or a sprayer.Ear and eye protection. (hammers and power tools are noisy)Desirable Tools:Table saw with a fine tooth bladeDriver bit and cordless drill.", "step_imgs": [], "step_title": "Step 3: Tools:"}, {"step": 4, "steps_text": "For accurate dimensions, see the Fusion 360 diagrams and model.  I scaled mine to be about the same height as my grandson, but it could be made to any size you wanted.", "step_imgs": ["https://cdn.instructables.com/F9T/EBDX/JDKKMUTE/F9TEBDXJDKKMUTE.LARGE.jpg", "https://cdn.instructables.com/FLT/O8MX/JDKKKPEM/FLTO8MXJDKKKPEM.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 4: Model Dimensions:"}, {"step": 5, "steps_text": "There are no step-by-step photos.  (construction is  simple)1) Make the base: The base sides are 4 pieces of wood: 2 x 38 x 38  x 500mm 2 x 38 x 38 x 370 butt jointed, glued and nailed to a piece of 6mm ply 450 x 500mm.  It has a piece of 80 x 38 x 420mm  wood  laterally across the centre so that the screws which secure the \u201clegs\u201d have something to grip onto, and so that the load is more evenly distributed over the base.The base was made to be detachable for easy transportation.  If the armour stand is likely to scratch the floor then adhesive rubber feet can be attached near each corner.2) Build the boxes:To simplify construction  I used 15mm pine for each 2 opposing sides, and 3mm plywood for the other 2 opposing sides.Once the  wood  is accurately cut into strips of the appropriate width (preferably with a table saw) it is cut to length and glued and nailed together into square tubes.The vertical boxes for each level must be exactly the same length, and any discrepancy should be corrected at this stage.3) Make the ends for the boxes:Two 20mm thick end plugs are needed for each vertical box, and they should be accurately cut to ensure a snug fit inside each box. (nominally 79mm x 55mm).   The top vertical box and the  horizontal boxes have a 3mm plywood \u201ccap\u201d over them rather than a fitted \u201cplug\u201d of wood.", "step_imgs": [], "step_title": "Step 5: Construction Detail:"}, {"step": 6, "steps_text": "The plywood ends are glued and nailed onto both horizontal boxes and sanded flush.  Sanding is much easier at this stage, and putting the ends on the boxes adds rigidity.The boxes that form the horizontal parts of the model should have the 15mm thick sides on the top & bottom so that there is enough wood for the screws to bite into.  In the end, it is the PVA glue that will hold it together, but the screws keep everything aligned until the glue is dried.At this stage, end blocks can be glued into the lower end  of the 2 lower legs, so the legs can be screwed  to the base when the main body is complete.Holes big enough for the 30mm screws can be drilled and countersunk at the centre of all the end plugs except the lower 2.  These ones will have smaller pilot holes drilled later when the stand is joined to the base.   To attach the \u201clegs\u201d onto the lower horizontal box:Mark and carefully measure where  the blocks should go Drill pilot holes Glue and screw one of the end  blocks in position. Glue on the leg.  Before the glue  starts to set between the end plug and the horizontal box, do any  fine rotational adjustment to align the leg perfectly with the edge  of the horizontal box.  If it doesn't align, this step will need to be re-done.Repeat for the other leg, then the same for both the vertical \u201cbody\u201d pieces, making sure at all times that the verticals are 120mm apart and parallel.Repeat the measuring and positioning for the longer horizontal box.  As this box is fitted to the top of both of the vertical \u201cbody\u201d boxes at once,  it needs to be tapped down evenly to prevent binding.  A piece of flat scrap wood is handy to prevent the model being damaged by the hammer.Once the vertical box is on the top, the body is complete!", "step_imgs": [], "step_title": "Step 6: Assembly:"}, {"step": 7, "steps_text": "When the glue is dry on the main body,  attach the base using 2 x 50mm woodscrews through the 38mm cross beam in the base.: Measure  100mm each side of centre   on the 38x80 cross piece, Drill & countersink holes for  the 50mm screws. The countersink should be deep enough so that the screw is about 5mm below the surface of the woodTo ensure accuracy:Mark out where the legs should   attach to the base using a pencil, or masking tape.  It is possible  to stand the main body up on the base, and support it or have  someone hold it while you mark it. With the main body flat on a table  or bench, support the base so that it aligns with the marks. Put one of the screws into the  base, and when it is properly aligned with the leg, tap it with a  hammer to mark the position for the hole in the bottom of the leg. Put the base aside and drill a  pilot hole in the mark you have just made. Retrieve the base, screw the screw  a few threads into the hole you just drilled,  until it is just firm   (not all the way in) Re-align the legs on the base,  ensure that the legs are parallel, then tap the screw in the other  hole to mark the other leg, Loosen the first screw Drill the pilot hole in the second  leg Screw both screws all the way in  to legs through the base.This might seem like the long way around, but it gives more accurate and reliable hole positioning.", "step_imgs": [], "step_title": "Step 7: Attaching the Base:"}, {"step": 8, "steps_text": "Prior to painting, any holes or gaps should be filled and sanded smooth.After this is done, the whole model should be given a coat of primer/undercoat and  allowed to dry overnight.Before any more paint goes on, the entire base should be masked.  I used newspaper to cover the large areas, and held it down with masking tape.From the materials list you will see there are 3 browns and 3 greys. Those with a discerning eye may notice more than 3 of each colour in online photos, like this one from Gamepedia.com:https://minecraft.gamepedia.com/Armor_StandTo get more than 3 colours:Apply 2 coats of  the lightest  colour as a base-coat,  leave it overnight. Mix some of the next darkest  colour with the first colour. It's best to use a separate container so that you will still have the original colours, and so any touch-up or corrections will be  easier.Working from a photo, mask the  bits that you want to remain light, apply the next 2 coats. Remask re-mix, and repaint until  you get to the last and darkest colour. Do this first for the armour stand body  then the grey base.The masking tape should be either green or blue, as it peels off easier than standard masking tape.  I used acrylic paints and allowed a day to dry for each colour before masking up and re-painting.  I did this so the paint would be strong enough to resist peeling with the tape.  Even so there was still some small amount of lifting which had to be fixed up later.Where you put the squares is up to you, but it's best if they are some easy fraction of the width of the arms & legs. Eg. The top horizontal piece is 120mm x 120mm, the other components are  about 85mm wide.  A  square of around 40mm works fine.  (They don't have to be \"exact\")It's best to look at a few online examples, and copy them.", "step_imgs": ["https://cdn.instructables.com/F5Y/KPXD/JDKKMUH5/F5YKPXDJDKKMUH5.LARGE.jpg", "https://cdn.instructables.com/F0D/4Z5Y/JDKKMU5E/F0D4Z5YJDKKMU5E.LARGE.jpg"], "step_title": "Step 8: Painting the Main Body:"}, {"step": 9, "steps_text": "Once all the coats of paint are on the main stand, peel off all the masking tape, fix any glaring errors, re-mask the legs to prevent the grey from the base getting on them, then repeat the paint-mask-mix-paint sequence on the base.Once all the painting is done, remove the masking tape, and fix any serious errors.  I gave the whole stand a light sand to smooth out the ridges where the tape overlapped the paint, and I put a final coat of satin clear  acrylic over the whole model to improve wear,  make it  easier to clean and to even out the textures.The armour stand was a great hit at the birthday party, and still gets plenty of use.It works well for Minecraft armour (made from cardboard boxes) and is also very handy for school clothes....", "step_imgs": [], "step_title": "Step 9: Painting the Base:"}], "channel": "Games"}, {"category": "costumes", "description": "\nMany people have a hard time trying to find their child a costume for Halloween, because it's too expensive.\u00a0Here is a costume that is eco-friendly and can be made at home as a family project.\u00a0This instructable was made for my high school project, which was to \"go green\" by\u00a0creating a marine themed costume made out of cardboard. Our group chose a reef animals theme, which included a clownfish, jellyfish, seahorse, turtle, and a manta ray.\u00a0This costume is creative and still saves you money.Design Brief:\nDesign and build a\u00a0marine themed\u00a0costume made solely out of cardboard without any adhesives. It also had to be made using slotted construction for easy flat pack storage. The costume is intended to fit middle school students (ages 10-13) either for Halloween or a staged show.Specifications:\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Marine-themed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Slotted construction\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Cardboard(any type)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Flat pack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Safe for age range\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0-10-13 year olds are target audienceLimitations:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - No tape, glue, or any other adhesive\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Able to be worn as stage costume or for Halloween\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -CardboardMaterials: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 QTY \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Size\n(S1) Cardboard \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a08-6\"x4\"\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a024\"x2\"\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a032\"-4\"on top, thinner on bottom cardboard\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a045\"across-thin on outside, thicker on inside cardboard\u00a0Tools: \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Use\n(T1)Cutting mat \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Padding to put underneath cardboard when cutting\n(T2)Utility knife \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Used to cut thicker cardboard\n(T3)Ruler \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Used to measure different parts of the costume\n(T3) Pencil \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Used to draw out all parts of costume onto cardboard before \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0cutting\n(T4) Circle template/compass \u00a0 \u00a0 \u00a0 \u00a0Used to draw rounded or circular shape\n(T5) Scissors \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Used to cut pieces of cardboard that are thinner and has a \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0round shapeParts: \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 QTY\n(P1) Eyes \u00a0 \u00a0 \u00a0 \u00a0 2\n(P2) Strap \u00a0 \u00a0 \u00a0 \u00a01\n(P3) Tail \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1\n(P4) Body \u00a0 \u00a0 \u00a0 \u00a01 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0", "title": "Swimming Through Seas in a Manta Ray Costume", "url": "https://www.instructables.com/id/Swimming-Through-Seas-in-a-Manta-Ray-Costume/", "section": "costumes", "steps": [{"step": 1, "steps_text": "\n1. Measure(T3) and draw(T4) 8 pieces of carboard(S1) that are 4\"x6 1.\n2. Cut out parts with a utility knife(T2) over a cutting mat(T1)2.\n3. Cut slots(T2) 1\" in each side of all 8 pieces", "step_imgs": ["https://cdn.instructables.com/FYC/5S29/GIWZLX7L/FYC5S29GIWZLX7L.LARGE.jpg"], "step_title": "Step 1: Part 1:Eyes-Measuring and Cutting Slots"}, {"step": 2, "steps_text": "1. Slot 4 pieces together to form a box and repeat so you have 2 boxes\r\n2. Cut(T2) 1\" slots on one opposite side of each box*Note: If you have extra strips of cardboard sticking out, trim it off with scissors(T6)", "step_imgs": ["https://cdn.instructables.com/F1F/U30E/GIWZLX7Z/F1FU30EGIWZLX7Z.LARGE.jpg"], "step_title": "Step 2: Part 1:Eyes-Slotting Together"}, {"step": 3, "steps_text": "1. Measure(T3) and draw(T4) a piece of cardboard(S1) that's 24\"x2\" 1.\n2. Cut out part with utility knife(T2) over a cutting mat(T1)3.\n3. Fold 3\" on each side* Note: This measurement is just an average measure so you can adjust it if you need to", "step_imgs": ["https://cdn.instructables.com/FVH/SGI9/GIWZLX84/FVHSGI9GIWZLX84.LARGE.jpg"], "step_title": "Step 3: Part 2:Strap-Measuring, Cutting and Folding"}, {"step": 4, "steps_text": "Measure(T3) and draw(T4) a piece of carboard(S1) that's 32\" lengthwise, 4\" on top across, and growing thinner on the bottom", "step_imgs": ["https://cdn.instructables.com/FR0/M0UJ/GIWZLX8O/FR0M0UJGIWZLX8O.LARGE.jpg"], "step_title": "Step 4: Part 3:Tail-Measuring"}, {"step": 5, "steps_text": "1. Cut out part with utility knife(T2) over a cutting mat(T1)\n3. Measure(T3) 1\" down, then drawing(T4) a square that's 1 1/2\" on both sides of the tail\n4. Cut out(T2) the 1 1/2\" squares", "step_imgs": ["https://cdn.instructables.com/FN6/8426/GIWZLX8V/FN68426GIWZLX8V.LARGE.jpg"], "step_title": "Step 5: Part 3:Tail-Cutting"}, {"step": 6, "steps_text": "\n\t1. Measure(T3) and draw(T4) a piece of cardboard(S1) that's 45\" across, growing thin on the outside to thicker on the inside.Note: the middle(tallest point) should be 19\"\n\t2. Cut out part with utility knife(T2) over a cutting mat(T1)", "step_imgs": ["https://cdn.instructables.com/F7F/Y4MU/GIWZLX99/F7FY4MUGIWZLX99.LARGE.jpg"], "step_title": "Step 6: Part 4:Body-Measuring"}, {"step": 7, "steps_text": "1. Cut(T2) a slot 5\" up from the bottom that's 4\" long and has a 1/4\" width over a cutting mat(T1)\n2. Cut(T2) 2 slots that are 3\" from the left of middle and are 4\" apart and 1\" deep over a cutting mat(T1)\n3. Repeat step 2 on the right side", "step_imgs": ["https://cdn.instructables.com/FIM/9PY6/GIWZLX9Z/FIM9PY6GIWZLX9Z.LARGE.jpg"], "step_title": "Step 7: Part 4:Body-Cutting Slots"}, {"step": 8, "steps_text": "1. Cut(T2) one slot 7\" from the end of the left side of the body(P4) that's 2\" long (up to down)\r\n2. Repeat on the right side", "step_imgs": ["https://cdn.instructables.com/FCA/UQEY/GIWZLXAF/FCAUQEYGIWZLXAF.LARGE.jpg"], "step_title": "Step 8: Part 4:Body-Cutting Slots Cont."}, {"step": 9, "steps_text": "1. Take the tail(P3) and slide it into the body(P4) at the bottom slot\n2. You can fold the top of the tail(P3) into the body (P4) to make it stay", "step_imgs": ["https://cdn.instructables.com/FVT/AR7S/GIWZLXAN/FVTAR7SGIWZLXAN.LARGE.jpg", "https://cdn.instructables.com/FY1/JQYM/GIWZLXAQ/FY1JQYMGIWZLXAQ.LARGE.jpg"], "step_title": "Step 9: Assembly Part 1"}, {"step": 10, "steps_text": "Take the eyes(P1) and slide them into the\u00a0body(P4) at the top where\u00a0there's 4 slots cut (2 slots for each eye)\u00a0", "step_imgs": ["https://cdn.instructables.com/FA7/5X18/GIWZLXB6/FA75X18GIWZLXB6.LARGE.jpg"], "step_title": "Step 10: Assembly Part 2"}, {"step": 11, "steps_text": "1. Take the strap(P2) and\u00a0insert it into the body(P4) where there are two slots that are 24\" apart (the two slots 7\" from the end)\n2. Bend the strap(P2) into the body so it stays", "step_imgs": ["https://cdn.instructables.com/F5F/1KCD/GIWZLXBE/F5F1KCDGIWZLXBE.LARGE.jpg"], "step_title": "Step 11: Assembly Part 3"}, {"step": 12, "steps_text": "", "step_imgs": ["https://cdn.instructables.com/FER/NR1V/GIWZLXBR/FERNR1VGIWZLXBR.LARGE.jpg", "https://cdn.instructables.com/FEO/59QP/GIWZLXBX/FEO59QPGIWZLXBX.LARGE.jpg"], "step_title": "Step 12: Final Costume"}, {"step": 13, "steps_text": "If you feel like you wish to paint the costume, be careful because the cardboard will warp. To prevent the costume from warping, paint both sides of the cardboard. In this case however, you may want the cardboard to warp so that the ray has curved wings.", "step_imgs": [], "step_title": "Step 13: Extra Notes-Color"}], "channel": "Animals"}, {"category": "costumes", "description": "\r\n\tThis instructable was inspired by a school project in my technology class. We were given the task of creating costumes made completely from slotted construction and cardboard. No glue, no tape.\u00a0We needed to learn the design process hands on so we\u00a0were placed in groups to determine the main theme of our costumes. Our project which had seemed so simple had evolved into a day by day mindset. Cardboard, learning about cardboard, and slotting cardboard was all that was on our minds. My group of four peers settled on the theme of \"Marine Life\". This incorperated a clownfish(anemone-fish), a seahorse, a jellyfish,\u00a0and a sea turtle.\r\n\tI learned a lot about how hard a designer's job really is. There are many steps which all require deep thought. You may be surprised that the final step, creating the product, is one of the easiest! However, the work paid off and I know have this easy and simple costume to share with you. You can use this for a school play or even trick or treating on a tight budget. Either way, I know you'll look great in it.\r\n\t\u00a0This is the basis of what we needed for the costume in case your curious\r\n\tSpecs-\r\n\t\u00a0\r\n\t1. Made from only cardboard\r\n\t2.\u00a0Made from slotted constructions\r\n\t3. No adhesive\r\n\t4. Must be flat-pack\r\n\tLimits-\u00a0\r\n\t\u00a0\r\n\t1. must be able to fit through a 7' by 3' opening", "title": "An Undersea Turtle Costume Made Simple", "url": "https://www.instructables.com/id/An-Undersea-Turtle-Costume-Made-Simple/", "section": "costumes", "steps": [{"step": 1, "steps_text": "The materials needed for this costume are cheap, easy to find, and easy to decorate. In the steps I will give a name of a material or tool and if you aren't sure what that is it will have the name next to it.\r\nex. Use the poster board(S1)Name -\u00a0Amount - Materials - Size -\u00a0Use\r\nS1 -4 - two ply sheets of carboard - 1'4'' by 8'' - Turtle Foot\r\nS2 -1 - sheet of poasterboard sheet - 2' 6'' by 3'6'' - Turtle shellName - Amount -\u00a0Tool\u00a0- Use\r\nT1 - 1 -\u00a0Ex-acto knife - to cut cardboard\r\nT2 - 1\u00a0-\u00a0Cutting mat - to save your tables and floors from gouging\r\nT3 -\u00a01 - Pencil - To mark measurements\r\nT4 - 1- Ruler - To measure\u00a0\u00a0Name - Amount -\u00a0Part \r\nP1 - 4\u00a0- Turtle foot\r\nP2 - 1 - Turtle Shell", "step_imgs": ["https://cdn.instructables.com/FFF/NZ8B/GIYWWK9Q/FFFNZ8BGIYWWK9Q.LARGE.jpg", "https://cdn.instructables.com/FQ9/XWJQ/GIYWWKF4/FQ9XWJQGIYWWKF4.LARGE.jpg"], "step_title": "Step 1: Materials, Tools, & Parts (Oh My!)"}, {"step": 2, "steps_text": "Find a clear space to work and lay out all of your tools and materials close by.\r\nRead through the rules once before begining. You may find that you want things to be slightly different and once you cut there is no going back.", "step_imgs": ["https://cdn.instructables.com/FRJ/K01E/GIYWWKB7/FRJK01EGIYWWKB7.LARGE.jpg"], "step_title": "Step 2: Step 1. Preparation"}, {"step": 3, "steps_text": "\r\n\t1. Take out a sheet of cardboard(S1) and lay it over the cutting mat(T2).\r\n\t2. Start at the top-left edge and measure(T4) down\u00a04'' and mark(T3) as point \"A\"\r\n\t3. Measure(T4) across to the right\u00a06'' and mark(T3) as point \"B\"\r\n\t4. Measure(T4) across to the right 3'' and up 4'' and mark(T3) as point \"C\"\r\n\t5. Measure(T4) down 4'' and over to the right\u00a03'' and mark(T3) as point \"D\"\r\n\t6. Measure(T4) from \"D\" to the right and at the edge mark(T3) point \"E\"\r\n\t7. Measure(T4) down 2'' from \"A\" and mark(T3) as point \"F\"\r\n\t8. Measure(T4) down 2'' from\u00a0\"B\" and mark(T3) as point \"G\"\r\n\t9. Measure(T4) down 2'' from\"D\"\u00a0and mark(T3) as point \"J\"\r\n\t10.Measure(T4) down 2'' from \"E\" and mark(T3) as point \"K\"\r\n\t11.Measure(T4) from \"G\" down 2'' and over to the right 2'' and mark(T3) as point \"H\"\r\n\t12.Measure(T4) across to the right 2'' and mark(T3) as point \"I\"\r\n\t13.Draw(T3) a line from \"A\" to \"B\", from \"B\" to \"C\", from \"C\" to \"D\", and from \"D\" to E\"\r\n\t14.Draw(T3) a line from \"F\" to \"G\",\u00a0 from \"H\" to \"I\",\u00a0 and from \"J\" to K\"\r\n\t15. Draw(T3) a rounded outward\u00a0line from \"G\" to \"H\" and\u00a0from \"I\" to \"J\",\r\n\t16. Use the knife(T1) to cut along the lines.\r\n\t17. Measure(T4) 1/2''\u00a0to the right\u00a0from point \"A\" and score(T3)\u00a0and down 1'' and score(T3).\r\n\t18. Cut(T1) between the score marks.\r\n\t19. Measure(T4) 1/2'' to the\u00a0left from point \"K\" and score(T3) and down 1'' and score(T3).\r\n\t20. Cut(T1) between the score marks.\r\n\t\u00a0", "step_imgs": ["https://cdn.instructables.com/FJ1/8IIO/GIYWWKCJ/FJ18IIOGIYWWKCJ.LARGE.jpg", "https://cdn.instructables.com/FER/48WG/GIYWWKCK/FER48WGGIYWWKCK.LARGE.jpg"], "step_title": "Step 3: Steps for the Creating Turtle Foot (P1)"}, {"step": 4, "steps_text": "1. Wrap cardboard around leg or arm.\r\n2. Connect the cut near point \"K\" to the cut near \"A\"\r\n3. Slot together", "step_imgs": ["https://cdn.instructables.com/F61/3J6C/GIYWWKCZ/F613J6CGIYWWKCZ.LARGE.jpg"], "step_title": "Step 4: Steps for Assembling the Turtle Foot (P1)"}, {"step": 5, "steps_text": "1. Place the cutting mat(T2) under the posterboard(S2). Measure(T4) 4'' to the right\u00a0of the top left corner\u00a0and mark(T3) as \"A\"\r\n2. Measure(T4) 2'' to the right of\u00a0\"A\" and mark(T3) as \"B\"\r\n3. Measure(T4) 6'' to the right of \"B\"and mark(T3) as \"C\"\r\n4. Measure(T4) 2'' to the right \"C\" and mark(T3) as \"A\"\r\n5. Measure(T4) down 9'' from \"A\",\"B\",\"C\",and \"D\" and mark(T3) as \"E\", \"F\", \"G\",and \"H\"\r\n6. Measure(T4) 4''\u00a0to the left and 4'' down of \"E\" and mark(T3) as \"I\"\r\n7. Measure(T4) 6'' down from \"I\" and mark(T3) as \"K\"\r\n8. Measure(T4) 1'6'' to the right of \"I\" and \"K\" and mark(T3) as \"J\" and \"L\".\r\n9. Measure(T4)\u00a06'' to the right of \"K\" and down 1' and mark(T3) as \"M\"\r\n10. Measure(T4)\u00a0across 6'' and mark(T3) as \"N\"\r\n11. Draw(T3) a rounded outward line from \"K\" to \"M\" and from \"L\" to \"M\"\r\n12.Draw(T3) a line from \"I\" to \"E\", \"E\" to \"A\", \"B\" to F\", \"G\" to \"C\", \"D\" to \"H\", and \"H\" to \"J\"\r\n13. Go over 1'6'' from the top-left edge and perform steps 1.- but don't mark \"A\",\"B\",\"C\", and \"D\". Also, add a \"2\" to every letter.\u00a0\r\n14. Draw(T3) a rounded inward line from \"F\" to \"G\".\r\n15. Draw(T3) a line from \"E2\" to \"H2\"\r\n16. Cut a 1'' slot near \"A\", \"C\", \"E2\", and \"H2\"", "step_imgs": ["https://cdn.instructables.com/FJ7/H1FC/GIYWWM0L/FJ7H1FCGIYWWM0L.LARGE.jpg"], "step_title": "Step 5: Steps for Creating the Turtle Shell (P2)"}, {"step": 6, "steps_text": "1. Wrap around body.\r\n2. Slot the scored mark areas to the back of the costume", "step_imgs": [], "step_title": "Step 6: Steps for Assembling the Turtle Shell (P2)"}], "channel": "Animals"}, {"category": "costumes", "description": "At school we were recently assigned a project where we designed and created a cardboard halloween costume. This costume had to be made out of slotted construction and also had to have a marine theme. I chose to make a clam costume. During this process we had to design the costume on paper, trace them onto cardboard pieces, and then finally assembling them. I had many different ideas while creating this idea, but i finally came up with the best solution which is diagrammed here in my instructable.\u00a0\nDesign Brief: I was part of a group with five members, our task was to design five costumes with a common marine theme using the method of slotted construction. My task in this group was to design and produce a clam costume out of slotted construction.\u00a0\nSpecifications:\n- The costume must be able be able to be worn by a middle school sized child\n- The costume must be a Halloween costume or a stage costume\u00a0\n- The costume must be flat pack construction (flat parts that can easily be folded and assembled)\nLimitations:\n- The costume must strictly be made of cardboard\n- No staples or adhesive may be used\n-\u00a0The costume must be only slotted construction\n- The costume must be flat pack construction\n- The cardboard for this costume must be easily obtainable\nMaterial List\u00a0\n- (S1) Cardboard Top Shell Piece, size 18\" by 21\", Qty 1. Can be made out of \u00a0the back of a trifold board.\n- (S2) Cardboard Bottom Shell Piece, size 20\" by 25\", Qty \u00a01. Can be made out of half of a speaker box.\n- (T1) Cutting Mat, to make cutting easier and to protect the cutting surface.\n- (T2) Utility Knife, to cut the cardboard.\n- (T3) Ruler, to make straight lines.\n- (T4) Pencil, to mark cuts\u00a0\nNOTE: 2 ply cardboard may be better to use for this costume.\nParts List\n- \u00a0( P1) Top Shell\u00a0\n- \u00a0(P2) Bottom Shell", "title": "Cool Cardboard Clam Costume", "url": "https://www.instructables.com/id/Cool-Cardboard-Calm-Costume/", "section": "costumes", "steps": [{"step": 1, "steps_text": "1. Start with a sheet of 2-ply cardboard. Mark off 18 inches for the bottom of the top shell(S1). Measure with a ruler (T3) and score with a pencil(T4) for the correct length.\n2. Measure with the ruler(T3) 21 inches from the center of the bottom of the shell and mark it with a pencil(T4)\n3. Draw rounded edges with a pencil (T4)\n4. Use a utility knife(T2) to cut out the shape where the designated lines were drawn\n\u00a0", "step_imgs": ["https://cdn.instructables.com/FLP/HE3S/GIYWWJ3L/FLPHE3SGIYWWJ3L.LARGE.jpg"], "step_title": "Step 1: "}, {"step": 2, "steps_text": "1. Start with a sheet of 2-ply cardboard. Mark off 20 inches for the bottom of the bottom shell(S2). Measure with a ruler (T3) and score with a pencil(T4) for the correct length.\n2. Measure with the ruler(T3) 25 inches from the center of the bottom of the shell and mark it with a pencil(T4)\n3. Draw rounded edges with a pencil (T4)\n4. Use a utility knife(T2) to cut out the shape where the designated lines were drawn\n5. Measure 5 inches from the bottom of the shell with the ruler(T3) then mark it with a pencil(T4)\n6. From the mark you make in step 5 measure 10 inches from that point with a ruler (T3)\n7. Draw rounded edges with a pencil(T4)\n8. Use a utility knife(T2) to cut out the shape where the designated lines were drawn\n9. Measure 2 and \u00bd inches from the bottom of the shell and mark with a pencil(T4)\n10. From this point measure horizontally with a ruler(T3) 18 and \u00bd inches\n11. Use a utility knife(T2) to cut out the shape where the designated lines were drawn\n\u00a0", "step_imgs": ["https://cdn.instructables.com/FT2/PZB7/GIYWWJ3S/FT2PZB7GIYWWJ3S.LARGE.jpg"], "step_title": "Step 2: Construction of the Bottom Shell"}, {"step": 3, "steps_text": "1. Take the top shell(p1) and insert it into the slot that was made in the bottom shell(p2)\nFor more information see the following attached file.\n\u00a0", "step_imgs": ["https://cdn.instructables.com/FD6/52P2/GIYWWNG8/FD652P2GIYWWNG8.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 3: Assembly"}], "channel": "For Kids"}, {"category": "technology", "description": "We will create a Verilog project for the Digilent Zybo to create a 1 Kilohertz sine wave on the output pins of a Digilent Pmod R2R. This project is intended as a introduction to production of sine waves using an FPGA, a critical step in starting a number of more complex projects, such as driving audio hardware and other analog circuits. We will also use a new feature of Vivado 2016.2, Add Module in the IP Integrator, which makes prototyping of complex projects relatively easy, as we will be able to skip the step of writing an HDL wrapper file and easily see how our modules are connected together and interact.The project is provided, build-able through a TCL script. If you only want the source code, the HDL (hardware descriptive language) files can be found under src/hdl. In order to use the IP Integrator and generate a bitstream file, the project will need to be built through Vivado's TCL console. A good tutorial for this process can be found in this Instructable. Downloading and building this project is not required though, as we will walk through what is required for you to create the project yourself.", "title": "Digilent Pmod R2R Sine Wave Generator", "url": "https://www.instructables.com/id/Digilent-Pmod-R2R-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "Materials Requirements ListInstalled version of Vivado 2016.2 --Earlier versions will not work, as a new feature in the IPI, \"Add Module\", will be used, though you may still be able to follow along and write a custom HDL wrapper. A Digilent Zybo (or other compatible Digilent FPGA).Your Digilent PmodR2R. A master XDC file for your Digilent board -- available through the board's page on the Digilent Wiki.. A Python environment.Functional DescriptionThe PmodR2R allows us to output voltages in a range between its ground and VDD levels. We pass the R2R 8 bits of input, ranging from 0 to 0xFF (255 in hexadecimal). It then outputs a voltage corresponding to our input, passing a zero means it will output ground, passing 0xFF means it will output 3.3V, the typical supply voltage for the Pmod headers on Digilent boards.In order to produce a 3.3V zero-to-peak sine wave, we will need to repeatedly count through a single sin wave scaled to the range 0 to 0xFF. The easiest way to do this in Verilog will be to create a lookup table, basically just an array, filled with the correct values in order. We would then count through the array, outputting each value in order. Since we also want to control the frequency of our sine wave, we will need a way to control the speed at which we count through our sine wave. The easiest way to do this is to only increment our counter every so often, which we can achieve by enabling it only when another counter hits a maximum value. We will talk about how to implement this in Verilog later.This design will give us essentially two variables we can use to control the speed and resolution of our sine wave in our lookup table size and maximum count of our \"clock divider\" counter. Depending on the selected values, we are placing a cap on the frequencies available at the R2R output, and the higher we decide to place this cap the worse the resolution of our signal will be. With the selected target frequency of 1KHz, we will be able to ignore this tradeoff and produce a reasonable result. We will discuss the selection of these parameters later.", "step_imgs": [], "step_title": "Step 1: Project Overview"}, {"step": 2, "steps_text": "After loading up Vivado, in order to get the project set up, follow these steps:Select \"Create New Project\". Select \"Next\", add a name for your project, without spaces, and select \"Next\". Make Sure \"RTL Project\" and \"Do not specify sources at this time\" are selected. Select \"Next\". Select Boards, and find and select your board's part file. Select \"Next\". Select \"Finish\".With this Vivado will have created a new empty project for you.", "step_imgs": ["https://cdn.instructables.com/F4R/0CPQ/IR3ZSZNK/F4R0CPQIR3ZSZNK.LARGE.jpg", "https://cdn.instructables.com/F9F/BCVY/IR3ZSZNL/F9FBCVYIR3ZSZNL.LARGE.jpg", "https://cdn.instructables.com/F5P/LJ1M/IR3ZSZNW/F5PLJ1MIR3ZSZNW.LARGE.jpg", "https://cdn.instructables.com/FSV/7JJC/IR3ZSZO4/FSV7JJCIR3ZSZO4.LARGE.jpg", "https://cdn.instructables.com/FOG/N3K2/IR3ZSZO5/FOGN3K2IR3ZSZO5.LARGE.jpg", "https://cdn.instructables.com/FSA/UEA3/IR3ZSZOS/FSAUEA3IR3ZSZOS.LARGE.jpg"], "step_title": "Step 2: Creating the Project"}, {"step": 3, "steps_text": "Before we can start writing our HDL code, we need to create the files. In order to do this, follow these steps:In the Project Manager \"Sources\" subwindow, right click on \"Design Sources\" and select \"Add Sources\". Select \"Add or create design sources\" and click Next. Select \"Create File\". Set file type as Verilog, file name as counter, and file location as . Repeat step 4 for another file named lut. The Define Module window will pop up, we can immediately click OK, then Yes at the prompt that will pop up.You have just created two new files with empty module templates, so next we will add HDL code to turn them into functional blocks for later use.We need three components to be able to produce a digital sine wave. A lookup table will allow us to convert a counter output to a digital sin wave -- just like indexing into an array. We will need one counter to generate the lookup table address, and a second counter to control the speed of the first counter.Our counter needs several features. First, it needs to be able to increment an output bus, so we will add a clock source and an output register. We need to be able to control how often this happens, so we will add an enable pin. We also want to be able to configure the size and maximum value of the count register differently for different counters, so we will add width and max value parameters. We also want an output representing that the counter is at it's maximum value, this will allow us to only increment our second counter when the first counter completes a rollover loop -- counting all of the way through it's range and resetting itself -- I will refer to this register as \"tc\", for \"terminal count\". The following code defines the counter module and it's ports:`timescale 1ns / 1ps\n\nmodule counter (\n\tinput clk,\n\tinput rst,\n\tinput en,\n\toutput reg [DATA_WIDTH-1:0] data,\n\toutput reg tc\n);\nparameter DATA_WIDTH=8;\nparameter DATA_MAX=255;\n\n//functional code goes here\n\nendmodule\nWhile we are required to give the two parameters default values, we will be able to change them for each counter later.The functional description described can be achieved with two \"always blocks\". The first always block will set the tc register whenever the data bus changes. The tc block should not be clocked, so that we can use it in our counter logic, without worrying about accidental \"off by one\" errors. The second always block will be clocked, whenever a clock edge occurs, it will increment or reset the counter from maximum, as long as enable is high, otherwise, it will hold it's current value. It should also trigger on resets, so that it will be set low as soon as the reset button is pushed.always@(data)\n\tif (data == DATA_MAX)\n\t\ttc = 1'b1;\n\telse\n\t\ttc = 1'b0;\n\nalways@(posedge clk, posedge rst)\n\tif (rst == 1'b1)\n\t\tdata <= 'b0;\n\telse if (en == 1'b0)\n\t\tdata <= data;\n\telse if (tc == 1'b1)\n\t\tdata <= 'b0;\n\telse\n\t\tdata <= data + 1'b1;\tThe approach toward building a lookup table is similar to that of the counter. It will need clock and address inputs, and an output data register. We also add a 256 byte block RAM by declaring a two dimensional register array.`timescale 1ns / 1ps\nmodule lut(\n\tinput clk,\n\tinput [ADDRESS_WIDTH-1:0] addr,\n\toutput reg [DATA_WIDTH-1:0] data\n);\nparameter ADDRESS_WIDTH=8;\nparameter DATA_WIDTH=8;\nparameter FILENAME=\"sin.hex\";\n\nreg [DATA_WIDTH-1:0] mem [2**ADDRESS_WIDTH-1:0];\n\n//functional code goes here\n\nendmoduleThe functional code for our lookup table is fairly simple:initial $readmemh(FILENAME, mem);\nalways@(posedge clk)\n\tdata <= mem[addr];The initial read memory statement will load our file into our block ram as the FPGA is programmed. The always block will just set the data register to the value stored in blockram at our address.", "step_imgs": ["https://cdn.instructables.com/FPA/XDJR/IR3ZSZ0B/FPAXDJRIR3ZSZ0B.LARGE.jpg", "https://cdn.instructables.com/FDQ/9RJ7/IR3ZSZ23/FDQ9RJ7IR3ZSZ23.LARGE.jpg", "https://cdn.instructables.com/FD7/6N5K/IR3ZSZ2H/FD76N5KIR3ZSZ2H.LARGE.jpg", "https://cdn.instructables.com/FZ3/DBIY/IR3ZSZ2I/FZ3DBIYIR3ZSZ2I.LARGE.jpg", "https://cdn.instructables.com/FFV/B0JT/IR3ZSZ3W/FFVB0JTIR3ZSZ3W.LARGE.jpg", "https://cdn.instructables.com/F5H/RG0Z/IR3ZSZ80/F5HRG0ZIR3ZSZ80.LARGE.jpg", "https://cdn.instructables.com/FTP/KS74/IR3ZSZ81/FTPKS74IR3ZSZ81.LARGE.jpg", "https://cdn.instructables.com/FIM/SN58/IR3ZSZ82/FIMSN58IR3ZSZ82.LARGE.jpg", "https://cdn.instructables.com/FS0/38N4/IR3ZSZ9E/FS038N4IR3ZSZ9E.LARGE.jpg"], "step_title": "Step 3: HDL Counter and Lookup Table"}, {"step": 4, "steps_text": "For us to initialize the memory in our lookup table, we used readmemh, however we are still missing the file to be read using that function. Since we want to initialize every memory address, not skipping any cells, this file will follow a simple format, the data for each memory address will be stored on its own line, in ascending order by address. The data will be in hexadecimal format, so a line representing \"for this address, output = 3.3V\" will read \"FF\", since the PmodR2R will output the supply voltage when all of the lines on its data bus are high.In order to automatically generate the file we will load into our lookup table, we can use Python.and it's built in math library. Since Python's math library's sin function takes radians as input and outputs a floating point number between -1 and 1, some scaling and conversion will be in order to write a hexadecimal integer string between 0 and FF to our file. We will count through our memory space, for each index, we will get a radian value between 0 and 2 pi. That radian value will be used with the sin function to get a float between 0 and 1, which will then be converted to an integer between 0 and 255. That integer will be converted to a hexadecimal string. In Python, these strings are generated with a leading \"0x\", so we will strip off the first two charactersimport math\nfilename = \"sin.hex\"\nf = open(filename, \"w\")\nmem_len = 256\nfor i in range(mem_len):\n\tradians = math.pi * 2.0 * i / mem_len # get how far through the file we are, convert to radians\n\tfvalue = (math.sin(radians) + 1.0) / 2.0 # get sin value, in range 0.0-1.0\n\tivalue = int(255 * fvalue) # convert from float to int, range from 0-0xFF\n\ts = hex(ivalue)[2:] # convert int calue to hexadecimal string and strip the leading \"0x\"\n\tf.write(s + \"\\n\") # write to file\nf.close()\tIn order to run this code, follow these steps:Create a new file called singen.py somewhere on your computer.  Copy the source into said file and save.  Open a console window, navigate to the directory that contains the .py file.  Call \"python singen.py\", or \"py singen.py\", depending on your python installation.The script will have now created a new file named sin.hex in the directory containing singen.py. You can now add this .hex file to your Vivado project.", "step_imgs": ["https://cdn.instructables.com/FR0/WZWN/IR3ZSXXI/FR0WZWNIR3ZSXXI.LARGE.jpg", "https://cdn.instructables.com/FJH/9QWV/IR3ZSXXQ/FJH9QWVIR3ZSXXQ.LARGE.jpg", "https://cdn.instructables.com/F5R/2H1A/IR3ZSXYO/F5R2H1AIR3ZSXYO.LARGE.jpg", "https://cdn.instructables.com/FWG/6QB4/IR3ZSXYW/FWG6QB4IR3ZSXYW.LARGE.jpg", "https://cdn.instructables.com/FLS/RK1Y/IR3ZSXZM/FLSRK1YIR3ZSXZM.LARGE.jpg", "https://cdn.instructables.com/FSM/B3TN/IR3ZSXZN/FSMB3TNIR3ZSXZN.LARGE.jpg"], "step_title": "Step 4: Look-Up Table Initialization File"}, {"step": 5, "steps_text": "Now for the fancy part. Create a new block design using the Flow Navigator under IP Integrator. Ensure that Design Name contains no spaces, that Directory is  and that the source set is Design Sources.With this block design created we can now draw our project design. Right click within the Diagram, and select \"Add Module\". This is a new feature to Vivado 2016.2, and lets us convert any sources we may have written into IP Cores automatically. We can add a module by just selecting it from the list of sources that pops up, and clicking OK. Use this method to add two counters and a lookup table. We should now connect these blocks together, and to input and output ports. Select one of the clk pins on one of the three blocks, and select Make External. You can now draw connections from each of the other clock pins to the new clock port. Do the same for the rst pins, so that each are tied to the same input. Tie the enable pin of counter_1 to the terminal count pin of the counter_0, and counter_1's data bus to the address bus of the lookup table. Make the lookup table's data bus external. Lastly, add a constant block, using \"Add IP\" and searching for \"constant\". Tie this constant block's output to the enable input of the counter_0. This constant block will ensure that counter_0 will always be runningNow that the design is drawn out, we need to go in and edit each block's parameters. This can be done by double clicking on the block in question, or right clicking the block, and selecting \"Customize Block\". We will be using the default values for the counter_1 data width and maximum count, and both the lookup table data width and address width. The maximum count for counter_0 depends on which board you are using. Since we are targeting 1KHz for the full sequence of counter_1, which only counts when counter_0 finishes its own sequence, we should use the following formula to determine our maximum count:T_c0 = f_base_clk / (f_target * T_c1)For the Digilent Zybo, our base clock frequency is 125MHz - a value which can be found in the board's reference manual on the Digilent Wiki, and which will likely be different for other FPGA boards - so with a target frequency of 1KHz and a lookup table size of 256 addresses, we get a counter_0 period of 488.28 clock cycles per address increment. Since this needs to be an integer, and our counter resets to zero, we will round down to get a maximum count of 488. To get counter_0's data width, we can to take the log base 2 of the maximum and round it up, telling us we need at least 9 bits to properly represent every value in the range 0 to 488. Customize counter_0 to fill in these values. Lastly, make sure that the constant block controlling counter_0's enable pin has width 1 and value 1.", "step_imgs": ["https://cdn.instructables.com/FFW/LFOU/IR3ZSWBY/FFWLFOUIR3ZSWBY.LARGE.jpg", "https://cdn.instructables.com/FO5/PPGL/IR3ZSWCW/FO5PPGLIR3ZSWCW.LARGE.jpg", "https://cdn.instructables.com/FC8/NCMS/IR3ZSWCX/FC8NCMSIR3ZSWCX.LARGE.jpg", "https://cdn.instructables.com/F0L/ZLRF/IR3ZSWDM/F0LZLRFIR3ZSWDM.LARGE.jpg", "https://cdn.instructables.com/FY0/5ZG6/IR3ZSWFI/FY05ZG6IR3ZSWFI.LARGE.jpg", "https://cdn.instructables.com/FV5/2M0H/IR3ZSWFK/FV52M0HIR3ZSWFK.LARGE.jpg", "https://cdn.instructables.com/FLB/L7UB/IR3ZSWFL/FLBL7UBIR3ZSWFL.LARGE.jpg", "https://cdn.instructables.com/FP0/16GQ/IR3ZSWFS/FP016GQIR3ZSWFS.LARGE.jpg", "https://cdn.instructables.com/FFY/XJUJ/IR3ZSWGX/FFYXJUJIR3ZSWGX.LARGE.jpg", "https://cdn.instructables.com/F8U/Q5YD/IR3ZSWH0/F8UQ5YDIR3ZSWH0.LARGE.jpg", "https://cdn.instructables.com/FAR/PQQZ/IR3ZSWHA/FARPQQZIR3ZSWHA.LARGE.jpg", "https://cdn.instructables.com/FSJ/MCA7/IR3ZSWHG/FSJMCA7IR3ZSWHG.LARGE.jpg", "https://cdn.instructables.com/F96/SXC9/IR3ZSWHH/F96SXC9IR3ZSWHH.LARGE.jpg", "https://cdn.instructables.com/FVZ/G7NJ/IR3ZSWHO/FVZG7NJIR3ZSWHO.LARGE.jpg", "https://cdn.instructables.com/F3B/O3KK/IR3ZSWHR/F3BO3KKIR3ZSWHR.LARGE.jpg", "https://cdn.instructables.com/FIJ/0VMK/IR3ZSWI2/FIJ0VMKIR3ZSWI2.LARGE.jpg"], "step_title": "Step 5: The Block Design"}, {"step": 6, "steps_text": "In order for Vivado to understand how our designs input and output ports are connected to the input and output pins of the boards FPGA, we need to add an XDC (Xilinx Design Constraint) file to our project. The easiest way to do this is to find and download the Master XDC for your board. The wiki page for your board on the Digilent Wiki should contain a link to this file on the sidebar under Design Resources. This file can be included in your project in the same way as adding a design source. Follow these steps:Right click on Constraints in the Sources subwindow. Select \"Add Sources\".Make sure \"Add or create constraints\" is selected. Click Next.Click \"Add Files\", navigate to your Master XDC, select it, and click Open.Click Finish.Once downloaded and included in your project, several changes will need to be made to this XDC file. Start by uncommenting the system clock signal, one button, and all eight signals for one of the Pmod headers. The system clock should be the first signal declared at the top of the file, while the others can be found using Finds (Ctrl-F) for \"btn\" and \"pmod\". If your board has a dedicated reset button (for example, \"cpu_resetn\" on the Nexys Video), use that instead of one of the normal buttons. As for the Pmod header, choose any that isn't intended for input to an onboard XADC. For each of these signals, replace the name in the get_ports call with the name you used in the Block Design, clk, rst, and data, while leaving the bus index alone.", "step_imgs": ["https://cdn.instructables.com/FWB/SZDB/IR3ZSW0X/FWBSZDBIR3ZSW0X.LARGE.jpg", "https://cdn.instructables.com/F3G/EBI0/IR3ZSW13/F3GEBI0IR3ZSW13.LARGE.jpg", "https://cdn.instructables.com/FEQ/PAID/IR3ZSW14/FEQPAIDIR3ZSW14.LARGE.jpg", "https://cdn.instructables.com/FSU/R21K/IR3ZSW1A/FSUR21KIR3ZSW1A.LARGE.jpg", "https://cdn.instructables.com/FBO/TYDG/IR3ZSW1F/FBOTYDGIR3ZSW1F.LARGE.jpg", "https://cdn.instructables.com/FCV/5MRV/IR3ZSW29/FCV5MRVIR3ZSW29.LARGE.jpg", "https://cdn.instructables.com/F7D/TA6A/IR3ZSW3T/F7DTA6AIR3ZSW3T.LARGE.jpg"], "step_title": "Step 6: Adding an XDC"}, {"step": 7, "steps_text": "In order to generate the .bit file required for programming your Digilent FPGA board, follow the following steps:In your block design, press F6 or right click anywhere and select \"Validate Design\". The design should pass validation with no errors if everything was done correctly.Under the Sources subwindow, select Sources from the tab menu. Right click on your block design and select \"Create HDL Wrapper\". Make sure the \"Let Vivado manage...\" option is selected and click OK.Make sure your new wrapper -- under Design Sources -- is bold in the sources window, if not, right click it and select \"Set as Top\".In the Flow Navigator, select \"Generate Bitstream\" under \"Program and Debug\". Select Yes when asked whether to launch synthesis and implementation.Vivado will now automatically generate the file used to program your FPGA. It might take a while, but once done, a window called \"Bitstream Generation Completed\" will pop up. Select \"Open Hardware Manager\" and move on to Step 8.", "step_imgs": ["https://cdn.instructables.com/F9A/1E1O/IR3ZSV4B/F9A1E1OIR3ZSV4B.LARGE.jpg", "https://cdn.instructables.com/FMR/0RJN/IR3ZSV4C/FMR0RJNIR3ZSV4C.LARGE.jpg", "https://cdn.instructables.com/F0U/2WMI/IR3ZSV5H/F0U2WMIIR3ZSV5H.LARGE.jpg", "https://cdn.instructables.com/FED/XEFF/IR3ZSV6L/FEDXEFFIR3ZSV6L.LARGE.jpg", "https://cdn.instructables.com/FJ7/8ESK/IR3ZSV6X/FJ78ESKIR3ZSV6X.LARGE.jpg", "https://cdn.instructables.com/FCP/TZ2U/IR3ZSV7Z/FCPTZ2UIR3ZSV7Z.LARGE.jpg", "https://cdn.instructables.com/FTZ/XCXB/IR3ZSV9Z/FTZXCXBIR3ZSV9Z.LARGE.jpg", "https://cdn.instructables.com/F0H/PQ3M/IR3ZSVB2/F0HPQ3MIR3ZSVB2.LARGE.jpg"], "step_title": "Step 7: Generating the Bit File"}, {"step": 8, "steps_text": "The Digilent Wiki has tutorials for most FPGA boards for how to program a bit file in a variety of ways. The following is going to be the easiest for seeing if our application works. In order to use Vivado's Hardware Manager to program your FPGA, follow these steps:Plug your board's programming port into a USB port of your PC.Attach your PmodR2R to whichever Pmod port you tied the lookup table data lines to in your XDC file. In the provided project for Zybo, this is the JE header.Power your board on, if necessary.In the Vivado hardware Manager, clock \"Open Target\" and \"Auto Connect\".Click \"Program Device\" and then then the device number that pops up.Ensure that the project's bitstream file is selected in the Program Device window. If not, click the \"...\" to the right of that field, navigate to and select /proj/.runs/impl_1/.bit.Click Program.In order to confirm that the project is now working, you can first check status LEDs to see if your board was programmed, then plug your Digilent Analog Discovery (or other oscilloscope) channel one ports into the R2R output ports. I used a six pin male to male connector snapped down to two pins for this, but a couple of small wires will work equally well. Watch the pretty sine wave go!", "step_imgs": ["https://cdn.instructables.com/FH2/6D2X/IR3ZST8U/FH26D2XIR3ZST8U.LARGE.jpg", "https://cdn.instructables.com/F37/0JDC/IR3ZST8Z/F370JDCIR3ZST8Z.LARGE.jpg", "https://cdn.instructables.com/FT4/JD66/IR3ZST9V/FT4JD66IR3ZST9V.LARGE.jpg", "https://cdn.instructables.com/FC7/POUK/IR3ZSTCT/FC7POUKIR3ZSTCT.LARGE.jpg", "https://cdn.instructables.com/F6L/WMM2/IR3ZSTKD/F6LWMM2IR3ZSTKD.LARGE.jpg"], "step_title": "Step 8: Programming the FPGA and Verifying Results"}, {"step": 9, "steps_text": "The following is a list of potential extensions of this project:Adding support for higher frequency waves, even up to the audio range, to control an analog speaker.Adding support for frequency selection, through switch inputs, a lookup table, and making the counter maximum parameter an input bus.Modifying the Python script to generate different types of waves, potentially including smaller amplitudes.Adding several lookup tables with differently shaped wave forms, with data buses multiplexed into the output bus.Adding a processor to the project in order to allow more complex control algorithms (might be able to use an AXI GPIO IP core to provide a simple interface to custom logic).Each of these ideas come with necessary complications, but could make for interesting projects.The \"Add Module\" feature is also very interesting, as it makes it much easier to translate from a functional description to a working prototype. A block diagram makes it much easier to comprehend what a design is actually doing than attempting to understand the same design written in Verilog or VHDL.", "step_imgs": [], "step_title": "Step 9: Additional Applications"}], "channel": "Electronics"}, {"category": "technology", "description": "We will create a Verilog project for the Digilent Zybo to create a 1 Kilohertz sine wave on the output pins of a Digilent Pmod R2R. This project is intended as a introduction to production of sine waves using an FPGA, a critical step in starting a number of more complex projects, such as driving audio hardware and other analog circuits. We will also use a new feature of Vivado 2016.2, Add Module in the IP Integrator, which makes prototyping of complex projects relatively easy, as we will be able to skip the step of writing an HDL wrapper file and easily see how our modules are connected together and interact.The project is provided, build-able through a TCL script. If you only want the source code, the HDL (hardware descriptive language) files can be found under src/hdl. In order to use the IP Integrator and generate a bitstream file, the project will need to be built through Vivado's TCL console. A good tutorial for this process can be found in this Instructable. Downloading and building this project is not required though, as we will walk through what is required for you to create the project yourself.", "title": "Digilent Pmod R2R Sine Wave Generator", "url": "https://www.instructables.com/id/Digilent-Pmod-R2R-Sine-Wave-Generator/", "section": "technology", "steps": [{"step": 1, "steps_text": "Materials Requirements ListInstalled version of Vivado 2016.2 --Earlier versions will not work, as a new feature in the IPI, \"Add Module\", will be used, though you may still be able to follow along and write a custom HDL wrapper. A Digilent Zybo (or other compatible Digilent FPGA).Your Digilent PmodR2R. A master XDC file for your Digilent board -- available through the board's page on the Digilent Wiki.. A Python environment.Functional DescriptionThe PmodR2R allows us to output voltages in a range between its ground and VDD levels. We pass the R2R 8 bits of input, ranging from 0 to 0xFF (255 in hexadecimal). It then outputs a voltage corresponding to our input, passing a zero means it will output ground, passing 0xFF means it will output 3.3V, the typical supply voltage for the Pmod headers on Digilent boards.In order to produce a 3.3V zero-to-peak sine wave, we will need to repeatedly count through a single sin wave scaled to the range 0 to 0xFF. The easiest way to do this in Verilog will be to create a lookup table, basically just an array, filled with the correct values in order. We would then count through the array, outputting each value in order. Since we also want to control the frequency of our sine wave, we will need a way to control the speed at which we count through our sine wave. The easiest way to do this is to only increment our counter every so often, which we can achieve by enabling it only when another counter hits a maximum value. We will talk about how to implement this in Verilog later.This design will give us essentially two variables we can use to control the speed and resolution of our sine wave in our lookup table size and maximum count of our \"clock divider\" counter. Depending on the selected values, we are placing a cap on the frequencies available at the R2R output, and the higher we decide to place this cap the worse the resolution of our signal will be. With the selected target frequency of 1KHz, we will be able to ignore this tradeoff and produce a reasonable result. We will discuss the selection of these parameters later.", "step_imgs": [], "step_title": "Step 1: Project Overview"}, {"step": 2, "steps_text": "After loading up Vivado, in order to get the project set up, follow these steps:Select \"Create New Project\". Select \"Next\", add a name for your project, without spaces, and select \"Next\". Make Sure \"RTL Project\" and \"Do not specify sources at this time\" are selected. Select \"Next\". Select Boards, and find and select your board's part file. Select \"Next\". Select \"Finish\".With this Vivado will have created a new empty project for you.", "step_imgs": ["https://cdn.instructables.com/F4R/0CPQ/IR3ZSZNK/F4R0CPQIR3ZSZNK.LARGE.jpg", "https://cdn.instructables.com/F9F/BCVY/IR3ZSZNL/F9FBCVYIR3ZSZNL.LARGE.jpg", "https://cdn.instructables.com/F5P/LJ1M/IR3ZSZNW/F5PLJ1MIR3ZSZNW.LARGE.jpg", "https://cdn.instructables.com/FSV/7JJC/IR3ZSZO4/FSV7JJCIR3ZSZO4.LARGE.jpg", "https://cdn.instructables.com/FOG/N3K2/IR3ZSZO5/FOGN3K2IR3ZSZO5.LARGE.jpg", "https://cdn.instructables.com/FSA/UEA3/IR3ZSZOS/FSAUEA3IR3ZSZOS.LARGE.jpg"], "step_title": "Step 2: Creating the Project"}, {"step": 3, "steps_text": "Before we can start writing our HDL code, we need to create the files. In order to do this, follow these steps:In the Project Manager \"Sources\" subwindow, right click on \"Design Sources\" and select \"Add Sources\". Select \"Add or create design sources\" and click Next. Select \"Create File\". Set file type as Verilog, file name as counter, and file location as . Repeat step 4 for another file named lut. The Define Module window will pop up, we can immediately click OK, then Yes at the prompt that will pop up.You have just created two new files with empty module templates, so next we will add HDL code to turn them into functional blocks for later use.We need three components to be able to produce a digital sine wave. A lookup table will allow us to convert a counter output to a digital sin wave -- just like indexing into an array. We will need one counter to generate the lookup table address, and a second counter to control the speed of the first counter.Our counter needs several features. First, it needs to be able to increment an output bus, so we will add a clock source and an output register. We need to be able to control how often this happens, so we will add an enable pin. We also want to be able to configure the size and maximum value of the count register differently for different counters, so we will add width and max value parameters. We also want an output representing that the counter is at it's maximum value, this will allow us to only increment our second counter when the first counter completes a rollover loop -- counting all of the way through it's range and resetting itself -- I will refer to this register as \"tc\", for \"terminal count\". The following code defines the counter module and it's ports:`timescale 1ns / 1ps\n\nmodule counter (\n\tinput clk,\n\tinput rst,\n\tinput en,\n\toutput reg [DATA_WIDTH-1:0] data,\n\toutput reg tc\n);\nparameter DATA_WIDTH=8;\nparameter DATA_MAX=255;\n\n//functional code goes here\n\nendmodule\nWhile we are required to give the two parameters default values, we will be able to change them for each counter later.The functional description described can be achieved with two \"always blocks\". The first always block will set the tc register whenever the data bus changes. The tc block should not be clocked, so that we can use it in our counter logic, without worrying about accidental \"off by one\" errors. The second always block will be clocked, whenever a clock edge occurs, it will increment or reset the counter from maximum, as long as enable is high, otherwise, it will hold it's current value. It should also trigger on resets, so that it will be set low as soon as the reset button is pushed.always@(data)\n\tif (data == DATA_MAX)\n\t\ttc = 1'b1;\n\telse\n\t\ttc = 1'b0;\n\nalways@(posedge clk, posedge rst)\n\tif (rst == 1'b1)\n\t\tdata <= 'b0;\n\telse if (en == 1'b0)\n\t\tdata <= data;\n\telse if (tc == 1'b1)\n\t\tdata <= 'b0;\n\telse\n\t\tdata <= data + 1'b1;\tThe approach toward building a lookup table is similar to that of the counter. It will need clock and address inputs, and an output data register. We also add a 256 byte block RAM by declaring a two dimensional register array.`timescale 1ns / 1ps\nmodule lut(\n\tinput clk,\n\tinput [ADDRESS_WIDTH-1:0] addr,\n\toutput reg [DATA_WIDTH-1:0] data\n);\nparameter ADDRESS_WIDTH=8;\nparameter DATA_WIDTH=8;\nparameter FILENAME=\"sin.hex\";\n\nreg [DATA_WIDTH-1:0] mem [2**ADDRESS_WIDTH-1:0];\n\n//functional code goes here\n\nendmoduleThe functional code for our lookup table is fairly simple:initial $readmemh(FILENAME, mem);\nalways@(posedge clk)\n\tdata <= mem[addr];The initial read memory statement will load our file into our block ram as the FPGA is programmed. The always block will just set the data register to the value stored in blockram at our address.", "step_imgs": ["https://cdn.instructables.com/FPA/XDJR/IR3ZSZ0B/FPAXDJRIR3ZSZ0B.LARGE.jpg", "https://cdn.instructables.com/FDQ/9RJ7/IR3ZSZ23/FDQ9RJ7IR3ZSZ23.LARGE.jpg", "https://cdn.instructables.com/FD7/6N5K/IR3ZSZ2H/FD76N5KIR3ZSZ2H.LARGE.jpg", "https://cdn.instructables.com/FZ3/DBIY/IR3ZSZ2I/FZ3DBIYIR3ZSZ2I.LARGE.jpg", "https://cdn.instructables.com/FFV/B0JT/IR3ZSZ3W/FFVB0JTIR3ZSZ3W.LARGE.jpg", "https://cdn.instructables.com/F5H/RG0Z/IR3ZSZ80/F5HRG0ZIR3ZSZ80.LARGE.jpg", "https://cdn.instructables.com/FTP/KS74/IR3ZSZ81/FTPKS74IR3ZSZ81.LARGE.jpg", "https://cdn.instructables.com/FIM/SN58/IR3ZSZ82/FIMSN58IR3ZSZ82.LARGE.jpg", "https://cdn.instructables.com/FS0/38N4/IR3ZSZ9E/FS038N4IR3ZSZ9E.LARGE.jpg"], "step_title": "Step 3: HDL Counter and Lookup Table"}, {"step": 4, "steps_text": "For us to initialize the memory in our lookup table, we used readmemh, however we are still missing the file to be read using that function. Since we want to initialize every memory address, not skipping any cells, this file will follow a simple format, the data for each memory address will be stored on its own line, in ascending order by address. The data will be in hexadecimal format, so a line representing \"for this address, output = 3.3V\" will read \"FF\", since the PmodR2R will output the supply voltage when all of the lines on its data bus are high.In order to automatically generate the file we will load into our lookup table, we can use Python.and it's built in math library. Since Python's math library's sin function takes radians as input and outputs a floating point number between -1 and 1, some scaling and conversion will be in order to write a hexadecimal integer string between 0 and FF to our file. We will count through our memory space, for each index, we will get a radian value between 0 and 2 pi. That radian value will be used with the sin function to get a float between 0 and 1, which will then be converted to an integer between 0 and 255. That integer will be converted to a hexadecimal string. In Python, these strings are generated with a leading \"0x\", so we will strip off the first two charactersimport math\nfilename = \"sin.hex\"\nf = open(filename, \"w\")\nmem_len = 256\nfor i in range(mem_len):\n\tradians = math.pi * 2.0 * i / mem_len # get how far through the file we are, convert to radians\n\tfvalue = (math.sin(radians) + 1.0) / 2.0 # get sin value, in range 0.0-1.0\n\tivalue = int(255 * fvalue) # convert from float to int, range from 0-0xFF\n\ts = hex(ivalue)[2:] # convert int calue to hexadecimal string and strip the leading \"0x\"\n\tf.write(s + \"\\n\") # write to file\nf.close()\tIn order to run this code, follow these steps:Create a new file called singen.py somewhere on your computer.  Copy the source into said file and save.  Open a console window, navigate to the directory that contains the .py file.  Call \"python singen.py\", or \"py singen.py\", depending on your python installation.The script will have now created a new file named sin.hex in the directory containing singen.py. You can now add this .hex file to your Vivado project.", "step_imgs": ["https://cdn.instructables.com/FR0/WZWN/IR3ZSXXI/FR0WZWNIR3ZSXXI.LARGE.jpg", "https://cdn.instructables.com/FJH/9QWV/IR3ZSXXQ/FJH9QWVIR3ZSXXQ.LARGE.jpg", "https://cdn.instructables.com/F5R/2H1A/IR3ZSXYO/F5R2H1AIR3ZSXYO.LARGE.jpg", "https://cdn.instructables.com/FWG/6QB4/IR3ZSXYW/FWG6QB4IR3ZSXYW.LARGE.jpg", "https://cdn.instructables.com/FLS/RK1Y/IR3ZSXZM/FLSRK1YIR3ZSXZM.LARGE.jpg", "https://cdn.instructables.com/FSM/B3TN/IR3ZSXZN/FSMB3TNIR3ZSXZN.LARGE.jpg"], "step_title": "Step 4: Look-Up Table Initialization File"}, {"step": 5, "steps_text": "Now for the fancy part. Create a new block design using the Flow Navigator under IP Integrator. Ensure that Design Name contains no spaces, that Directory is  and that the source set is Design Sources.With this block design created we can now draw our project design. Right click within the Diagram, and select \"Add Module\". This is a new feature to Vivado 2016.2, and lets us convert any sources we may have written into IP Cores automatically. We can add a module by just selecting it from the list of sources that pops up, and clicking OK. Use this method to add two counters and a lookup table. We should now connect these blocks together, and to input and output ports. Select one of the clk pins on one of the three blocks, and select Make External. You can now draw connections from each of the other clock pins to the new clock port. Do the same for the rst pins, so that each are tied to the same input. Tie the enable pin of counter_1 to the terminal count pin of the counter_0, and counter_1's data bus to the address bus of the lookup table. Make the lookup table's data bus external. Lastly, add a constant block, using \"Add IP\" and searching for \"constant\". Tie this constant block's output to the enable input of the counter_0. This constant block will ensure that counter_0 will always be runningNow that the design is drawn out, we need to go in and edit each block's parameters. This can be done by double clicking on the block in question, or right clicking the block, and selecting \"Customize Block\". We will be using the default values for the counter_1 data width and maximum count, and both the lookup table data width and address width. The maximum count for counter_0 depends on which board you are using. Since we are targeting 1KHz for the full sequence of counter_1, which only counts when counter_0 finishes its own sequence, we should use the following formula to determine our maximum count:T_c0 = f_base_clk / (f_target * T_c1)For the Digilent Zybo, our base clock frequency is 125MHz - a value which can be found in the board's reference manual on the Digilent Wiki, and which will likely be different for other FPGA boards - so with a target frequency of 1KHz and a lookup table size of 256 addresses, we get a counter_0 period of 488.28 clock cycles per address increment. Since this needs to be an integer, and our counter resets to zero, we will round down to get a maximum count of 488. To get counter_0's data width, we can to take the log base 2 of the maximum and round it up, telling us we need at least 9 bits to properly represent every value in the range 0 to 488. Customize counter_0 to fill in these values. Lastly, make sure that the constant block controlling counter_0's enable pin has width 1 and value 1.", "step_imgs": ["https://cdn.instructables.com/FFW/LFOU/IR3ZSWBY/FFWLFOUIR3ZSWBY.LARGE.jpg", "https://cdn.instructables.com/FO5/PPGL/IR3ZSWCW/FO5PPGLIR3ZSWCW.LARGE.jpg", "https://cdn.instructables.com/FC8/NCMS/IR3ZSWCX/FC8NCMSIR3ZSWCX.LARGE.jpg", "https://cdn.instructables.com/F0L/ZLRF/IR3ZSWDM/F0LZLRFIR3ZSWDM.LARGE.jpg", "https://cdn.instructables.com/FY0/5ZG6/IR3ZSWFI/FY05ZG6IR3ZSWFI.LARGE.jpg", "https://cdn.instructables.com/FV5/2M0H/IR3ZSWFK/FV52M0HIR3ZSWFK.LARGE.jpg", "https://cdn.instructables.com/FLB/L7UB/IR3ZSWFL/FLBL7UBIR3ZSWFL.LARGE.jpg", "https://cdn.instructables.com/FP0/16GQ/IR3ZSWFS/FP016GQIR3ZSWFS.LARGE.jpg", "https://cdn.instructables.com/FFY/XJUJ/IR3ZSWGX/FFYXJUJIR3ZSWGX.LARGE.jpg", "https://cdn.instructables.com/F8U/Q5YD/IR3ZSWH0/F8UQ5YDIR3ZSWH0.LARGE.jpg", "https://cdn.instructables.com/FAR/PQQZ/IR3ZSWHA/FARPQQZIR3ZSWHA.LARGE.jpg", "https://cdn.instructables.com/FSJ/MCA7/IR3ZSWHG/FSJMCA7IR3ZSWHG.LARGE.jpg", "https://cdn.instructables.com/F96/SXC9/IR3ZSWHH/F96SXC9IR3ZSWHH.LARGE.jpg", "https://cdn.instructables.com/FVZ/G7NJ/IR3ZSWHO/FVZG7NJIR3ZSWHO.LARGE.jpg", "https://cdn.instructables.com/F3B/O3KK/IR3ZSWHR/F3BO3KKIR3ZSWHR.LARGE.jpg", "https://cdn.instructables.com/FIJ/0VMK/IR3ZSWI2/FIJ0VMKIR3ZSWI2.LARGE.jpg"], "step_title": "Step 5: The Block Design"}, {"step": 6, "steps_text": "In order for Vivado to understand how our designs input and output ports are connected to the input and output pins of the boards FPGA, we need to add an XDC (Xilinx Design Constraint) file to our project. The easiest way to do this is to find and download the Master XDC for your board. The wiki page for your board on the Digilent Wiki should contain a link to this file on the sidebar under Design Resources. This file can be included in your project in the same way as adding a design source. Follow these steps:Right click on Constraints in the Sources subwindow. Select \"Add Sources\".Make sure \"Add or create constraints\" is selected. Click Next.Click \"Add Files\", navigate to your Master XDC, select it, and click Open.Click Finish.Once downloaded and included in your project, several changes will need to be made to this XDC file. Start by uncommenting the system clock signal, one button, and all eight signals for one of the Pmod headers. The system clock should be the first signal declared at the top of the file, while the others can be found using Finds (Ctrl-F) for \"btn\" and \"pmod\". If your board has a dedicated reset button (for example, \"cpu_resetn\" on the Nexys Video), use that instead of one of the normal buttons. As for the Pmod header, choose any that isn't intended for input to an onboard XADC. For each of these signals, replace the name in the get_ports call with the name you used in the Block Design, clk, rst, and data, while leaving the bus index alone.", "step_imgs": ["https://cdn.instructables.com/FWB/SZDB/IR3ZSW0X/FWBSZDBIR3ZSW0X.LARGE.jpg", "https://cdn.instructables.com/F3G/EBI0/IR3ZSW13/F3GEBI0IR3ZSW13.LARGE.jpg", "https://cdn.instructables.com/FEQ/PAID/IR3ZSW14/FEQPAIDIR3ZSW14.LARGE.jpg", "https://cdn.instructables.com/FSU/R21K/IR3ZSW1A/FSUR21KIR3ZSW1A.LARGE.jpg", "https://cdn.instructables.com/FBO/TYDG/IR3ZSW1F/FBOTYDGIR3ZSW1F.LARGE.jpg", "https://cdn.instructables.com/FCV/5MRV/IR3ZSW29/FCV5MRVIR3ZSW29.LARGE.jpg", "https://cdn.instructables.com/F7D/TA6A/IR3ZSW3T/F7DTA6AIR3ZSW3T.LARGE.jpg"], "step_title": "Step 6: Adding an XDC"}, {"step": 7, "steps_text": "In order to generate the .bit file required for programming your Digilent FPGA board, follow the following steps:In your block design, press F6 or right click anywhere and select \"Validate Design\". The design should pass validation with no errors if everything was done correctly.Under the Sources subwindow, select Sources from the tab menu. Right click on your block design and select \"Create HDL Wrapper\". Make sure the \"Let Vivado manage...\" option is selected and click OK.Make sure your new wrapper -- under Design Sources -- is bold in the sources window, if not, right click it and select \"Set as Top\".In the Flow Navigator, select \"Generate Bitstream\" under \"Program and Debug\". Select Yes when asked whether to launch synthesis and implementation.Vivado will now automatically generate the file used to program your FPGA. It might take a while, but once done, a window called \"Bitstream Generation Completed\" will pop up. Select \"Open Hardware Manager\" and move on to Step 8.", "step_imgs": ["https://cdn.instructables.com/F9A/1E1O/IR3ZSV4B/F9A1E1OIR3ZSV4B.LARGE.jpg", "https://cdn.instructables.com/FMR/0RJN/IR3ZSV4C/FMR0RJNIR3ZSV4C.LARGE.jpg", "https://cdn.instructables.com/F0U/2WMI/IR3ZSV5H/F0U2WMIIR3ZSV5H.LARGE.jpg", "https://cdn.instructables.com/FED/XEFF/IR3ZSV6L/FEDXEFFIR3ZSV6L.LARGE.jpg", "https://cdn.instructables.com/FJ7/8ESK/IR3ZSV6X/FJ78ESKIR3ZSV6X.LARGE.jpg", "https://cdn.instructables.com/FCP/TZ2U/IR3ZSV7Z/FCPTZ2UIR3ZSV7Z.LARGE.jpg", "https://cdn.instructables.com/FTZ/XCXB/IR3ZSV9Z/FTZXCXBIR3ZSV9Z.LARGE.jpg", "https://cdn.instructables.com/F0H/PQ3M/IR3ZSVB2/F0HPQ3MIR3ZSVB2.LARGE.jpg"], "step_title": "Step 7: Generating the Bit File"}, {"step": 8, "steps_text": "The Digilent Wiki has tutorials for most FPGA boards for how to program a bit file in a variety of ways. The following is going to be the easiest for seeing if our application works. In order to use Vivado's Hardware Manager to program your FPGA, follow these steps:Plug your board's programming port into a USB port of your PC.Attach your PmodR2R to whichever Pmod port you tied the lookup table data lines to in your XDC file. In the provided project for Zybo, this is the JE header.Power your board on, if necessary.In the Vivado hardware Manager, clock \"Open Target\" and \"Auto Connect\".Click \"Program Device\" and then then the device number that pops up.Ensure that the project's bitstream file is selected in the Program Device window. If not, click the \"...\" to the right of that field, navigate to and select /proj/.runs/impl_1/.bit.Click Program.In order to confirm that the project is now working, you can first check status LEDs to see if your board was programmed, then plug your Digilent Analog Discovery (or other oscilloscope) channel one ports into the R2R output ports. I used a six pin male to male connector snapped down to two pins for this, but a couple of small wires will work equally well. Watch the pretty sine wave go!", "step_imgs": ["https://cdn.instructables.com/FH2/6D2X/IR3ZST8U/FH26D2XIR3ZST8U.LARGE.jpg", "https://cdn.instructables.com/F37/0JDC/IR3ZST8Z/F370JDCIR3ZST8Z.LARGE.jpg", "https://cdn.instructables.com/FT4/JD66/IR3ZST9V/FT4JD66IR3ZST9V.LARGE.jpg", "https://cdn.instructables.com/FC7/POUK/IR3ZSTCT/FC7POUKIR3ZSTCT.LARGE.jpg", "https://cdn.instructables.com/F6L/WMM2/IR3ZSTKD/F6LWMM2IR3ZSTKD.LARGE.jpg"], "step_title": "Step 8: Programming the FPGA and Verifying Results"}, {"step": 9, "steps_text": "The following is a list of potential extensions of this project:Adding support for higher frequency waves, even up to the audio range, to control an analog speaker.Adding support for frequency selection, through switch inputs, a lookup table, and making the counter maximum parameter an input bus.Modifying the Python script to generate different types of waves, potentially including smaller amplitudes.Adding several lookup tables with differently shaped wave forms, with data buses multiplexed into the output bus.Adding a processor to the project in order to allow more complex control algorithms (might be able to use an AXI GPIO IP core to provide a simple interface to custom logic).Each of these ideas come with necessary complications, but could make for interesting projects.The \"Add Module\" feature is also very interesting, as it makes it much easier to translate from a functional description to a working prototype. A block diagram makes it much easier to comprehend what a design is actually doing than attempting to understand the same design written in Verilog or VHDL.", "step_imgs": [], "step_title": "Step 9: Additional Applications"}], "channel": "Electronics"}, {"category": "technology", "description": "This oscilloscope (here after referred to as \"o-scope\") is an excellent beginning o-scope which provides most of the basic functions needed for analyzing/trouble shooting circuits. This guide will document how to properly set up the o-scope, and safely use many of its features. To begin with, here is a summary of the operating requirements and capabilities of the o-scope and the probes:Power supply required: 90-264 VACRMS, 45-66 Hz. North American wall power is 120V, 60 Hz.Channels: 2Bandwidth: 40MHzInput capacitance: 20 pFSample rate: 500 MS/s ( 500 Megasamples/second, or 500X106 samples/second)Here are the specifications from the manual about the probes for this o-scope. It works well with the Textronix TPP0101 and the TPP0201. Both are passive probes with an attenuation factor of 10X. The only difference between the probes is the bandwidth. The TPP0101 has a maximum bandwidth of 100 MHz, while the TPP0201 can measure up to 200 MHz. Electrical and Mechanical SpecificationsCharacteristicTPP0101TPP0201BandwidthDC to 100MHzDC to 200MHzSystem attenuation accuracy10:1 \u00b1 3.2%10:1 \u00b1 3.2%Compensation Range15 pF - 25 pF15 pF - 25 pFSystem Input Resistance10 \u03a9M \u00b1 1.5%10 \u03a9M \u00b1 1.5%System Input Capacitance<12 pF<12 pFSystem Rise Time (typical)<3.5 ns<3.5 nsPropagation Delay~6.1 ns~6.1 nsMaximum Input Voltage<300 VRMS CAT II<300 VRMS CAT IICable Length<1.3 m<1.3 mProbe Connection InterfaceBNCBNCEnvironmental SpecificationsCharacteristicDescriptionOperating Temperature -10 \u00b0 C to +55 \u00b0 C (+14 \u00b0 F to +131 \u00b0 F)Storage Temperature -55 \u00b0 C to +71 \u00b0 C (-60 \u00b0 F to +160 \u00b0 F)Operating Alitude3.0 km (10,000 ft) maximumStorage Altitude12.2 km (40,000 ft) maximum ", "title": "Guide to the Tektronix TBS 1042 Oscilloscope", "url": "https://www.instructables.com/id/Guide-to-the-Tektronix-TBS-1042-Oscilloscope/", "section": "technology", "steps": [{"step": 1, "steps_text": "Some preliminary terms to get us startedSoft key: any of the keys to the right of the screen without permanent labels. The screen will display an appropriate label for the keys depending on the context.CH1 button: the yellow button labeled with a 1CH 2 button: the blue button labeled with a 2Step / Step: The slash indicates a series of steps that build on one another", "step_imgs": ["https://cdn.instructables.com/F4M/GY63/I12KIH5D/F4MGY63I12KIH5D.LARGE.jpg"], "step_title": "Step 1: Guide Terminology"}, {"step": 2, "steps_text": "Turn the o-scope on. Wait for it to pass the self-check, then press any button to continue. Connect the probe to the BNC port of Channel 1 on the o-scope. Align the slots on the probe with the small posts on the o-scope port. Twist the probe connector to the right to lock it in place. (Picture 1)Probe compensation involves turning a small screw attached to  variable capacitor inside the probe. By turning the screw, you change the frequency response of the probe. It helps ensure the probe measures accurately. On the TPP0101 and TPP0201 probes, the screw is located on the BNC connector.Connect the probe tip to the upper terminal that says Probe comp. Connect the alligator clip of the probe to the bottom terminal with the ground symbol next to it. See the second picture for clarificationNow we need to make sure the o-scope knows the attenuation of the probe. The attenuation factor helps limit the load on the circuit under test, but it also divides your signal by some factor. The standard for general probes is 10X or an attenuation factor of 10. To set the o-scope, press the CH 1 button / press the Probe 10X Attenuation soft key / press Voltage Attenuation soft key until 10x appears. Press Back  soft key / Press the button labeled AutoSet (see the third picture)You will see a square wave on the screen with a period of 1 kHz at about 5 V peak-to-peak at 1ms/division (1ms/Div) (see the fourth picture)Now we can compensate! If the output from the probe looks like the fourth picture with flat topped square waves, the probe is properly attenuated. If the leading edge of the square wave is curved like the fifth picture, the probe needs to be compensated more. Turn the compensations screw until the square wave is flat. If the leading edge of the wave is peaked, the probe is over compensated. Turn the screw until the wave is flat. Usually it will not take much turning to properly compensate the probe.", "step_imgs": ["https://cdn.instructables.com/F54/KUIU/I0R18KXB/F54KUIUI0R18KXB.LARGE.jpg", "https://cdn.instructables.com/FOY/OQZS/I12KHURI/FOYOQZSI12KHURI.LARGE.jpg", "https://cdn.instructables.com/FF1/HBP4/I12KI7TZ/FF1HBP4I12KI7TZ.LARGE.jpg", "https://cdn.instructables.com/FZC/3FU6/I0R18KW6/FZC3FU6I0R18KW6.LARGE.jpg", "https://cdn.instructables.com/FY7/BE16/I0R18KW8/FY7BE16I0R18KW8.LARGE.jpg", "https://cdn.instructables.com/FD5/BMN3/I0R18KWA/FD5BMN3I0R18KWA.LARGE.jpg"], "step_title": "Step 2: Probe Setup"}, {"step": 3, "steps_text": "Self CalibrationThe Self Calibration feature ensures your o-scope is measuring accurately. The routine should be performed after the scope has been turned on for about 20 minutes to ensure it has equalized to ambient temperature. The check should be performed if the ambient temperature changes by 5 \u00b0C (9 \u00b0F) or more.Disconnect any probes from the inputs ports. Then, press Utility / Do Self Cal and follow the directions on the screen.NOTE: You can skip the following section if you are using a regular probe.From the manual:Current probes provide a voltage signal proportional to the current. The o-scope needs to be set so it matches the scale of the probe. The default scale is 10 A/V (10 amps/volt)For a probe connected to CH 1, push the yellow 1 button / Probe (to the right of the screen) / Current / Scale and select the appropriate value", "step_imgs": [], "step_title": "Step 3: Self Calibration and Current Probe Setup"}, {"step": 4, "steps_text": "The controls on the left control CH 1, and the controls on the right control CH 2.The Position knob moves the respective signal up or downThe Scale knob increases or decreases the vertical scale factor of the window. It ranges from 20 mV to 50 V (0.02 V - 50 V). By pressing the Volts/Div soft key (shown in the third picture) you can select to have the Scale knob provide course or fine adjustments of the vertical scale (AKA the vertical Volts/Division). A division is one of the white dotted lines displayed on the screen. 5 Volts/Div means each horizontal line indicates a change of 5 V from the previous horizontal line. The horizontal line in the middle of the screen represents 0 V.The CH 1 and CH 2 buttons toggle their respective channels on or off.The Math button toggles the Math waveform. Once the Math button is pressed, you will be able to select mathematical operations to perform using the two waveforms such as addition, subtraction, and multiplication. These options can be selected using the soft key labeled Operation.", "step_imgs": ["https://cdn.instructables.com/FAQ/D625/I12KIFFW/FAQD625I12KIFFW.LARGE.jpg", "https://cdn.instructables.com/FXM/00J9/I12KIH3C/FXM00J9I12KIH3C.LARGE.jpg", "https://cdn.instructables.com/F4M/GY63/I12KIH5D/F4MGY63I12KIH5D.LARGE.jpg"], "step_title": "Step 4: Vertical Controls"}, {"step": 5, "steps_text": "The Position knob controls the horizontal location of all waveforms: CH 1, CH 2, and MathThe Horiz Menu button displays the Horizontal MenuThe Set to Zero button returns the horizontal axis to 0The Scale knob controls the horizontal time/division factor of the window. It can range from 5 ns to 50 s.", "step_imgs": ["https://cdn.instructables.com/FSF/7Y3K/I12KIJCY/FSF7Y3KI12KIJCY.LARGE.jpg"], "step_title": "Step 5: Horizontal Controls"}, {"step": 6, "steps_text": "The trigger controls are used to change where the o-scope thinks a waveform begins or ends. These controls are useful for helping the o-scope understand what it should look for to display a clear and informative picture.Generally the o-scope will look for the rising or falling edge of a waveform to define the start or end of a wave. The rising and falling edges are labeled in the second picture.The Level knob controls what voltage the o-scope will trigger at. The knob moves the trigger level up or down, raising or lowering the trigger voltage level. The level is indicated on the screen with a line, called the Cursor.The Set to 50% button sets the trigger level to halfway between the minimum and maximum amplitudes of the waveform.The Force Trig button forces the o-scope to finish acquiring a signal and determine a trigger point. It does not function if the o-scope has already acquired a signal.While holding the Trig View button, you can view the trigger waveform in place of the CH 1 or CH 2 waveform. This is useful for determining how the trigger settings affect where the o-scope thinks the trigger point is. It's good for trouble shooting.There is also a trigger input on the bottom next to the CH 1 and CH 2 inputs. The trigger input can be used to tell the o-scope when to look for the start of a new waveform.", "step_imgs": ["https://cdn.instructables.com/FCD/YNUL/I1563C6I/FCDYNULI1563C6I.LARGE.jpg", "https://cdn.instructables.com/FYR/YXDQ/I1563CVV/FYRYXDQI1563CVV.LARGE.jpg"], "step_title": "Step 6: Trigger Controls"}, {"step": 7, "steps_text": "The last group of buttons perform most of the information gathering functions of the o-scope.The Multipurpose knob is used to navigate through menus displayed on the screen. When the green LED next to the knob is illuminated, the knob can be used to select various options.The AutoRange button attempts to scale the window view to fit the waveform from the CH 1 or CH 2 probes. Be careful, you may get strange results if the o-scope cannot determine how to properly scale the display window. AutoRange continues to scale the window to fit the waveform if the waveform changes drastically.The Save/Recall button access the Save/Recall menuThe Measurements button displays the Measurements menu. This is useful if you wish to measure certain aspects of the waveform, such as amplitude, period, frequency, or phase shift between two signals.The Acquire button displays the Acquire menu. In the menu you will find settings to change how the o-scope interprets the waveform being measured. More information can be found in the manual.The Ref. button allows you access stored reference waveforms.The Utility button accesses the Utility menuThe Cursor button accesses the Cursor menu. Cursors are vertical and horizontal lines that can only be moved when the Cursor menu is activated. They are moved using the knobs on the o-scope. There are Time cursors (vertical lines) and Amplitude cursors (horizontal lines) that are used to measure time and amplitude characteristics of the waveform.The Display button accesses the Display menu. The Help button accesses the Help menu, which is quite useful for learning about various functions.The Default Setup button returns the o-scope to the factory setup. This is useful if you make a big mess of things.The AutoSet button attempts to make an intelligent choice to best display the input waveform. It seems to take more liberties than AutoRange, which one can interpret as more chances of making a mess  displaying the signal. It can be useful for finding evasive waveforms.The Single button acquires a single waveform and stops.The Run/Stop button toggles between acquiring and pausing acquisition of the input waveform.The Save and Save/Print buttons are used to save data to a USB drive inserted in the front panel.", "step_imgs": ["https://cdn.instructables.com/FTV/XC99/I1563EYW/FTVXC99I1563EYW.LARGE.jpg"], "step_title": "Step 7: General and Menu Control Buttons"}, {"step": 8, "steps_text": "This step provides an easy way to learn how the o-scope probe is used to measure circuit components. I used an Arduino as the signal source.The code was very rudimentary, just enough to get a PWM signal from the board. I attached a jumper cable to Pin 11, and another to ground. Then I attached the probe as shown in the first picture. The code was:const int SignalOut = 11;void setup() {pinMode(SignalOut, OUTPUT);}void loop() {analogWrite(SignalOut, 200);}Any pin with PWM capabilities can be used (it has a ~ next to the pin number) and any ground on the Arduino should work. As for the number, it can range from 0-255. Try different values to see what they look like on the o-scope! The result from my Arduino is in the second picture.", "step_imgs": ["https://cdn.instructables.com/F71/4DHV/I1WHFR7Z/F714DHVI1WHFR7Z.LARGE.jpg", "https://cdn.instructables.com/FE1/J2NM/I1WHFR7X/FE1J2NMI1WHFR7X.LARGE.jpg"], "step_title": "Step 8: Simple Measurement Excercise"}, {"step": 9, "steps_text": "Once the probes are compensated, it is fairly straight forward to use the o-scope to acquire data. The the probe tip attaches to the point you are trying to measure. The attachment point for the ground clip can vary depending on the circuit, but it generally attaches to the ground of the circuit.This o-scope as a lot to offer, and it will serve you well.A great resource for advanced usage is the online manual, found here: http://www.giakova.com/siti/GIAKOVA/img/upload/Pro...It covers many more topics in greater depth.", "step_imgs": [], "step_title": "Step 9: Go Measure Things!"}], "channel": "Electronics"}, {"category": "technology", "description": "In this instructables we are going to show how to show charts and gauges on an IOT device sensor data with Arduino web server with JavaScript. An Arduino compatible board with WIFI module has been used to act as a webserver that is going to show IOT device sensor data and status.Benefits of using Web serverThe Internet of things or IoT is the internetworking of physical devices, vehicles (also referred to as \"connected devices\" and \"smart devices\"), buildings, and other items\u2014embedded with electronics, software, sensors, actuators, and network connectivity that enable these objects to collect and exchange data. In 2013 the Global Standards Initiative on Internet of Things (IoT-GSI) defined the IoT as \"the infrastructure of the information society.\" The IoT allows objects to be sensed and/or controlled remotely across existing network infrastructure, creating opportunities for more direct integration of the physical world into computer-based systems, and resulting in improved efficiency, accuracy and economic benefit. When IoT is augmented with sensors and actuators, the technology becomes an instance of the more general class of cyber-physical systems, which also encompasses technologies such as smart grids, smart homes, intelligent transportation and smart cities. Each thing is uniquely identifiable through its embedded computing system but is able to interoperate within the existing Internet infrastructure. Typically, IoT is expected to offer advanced connectivity of devices, systems, and services that goes beyond machine-to-machine (M2M) communications and covers a variety of protocols, domains, and applications. The interconnection of these embedded devices (including smart objects), is expected to usher in automation in nearly all fields, while also enabling advanced applications like a smart grid, and expanding to the areas such as smart cities.There are many ways that an IoT device can communicate with other devices. Some has two way communications like  Bluetooth and other ways like using wired or wireless internet protocol. For better communication and interfacing we need efficient way with less efforts, using bluetooth means you need to develop  apps and software but if you use an IoT with a builtin webserver device makes it much simpler and you can access the data and presentation of data with only a web browser that can be run in a smartphone, tablet or PC. BOM:1. Adafruit Feather M0 WiFi - ATSAMD21 + ATWINC15002. some sensor (Temperature, Humidity, ....)", "title": "Showing Charts and Gauges of IOT Device Data Using Arduino Web Server With JavaScript", "url": "https://www.instructables.com/id/Showing-Charts-and-Gauges-of-IOT-Device-Data-Using/", "section": "technology", "steps": [{"step": 1, "steps_text": "We have used WiFiWebServer Arduino sketch which Serves a webpage from the WiFi shield. This sketch was modified to show charts and gauges using plotly Javascript.Arduino WiFi101 libraryThis library allows you to use the Arduino WiFi compatible Shield 101 and the MKR1000 compatible board. These are powerful IoT solutions with crypto-authentication, developed with ATMEL, that connects your Arduino or Genuino to the internet wirelessly. Connecting the board or the shield to a WiFi network is simple, no further configuration in addition to the SSID and the password are required. It can serve as either a server accepting incoming connections or a client making outgoing ones. The library supports WEP and WPA2 Personal encryption. Compared to the retired WiFi Shield and the related library, this product and library support all the same methods plus the connectSSL(). The board connected to the shield communicates with the WiFi shield 101 compatible using the SPI bus. The WiFi101 library is very similar to the Ethernet and the library WiFi, and many of the function calls are the same. Arduino sketch/*\n  WiFi Web Server with JavaScript\n\n A simple web server that shows the value of the analog input pins.\n using a WiFi shield.\n\n Circuit:\n * WiFi shield attached\n * Analog inputs attached to pin A0\n \n */\n\n#include <SPI.h>\n#include <WiFi101.h>\n\n\nchar ssid[] = \"YOURHOTSPOT\"; //  your network SSID (name)\nchar pass[] = \"PASSWORD\";   // your network password\nint keyIndex = 0;                 // your network key Index number (needed only for WEP)\n\nint status = WL_IDLE_STATUS;\n\nWiFiServer server(80);\n\nfloat Gain_A     = 0.154   ; // Sensor A\nint   analogPin0 = A0       ; // Sensor A  \n\nconst int numReadings = 1000;\nint readsens2=0;\nint readsens3=0;\nint readsens4=0;\nint readsens5=0;\nint readsens=0;\nvoid setup() {\n  IPAddress ip(192, 168, 1, 100);    \n   WiFi.setPins(8,7,4,2);\n//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n   ; // wait for serial port to connect. Needed for native USB port only\n  }\n  analogReadResolution(12);\n  analogReference(AR_INTERNAL);  //Reference voltage set to 1.1 V\n\n// check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n//   Serial.println(\"WiFi shield not present\");\n// don't continue:\n    while (true);\n  }\n\n// attempt to connect to Wifi network:\n  while ( status != WL_CONNECTED) {\n   Serial.print(\"Attempting to connect to SSID: \");\n   Serial.println(ssid);\n// Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n    WiFi.config(ip);  \n    status = WiFi.begin(ssid, pass);\n\n// wait 10 seconds for connection:\n    delay(10000);\n  }\n  server.begin();\n// you're connected now, so print out the status:\n  printWifiStatus();\n}\n\n\nvoid loop() {\n  // listen for incoming clients\n  WiFiClient client = server.available();\n  if (client) {\n      Serial.println(\"new client\");\n    // an http request ends with a blank line\n    boolean currentLineIsBlank = true;\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        Serial.write(c);\n        // if you've gotten to the end of the line (received a newline\n        // character) and the line is blank, the http request has ended,\n        // so you can send a reply\n        if (c == '\\n' && currentLineIsBlank) {\n          // send a standard http response header\n//===========================================================================\n// Web server text starts from here\t\t  \nchar messagesp[] =\"<!DOCTYPE html>\"\n\"\\n<html>\"\n\"\\n<head>\"\n\"\\n  <!-- Plotly.js -->\"\n\"\\n  <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>\"    // Java script for defining chart functions\n\"\\n</head>\"\n\"\\n  \"\n\"\\n<body>\"\n\"\\n  <div id='myDiv' style='width: 480px; height: 400px;'><!-- Plotly chart will be drawn inside this DIV --></div>\"\n\"\\n  <script>\"\n\"\\nvar trace1 = {\"\n\"\\n  x: [1, 2, 3, 4, 5],\";\n\nchar messagesp3[] =\"\\n  mode: 'markers',\"\n\"\\n  name: 'Sensor data'\"\n\"\\n};\"\n\"\\n \"\n\"\\nvar trace2 = {\"\n\"\\n  x: [1, 2, 3, 4, 5],\"\n\"\\n  y: [27, 24, 24, 24, 24],\"\n\"\\n  mode: 'lines',\"\n\"\\n  name: 'Temp'\"\n\"\\n};\"\n\"\\n \"\n\"\\nvar trace3 = {\"\n\"\\n  x: [1, 2, 3, 4,5],\"\n\"\\n  y: [32, 31, 35, 33, 27],\"\n\"\\n  mode: 'lines+markers',\"\n\"\\n  name: 'Humidity'\"\n\"\\n};\"\n\"\\n \"\n\"\\nvar data = [trace1, trace2, trace3];\"\n\"\\n \"\n\"\\nvar layout = {\"\n\"\\n  title: '--IoT device data chart--',\"\n\"\\n  xaxis: {\"\n\"\\n    title: 'Time sec'\"\n\"\\n  },\"\n\"\\n  yaxis: {\"\n\"\\n    title: 'Sensor output'\"\n\"\\n  }\"\n\"\\n};\"\n\"\\n \"\n\"\\nPlotly.newPlot('myDiv', data, layout);\"\n\"\\n  </script>\"\n\"\\n</body>\"\n\"\\n</html>\";\n\n\n          client.println(\"HTTP/1.1 200 OK\");\n          \n          client.println(\"Content-Type: text/html\");\n \n          client.println();\n//client.println(\"Connection: keep-alive\");\n          client.println();\n          client.write(messagesp);\n//=============================================          \n//    Substituting sensor data values inside web server text \nint readsens=analogRead(analogPin0)*Gain_A;\n\nclient.print(\"\\n  y: [\");\nclient.print(readsens5);\nclient.print(\", \"); \nclient.print(readsens4);\n\nclient.print(\", \"); \nclient.print(readsens3);\n\nclient.print(\", \"); \nclient.print(readsens2);\n\nclient.print(\", \"); \nclient.print(readsens);\nreadsens5=readsens4;\nclient.print(\"],\");\nreadsens4=readsens3;\nreadsens3=readsens2;\nreadsens2=readsens;\n//===============================================\n           client.write(messagesp3);\n\n          client.println();\n          break;\n        }\n        if (c == '\\n') {\n          // you're starting a new line\n          currentLineIsBlank = true;\n        }\n        else if (c != '\\r') {\n          // you've gotten a character on the current line\n          currentLineIsBlank = false;\n        }\n      }\n    }\n    // give the web browser time to receive the data\n    delay(1);\n\n    // close the connection:\n    client.stop();\n   Serial.println(\"client disonnected\");\n  }\n}\n\n\nvoid printWifiStatus() {\n// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n}\n\n Result is shown as Line chart.", "step_imgs": ["https://cdn.instructables.com/FLI/PUH6/IXAQ89T8/FLIPUH6IXAQ89T8.LARGE.jpg"], "step_title": "Step 1: Arduino Sketch"}, {"step": 2, "steps_text": "I have used Plotly's JavaScript charting library to show charts and gauges.  Plotly is the modern platform for agile business intelligence and data science. What is plotly.js?Built on top of d3.js and stack.gl, plotly.js is a high-level, declarative charting library. plotly.js ships with 20 chart types, including 3D charts, statistical graphs, and SVG maps. Learn about why we open sourced plotly.js or view the source on GitHub.", "step_imgs": ["https://cdn.instructables.com/FE4/O2TT/IXAQ0F0Q/FE4O2TTIXAQ0F0Q.LARGE.jpg", "https://cdn.instructables.com/FUY/I0KT/IXAQ0F0R/FUYI0KTIXAQ0F0R.LARGE.jpg", "https://cdn.instructables.com/FP0/QTI4/IXAQ0F0S/FP0QTI4IXAQ0F0S.LARGE.jpg"], "step_title": "Step 2: Using Javascript for Showing Charts and Gauges"}, {"step": 3, "steps_text": "Web site text is HTML with JavaScript inside, for example for showing a gauge html part is HTML Part================================<head>\n  <!-- Plotly.js -->\n  <script src=\"https://cdn.plot.ly/plotly-latest.min.j\"></script>\n</head>\n\n<body>\n  \n  <div id=\"myDiv\" style=\"width: 480px; height: 400px;\">\n<!-- Plotly chart will be drawn inside this DIV --></div>\n  <script>\n    <!-- JAVASCRIPT CODE GOES HERE -->\n  </script>\n</body>\nJAVASCRIPT CODE ================================================// Enter a speed between 0 and 180\nvar level = 175;\n\n// Trig to calc meter point\nvar degrees = 180 - level,\n     radius = .5;\nvar radians = degrees * Math.PI / 180;\nvar x = radius * Math.cos(radians);\nvar y = radius * Math.sin(radians);\n\n// Path: may have to change to create a better triangle\nvar mainPath = 'M -.0 -0.025 L .0 0.025 L ',\n     pathX = String(x),\n     space = ' ',\n     pathY = String(y),\n     pathEnd = ' Z';\nvar path = mainPath.concat(pathX,space,pathY,pathEnd);\n\nvar data = [{ type: 'scatter',\n   x: [0], y:[0],\n    marker: {size: 28, color:'850000'},\n    showlegend: false,\n    name: 'speed',\n    text: level,\n    hoverinfo: 'text+name'},\n  { values: [50/6, 50/6, 50/6, 50/6, 50/6, 50/6, 50],\n  rotation: 90,\n  text: ['TOO FAST!', 'Pretty Fast', 'Fast', 'Average',\n            'Slow', 'Super Slow', ''],\n  textinfo: 'text',\n  textposition:'inside',\n  marker: {colors:['rgba(14, 127, 0, .5)', 'rgba(110, 154, 22, .5)',\n                         'rgba(170, 202, 42, .5)', 'rgba(202, 209, 95, .5)',\n                         'rgba(210, 206, 145, .5)', 'rgba(232, 226, 202, .5)',\n                         'rgba(255, 255, 255, 0)']},\n  labels: ['151-180', '121-150', '91-120', '61-90', '31-60', '0-30', ''],\n  hoverinfo: 'label',\n  hole: .5,\n  type: 'pie',\n  showlegend: false\n}];\n\nvar layout = {\n  shapes:[{\n      type: 'path',\n      path: path,\n      fillcolor: '850000',\n      line: {\n        color: '850000'\n      }\n    }],\n  title: '<b>Gauge</b> <br> Speed 0-100',\n  height: 1000,\n  width: 1000,\n  xaxis: {zeroline:false, showticklabels:false,\n             showgrid: false, range: [-1, 1]},\n  yaxis: {zeroline:false, showticklabels:false,\n             showgrid: false, range: [-1, 1]}\n};\n\nPlotly.newPlot('myDiv', data, layout);\n Resault is shown as Gauge ", "step_imgs": ["https://cdn.instructables.com/F56/0B33/IXAQ0F78/F560B33IXAQ0F78.LARGE.jpg"], "step_title": "Step 3: Substituting Sensor Data in Web Server Text for a Gauge"}, {"step": 4, "steps_text": "Just substitute javascript part inside HTML and include the sensor data as I did in Arduino sketch between lines 147 to 169. The complete we page text will be something like Image.", "step_imgs": ["https://cdn.instructables.com/F1S/5VH8/IXAQ0G4B/F1S5VH8IXAQ0G4B.LARGE.jpg", "https://cdn.instructables.com/FEN/AFIW/IXAQ1JIV/FENAFIWIXAQ1JIV.LARGE.jpg"], "step_title": "Step 4: Substituting Sensor Data in Web Server Text for a Line Chart"}], "channel": "Gadgets"}, {"category": "technology", "description": "Sine wave frequency measurement project is designed using pic microcontroller. This project measures the frequency of sine wave. Zero crossing detection technique is used to measure frequency of sine wave.Zero crossing detection using pic microcontroller has been done. PIC16F877A microcontroller timer is used as a counter. Time is measured between two consective zero crossings. Timer is used to measure time. Time is converted back into frequency by taking its inverse. check this post for code of sine wave frequency measurement project using pic microcontroller", "title": "Sine Wave Frequency Measurement Using Pic Microcontroller", "url": "https://www.instructables.com/id/Sine-wave-frequency-measurement-using-pic-microcon/", "section": "technology", "steps": [], "channel": "Electronics"}, {"category": "technology", "description": "This project started off innocently enough; I just wanted to add one permanent light to my bicycle for when I ride at night. The idea snowballed from there and I now have a super fancy bicycle safety light system using an Arduino strobe controller shield, which I designed just for this purpose.So here\u2019s the skinny on what my bicycle now has: Six light modules      Five light channels      A strobe controller module      Some batteries to power the thingThe strobe controller module is a PCB shield I designed and got manufactured specifically for this project, and is actually the first PCB I have designed. I am very pleased with how it turned out. Here are the features of the strobe controller:Up to eight output channels      Up to 600mA output per channel      Uses an Arduino nano or Arduino micro     Uses 6-20v input     Twelve possible modes with the 4x3 keypad (or more if you are handy with the code)With as much time and effort as I have spent on this project, it seems a little silly for it to just be me and my bike with one light system, so I am writing this instructable in the hopes that you guys can make one of your own! I am selling kits so can build your own (info is in the last page). This project turned out to be somewhat lengthy with a lot of steps, so here's what you can expect to see in this instructable:Designing the lights     Assembling the lights      Installing the lights      Designing the strobe controller shield     Assembling the strobe controller      Installing the strobe controller     Designing the software And as a bit of a teaser, here's what the lights look like on the finished product:", "title": "Bicycle Strobe Light System From an Arduino", "url": "https://www.instructables.com/id/How-to-Build-the-Ultimate-Bicycle-Safety-Light-Sys/", "section": "technology", "steps": [{"step": 1, "steps_text": "While my original idea consisted mainly of a single red light to the rear, my final design had five lighting channels controlling six light modules: Front center     Rear center    Front left     Front right     Rear left     Rear rightThe channels I decided to run are:Left (L)      Right (R)      Center (C)      Blue (B)      Rear red (RR)Now, you'll notice that I have six modules but five channels, so what gives? There's a little bit of overlap. The blue (B) and center (C) channels run the center modules identically on the front and the rear, the rear red (RR) channel is wired to both the left and right rear modules, and lastly, the left and right channels are used for the left front and rear, and the right front and rear, respectively. In other words:Front Center: 6 white LEDs (C), 1 blue LED (B)      Rear Center: 6 red (C), 1 blue (B)      Front Left: 4 amber (L)      Front Right: 4 amber (R)      Rear Left: 4 amber (L), 2 red (RR)      Rear Right: 4 amber (R), 2 red (RR)It helps to look at the picture.Now is a good time to address something that I'm sure plenty of you have noticed: there are blue lights on my safety strobe system. Isn't that impersonating an officer or something? Good question. I decided to feature blue lights on the front and rear because I find the color blue to be especially attention-grabbing at night. However, because I don't want any trouble with the law, I am only using one blue LED on the front and one on the rear, compared with 14 other LEDs on the front and 18 others on the rear. Furthermore, I have made only sparing use of the blue lights in the various strobe patterns. I am comfortable using this light, but if you have reservations about the colors, I recommend simply omitting blue from your project. See the last step for the reactions I have noted from police.", "step_imgs": ["https://cdn.instructables.com/FNT/9T1R/IRLQHCYS/FNT9T1RIRLQHCYS.LARGE.jpg"], "step_title": "Step 1: Light Layout"}, {"step": 2, "steps_text": "I used red, amber, blue, and white LEDs for the light modules. The red and amber LEDs have a recommended current of 30mA, while the blue and white are recommended to take 20mA.I am using two li-ion cells in series to power this project because that gives me a nice voltage range: 8.4v when full, down to ~6v when empty. The Arduino nano has a minimum input of 6v, so that happens to work out nicely.I decided to pair up the amber and red LEDs in series to get a total forward voltage of 4.4v, but to leave the blue and white LEDs as single diodes for a forward voltage of just 3.3v. If I put two blue in series, the forward voltage would be 6.6v for the pair, which would get very dim with low batteries.For the red/amber, I calculate that I need a ~150 ohm resistor in series with the pair to get around 30mA with a full battery. 8.4v - 4.4v = 4v across the resistor, and ohms law (V = IR, R = V/I) says that to get 30mA from 4v, I need 4 / 0.030 = 133.3 ohms. I used the nearest common value of 120 ohms.For the white/blue, I need ~250 ohms. 8.4v - 3.3v = 5v. 5v / 0.020 A = ~250 ohms.I decided that I was going to use a common ground in my light modules, meaning that I would provide a switched positive signal to each unit/channel. I designed the strobe controller module to provide just this.The specific LEDs I used are:Cree red LEDsCree amber LEDs Cree blue LEDs Generic white LEDs ", "step_imgs": ["https://cdn.instructables.com/FAO/7ZN5/IRLQOP2M/FAO7ZN5IRLQOP2M.LARGE.jpg", "https://cdn.instructables.com/FOK/0QDB/IRLQOP2P/FOK0QDBIRLQOP2P.LARGE.jpg"], "step_title": "Step 2: Light Design, Electrical"}, {"step": 3, "steps_text": "To build the light modules, I soldered the diodes/resistors together, and wired all the LED/resistor sets, then jammed everything in a mold. For the left and right modules, I used a piece of rubber hose as the mold, and for the center modules, I used a 3/4\" PVC cap.For mounting the side modules, I added a piece of 1/8\" steel rod with a kink inside of the plastic. For the center modules, I just cast an M6 bolt in the resin, sticking out the back.After wiring the lights and installing them in the mold, I poured casting resin over the lights, resistors, wires and all, then set it in the sun to cure.The resin I used is called Solarez, and I like how it contains a UV-activated catalyst so there's no fiddling with mixing anything: just pour it and set it in the sun. The can claims it will cure in 3 minutes with sunlight, but I found it to be more like a whole afternoon. Nonetheless, it cured very hard and I am pleased with the results.Here are some videos of me assembling the center modules", "step_imgs": ["https://cdn.instructables.com/F7Z/58NS/IRLQOPLE/F7Z58NSIRLQOPLE.LARGE.jpg", "https://cdn.instructables.com/FW7/JVU6/IRLQOPLH/FW7JVU6IRLQOPLH.LARGE.jpg", "https://cdn.instructables.com/FAC/CCQK/IRLQOPLC/FACCCQKIRLQOPLC.LARGE.jpg", "https://cdn.instructables.com/FTP/ZEM6/IRLQNAPI/FTPZEM6IRLQNAPI.LARGE.jpg", "https://cdn.instructables.com/FQK/G76O/IRLQOSKE/FQKG76OIRLQOSKE.LARGE.jpg", "https://cdn.instructables.com/FNU/BTET/IRLQNAQV/FNUBTETIRLQNAQV.LARGE.jpg", "https://cdn.instructables.com/FO9/QAT3/IRLQOPNA/FO9QAT3IRLQOPNA.LARGE.jpg", "https://cdn.instructables.com/F3A/1BIK/IRLQNAY2/F3A1BIKIRLQNAY2.LARGE.jpg", "https://cdn.instructables.com/F9Y/ZU87/IRLQNB4W/F9YZU87IRLQNB4W.LARGE.jpg", "https://cdn.instructables.com/FOL/GBE6/IRLQOPLA/FOLGBE6IRLQOPLA.LARGE.jpg", "https://cdn.instructables.com/FSE/P7G7/IRLQOPNE/FSEP7G7IRLQOPNE.LARGE.jpg", "https://cdn.instructables.com/FBM/HJU6/IRLQOPO2/FBMHJU6IRLQOPO2.LARGE.jpg", "https://cdn.instructables.com/FSY/NXFK/IRLQOPN9/FSYNXFKIRLQOPN9.LARGE.jpg", "https://cdn.instructables.com/F9F/ST96/IRLQOSL7/F9FST96IRLQOSL7.LARGE.jpg"], "step_title": "Step 3: Light Assembly"}, {"step": 4, "steps_text": "Mounting the lights is the part of this project that will vary the most between one bike and the next, but for completeness, here's how I mounted the lights on my bicycle.For the front center module, all I needed was a simple triangular piece of sheet metal with 3 holes - two line up with the handlebar clamp, and the last one serves to receive the bolt on the center light module.The front left/right modules were a little more complicated. After contemplating how to put the lights on my \"ram's horn\" handlebars without getting in my way, I decided to mount them sticking out from the very top front of the plastic brake actuator bodies. I used a washer in conjunction with the mounting rod so that a single screw could clamp the modules without letting them spin. The pictures are really the best way to describe this.", "step_imgs": ["https://cdn.instructables.com/FBJ/M0XU/IRLQHEZS/FBJM0XUIRLQHEZS.LARGE.jpg", "https://cdn.instructables.com/FSO/PKR0/IRLQHE50/FSOPKR0IRLQHE50.LARGE.jpg", "https://cdn.instructables.com/FYA/3T9W/IRLQHF2L/FYA3T9WIRLQHF2L.LARGE.jpg", "https://cdn.instructables.com/FIF/NNNQ/IRLQHF2P/FIFNNNQIRLQHF2P.LARGE.jpg", "https://cdn.instructables.com/FVX/RLG1/IRLQHF2S/FVXRLG1IRLQHF2S.LARGE.jpg", "https://cdn.instructables.com/FHE/ZU8C/IRLQHF3U/FHEZU8CIRLQHF3U.LARGE.jpg", "https://cdn.instructables.com/F4I/DKRU/IRLQHEI5/F4IDKRUIRLQHEI5.LARGE.jpg", "https://cdn.instructables.com/F2D/RQQS/IRLQHEI9/F2DRQQSIRLQHEI9.LARGE.jpg", "https://cdn.instructables.com/FJ7/FBIE/IRLQHEDX/FJ7FBIEIRLQHEDX.LARGE.jpg", "https://cdn.instructables.com/FIO/4PXA/IRLQHEF2/FIO4PXAIRLQHEF2.LARGE.jpg", "https://cdn.instructables.com/FNJ/ZJ9U/IRLQHEGP/FNJZJ9UIRLQHEGP.LARGE.jpg", "https://cdn.instructables.com/FNM/1UEX/IRLQHEI1/FNM1UEXIRLQHEI1.LARGE.jpg", "https://cdn.instructables.com/F2P/NI72/IRLQHKJM/F2PNI72IRLQHKJM.LARGE.jpg", "https://cdn.instructables.com/FBZ/DTI2/IRLQHEIC/FBZDTI2IRLQHEIC.LARGE.jpg", "https://cdn.instructables.com/F8T/KPH8/IRLQHERJ/F8TKPH8IRLQHERJ.LARGE.jpg", "https://cdn.instructables.com/FI8/EEWA/IRLQHETY/FI8EEWAIRLQHETY.LARGE.jpg", "https://cdn.instructables.com/FVH/KUA7/IRLQHER2/FVHKUA7IRLQHER2.LARGE.jpg"], "step_title": "Step 4: Light Installation, Front"}, {"step": 5, "steps_text": "On the rear, I no place to mount the lights without some sort of a clamp-on fixture. I didn't take pictures as I built it, so my  \"artistic\" rendering will have to suffice. It is made with some 16ga sheet metal. The fixture clamps onto the  seat tube with a piece of rubber hose as extra friction and scratch  protector. The rear center module just bolts straight onto the fixture,  and the rear left/right modules got an M5 bolt welded onto their rods so  they could bolt straight on also.Once the lights bolted into their appropriate holes,  the wires were connected where appropriate (grounds were consolidated,  as well as the two RR light leads), and a bit of tape was added to protect  the wires where they go over sharp edges. The wire bundle was bulkier than I  anticipated, but that's just what I get for choosing five lighting channels.", "step_imgs": ["https://cdn.instructables.com/FPP/IPVE/IRLQHIRV/FPPIPVEIRLQHIRV.LARGE.jpg", "https://cdn.instructables.com/FZ3/O524/IRLQHITD/FZ3O524IRLQHITD.LARGE.jpg", "https://cdn.instructables.com/FA8/NC8W/IRLQHIUZ/FA8NC8WIRLQHIUZ.LARGE.jpg", "https://cdn.instructables.com/FFD/QO4F/IRLQHIR5/FFDQO4FIRLQHIR5.LARGE.jpg", "https://cdn.instructables.com/FRJ/GX26/IRLQHIU7/FRJGX26IRLQHIU7.LARGE.jpg", "https://cdn.instructables.com/F3G/N1LU/IRLQHE8T/F3GN1LUIRLQHE8T.LARGE.jpg", "https://cdn.instructables.com/F7I/4MJR/IRLQHE73/F7I4MJRIRLQHE73.LARGE.jpg", "https://cdn.instructables.com/F4U/FBSM/IRLQHE7Y/F4UFBSMIRLQHE7Y.LARGE.jpg", "https://cdn.instructables.com/F92/6CZB/IRLQHIZ1/F926CZBIRLQHIZ1.LARGE.jpg", "https://cdn.instructables.com/FU2/0JSN/IRLQHEBI/FU20JSNIRLQHEBI.LARGE.jpg", "https://cdn.instructables.com/F6S/3GAN/IRLQHEAD/F6S3GANIRLQHEAD.LARGE.jpg", "https://cdn.instructables.com/F2L/3FO3/IRLQHECN/F2L3FO3IRLQHECN.LARGE.jpg", "https://cdn.instructables.com/FKY/OQSY/IRLQHED4/FKYOQSYIRLQHED4.LARGE.jpg", "https://cdn.instructables.com/FVQ/0GHG/IRLQHKIT/FVQ0GHGIRLQHKIT.LARGE.jpg"], "step_title": "Step 5: Light Mounting, Rear"}, {"step": 6, "steps_text": "When I first started this project, I was considering a single light on the rear, perhaps made to blink using a 555 timer. The 555 train of thought led me to consider stringing two timers together to get an intermittent strobe. Then I thought about stringing together three... and I realized that the hardware was getting very complicated very fast, because around the same time started considering adding more independent channels with their own patterns. And if I was going this far in complexity, why not throw in a couple different modes, just because I can?If you think a good option to simplify this would be an Arduino, you and I are in agreement. I decided to use the Arduino nano due to its tiny size and low price. It uses the same atmega328p chip and is functionally identical to the Arduino uno, except that it uses miniaturized components, so it is very small. The nano has been discontinued by the Arduino brand, but you can still buy it directly from the company which designed it, Gravitech. Alternatively, generic/knockoff nanos go for about $5 on eBay (and that's what I'm using). The Arduino micro will also work in the shield, because it has a backwards compatible pinout. Just make sure to plug it into the header sockets so that the correct pins line up; it will have two extra pins on each side, which will just hang out, not connected or anything.The lack of real estate on the Arduino nano makes it obvious that I needed a shield to interface between the Arduino and the light modules. The nano can source 5v from the output pins, but with a maximum of 40mA, while I wanted to use a little more than that for each channel. So the shield needs to step up that output.Also,there is still the question of how to change modes. I have seen matrix keypads used in Arduino projects before, so, without any knowledge of how to implement one, I decided to use a 4x3 membrane switch, which has 7 wires (one for each row and one for each column). On the next page I'll discuss how I interfaced between the keypad and the Arduino. ", "step_imgs": ["https://cdn.instructables.com/F4B/G6EK/IRLQNCSH/F4BG6EKIRLQNCSH.LARGE.jpg"], "step_title": "Step 6: Hardware Design"}, {"step": 7, "steps_text": "The transistor switch works like this: a high signal (5v) comes from the digital pin through the base of the NPN transistor. This turns on the NPN and sinks current from the base of the PNP transistor. The result is that the PNP transistor is turned on and allows current to flow to the lights, with a much higher current than the Arduino can provide. The PNP transistor I used is a pn2907 which has an absolute maximum current of 800mA. Derating this to about 600mA should keep the PNP transistor below its maximum power dissipation. Still, that's a huge increase over the 40mA from the Arduino.Now, as far as reading input from the keypad, I found out that there are basically two ways to read input from a matrix switch: digital and analog. The digital method requires a digital pin for each wire (for a 4x3, that\u2019s seven pins). At the time I designed the PCB, I hadn't realized that the Arduino's analog pins can be used as fully functional digital pins, so, feeling a shortage of digital pins (14 - 8 = only 6), I implemented the analog, one wire method, which essentially puts an array of resistors on the keypad such that each key generates a unique voltage. You can read more about it here.(and the next PCB design will use the digital method).Note: Something nice about the keypad interface is that it can work with any size of matrix keypad, as long as it's 4x3 or smaller. If you wanted a smaller keypad, you could always go with the 4x1; the only downside is that the software maps one mode to one button, so you would only have four modes with a 4x1 keypad (unless you tweaked the software). Anyway, on to building the circuit!", "step_imgs": ["https://cdn.instructables.com/FJK/SDPI/IRXTAIE7/FJKSDPIIRXTAIE7.LARGE.jpg", "https://cdn.instructables.com/F3W/SW6C/IRXT2QI9/F3WSW6CIRXT2QI9.LARGE.jpg", "https://cdn.instructables.com/FEV/Z6HN/IRXTCX5T/FEVZ6HNIRXTCX5T.LARGE.jpg"], "step_title": "Step 7: Hardware Design, Schematics"}, {"step": 8, "steps_text": "I have to give a huge shout out to Dangerous Prototypes for making my boards. They had (by far) the best price I found in weeks of searching for a supplier. I got my boards about 6 days after I submitted the order using express shipping. They are the same people as \"dirty pcbs\" and \"seeed studio\". They have some top notch DIY stuff and I recommend giving them a look.Once I knew what I needed my circuits to do and how I wanted to build them, all that I needed to sort out were the traces for each circuit element. There were eight amplifier units for eight channels and one voltage divider for the keypad. I compared some software options, and ultimately used fritzing, which is free but powerful. It has a schematic, breadboard, and PCB view, with a \"rat's nest wire\" feature that makes it really easy to lay out the traces after creating the schematic. The people at fritzing do offer a PCB manufacturing service, but I preferred the price/quantity that Dangerous Prototypes offered.One cool thing I noticed about fritzing was that, while searching for a specific feature, I would find years-old forum posts asking about this feature or that, and the developers would say \"we don't have that feature yet.\" But when I searched a little further, I found that they had actually added the feature since then. So they have an active and interactive development team.I spent a lot of time tweaking this board until I was happy with it, and went though about 7 major revisions over the course of a week or so. So that you can replicate this project, I am selling the PCBs alone or in a kit. Info is in the last step.", "step_imgs": ["https://cdn.instructables.com/F6R/I7TU/IRLQNCSY/F6RI7TUIRLQNCSY.LARGE.jpg"], "step_title": "Step 8: PCB Design and Ordering"}, {"step": 9, "steps_text": "So what goes where? Q1-Q8 are a 2n2222 or 2n3904 transistor (NPN ebc)             Q9-Q16 are pn2907 or 2n3906 (PNP ebc) (but the 3906 has lower current capacity)             R1-R8 are 100ohm              R9-R16 and R20-R22 are 1k ohm             R17-R19 are 4.7k ohm             J1-J7 are 1935161 or similar screw terminals, 5mm pitch             C1, an optional filter capacitor to help shield the Arduino from noise. It should be at least double your battery voltage and ~1000\u03bcF    Arduino has header sockets, not shown in the photos    keypad connector has header pinsR1-R16 are installed flat against the board, while R17-R22 are installed in the \"stand up\" orientation. I recommend installing the resistors first, the header pins/sockets, then the transistors, then the remaining components. The Arduino needs to be soldered into the strobe controller or installed using header sockets. I went with the header socket method, but that was after taking pictures. The Arduino connections will be sketchy if you just put it in the board with no assistance.", "step_imgs": [], "step_title": "Step 9: PCB Population"}, {"step": 10, "steps_text": "Once you have the PCB assembled, and unless you live in the Mojave Desert and like the components to be hanging loose, you'll need to put everything in a water-resistant case. I found that a Hammond 1591XXC fits the board nicely, and it just happens to carry an IP54 rating.Use the board as a template to mark the four hole locations on the lid of the box, then drill them with a 1/16\" or 1mm drill bit. Use a chisel to remove the PCB mounting posts from the lid, and use 6mm spacers on #2 sheet metal screws to mount the board. Use #2 sheet metal screws to hold the board down, on top of the spacers.", "step_imgs": ["https://cdn.instructables.com/FU6/57CR/IRXT9ZCM/FU657CRIRXT9ZCM.LARGE.jpg", "https://cdn.instructables.com/FVV/WVMR/IRXT9ZII/FVVWVMRIRXT9ZII.LARGE.jpg", "https://cdn.instructables.com/F99/7OIC/IRXT9Z53/F997OICIRXT9Z53.LARGE.jpg", "https://cdn.instructables.com/FG4/3KKO/IRXTA18R/FG43KKOIRXTA18R.LARGE.jpg", "https://cdn.instructables.com/FBB/5MUN/IRXT9ZQQ/FBB5MUNIRXT9ZQQ.LARGE.jpg", "https://cdn.instructables.com/FIU/ZT97/IRXT9ZQW/FIUZT97IRXT9ZQW.LARGE.jpg", "https://cdn.instructables.com/F2F/Z8XY/IRXT9ZS8/F2FZ8XYIRXT9ZS8.LARGE.jpg"], "step_title": "Step 10: Put It in a Box"}, {"step": 11, "steps_text": "With the PCB mounted in the lid of the case, let's add the battery holder. We will use the case lid screws to mount the battery holder, except that we need slightly longer ones than are included with the case.In the battery holder, drill two holes through the base of one cell cavity that align with the case lid mounting holes. In the lid, drill one hole under the battery holder for the wires to go through. In the case box, drill a hole for the switch to mount. This switch could go anywhere according to your preference, but I decided to put it on the rear of the box - the side which will have the keypad ribbon.Feed the battery wires through the hole and extend the positive lead a few inches to reach the switch on the other side of the box. Then add a wire from the switch to the positive input on the board. The ground lead from the battery holder goes straight to any ground connection.", "step_imgs": ["https://cdn.instructables.com/FTS/Y8FS/IRXTA01C/FTSY8FSIRXTA01C.LARGE.jpg", "https://cdn.instructables.com/FLV/NLLS/IRXT9ZZU/FLVNLLSIRXT9ZZU.LARGE.jpg", "https://cdn.instructables.com/FQE/CFF2/IRXTA000/FQECFF2IRXTA000.LARGE.jpg", "https://cdn.instructables.com/FBK/F3MQ/IRXTA01N/FBKF3MQIRXTA01N.LARGE.jpg", "https://cdn.instructables.com/FX1/8GLW/IRXTCV0I/FX18GLWIRXTCV0I.LARGE.jpg"], "step_title": "Step 11: Add a Battery Holder"}, {"step": 12, "steps_text": "The power switch needs a hole to mount, and we also need a way to pass the wires through the box.For the switch,use a 1/4\" drill.For the wire hole, use a 1/2\" bit to accommodate the cable gland (it's a weird name, I know). There is a nut that goes on the back side, so don't put the hole too close to the edge.", "step_imgs": ["https://cdn.instructables.com/F79/VZ3J/IRXT9ZSR/F79VZ3JIRXT9ZSR.LARGE.jpg", "https://cdn.instructables.com/FC6/FYNQ/IRXT9ZXR/FC6FYNQIRXT9ZXR.LARGE.jpg", "https://cdn.instructables.com/FAQ/2ASG/IRXT9ZYZ/FAQ2ASGIRXT9ZYZ.LARGE.jpg", "https://cdn.instructables.com/FME/04WX/IRXTA1NX/FME04WXIRXTA1NX.LARGE.jpg", "https://cdn.instructables.com/FE8/LA7Z/IRXT9ZUD/FE8LA7ZIRXT9ZUD.LARGE.jpg", "https://cdn.instructables.com/FQF/TL3M/IRXTA02T/FQFTL3MIRXTA02T.LARGE.jpg"], "step_title": "Step 12: Holes for Wires and Switch"}, {"step": 13, "steps_text": "Who doesn't like velcro? The strobe controller box hangs from the top tube using a couple hook and loop straps, and the straps are attached to the box using plain ol' sheet metal screws. Drill 1/8\" holes through the PCB posts in the box, so that there's a little more \"meat\" for the screws to grab. Use a soldering iron or awl to punch holes through the two velcro straps, then screw them onto the box, soft side up (for the bicycle paint).", "step_imgs": ["https://cdn.instructables.com/F9T/83ED/IRXTA04O/F9T83EDIRXTA04O.LARGE.jpg", "https://cdn.instructables.com/FEO/JXV0/IRXTA08T/FEOJXV0IRXTA08T.LARGE.jpg", "https://cdn.instructables.com/FXV/AYHV/IRXT9Z8I/FXVAYHVIRXT9Z8I.LARGE.jpg", "https://cdn.instructables.com/FFQ/A5OR/IRXT9YAH/FFQA5ORIRXT9YAH.LARGE.jpg"], "step_title": "Step 13: Velcro Mounting Straps"}, {"step": 14, "steps_text": "You should have your lights mounted and the wires run to the rough location of the Strobe Controller box, plus at least 6\" of extra wire. Run the wires through the cable gland, then connect the individual wires into their appropriate slots. The strobe controller provides 5 ground slots and 8 channel outputs (I only used 5).Normally, a cable gland is used only with a smooth, jacketed wire, and it seals effectively on the jacket, but I am using a bunch of individual wires. To keep this water tight, I backed out the wire bundle just a little bit, added some silicone RTV all through the bundle, then slid everything back into the gland. While you have out the RTV, go ahead and glob on a bit to the battery wires where they enter the box.Aside from being waterproof, the rubber gland provides a nice anti-stress clamp on the wires. Don't go crazy when tightening it - very finger tight is all it needs, or lightly snug with a wrench.Before you close up the box, load the software on the Arduino and install it in its socket. Speaking of software...", "step_imgs": ["https://cdn.instructables.com/F8Q/DNJR/IRXT9Z1W/F8QDNJRIRXT9Z1W.LARGE.jpg", "https://cdn.instructables.com/F1I/A7RQ/IRXT9YYC/F1IA7RQIRXT9YYC.LARGE.jpg", "https://cdn.instructables.com/FR3/QG8R/IRXT9YR3/FR3QG8RIRXT9YR3.LARGE.jpg", "https://cdn.instructables.com/FAZ/2VA1/IRXT9YPJ/FAZ2VA1IRXT9YPJ.LARGE.jpg", "https://cdn.instructables.com/FSA/6ABI/IRXT9YIS/FSA6ABIIRXT9YIS.LARGE.jpg", "https://cdn.instructables.com/FGV/C466/IRXTADQS/FGVC466IRXTADQS.LARGE.jpg", "https://cdn.instructables.com/FPM/IEC5/IRXTADU3/FPMIEC5IRXTADU3.LARGE.jpg", "https://cdn.instructables.com/FV7/8L28/IRXTAD54/FV78L28IRXTAD54.LARGE.jpg", "https://cdn.instructables.com/FME/OUGG/IRXTADBE/FMEOUGGIRXTADBE.LARGE.jpg", "https://cdn.instructables.com/FB8/QMOT/IRXTCV0K/FB8QMOTIRXTCV0K.LARGE.jpg", "https://cdn.instructables.com/FHD/Q2VW/IRXTA0GF/FHDQ2VWIRXTA0GF.LARGE.jpg"], "step_title": "Step 14: Wire the Lights"}, {"step": 15, "steps_text": "Download the code here!First off, a big shout out to TimothyBeenefor doing the heavy lifting in terms of developing the code for this project.When I started designing this strobe controller, I was indeed familiar with the basic \"blink\" sketch, but in terms of making multiple lights flash simultaneously, each with their own patterns, I was not so well prepared. No matter, this was a learning opportunity! TimothyBeene and I wound up using the \"millis()\" method outlined here, modified to be a little more \"modular.\" First, the patterns are defined in an integer array, one for each channel, as millisecond values of times that the channel should stay in its state. The state is determined by the sign of the interval: positive values are \"on\" times, and negative values are \"off\" times. The lists are terminated with a zero because they are arbitrarily long arrays; there is no built in terminating character for an array like this, so the program will read intervals until it gets to the zero that we put at the end. This is kind of like the \"\\0\" in a string. These patterns are in a separate file to make the code a little neater.Each mode has its own interval array (pattern) for each channel used in that mode, and the mode accesses the individual interval arrays through an interval array array (sort of a two dimensional array), such as modeX_data. Because there are one pattern for one channel,  up to 8 channels per mode, and 12 modes, there are up to 96 individual patterns. If each pattern were 50 intervals long (a high estimate), there could possibly be 4800 int values being stored to keep track of the patterns. At 2 bytes per int, that's 9.6KB. This doesn't seem like a big number to anyone who didn't start programming in the '70s, but it is too big to store in the atmega328's ram, which maxes out at 2KB. Fortunately, the onboard flash is 32KB, so we can force these variables into the flash using the word PROGMEM. Variables declared with PROGMEM cannot be changed after burn-in, but that's a-ok for this application.Anyway, now that we have all the patterns taken care of, we need to do some actual flashing of lights. When the program starts, or when a key is pressed, a particular mode object is created, called with the appropriate array directing it to its patterns and the pins used by that mode. The mode object will create a channel object for each pin listed in the mode call. Each channel then handles one pattern array.The actual work of flashing the lights happens in the channel object. The channel grabs the first interval in the pattern and checks the sign. If the sign is positive, it sets the pin HIGH, and if the sign is negative, it sets the pin LOW. The channel records the system time (from millis()) that the channel state was set, and every time that the thread loops back around, it checks to see if the difference between nowand the last time is greater than the absolute value of the current interval, and if it is, the channel will read the next value, check its sign, and do the same thing again. Once the last interval is reached, the channel loops back and starts with the first interval in the pattern.All of the channels are operating simultaneously, of course, so the thread loops through all of the channels, checking if enough time has elapsed to advance the interval. ", "step_imgs": ["https://cdn.instructables.com/FFE/4T0U/IRXT2OAA/FFE4T0UIRXT2OAA.LARGE.jpg"], "step_title": "Step 15: Software Design, Under the Hood"}, {"step": 16, "steps_text": "So let's say you build this, but you just don't really like the patterns, or the pin assignments. We wrote the code with the intent that it could be customized fairly easily, hopefully in a way that is at least a little intuitive.Let's recap from the last step. I'll discuss just mode 0 for simplicity. Each channel is pointed at an array of millisecond intervals, mode0_1 for the first pattern. Positive values are \"on\" and negative values are \"off,\" comma separated, and the list must end with a zero for the last value. Each channel is assigned a pin number in the array mode0_pins (the first value is the pin number for the first pattern, second value is pin number for second pattern, etc). Nothing says that the patterns must be synchronous, but if you want your pattern to stay in sync, you need to make sure that the total period of each pattern matches. Otherwise your patterns will become offset within a mode. A great example of this is the difference between mode 1 and mode 4. They are very similar, both having one \"off\" time and one \"on\" time, but pattern 1 has the same period for all lights, while 4 has the same \"on\" times but slightly different \"off\" times. You can see a big difference between the two patterns in the demo video below (they are mapped to 2 and 5 on the keypad).The shortest interval that seems to still work nicely is about 5 milliseconds. If you include any intervals much shorter than this, they won't look right, and won't stay synchronized.", "step_imgs": ["https://cdn.instructables.com/F23/B2WY/IRXT2OA9/F23B2WYIRXT2OA9.LARGE.jpg"], "step_title": "Step 16: Software Design, Customization"}, {"step": 17, "steps_text": "This project took about 7 weeks from the first idea to the finished product (I spent plenty of time waiting on shipping from China), and I learned a whole lot in the process. I have gotten plenty of looks, nods, smiles and waves with the lights flashing, so I think it accomplishes the goal: attract drivers' attention. However, I have almost been run over once while running these lights, which goes to reinforce a rule of bicycling: no matter what you do, you have to keep an eye on cars. I should note that the headlight on this setup, just six regular white LEDs, is not bright enough to illuminate the road ahead of me, but that isn't the point; it's supposed to grab attention. I still use a very bright headlamp on my helmet, and I also make a habit of using it to grab the attention of drivers who I don't think have noticed me. In terms of the reaction from local law enforcement, I have noted the reactions from police in various municipalities, including some pretty small towns. At night, with all the lights blazing, I have ridden near different police officers who did nothing more than give a disinterested stare. If I were to wager a guess, they are probably just happy that I have lights to grab drivers' attention.When I was designing this strobe controller system, I had the intention to develop it to the point I could sell it as a DIY kit. I intentionally purchased more PCBs than I needed (I only needed one) so that I could sell them to fellow makers in the hope that other bicycles (and other vehicles, signs, or whatever other applications) would become a little more attention-grabbing with the addition of a Strobe Controller. Information about buying this kit is in this forum post. I am looking forward to your feedback in the comments. How could I improve? How does it look on your bicycle? What would you change when building it?Thanks for reading!", "step_imgs": ["https://cdn.instructables.com/FRS/NUHX/IRXTA0BT/FRSNUHXIRXTA0BT.LARGE.jpg"], "step_title": "Step 17: Conclusions"}, {"step": 18, "steps_text": "In the course of building this project and writing this instructable, there have been many small changes that I would implement if I were to build it again.The mount for the lights on the rear is kind of big and wobbly. It should really be trimmed down a lot smaller.The side light modules should be mounted on a smaller diameter rod, perhaps a bicycle spoke. Furthermore, integration of a spring would make the lights resilient against breakage when the bike falls over.The strobe controller V1.1 PCB will no longer use the \"oneWireKeypad,\" but rather the fully digital \"standard\" method of reading keys. I will probably also use mosfets for switching the lights. I think I will also include a way for the arduino to detect the battery voltage and switch to a low power pattern automatically when the batteries get low, as I have found that the arduino will run well below the rated 6v input, and the lights just get dim.", "step_imgs": [], "step_title": "Step 18: Future Work and Improvements"}], "channel": "Arduino"}, {"category": "technology", "description": "This is a step by step walk through of how to set-up and use Quartus software and upload it to the Altera Cyclone FPGA. \u00a0Done as a primer for my school's(Ivy Tech CC) Digital Fundementals EECT122 course. \u00a0This will cover in great detail the exact method to setup the software, your design and upload it to the FPGA(Field Programmable Gate Array) board. \u00a0", "title": "The Altera FPGA and Quartus II Software", "url": "https://www.instructables.com/id/The-Altera-FPGA-and-Quartus-II-software/", "section": "technology", "steps": [{"step": 1, "steps_text": "Double click the Quartus Icon on the desktop. \u00a0", "step_imgs": ["https://cdn.instructables.com/FKW/84SN/H8CVFPEF/FKW84SNH8CVFPEF.LARGE.jpg"], "step_title": "Step 1: Open Quartus"}, {"step": 2, "steps_text": "Once Quartus opens you will see this screen. \u00a0Go to the New Project Wizard located in the File tab. \u00a0\nCreate a parent folder on your flash drive. \u00a0 You want this on your flash drive because anything saved on the colleges hard-drives may not be there next class. \u00a0\nCreate a parent folder where you want to keep all of your Labs! \u00a0i.e. \u00a0G:\\Joe_Schmo_jumpdrive\\EECT122\\Next:\nCreate a child folder this particular lab will be stored. \u00a0i.e. \u00a0G:\\Joe_Schmo\\EECT122\\Lab_1-1\\\n\u00a0You can do this either in windows explorer or directly in the program Quartus.\u00a0IMPORTANT!!!!:\nVERY IMPORTANT!!!!!!!!!:\nFor quartus to work right, your build files(.bdf/.vhd/.etc) need to be in a folder(your child folder) that has the same name as the projects. \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FAH/RWTI/H8CVFPEV/FAHRWTIH8CVFPEV.LARGE.jpg", "https://cdn.instructables.com/FNP/MAXD/H8CVFPF9/FNPMAXDH8CVFPF9.LARGE.jpg"], "step_title": "Step 2: Folders"}, {"step": 3, "steps_text": "Wizards are great aren't they? \u00a0This one guides you through the initial setup of your project. \u00a0After selecting the appropriate name of your parent folder and creating an appropriate child folder, it's time to name your project. \u00a0You want to call it \"I rock Ivy Tech EE\" I know. \u00a0But if you do that and it doesn't match the child folder you've create, the software will get really confuses later on. \u00a0Just name your project the EXACT same thing as the child folder. \u00a0In the picture below it is \"tutorial.\" \u00a0And so EVERY different type of file in this project will get named \"tutorial.\" \u00a0\ntutorial.bdf\ntutorial.vdl\nturorial.etc\nAfter that's done, click next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FE9/RL8D/H8CVFPFV/FE9RL8DH8CVFPFV.LARGE.jpg"], "step_title": "Step 3: New Project Wizard"}, {"step": 4, "steps_text": "Do you want to add files. \u00a0Well for our purposes NO. \u00a0Click next without hitting anything. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB7/BRVM/H8CVFPG5/FB7BRVMH8CVFPG5.LARGE.jpg"], "step_title": "Step 4: Add Files"}, {"step": 5, "steps_text": "In this class we are using the Cyclone II\u00a0EP2C20F484C7.", "step_imgs": ["https://cdn.instructables.com/FQB/FTAD/H8CVFPGT/FQBFTADH8CVFPGT.LARGE.jpg", "https://cdn.instructables.com/F1F/3FXP/H8CVFPGU/F1F3FXPH8CVFPGU.LARGE.jpg"], "step_title": "Step 5: Select the Right Board"}, {"step": 6, "steps_text": "You don't need any tools. \u00a0Hit next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FPI/C7FF/H8CVFPH7/FPIC7FFH8CVFPH7.LARGE.jpg"], "step_title": "Step 6: EDA Tools?"}, {"step": 7, "steps_text": "Everything look right?\u00a0\nWell hit finish and lets get started programming a FPGA. \u00a0", "step_imgs": ["https://cdn.instructables.com/F3W/KF8M/H8CVFPHE/F3WKF8MH8CVFPHE.LARGE.jpg"], "step_title": "Step 7: Finish Your Set Up"}, {"step": 8, "steps_text": "We will now begin to enter gates and create a schematic \"program\" to be executed on the hardware\u00a0development\u00a0board. \u00a0\nGo to the\u00a0FILE\u00a0tab and hit New.\u00a0 Here you will have the option to create many different types of files. \u00a0 For this tutorial we will be creating a Block Diagram/Schematic File.", "step_imgs": ["https://cdn.instructables.com/FQ0/2DCU/HCB8CRRW/FQ02DCUHCB8CRRW.LARGE.jpg", "https://cdn.instructables.com/FC2/5C7S/HCB8CRFI/FC25C7SHCB8CRFI.LARGE.jpg", "https://cdn.instructables.com/F6E/LG63/HCB8CRFS/F6ELG63HCB8CRFS.LARGE.jpg"], "step_title": "Step 8: Block Diagram/ Schematic"}, {"step": 9, "steps_text": "It is highly recommended that you save the file at this time. \u00a0 Remember, this file name \" *.bdf \" must be the same name as the folder that was created earlier on. \u00a0Steps 1 though 8 go about created other files that are needed for everything to work properly and if this \".DBF\" (Diagram-Block) file does not live in that same folder, it won't work right.\nSo for this example I saved it as \"G:\\tutorial.bdf", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg"], "step_title": "Step 9: Save the File"}, {"step": 10, "steps_text": "Now the fun part begins. \u00a0 This is where we create the schematic. \u00a0 On the left of this new window are various tools you can use to add logic gates and other parts to complete your project. \u00a0You are able to turns wires into buses, add text, zoom in and out, and many other things through the buttons on the left. \u00a0\nThe third picture in this series shows a diagram of a 4 bit comparator that was created rather quickly. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB2/UL4S/HCB8CRGC/FB2UL4SHCB8CRGC.LARGE.jpg", "https://cdn.instructables.com/FOA/0JLY/HCB8CRGD/FOA0JLYHCB8CRGD.LARGE.jpg", "https://cdn.instructables.com/FJW/TGRK/HCB8CRGE/FJWTGRKHCB8CRGE.LARGE.jpg"], "step_title": "Step 10: Create a Schematic"}, {"step": 11, "steps_text": "Just like written code, schematic diagrams must be compiled into machine code for it to be used. \u00a0 Also like writing programming language, this is where you get error and must debug things. \u00a0The error messages provided by Quartus tend to be much more useful than other messages from IDE compilers. \u00a0\nUp at the top tool bar,\u00a0 the button that looks like play button will start the compilation.\nYou can also navigate to the \"Processing Tab\" and hit \"Start Compilation\".", "step_imgs": ["https://cdn.instructables.com/FVT/XKAL/HCB8CRH7/FVTXKALHCB8CRH7.LARGE.jpg", "https://cdn.instructables.com/FWF/N9HQ/HCB8CRH8/FWFN9HQHCB8CRH8.LARGE.jpg"], "step_title": "Step 11: Start Compilation"}, {"step": 12, "steps_text": "If you are successful your screen will look similar to image 2. \u00a0\nYou must save the compiled BDF before proceeding to create a Vector Waveform. \u00a0", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FCB/55SG/HCB8CRJ8/FCB55SGHCB8CRJ8.LARGE.jpg"], "step_title": "Step 12: Save"}, {"step": 13, "steps_text": "So you've wired some virtual chips together and it works. \u00a0Now it's time to see what the output actually is and determine if it's what was expected. \u00a0To do that we are going to use a Vector Waveform file.\u00a0\nUnder the File tab, \u00a0select New,\u00a0and then\u00a0Vector Waveform file.\nThis screen should look familiar, it is the same place where we created the Block Diagram file.", "step_imgs": ["https://cdn.instructables.com/FRC/JNHU/HCB8CRM7/FRCJNHUHCB8CRM7.LARGE.jpg", "https://cdn.instructables.com/FKR/YN1J/HCB8CRM4/FKRYN1JHCB8CRM4.LARGE.jpg", "https://cdn.instructables.com/FG4/78CR/HCB8CRO9/FG478CRHCB8CRO9.LARGE.jpg"], "step_title": "Step 13: Vector Waveforms"}, {"step": 14, "steps_text": "Once\u00a0again, \u00a0Immediately\u00a0after creating the new vector waveform file, \u00a0Re-save it with the SAME name as the parent folder. \u00a0\nSo for this tutorial it is saved as \"G:\\Joe_Schmo\\EECT122\\Lab_1-1\\tutorial\\tutorial.VCF\"", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FRU/QLMT/HCB8CROS/FRUQLMTHCB8CROS.LARGE.jpg"], "step_title": "Step 14: SAVE"}, {"step": 15, "steps_text": "Typically, this window pops up with a total time to analyse the output of your circuit of 20 nanoseconds. \u00a0That is a little short on time. \u00a0We will change this by navigating to the Edit tab, and selecting End Time.\nIn this class, 16 micro-seconds will be a nice time frame to work with. \u00a0Some labs might specify a different time, this is where you change that. \u00a0", "step_imgs": ["https://cdn.instructables.com/FES/YV1V/HCB8CRPH/FESYV1VHCB8CRPH.LARGE.jpg", "https://cdn.instructables.com/FMG/77OD/HCB8CRPI/FMG77ODHCB8CRPI.LARGE.jpg"], "step_title": "Step 15: Setting Up the Waveform File-End Time"}, {"step": 16, "steps_text": "The grid size doesn't automatically change. \u00a0So want to change it. \u00a0 Under the Edit tab, click Grid Size.\u00a0\nInside the dialogue window, edit the boxes and double check that you have selected the right scale(nano, micro, milli).\u00a0\nAfter the settings are correct, \u00a0Use the keyboard shortcut and press CTRL W to view the entire timeline. \u00a0It should look like picture 3. \u00a0", "step_imgs": ["https://cdn.instructables.com/F0G/HX5G/HCB8CRQ6/F0GHX5GHCB8CRQ6.LARGE.jpg", "https://cdn.instructables.com/FAC/EY6R/HCB8CRQ7/FACEY6RHCB8CRQ7.LARGE.jpg"], "step_title": "Step 16: Setting Up the Waveform File-Edit Grid Size"}, {"step": 17, "steps_text": "Now that the vector file is configured properly we need to import or link to the inputs and outputs created in our Schematic file. \u00a0\nRight click on the left panel. \u00a0Scroll down to INSERT and over to INSERT NODE OR BUS.\nThis will bring up a new window with several options. \u00a0Underneath the cancel button, is a button called NODE FINDER. \u00a0Press that button and leave the other options alone. \u00a0\nThis brings up a new window called NODE FINDER. \u00a0\n----At the top middle, scroll down and select \"Pins: All\" \u00a0\n----next, over to the right is a button that says list. \u00a0It searches for the pins in your schematic. \u00a0Hit that button.\n----Once pins are in the left tab, we need to select them. \u00a0This can be done individually if needed with the single arrow button, \u00a0or all pins at once with the double arrow button. \u00a0\n-----Lastly, Click OK in the \"Node Finder\" window and also OK in the \"Insert Node or Bus\" window.", "step_imgs": ["https://cdn.instructables.com/FL8/63GB/HCB8CRQP/FL863GBHCB8CRQP.LARGE.jpg", "https://cdn.instructables.com/FKM/CEQY/HCB8CRQQ/FKMCEQYHCB8CRQQ.LARGE.jpg", "https://cdn.instructables.com/FC4/NJ18/HCB8CRQR/FC4NJ18HCB8CRQR.LARGE.jpg", "https://cdn.instructables.com/FWK/ZH6J/HCB8CRQS/FWKZH6JHCB8CRQS.LARGE.jpg", "https://cdn.instructables.com/FAD/X7ZA/HCB8CRQT/FADX7ZAHCB8CRQT.LARGE.jpg", "https://cdn.instructables.com/FOD/1EU2/HCB8CRQU/FOD1EU2HCB8CRQU.LARGE.jpg"], "step_title": "Step 17: Add Inputs and Outputs"}, {"step": 18, "steps_text": "This simulation will run your circuit and easily allow you to change the inputs.\u00a0 This was our whole goal.\nThe first two pictures show my comparator circuit will no inputs.\u00a0 Both data streams here A and B have no data, thus they are equal and the \"W\" output goes high.\u00a0\nThe next few pictures will show how to change the input and what happens to the output \"W\" when the two data streams are not equal.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/F4C/FG76/HCB8L7UF/F4CFG76HCB8L7UF.LARGE.jpg", "https://cdn.instructables.com/FO2/JCVU/HCB8CWGU/FO2JCVUHCB8CWGU.LARGE.jpg"], "step_title": "Step 18: Simulating"}, {"step": 19, "steps_text": "\n\t\tRight click the input on the left hand column.\n\t\tScroll down to Value and over to Count value or some other value(Like Clock).\n\t\tShown is \"count value.\" I will use Hex for this purpose\n\t\tThis brings up a pop-up with option for how much to count by and when to count by.\u00a0 (Change time and value)\n\t\tDo the same thing for the \"B\" data stream.\n\t\tNo highlight a few clock cycles and you can manually change them by right clicking on the highlighted area and selecting the value.\u00a0\n\t\tNotice in this last picture that the two data stream are now no longer equal.\u00a0\n\t\tAnd the result is a low where the two data streams do not match up.\u00a0", "step_imgs": ["https://cdn.instructables.com/FMO/WXAL/HCB8IMD7/FMOWXALHCB8IMD7.LARGE.jpg", "https://cdn.instructables.com/F9D/600Y/HCB8U7EE/F9D600YHCB8U7EE.LARGE.jpg", "https://cdn.instructables.com/FFB/QZRF/HCB8TO1W/FFBQZRFHCB8TO1W.LARGE.jpg", "https://cdn.instructables.com/FP9/SQHS/HCB8TO1V/FP9SQHSHCB8TO1V.LARGE.jpg", "https://cdn.instructables.com/FLJ/P1QM/HCB8L7UR/FLJP1QMHCB8L7UR.LARGE.jpg", "https://cdn.instructables.com/F0D/QYXY/HCB8REEN/F0DQYXYHCB8REEN.LARGE.jpg", "https://cdn.instructables.com/FTH/MJZ2/HCB8REE6/FTHMJZ2HCB8REE6.LARGE.jpg", "https://cdn.instructables.com/F91/38E2/HCB8U7EY/F9138E2HCB8U7EY.LARGE.jpg"], "step_title": "Step 19: Changing the Input of the Circuit."}, {"step": 20, "steps_text": "\n          We have now created and function circuit with virtual gates and now we want to see it in real life.\u00a0\n\n\t\tFirst thing is to assign to the pins on the Alterra board that we are going to use.\u00a0 For this example we need 8 input pins and one output indicator. The DOC attached to this step has the Alterra pin assignments.\u00a0", "step_imgs": ["https://cdn.instructables.com/FCY/AWBM/HCB8F2OU/FCYAWBMHCB8F2OU.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 20: Download to Board"}, {"step": 21, "steps_text": "Go to the Assignments tab and down to Pin Planner.\nThis brings up a new window.\u00a0 Go ahead and maximize it.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FW0/1XMR/HCB8U7H2/FW01XMRHCB8U7H2.LARGE.jpg", "https://cdn.instructables.com/F3M/ZNXI/HCB8REO3/F3MZNXIHCB8REO3.LARGE.jpg", "https://cdn.instructables.com/FD0/TQJZ/HCB883H1/FD0TQJZHCB883H1.LARGE.jpg"], "step_title": "Step 21: Pin Planner"}, {"step": 22, "steps_text": "In this pin assignment window, you can select the individual pins by clicking in the location field and typing or searching for the correct pins.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FLN/4246/HCJODIEP/FLN4246HCJODIEP.LARGE.jpg", "https://cdn.instructables.com/F0C/TNVE/HCJNWL54/F0CTNVEHCJNWL54.LARGE.jpg"], "step_title": "Step 22: Pin Planner 2"}, {"step": 23, "steps_text": "This last step is the easy one.\u00a0\nGo to TOOLS and down to Programmer.\nThis will bring up a new window;\u00a0 check to make sure it says Blaster and click Start.\u00a0\nCongrats you're Done.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FQE/55Q9/HCRVR3SW/FQE55Q9HCRVR3SW.LARGE.jpg", "https://cdn.instructables.com/F2X/5RL4/HCJNWL5E/F2X5RL4HCJNWL5E.LARGE.jpg"], "step_title": "Step 23: Get It on the Board"}], "channel": "Software"}, {"category": "technology", "description": "This is a step by step walk through of how to set-up and use Quartus software and upload it to the Altera Cyclone FPGA. \u00a0Done as a primer for my school's(Ivy Tech CC) Digital Fundementals EECT122 course. \u00a0This will cover in great detail the exact method to setup the software, your design and upload it to the FPGA(Field Programmable Gate Array) board. \u00a0", "title": "The Altera FPGA and Quartus II Software", "url": "https://www.instructables.com/id/The-Altera-FPGA-and-Quartus-II-software/", "section": "technology", "steps": [{"step": 1, "steps_text": "Double click the Quartus Icon on the desktop. \u00a0", "step_imgs": ["https://cdn.instructables.com/FKW/84SN/H8CVFPEF/FKW84SNH8CVFPEF.LARGE.jpg"], "step_title": "Step 1: Open Quartus"}, {"step": 2, "steps_text": "Once Quartus opens you will see this screen. \u00a0Go to the New Project Wizard located in the File tab. \u00a0\nCreate a parent folder on your flash drive. \u00a0 You want this on your flash drive because anything saved on the colleges hard-drives may not be there next class. \u00a0\nCreate a parent folder where you want to keep all of your Labs! \u00a0i.e. \u00a0G:\\Joe_Schmo_jumpdrive\\EECT122\\Next:\nCreate a child folder this particular lab will be stored. \u00a0i.e. \u00a0G:\\Joe_Schmo\\EECT122\\Lab_1-1\\\n\u00a0You can do this either in windows explorer or directly in the program Quartus.\u00a0IMPORTANT!!!!:\nVERY IMPORTANT!!!!!!!!!:\nFor quartus to work right, your build files(.bdf/.vhd/.etc) need to be in a folder(your child folder) that has the same name as the projects. \u00a0\u00a0", "step_imgs": ["https://cdn.instructables.com/FAH/RWTI/H8CVFPEV/FAHRWTIH8CVFPEV.LARGE.jpg", "https://cdn.instructables.com/FNP/MAXD/H8CVFPF9/FNPMAXDH8CVFPF9.LARGE.jpg"], "step_title": "Step 2: Folders"}, {"step": 3, "steps_text": "Wizards are great aren't they? \u00a0This one guides you through the initial setup of your project. \u00a0After selecting the appropriate name of your parent folder and creating an appropriate child folder, it's time to name your project. \u00a0You want to call it \"I rock Ivy Tech EE\" I know. \u00a0But if you do that and it doesn't match the child folder you've create, the software will get really confuses later on. \u00a0Just name your project the EXACT same thing as the child folder. \u00a0In the picture below it is \"tutorial.\" \u00a0And so EVERY different type of file in this project will get named \"tutorial.\" \u00a0\ntutorial.bdf\ntutorial.vdl\nturorial.etc\nAfter that's done, click next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FE9/RL8D/H8CVFPFV/FE9RL8DH8CVFPFV.LARGE.jpg"], "step_title": "Step 3: New Project Wizard"}, {"step": 4, "steps_text": "Do you want to add files. \u00a0Well for our purposes NO. \u00a0Click next without hitting anything. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB7/BRVM/H8CVFPG5/FB7BRVMH8CVFPG5.LARGE.jpg"], "step_title": "Step 4: Add Files"}, {"step": 5, "steps_text": "In this class we are using the Cyclone II\u00a0EP2C20F484C7.", "step_imgs": ["https://cdn.instructables.com/FQB/FTAD/H8CVFPGT/FQBFTADH8CVFPGT.LARGE.jpg", "https://cdn.instructables.com/F1F/3FXP/H8CVFPGU/F1F3FXPH8CVFPGU.LARGE.jpg"], "step_title": "Step 5: Select the Right Board"}, {"step": 6, "steps_text": "You don't need any tools. \u00a0Hit next. \u00a0", "step_imgs": ["https://cdn.instructables.com/FPI/C7FF/H8CVFPH7/FPIC7FFH8CVFPH7.LARGE.jpg"], "step_title": "Step 6: EDA Tools?"}, {"step": 7, "steps_text": "Everything look right?\u00a0\nWell hit finish and lets get started programming a FPGA. \u00a0", "step_imgs": ["https://cdn.instructables.com/F3W/KF8M/H8CVFPHE/F3WKF8MH8CVFPHE.LARGE.jpg"], "step_title": "Step 7: Finish Your Set Up"}, {"step": 8, "steps_text": "We will now begin to enter gates and create a schematic \"program\" to be executed on the hardware\u00a0development\u00a0board. \u00a0\nGo to the\u00a0FILE\u00a0tab and hit New.\u00a0 Here you will have the option to create many different types of files. \u00a0 For this tutorial we will be creating a Block Diagram/Schematic File.", "step_imgs": ["https://cdn.instructables.com/FQ0/2DCU/HCB8CRRW/FQ02DCUHCB8CRRW.LARGE.jpg", "https://cdn.instructables.com/FC2/5C7S/HCB8CRFI/FC25C7SHCB8CRFI.LARGE.jpg", "https://cdn.instructables.com/F6E/LG63/HCB8CRFS/F6ELG63HCB8CRFS.LARGE.jpg"], "step_title": "Step 8: Block Diagram/ Schematic"}, {"step": 9, "steps_text": "It is highly recommended that you save the file at this time. \u00a0 Remember, this file name \" *.bdf \" must be the same name as the folder that was created earlier on. \u00a0Steps 1 though 8 go about created other files that are needed for everything to work properly and if this \".DBF\" (Diagram-Block) file does not live in that same folder, it won't work right.\nSo for this example I saved it as \"G:\\tutorial.bdf", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg"], "step_title": "Step 9: Save the File"}, {"step": 10, "steps_text": "Now the fun part begins. \u00a0 This is where we create the schematic. \u00a0 On the left of this new window are various tools you can use to add logic gates and other parts to complete your project. \u00a0You are able to turns wires into buses, add text, zoom in and out, and many other things through the buttons on the left. \u00a0\nThe third picture in this series shows a diagram of a 4 bit comparator that was created rather quickly. \u00a0", "step_imgs": ["https://cdn.instructables.com/FB2/UL4S/HCB8CRGC/FB2UL4SHCB8CRGC.LARGE.jpg", "https://cdn.instructables.com/FOA/0JLY/HCB8CRGD/FOA0JLYHCB8CRGD.LARGE.jpg", "https://cdn.instructables.com/FJW/TGRK/HCB8CRGE/FJWTGRKHCB8CRGE.LARGE.jpg"], "step_title": "Step 10: Create a Schematic"}, {"step": 11, "steps_text": "Just like written code, schematic diagrams must be compiled into machine code for it to be used. \u00a0 Also like writing programming language, this is where you get error and must debug things. \u00a0The error messages provided by Quartus tend to be much more useful than other messages from IDE compilers. \u00a0\nUp at the top tool bar,\u00a0 the button that looks like play button will start the compilation.\nYou can also navigate to the \"Processing Tab\" and hit \"Start Compilation\".", "step_imgs": ["https://cdn.instructables.com/FVT/XKAL/HCB8CRH7/FVTXKALHCB8CRH7.LARGE.jpg", "https://cdn.instructables.com/FWF/N9HQ/HCB8CRH8/FWFN9HQHCB8CRH8.LARGE.jpg"], "step_title": "Step 11: Start Compilation"}, {"step": 12, "steps_text": "If you are successful your screen will look similar to image 2. \u00a0\nYou must save the compiled BDF before proceeding to create a Vector Waveform. \u00a0", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FCB/55SG/HCB8CRJ8/FCB55SGHCB8CRJ8.LARGE.jpg"], "step_title": "Step 12: Save"}, {"step": 13, "steps_text": "So you've wired some virtual chips together and it works. \u00a0Now it's time to see what the output actually is and determine if it's what was expected. \u00a0To do that we are going to use a Vector Waveform file.\u00a0\nUnder the File tab, \u00a0select New,\u00a0and then\u00a0Vector Waveform file.\nThis screen should look familiar, it is the same place where we created the Block Diagram file.", "step_imgs": ["https://cdn.instructables.com/FRC/JNHU/HCB8CRM7/FRCJNHUHCB8CRM7.LARGE.jpg", "https://cdn.instructables.com/FKR/YN1J/HCB8CRM4/FKRYN1JHCB8CRM4.LARGE.jpg", "https://cdn.instructables.com/FG4/78CR/HCB8CRO9/FG478CRHCB8CRO9.LARGE.jpg"], "step_title": "Step 13: Vector Waveforms"}, {"step": 14, "steps_text": "Once\u00a0again, \u00a0Immediately\u00a0after creating the new vector waveform file, \u00a0Re-save it with the SAME name as the parent folder. \u00a0\nSo for this tutorial it is saved as \"G:\\Joe_Schmo\\EECT122\\Lab_1-1\\tutorial\\tutorial.VCF\"", "step_imgs": ["https://cdn.instructables.com/FVJ/SU9H/HCB8CRHQ/FVJSU9HHCB8CRHQ.LARGE.jpg", "https://cdn.instructables.com/FRU/QLMT/HCB8CROS/FRUQLMTHCB8CROS.LARGE.jpg"], "step_title": "Step 14: SAVE"}, {"step": 15, "steps_text": "Typically, this window pops up with a total time to analyse the output of your circuit of 20 nanoseconds. \u00a0That is a little short on time. \u00a0We will change this by navigating to the Edit tab, and selecting End Time.\nIn this class, 16 micro-seconds will be a nice time frame to work with. \u00a0Some labs might specify a different time, this is where you change that. \u00a0", "step_imgs": ["https://cdn.instructables.com/FES/YV1V/HCB8CRPH/FESYV1VHCB8CRPH.LARGE.jpg", "https://cdn.instructables.com/FMG/77OD/HCB8CRPI/FMG77ODHCB8CRPI.LARGE.jpg"], "step_title": "Step 15: Setting Up the Waveform File-End Time"}, {"step": 16, "steps_text": "The grid size doesn't automatically change. \u00a0So want to change it. \u00a0 Under the Edit tab, click Grid Size.\u00a0\nInside the dialogue window, edit the boxes and double check that you have selected the right scale(nano, micro, milli).\u00a0\nAfter the settings are correct, \u00a0Use the keyboard shortcut and press CTRL W to view the entire timeline. \u00a0It should look like picture 3. \u00a0", "step_imgs": ["https://cdn.instructables.com/F0G/HX5G/HCB8CRQ6/F0GHX5GHCB8CRQ6.LARGE.jpg", "https://cdn.instructables.com/FAC/EY6R/HCB8CRQ7/FACEY6RHCB8CRQ7.LARGE.jpg"], "step_title": "Step 16: Setting Up the Waveform File-Edit Grid Size"}, {"step": 17, "steps_text": "Now that the vector file is configured properly we need to import or link to the inputs and outputs created in our Schematic file. \u00a0\nRight click on the left panel. \u00a0Scroll down to INSERT and over to INSERT NODE OR BUS.\nThis will bring up a new window with several options. \u00a0Underneath the cancel button, is a button called NODE FINDER. \u00a0Press that button and leave the other options alone. \u00a0\nThis brings up a new window called NODE FINDER. \u00a0\n----At the top middle, scroll down and select \"Pins: All\" \u00a0\n----next, over to the right is a button that says list. \u00a0It searches for the pins in your schematic. \u00a0Hit that button.\n----Once pins are in the left tab, we need to select them. \u00a0This can be done individually if needed with the single arrow button, \u00a0or all pins at once with the double arrow button. \u00a0\n-----Lastly, Click OK in the \"Node Finder\" window and also OK in the \"Insert Node or Bus\" window.", "step_imgs": ["https://cdn.instructables.com/FL8/63GB/HCB8CRQP/FL863GBHCB8CRQP.LARGE.jpg", "https://cdn.instructables.com/FKM/CEQY/HCB8CRQQ/FKMCEQYHCB8CRQQ.LARGE.jpg", "https://cdn.instructables.com/FC4/NJ18/HCB8CRQR/FC4NJ18HCB8CRQR.LARGE.jpg", "https://cdn.instructables.com/FWK/ZH6J/HCB8CRQS/FWKZH6JHCB8CRQS.LARGE.jpg", "https://cdn.instructables.com/FAD/X7ZA/HCB8CRQT/FADX7ZAHCB8CRQT.LARGE.jpg", "https://cdn.instructables.com/FOD/1EU2/HCB8CRQU/FOD1EU2HCB8CRQU.LARGE.jpg"], "step_title": "Step 17: Add Inputs and Outputs"}, {"step": 18, "steps_text": "This simulation will run your circuit and easily allow you to change the inputs.\u00a0 This was our whole goal.\nThe first two pictures show my comparator circuit will no inputs.\u00a0 Both data streams here A and B have no data, thus they are equal and the \"W\" output goes high.\u00a0\nThe next few pictures will show how to change the input and what happens to the output \"W\" when the two data streams are not equal.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/F4C/FG76/HCB8L7UF/F4CFG76HCB8L7UF.LARGE.jpg", "https://cdn.instructables.com/FO2/JCVU/HCB8CWGU/FO2JCVUHCB8CWGU.LARGE.jpg"], "step_title": "Step 18: Simulating"}, {"step": 19, "steps_text": "\n\t\tRight click the input on the left hand column.\n\t\tScroll down to Value and over to Count value or some other value(Like Clock).\n\t\tShown is \"count value.\" I will use Hex for this purpose\n\t\tThis brings up a pop-up with option for how much to count by and when to count by.\u00a0 (Change time and value)\n\t\tDo the same thing for the \"B\" data stream.\n\t\tNo highlight a few clock cycles and you can manually change them by right clicking on the highlighted area and selecting the value.\u00a0\n\t\tNotice in this last picture that the two data stream are now no longer equal.\u00a0\n\t\tAnd the result is a low where the two data streams do not match up.\u00a0", "step_imgs": ["https://cdn.instructables.com/FMO/WXAL/HCB8IMD7/FMOWXALHCB8IMD7.LARGE.jpg", "https://cdn.instructables.com/F9D/600Y/HCB8U7EE/F9D600YHCB8U7EE.LARGE.jpg", "https://cdn.instructables.com/FFB/QZRF/HCB8TO1W/FFBQZRFHCB8TO1W.LARGE.jpg", "https://cdn.instructables.com/FP9/SQHS/HCB8TO1V/FP9SQHSHCB8TO1V.LARGE.jpg", "https://cdn.instructables.com/FLJ/P1QM/HCB8L7UR/FLJP1QMHCB8L7UR.LARGE.jpg", "https://cdn.instructables.com/F0D/QYXY/HCB8REEN/F0DQYXYHCB8REEN.LARGE.jpg", "https://cdn.instructables.com/FTH/MJZ2/HCB8REE6/FTHMJZ2HCB8REE6.LARGE.jpg", "https://cdn.instructables.com/F91/38E2/HCB8U7EY/F9138E2HCB8U7EY.LARGE.jpg"], "step_title": "Step 19: Changing the Input of the Circuit."}, {"step": 20, "steps_text": "\n          We have now created and function circuit with virtual gates and now we want to see it in real life.\u00a0\n\n\t\tFirst thing is to assign to the pins on the Alterra board that we are going to use.\u00a0 For this example we need 8 input pins and one output indicator. The DOC attached to this step has the Alterra pin assignments.\u00a0", "step_imgs": ["https://cdn.instructables.com/FCY/AWBM/HCB8F2OU/FCYAWBMHCB8F2OU.LARGE.jpg", "/assets/img/pixel.png"], "step_title": "Step 20: Download to Board"}, {"step": 21, "steps_text": "Go to the Assignments tab and down to Pin Planner.\nThis brings up a new window.\u00a0 Go ahead and maximize it.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FW0/1XMR/HCB8U7H2/FW01XMRHCB8U7H2.LARGE.jpg", "https://cdn.instructables.com/F3M/ZNXI/HCB8REO3/F3MZNXIHCB8REO3.LARGE.jpg", "https://cdn.instructables.com/FD0/TQJZ/HCB883H1/FD0TQJZHCB883H1.LARGE.jpg"], "step_title": "Step 21: Pin Planner"}, {"step": 22, "steps_text": "In this pin assignment window, you can select the individual pins by clicking in the location field and typing or searching for the correct pins.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FLN/4246/HCJODIEP/FLN4246HCJODIEP.LARGE.jpg", "https://cdn.instructables.com/F0C/TNVE/HCJNWL54/F0CTNVEHCJNWL54.LARGE.jpg"], "step_title": "Step 22: Pin Planner 2"}, {"step": 23, "steps_text": "This last step is the easy one.\u00a0\nGo to TOOLS and down to Programmer.\nThis will bring up a new window;\u00a0 check to make sure it says Blaster and click Start.\u00a0\nCongrats you're Done.\u00a0 ", "step_imgs": ["https://cdn.instructables.com/FQE/55Q9/HCRVR3SW/FQE55Q9HCRVR3SW.LARGE.jpg", "https://cdn.instructables.com/F2X/5RL4/HCJNWL5E/F2X5RL4HCJNWL5E.LARGE.jpg"], "step_title": "Step 23: Get It on the Board"}], "channel": "Software"}, {"category": "technology", "description": "This digital sine wave keyboard synthesizer will take user inputs via a series of momentary switches laid out like a keyboard and output an audio wave through a speaker. Based on user inputs, the device will generate sine waves of various frequencies from C4 to C6. The user can input notes from C4 up to C6 (25 notes total), and up to four keys at the same time -- if more than four keys are pressed, the four lowest tones will be played.This project was done by Ryan Morris and Mavis Tsoi for our Cal Poly CPE 133 Digital Design class :)", "title": "Basys3 FPGA Digital Audio Synthesizer", "url": "https://www.instructables.com/id/Basys3-FPGA-Digital-Audio-Synthesizer/", "section": "technology", "steps": [{"step": 1, "steps_text": "An FPGA board can only output digital signals. In other words, it can only produce a high (3.3V) voltage or a low (0V) voltage. However, audio signals are analog and can have infinitely many increments in voltage. To get around this, we will use a PWM (pulse width modulation) signal to emulate an analog wave. If you don\u2019t know what PWM is, check this out: https://learn.sparkfun.com/tutorials/pulse-width-modulation.", "step_imgs": [], "step_title": "Step 1: Theory"}, {"step": 2, "steps_text": "Computer with Vivado installed  We will be using Vivado version 2017.2   Basys3 FPGA Board   25 SPDT Limit Switches (we used these)30 jumper wires (one end male, other end doesn\u2019t matter), 12 inchWire cutters Wire strippers Spare wire for soldering   Resin-core Solder   Soldering iron\u00bc\u201d female audio jack   Amplifier/speaker   Something to mount the switches on (we used protoboard + wooden box)", "step_imgs": [], "step_title": "Step 2: Ingredients & Tools"}, {"step": 3, "steps_text": "System ArchitectureSee Figure 1: 25 available inputs \u2192 Basys3 Board \u2192 amplifier & speaker.OutputSee Figure 2: Basys3 Board \u2192 1/2\" Female Audio Jack \u2192 Speaker (with Amplifier)InputThe pmod connections on the Basys3 board must be connected to ground in order to see a low input and will not function properly if left as an open circuit. Because of this, we have to use SPDT switches for all of our note keys. An SPDT switch basically allows the user to switch between circuits when pressed, so we will use them as our \u201cbuttons\u201d to input low (0V) or high (3.3V) signals to the Basys3 board. Each switch will have the NO (normally opened) terminal connected to 3.3V, NC (normally closed) terminal connected to GND, and COM (common) terminal connected to the FPGA input. See Figure 3.Because we have 25 limit switches, they will all share a common 3.3V line and a common GND line. Then, the signal line from each limit switch will be bundled up in groups of 8 and hooked up to the pmod connections on the Basys3 board using zippable jumper wires to minimize the monumental mess we\u2019ll make. See Figure 4 or an example of the first eight keys.", "step_imgs": ["https://cdn.instructables.com/F9I/1BS9/JAMTQKO0/F9I1BS9JAMTQKO0.LARGE.jpg", "https://cdn.instructables.com/FL8/GH72/JAMTQKO1/FL8GH72JAMTQKO1.LARGE.jpg", "https://cdn.instructables.com/F2F/94Q1/JAMTQKNZ/F2F94Q1JAMTQKNZ.LARGE.jpg", "https://cdn.instructables.com/FFH/1EX3/JAMTQKP8/FFH1EX3JAMTQKP8.LARGE.jpg", "https://cdn.instructables.com/FFD/2HJF/JAMTQLDI/FFD2HJFJAMTQLDI.LARGE.jpg", "https://cdn.instructables.com/F68/WYUJ/JAMTQLDH/F68WYUJJAMTQLDH.LARGE.jpg", "https://cdn.instructables.com/FRN/UNDK/JAMTQLDD/FRNUNDKJAMTQLDD.LARGE.jpg", "https://cdn.instructables.com/F1G/2NIU/JAMTWIZY/F1G2NIUJAMTWIZY.LARGE.jpg"], "step_title": "Step 3: Wiring & Hardware Setup"}, {"step": 4, "steps_text": "The sine wave generator and PWM generator were first tested to make sure our concept worked, then the input limiter and amplitude adder/shifter were integrated. Details of the function and I/O of each process block is as shown in the Figure. The code is shown below, but also attached as VHD and txt files. If there are discrepancies, go with the VHD files.BTW: we probably should've made our lines shorter but code embedding on Instructables also turned out to be quite annoying to deal with, so the spacing isn't the greatest and there's no syntax highlighting. If you have Vivado and would like to follow along the code, we highly recommend you to just download the file.First, let's look at the Sine Wave Generator module. library IEEE;<br>use IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.NUMERIC_STD.ALL;\nentity Wave_Generator is\n    Port ( Trigger : in STD_LOGIC;                       -- Key press\n          Freq_Cnt : in STD_LOGIC_VECTOR(15 downto 0);   -- Counter value = 100MHz / (Note Frequency*64 Divisions of Sine Wave) (round to nearest num)\n                                                            -- renamed from Freq\n        wavegenCLK : in STD_LOGIC;                       -- Basys3 100MHz CLK\n           WaveOut : out STD_LOGIC_VECTOR(9 downto 0));  -- Signed amplitude of wave\nend Wave_Generator;\narchitecture Behavioral of Wave_Generator is\n    signal i : integer range 0 to 64 := 0;                           -- index of amplitude memory bank\n    type memory_type is array (0 to 63) of integer range -64 to 63;  -- create memory bank (ROM) to hold amplitude values\n                                                                      -- is this RAM or ROM just wondering...\n    signal amplitude : memory_type := ( 0,  7, 13, 19, 25, 30, 35, 40, 45, 49, 52, 55, 58, 60, 62, 63, \n                                       63, 63, 62, 60, 58, 55, 52, 49, 45, 40, 35, 30, 25, 19, 13,  7, \n                                        0, -7,-13,-19,-25,-30,-35,-40,-45,-49,-52,-55,-58,-60,-62,-63,  \n                                      -63,-63,-62,-60,-58,-55,-52,-49,-45,-40,-35,-30,-25,-19,-13, -7); -- amplitude memory bank for sine wave\nbegin\n    process (wavegenCLK, Trigger)\n        variable counter : unsigned (15 downto 0) := to_unsigned(0, 16); -- clock divider counter, renamed from count1\n    begin\n        if (rising_edge(wavegenCLK)) then\n            if (Trigger = '1') then -- key is pressed\n                counter := counter + 1;\n                if (counter = unsigned(Freq_Cnt)) then  -- Freq_Cnt = 100Mhz / (note freq * 64 divisions of the sine wave)   \n                    -- reset counter and assign amplitude data to output\n                    counter := to_unsigned(0, 16);\n                    WaveOut <= STD_LOGIC_VECTOR (to_signed(amplitude(i), 10));\n                    -- increment i for next reading\n                    i <= i + 1;\n                    -- reset i if one sine wave has been completed\n                    if(i = 63) then\n                        i <= 0;\n                    end if;\n                end if; -- (counter = unsigned(Freq_Cnt))\n            else -- key is not pressed\n                -- reset output, amplitude index, and counter\n                WaveOut <= \"0000000000\";\n                i <= 0;\n                counter := to_unsigned(0, 16); --output Amplitude = -64 when no note is played\n            end if; -- (Trigger = '1')\n        end if; -- (rising_edge(CLK))\n    end process;\nend Behavioral;\nWe will generate a digital sine wave in the Basys3 by using the internal clock and a ROM. This ROM will store 64 values that represent 64 amplitudes on a sine wave. See Figure 1. The 64 values we use emulate a sine wave with pretty good resolution.Using the internal clock, we count to a value that represents the clock speed divided by the frequency of the wave we want and 64: Clk div = 100MHz / (Freq * 64) Every time our counter reaches that value, we call a number from the ROM and send that out of our wave generator module. The frequency of our wave will depend on how fast we call these amplitudes.We will have 25 sub-modules, each associated with one frequency/note.Here's the remaining of the code that calls the Sine Wave Generator modules:library IEEE;<br>use IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.NUMERIC_STD.ALL;\n\n\nentity Two_Octave_Synth is\n    Port ( CLK : in STD_LOGIC; \n           O4 : in STD_LOGIC_VECTOR(11 downto 0);\n           O5 : in STD_LOGIC_VECTOR(12 downto 0);\n           output : out STD_LOGIC);\nend Two_Octave_Synth;\n\n\narchitecture Behavioral of Two_Octave_Synth is\n    component Wave_Generator is\n        Port ( Trigger : in STD_LOGIC;\n           Freq_Cnt : in STD_LOGIC_VECTOR(15 downto 0);\n           wavegenCLK : in STD_LOGIC;\n           WaveOut : out STD_LOGIC_VECTOR(9 downto 0));\n    end component;\n\n\n---------------------------output signals from wave generator-----------------------\n    signal WaveC4, WaveCs4, WaveD4, WaveDs4, WaveE4, WaveF4, WaveFs4, WaveG4, WaveGs4, WaveA4, WaveAs4, WaveB4, \n           WaveC5, WaveCs5, WaveD5, WaveDs5, WaveE5, WaveF5, WaveFs5, WaveG5, WaveGs5, WaveA5, WaveAs5, WaveB5, WaveC6  : signed(9 downto 0);\n\n\n--------------------------------for note selection logic--------------------\n    signal C4, Cs4, D4, Ds4, E4, F4, Fs4, G4, Gs4, A4, As4, B4, C5, Cs5, D5, Ds5, E5, F5, Fs5, G5, Gs5, A5, As5, B5, C6 : unsigned(4 downto 0);\n    signal cntC4, cntCs4, cntD4, cntDs4, cntE4, cntF4, cntFs4, cntG4, cntGs4, cntA4, cntAs4, cntB4, cntC5, cntCs5, cntD5, \n           cntDs5, cntE5, cntF5, cntFs5, cntG5, cntGs5, cntA5, cntAs5, cntB5, cntC6 : unsigned(4 downto 0);\n    signal error : STD_LOGIC;\n\n\n-----------------------------------for adding sine waves--------------------------\n    signal Wave0, Wave1, Wave2, Wave3 : signed(9 downto 0); --signals from Wave Generator module output\n    signal WaveSum : STD_LOGIC_VECTOR(9 downto 0); --signal for summed sine waves (2's compliment -512 to 511)\n    signal positiveWaveSum : STD_LOGIC_VECTOR(9 downto 0); --unsigned 0 to 1023, for use in PWM generator\n\n\n-----------------------------------for generating PWM-------------------------------\n    signal ping_length : unsigned (9 downto 0) := unsigned(positiveWaveSum);\n    --signal off_length : unsigned (6 downto 0) := to_unsigned(127, 7) - unsigned(WAVE);\n    signal PWM : unsigned (9 downto 0) := to_unsigned(0, 10);\n\n\nbegin\n    Note_C4  : Wave_Generator port map (Trigger => O4(0), Freq_Cnt => X\"1755\", wavegenCLK => CLK, signed(WaveOut) => WaveC4); --5973, 261.63 Hz\n    Note_Cs4 : Wave_Generator port map (Trigger => O4(1), Freq_Cnt => X\"1606\", wavegenCLK => CLK, signed(WaveOut) => WaveCs4);--5638, 277.18 Hz\n    Note_D4  : Wave_Generator port map (Trigger => O4(2), Freq_Cnt => X\"14C9\", wavegenCLK => CLK, signed(WaveOut) => WaveD4); --5321, 293.66 Hz\n    Note_Ds4 : Wave_Generator port map (Trigger => O4(3), Freq_Cnt => X\"139F\", wavegenCLK => CLK, signed(WaveOut) => WaveDs4);--5023, 311.13 Hz\n    Note_E4  : Wave_Generator port map (Trigger => O4(4), Freq_Cnt => X\"1285\", wavegenCLK => CLK, signed(WaveOut) => WaveE4); --4741, 329.63 Hz\n    Note_F4  : Wave_Generator port map (Trigger => O4(5), Freq_Cnt => X\"117B\", wavegenCLK => CLK, signed(WaveOut) => WaveF4); --4475, 349.23 Hz\n    Note_Fs4 : Wave_Generator port map (Trigger => O4(6), Freq_Cnt => X\"1080\", wavegenCLK => CLK, signed(WaveOut) => WaveFs4);--4224, 369.99 Hz\n    Note_G4  : Wave_Generator port map (Trigger => O4(7), Freq_Cnt => X\"0F92\", wavegenCLK => CLK, signed(WaveOut) => WaveG4); --3986, 392.00 Hz\n    Note_Gs4 : Wave_Generator port map (Trigger => O4(8), Freq_Cnt => X\"0EB3\", wavegenCLK => CLK, signed(WaveOut) => WaveGs4);--3763, 415.30 Hz\n    Note_A4  : Wave_Generator port map (Trigger => O4(9), Freq_Cnt => X\"0DE0\", wavegenCLK => CLK, signed(WaveOut) => WaveA4); --3552, 440.00 Hz\n    Note_As4 : Wave_Generator port map (Trigger => O4(10),Freq_Cnt => X\"0D18\", wavegenCLK => CLK, signed(WaveOut) => WaveAs4);--3352, 466.16 Hz\n    Note_B4  : Wave_Generator port map (Trigger => O4(11),Freq_Cnt => X\"0C5C\", wavegenCLK => CLK, signed(WaveOut) => WaveB4); --3164, 493.88 Hz\n-------------------------------------------------------------------------------------------------------------------------                                                                  \n    Note_C5  : Wave_Generator port map (Trigger => O5(0), Freq_Cnt => X\"0BAB\", wavegenCLK => CLK, signed(WaveOut) => WaveC5); --2987, 523.25 Hz\n    Note_Cs5 : Wave_Generator port map (Trigger => O5(1), Freq_Cnt => X\"0B03\", wavegenCLK => CLK, signed(WaveOut) => WaveCs5);--2819, 554.37 Hz\n    Note_D5  : Wave_Generator port map (Trigger => O5(2), Freq_Cnt => X\"0A65\", wavegenCLK => CLK, signed(WaveOut) => WaveD5); --2661, 587.33 Hz\n    Note_Ds5 : Wave_Generator port map (Trigger => O5(3), Freq_Cnt => X\"09D0\", wavegenCLK => CLK, signed(WaveOut) => WaveDs5);--2512, 622.25 Hz\n    Note_E5  : Wave_Generator port map (Trigger => O5(4), Freq_Cnt => X\"0943\", wavegenCLK => CLK, signed(WaveOut) => WaveE5); --2371, 659.25 Hz\n    Note_F5  : Wave_Generator port map (Trigger => O5(5), Freq_Cnt => X\"08Be\", wavegenCLK => CLK, signed(WaveOut) => WaveF5); --2238, 698.46 Hz\n    Note_Fs5 : Wave_Generator port map (Trigger => O5(6), Freq_Cnt => X\"0840\", wavegenCLK => CLK, signed(WaveOut) => WaveFs5);--2112, 739.99 Hz\n    Note_G5  : Wave_Generator port map (Trigger => O5(7), Freq_Cnt => X\"07CA\", wavegenCLK => CLK, signed(WaveOut) => WaveG5); --1994, 783.99 Hz\n    Note_Gs5 : Wave_Generator port map (Trigger => O5(8), Freq_Cnt => X\"075A\", wavegenCLK => CLK, signed(WaveOut) => WaveGs5);--1882, 830.61 Hz\n    Note_A5  : Wave_Generator port map (Trigger => O5(9), Freq_Cnt => X\"06F0\", wavegenCLK => CLK, signed(WaveOut) => WaveA5); --1776, 880.00 Hz\n    Note_As5 : Wave_Generator port map (Trigger => O5(10),Freq_Cnt => X\"068C\", wavegenCLK => CLK, signed(WaveOut) => WaveAs5);--1676, 932.33 Hz\n    Note_B5  : Wave_Generator port map (Trigger => O5(11),Freq_Cnt => X\"062E\", wavegenCLK => CLK, signed(WaveOut) => WaveB5); --1582, 987.77 Hz\n    Note_C6  : Wave_Generator port map (Trigger => O5(12),Freq_Cnt => X\"05D6\", wavegenCLK => CLK, signed(WaveOut) => WaveC6); --1494, 1046.5 Hz\n\n\n------------note selection logic------------\n    C4  <= \"0000\" & O4(0);\n    Cs4 <= \"0000\" & O4(1);\n    D4  <= \"0000\" & O4(2);\n    Ds4 <= \"0000\" & O4(3);\n    E4  <= \"0000\" & O4(4);\n    F4  <= \"0000\" & O4(5);\n    Fs4 <= \"0000\" & O4(6);\n    G4  <= \"0000\" & O4(7);\n    Gs4 <= \"0000\" & O4(8);\n    A4  <= \"0000\" & O4(9);\n    As4 <= \"0000\" & O4(10);\n    B4  <= \"0000\" & O4(11);\n    C5  <= \"0000\" & O5(0);\n    Cs5 <= \"0000\" & O5(1);\n    D5  <= \"0000\" & O5(2);\n    Ds5 <= \"0000\" & O5(3);\n    E5  <= \"0000\" & O5(4);\n    F5  <= \"0000\" & O5(5);\n    Fs5 <= \"0000\" & O5(6);\n    G5  <= \"0000\" & O5(7);\n    Gs5 <= \"0000\" & O5(8);\n    A5  <= \"0000\" & O5(9);\n    As5 <= \"0000\" & O5(10);\n    B5  <= \"0000\" & O5(11);\n    C6  <= \"0000\" & O5(12);  \n    cntC4 <= C4;\n    cntCs4 <= C4 + Cs4;\n    cntD4  <= C4 + Cs4 + D4;\n    cntDs4 <= C4 + Cs4 + D4 + Ds4;\n    cntE4  <= C4 + Cs4 + D4 + Ds4 + E4;\n    cntF4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4;\n    cntFs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4;\n    cntG4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4;\n    cntGs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4;\n    cntA4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4;\n    cntAs4 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4;\n    cntB4  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4;\n    cntC5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5;\n    cntCs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5;\n    cntD5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5;\n    cntDs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5;\n    cntE5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5;\n    cntF5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5;\n    cntFs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5;\n    cntG5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5;\n    cntGs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5;\n    cntA5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5;\n    cntAs5 <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5;\n    cntB5  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5 + B5;\n    cntC6  <= C4 + Cs4 + D4 + Ds4 + E4 + F4 + Fs4 + G4 + Gs4 + A4 + As4 + B4 + C5 + Cs5 + D5 + Ds5 + E5 + F5 + Fs5 + G5 + Gs5 + A5 + As5 + B5 + C6;\n\n\n    Selection : process (WaveC4, WaveCs4, WaveD4, WaveDs4, WaveE4, WaveF4, WaveFs4, WaveG4, WaveGs4, WaveA4, WaveAs4, WaveB4, \n                         WaveC5, WaveCs5, WaveD5, WaveDs5, WaveE5, WaveF5, WaveFs5, WaveG5, WaveGs5, WaveA5, WaveAs5, WaveB5, WaveC6)\n\n\n    begin  \n        if (cntC6 = \"00000\") then ---------------if no signals being generated\n            Wave0 <= \"0000000000\";\n            Wave1 <= \"0000000000\";\n            Wave2 <= \"0000000000\";\n            Wave3 <= \"0000000000\";\n        else\n            if (O4(0) = '1') then -------------------note C4 played\n                Wave0 <= WaveC4;\n            end if;\n            if (O4(1) = '1') then -------------------note Cs5 played\n                case(cntCs4) is\n                    when \"00001\" => Wave0 <= WaveCs4;\n                    when \"00010\" => Wave1 <= WaveCs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(2) = '1') then--------------------note D4 played\n                case(cntD4) is\n                    when \"00001\" => Wave0 <= WaveD4;\n                    when \"00010\" => Wave1 <= WaveD4;\n                    when \"00011\" => Wave2 <= WaveD4;\n                    when others => error <= '1';\n                end case;\n            end if;\n-------------------------------------------------------------------------------------------------------------------------\n            if (O4(3) = '1') then--------------------note Ds4 played\n                case(cntDs4) is\n                    when \"00001\" => Wave0 <= WaveDs4;\n                    when \"00010\" => Wave1 <= WaveDs4;\n                    when \"00011\" => Wave2 <= WaveDs4;\n                    when \"00100\" => Wave3 <= WaveDs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(4) = '1') then--------------------note E4 played\n                case(cntE4) is\n                    when \"00001\" => Wave0 <= WaveE4;\n                    when \"00010\" => Wave1 <= WaveE4;\n                    when \"00011\" => Wave2 <= WaveE4;\n                    when \"00100\" => Wave3 <= WaveE4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(5) = '1') then--------------------note F4 played\n                case(cntF4) is\n                    when \"00001\" => Wave0 <= WaveF4;\n                    when \"00010\" => Wave1 <= WaveF4;\n                    when \"00011\" => Wave2 <= WaveF4;\n                    when \"00100\" => Wave3 <= WaveF4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(6) = '1') then--------------------note Fs4 played\n                case(cntFs4) is\n                    when \"00001\" => Wave0 <= WaveFs4;\n                    when \"00010\" => Wave1 <= WaveFs4;\n                    when \"00011\" => Wave2 <= WaveFs4;\n                    when \"00100\" => Wave3 <= WaveFs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(7) = '1') then--------------------note G4 played\n                case(cntG4) is\n                    when \"00001\" => Wave0 <= WaveG4;\n                    when \"00010\" => Wave1 <= WaveG4;\n                    when \"00011\" => Wave2 <= WaveG4;\n                    when \"00100\" => Wave3 <= WaveG4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(8) = '1') then--------------------note Gs4 played\n                case(cntGs4) is\n                    when \"00001\" => Wave0 <= WaveGs4;\n                    when \"00010\" => Wave1 <= WaveGs4;\n                    when \"00011\" => Wave2 <= WaveGs4;\n                    when \"00100\" => Wave3 <= WaveGs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(9) = '1') then--------------------note A4 played\n                case(cntA4) is\n                    when \"00001\" => Wave0 <= WaveA4;\n                    when \"00010\" => Wave1 <= WaveA4;\n                    when \"00011\" => Wave2 <= WaveA4;\n                    when \"00100\" => Wave3 <= WaveA4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(10) = '1') then--------------------note As4 played\n                case(cntAs4) is\n                    when \"00001\" => Wave0 <= WaveAs4;\n                    when \"00010\" => Wave1 <= WaveAs4;\n                    when \"00011\" => Wave2 <= WaveAs4;\n                    when \"00100\" => Wave3 <= WaveAs4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O4(11) = '1') then--------------------note B4 played\n                case(cntB4) is\n                    when \"00001\" => Wave0 <= WaveB4;\n                    when \"00010\" => Wave1 <= WaveB4;\n                    when \"00011\" => Wave2 <= WaveB4;\n                    when \"00100\" => Wave3 <= WaveB4;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(0) = '1') then--------------------note C5 played\n                case(cntC5) is\n                    when \"00001\" => Wave0 <= WaveC5;\n                    when \"00010\" => Wave1 <= WaveC5;\n                    when \"00011\" => Wave2 <= WaveC5;\n                    when \"00100\" => Wave3 <= WaveC5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(1) = '1') then--------------------note Cs5 played\n                case(cntCs5) is\n                    when \"00001\" => Wave0 <= WaveCs5;\n                    when \"00010\" => Wave1 <= WaveCs5;\n                    when \"00011\" => Wave2 <= WaveCs5;\n                    when \"00100\" => Wave3 <= WaveCs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(2) = '1') then--------------------note D5 played\n                case(cntD5) is\n                    when \"00001\" => Wave0 <= WaveD5;\n                    when \"00010\" => Wave1 <= WaveD5;\n                    when \"00011\" => Wave2 <= WaveD5;\n                    when \"00100\" => Wave3 <= WaveD5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(3) = '1') then--------------------note Ds5 played\n                case(cntDs5) is\n                    when \"00001\" => Wave0 <= WaveDs5;\n                    when \"00010\" => Wave1 <= WaveDs5;\n                    when \"00011\" => Wave2 <= WaveDs5;\n                    when \"00100\" => Wave3 <= WaveDs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(4) = '1') then--------------------note E5 played\n                case(cntE5) is\n                    when \"00001\" => Wave0 <= WaveE5;\n                    when \"00010\" => Wave1 <= WaveE5;\n                    when \"00011\" => Wave2 <= WaveE5;\n                    when \"00100\" => Wave3 <= WaveE5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(5) = '1') then--------------------note F5 played\n                case(cntF5) is\n                    when \"00001\" => Wave0 <= WaveF5;\n                    when \"00010\" => Wave1 <= WaveF5;\n                    when \"00011\" => Wave2 <= WaveF5;\n                    when \"00100\" => Wave3 <= WaveF5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(6) = '1') then--------------------note Fs5 played\n                case(cntFs5) is\n                    when \"00001\" => Wave0 <= WaveFs5;\n                    when \"00010\" => Wave1 <= WaveFs5;\n                    when \"00011\" => Wave2 <= WaveFs5;\n                    when \"00100\" => Wave3 <= WaveFs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(7) = '1') then--------------------note G5 played\n                case(cntG5) is\n                    when \"00001\" => Wave0 <= WaveG5;\n                    when \"00010\" => Wave1 <= WaveG5;\n                    when \"00011\" => Wave2 <= WaveG5;\n                    when \"00100\" => Wave3 <= WaveG5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(8) = '1') then--------------------note Gs5 played\n                case(cntGs5) is\n                    when \"00001\" => Wave0 <= WaveGs5;\n                    when \"00010\" => Wave1 <= WaveGs5;\n                    when \"00011\" => Wave2 <= WaveGs5;\n                    when \"00100\" => Wave3 <= WaveGs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(9) = '1') then--------------------note A5 played\n                case(cntA5) is\n                    when \"00001\" => Wave0 <= WaveA5;\n                    when \"00010\" => Wave1 <= WaveA5;\n                    when \"00011\" => Wave2 <= WaveA5;\n                    when \"00100\" => Wave3 <= WaveA5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(10) = '1') then--------------------note As5 played\n                case(cntAs5) is\n                    when \"00001\" => Wave0 <= WaveAs5;\n                    when \"00010\" => Wave1 <= WaveAs5;\n                    when \"00011\" => Wave2 <= WaveAs5;\n                    when \"00100\" => Wave3 <= WaveAs5;\n                    when others => error <= '1';\n                end case;\n            end if;\n            if (O5(11) = '1') then--------------------note B5 played\n                case(cntB5) is\n                    when \"00001\" => Wave0 <= WaveB5;\n                    when \"00010\" => Wave1 <= WaveB5;\n                    when \"00011\" => Wave2 <= WaveB5;\n                    when \"00100\" => Wave3 <= WaveB5;\n                    when others => error <= '1';\n                end case;\n            end if;\n---------------------------------------------------------------------------------------------------------------------------------    \n            if(O5(12) = '1') then--------------------note C6 played\n                case(cntC6) is\n                    when \"00001\" => \n                        Wave0 <= WaveC6;\n                        Wave1 <= \"0000000000\";\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00010\" => \n                        Wave1 <= WaveC6;\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00011\" => \n                        Wave2 <= WaveC6;\n                        Wave3 <= \"0000000000\";\n                    when \"00100\" => Wave3 <= WaveC6;\n                    when others => error <= '1';\n                end case;   \n            else\n                case(cntC6) is--------------------------fill in extra waves\n                    when \"00001\" => \n                        Wave1 <= \"0000000000\";\n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00010\" => \n                        Wave2 <= \"0000000000\";\n                        Wave3 <= \"0000000000\";\n                    when \"00011\" => \n                        Wave3 <= \"0000000000\";\n                    when others => error <= '1';\n                end case;   \n            end if;    \n        end if;     \n    end process;\n\n\n-------------sine wave adder--------------------\n    WaveSum <= STD_LOGIC_VECTOR(Wave0 + Wave1 + Wave2 + Wave3);\n\n\n---------make sine wave positive for pwm---------------------\n    positiveWaveSum <= not WaveSum(9) & WaveSum(8 downto 0);\n\n\n-------------PWM generator---------------------\n    process(CLK) \n            --variable count : unsigned (1 downto 0) := to_unsigned(0, 2);\n        begin\n            if (rising_edge(CLK)) then\n                --count := count + 1;\n                --if (count = to_unsigned(4, 2)) then\n                    --count := to_unsigned(0, 2);\n                    --if (PWM = to_\n                    if (PWM < ping_length) then\n                        output <= '1';\n                    else\n                        output <= '0';\n                    end if;\n                    PWM <= PWM + 1;\n                    ping_length <= unsigned(positiveWaveSum);\n                --end if;\n            end if;\n        end process;\nend Behavioral; 4 Note SelectorThe trickiest part of this project is selecting just four frequencies. We did it with a whole lotta IF statements, and we used signals instead of variables so that the process can be simulated and debugged. We tried other methods using variables and FOR loops, but ran into run-time errors. So, in the end, we decided that if it works, we\u2019ll leave it alone. Don\u2019t fix what ain\u2019t broken amirite?The four output waves are labeled Wave0, Wave1, Wave2, Wave3 -- these are what will be added together to form the final output.Looking at the code, you\u2019ll see a bunch of signals labeled C4, Cs4, D4, Ds4, etc. These are 5-bit signals that take the corresponding trigger from O4 (octave 4) or O5 (octave 5) and make them 5-bit for adding. Next the cntC4, cntCs4, etc variables represent how many notes lower than the target note have been played, including the target note. For example, if C4, E4, G4, A#4, and D5 are played (C9 chord) cntC4 will be 1, cntE4 will be 2, cntG4 will be 3, etc. Then, whenever a note is played, the count for the target note will be examined to see where to hook the note signal up to. For example, if D5 note is played (which means O5(2) is high) and cntD5 is 3, then there are currently 3 notes being played, with 2 notes lower than D5, so we will hook waveD5 to Wave2 (the third wave signal counting from Wave0). Alternatively, if cntD5 is 5, then there are currently 5 notes being played, with 4 notes lower than D5, so we will just leave waveD5 hanging and not do anything with it.The IF statements are then repeated to cover the cases for all 25 notes.Amplitude Adder After the lowest 4 waves are selected we have to add them together. The reason we will only add four notes together is because the PWM idea we are using for our output can only have a certain resolution until the PWM is running too slow and the speaker will start picking up the PWM square wave. For example, if we were to use a resolution of 8192 (13 bit), each of those 8192 points has to correspond to a rising edge of the onboard clock. So, 100MHz / 8192 = 12.2kHz, which is well within the range of human hearing.The actual addition of the amplitudes is super simple, you just have to make sure it can run really fast.PWM Output The PWM\u2019s duty cycle will represent the amplitude of our output wave at that instant. For example, if we have an amplitude range of 0 to 128, 0 would be a 0% duty cycle, 64 would be 50%, 128 would be 100%, etc.  This PWM will run extremely fast (ours is 97.6 kHz),  so fast that the speaker will not recognize the individual square waves and instead look at the average voltage, creating our \u201canalog\u201d signal.Constraints FileYou may have hooked up your hardware differently, so just make sure the constraints file matches up.", "step_imgs": ["https://cdn.instructables.com/FVK/OOU2/JAMTQLIK/FVKOOU2JAMTQLIK.LARGE.jpg", "https://cdn.instructables.com/F54/9HYJ/JAIJOPH9/F549HYJJAIJOPH9.LARGE.jpg"], "step_title": "Step 4: VHDL Setup (Vivado)"}, {"step": 5, "steps_text": "Below is the code, both in .txt format and .vhd for Vivado. Wave_Generator is the wave generator sub-module, and Two_Octave_Synth is the top module with everything else.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 5: Code Downloads"}], "channel": "Gadgets"}, {"category": "technology", "description": "Has anyone ever wanted to measure the actual feed-rate on a CNC machine? Probably not, until the milling bits are intact after a CNC job... but when they start breaking on a regular basis, maybe it is time to investigate. In this instructable you can follow a quest in determining the actual feed-rate of a CNC machine. It will cover the reverse-engineering part of a printer, arduino firmware, PC software, and the results I got with the help of my colleagues, and a trash turned into treasure.", "title": "CNC Feed-rate Measuring Tool Made From Scrap", "url": "https://www.instructables.com/id/CNC-Feed-rate-Measuring-Tool-Made-From-Scrap/", "section": "technology", "steps": [{"step": 1, "steps_text": "When I began working on this, I thought out a short list of the things we will need:disassembled printer carriage mechanismhand tools to tweak thatsoldering iron, solder, wiresmultimeteroscilloscope or logic analyzer - this is not absolutely necessarypower supplymicroscopeArduino nano + pinoutPC with Arduino IDE, Visual Studio 2008 Express + MS Charting tools installed(MPU6050 - I ended up not using this)willing to browse for everything you don't know how to doAt the beginning, I thought that an MPU6050 board will allow me to measure feed-rate on all three axes at once. Having the accelerometer inside it, I was sure that summing up accelerometer data will give me the desired value - the speed on each axis. After downloading and modifying an Arduino snippet that displayed raw data on the serial monitor, I wrote a small PC program in Visual Studio that processed the data, and plotted it on a chart for easier interpretation. I had to download both Visual Studio C# Express 2008 and the charting tools for this.After coding a while and looking up all the things I needed for serial communication, I ended up with the values plotted, but no matter what I did, it wasn't usable. Small but sudden movements would result in huge spikes, while longer travels wouldn't even show up on the charts. After two days of hammering the MPU6050, I finally gave up and turned to something else - a disassembled printer's position feedback mechanism.", "step_imgs": [], "step_title": "Step 1: Materials, Tools, Devices Used to Get the Project Running"}, {"step": 2, "steps_text": "Reverse EngineeringOf course, the printer mechanism had no part number I could have used to determine its exact properties, there was need for a little reverse-engineering to get where we wanted. After closely examining the mechanism and the electronics, I decided that the first thing has to be the identification of the optical sensor pins. This had to be done in order to interface the whole thing to the Arduino. I disassembled the black plastic part, extracted the PCB, and examined the sensor: it had ROHM RPI-2150 written on it. That got me happy, the hope was high that I'll find a datasheet. Unfortunately this is either an old, or a custom part - there was no datasheet to be found anywhere on the web. This meant that I had to take matters into own hands: knowing that these sensors usually have an infrared LED and two photo-transistors inside, I grabbed a multimeter, set it to diode measurement mode, and began measuring between pins.The power pins are usually easy to find - they will have capacitors across them, and they are usually connected with wide traces on the PCB-s. Ground traces are often connected to multiple pads for better noise rejection.The input and output pins are not that trivial, however. When measuring across a diode, the meter will show its forward voltage in one direction, and overload (infinite) in the other. I was able to identify four diodes between pins, I concluded that the fourth diode must be some kind of zener or TVS diode, as it was right between the power pins of the component. Locating the infrared emitter was easy, there was a 89R resistor in series with it. I got left with two diode measurements on the remaining two pins, those had to be the two receivers. Note: These sensors have two receivers in order to be able to determine the direction of movement in addition to determining the position by counting the pulses. These two output waveforms are 90\u00b0 out of phase, this is used to produce a count-up or a count-down pulse. By following the number of these pulses, the exact position of the printing head can be determined.When the emitter and the two receivers were located, I soldered wires on their pins, so I can interface the sensor with the Arduino. Before doing that, I supplied the sensor with 3.3V, pulled the strip between the sensor a couple of times, and observed the square wave on the outputs. The frequency of the square wave varied with the movement speed, and I concluded that the measurement system is now ready to be connected to the Arduino.Connecting the ArduinoConnecting this new 'sensor' is very easy. Just connect the sensor outputs to D2 and D3 (interrupt-capable pins!), and the power supply lines, and the coding can begin. ", "step_imgs": ["https://cdn.instructables.com/FYC/B36G/JEYIOFYD/FYCB36GJEYIOFYD.LARGE.jpg", "https://cdn.instructables.com/F9M/4G0J/JEYIOFYJ/F9M4G0JJEYIOFYJ.LARGE.jpg", "https://cdn.instructables.com/FJM/44PB/JEYIOFYM/FJM44PBJEYIOFYM.LARGE.jpg", "https://cdn.instructables.com/F7U/ME1U/JEYIOFYK/F7UME1UJEYIOFYK.LARGE.jpg", "https://cdn.instructables.com/F5Z/KK05/JEYIOFRV/F5ZKK05JEYIOFRV.LARGE.jpg", "https://cdn.instructables.com/FAF/5642/JEYIOFUU/FAF5642JEYIOFUU.LARGE.jpg", "https://cdn.instructables.com/FJJ/ZNVE/JEYIOFUN/FJJZNVEJEYIOFUN.LARGE.jpg"], "step_title": "Step 2: Hardware Stuff That Needed to Be Done"}, {"step": 3, "steps_text": "The Arduino code is quite simple. I assigned a function that executes every time D2 sees a rising edge, this is the elapse function from the Arduino code I attached. If you take a look on the signals of a quadratic encoder, you will see this:in one direction phase A is logic high on every phase B rising edgein the other direction phase A is logic low on every phase B rising edge This was the property of the encoder I took advantage: since the elapse function executes every time D2 has a rising edge, I just wrote an if that increments a counter when D3 is high, and decrements it when D3 is low. This worked at first try, I sent the counter value out to the serial monitor, and watched it increase/decrease when I moved the printer head on the shaft. Long story short, the firmware does the following thing in the loop function:checks the serial receive buffer for any incoming data if there is incoming data, check if it's a '1' or notif it's a '1', it means that the PC software is requesting the counter valuesend the counter value to the PC via serialstart over at 1.With this, the ball is in the PC software's court now. Let's get into that!", "step_imgs": ["https://cdn.instructables.com/FJ5/N3JK/JEYIOH9I/FJ5N3JKJEYIOH9I.LARGE.jpg"], "step_title": "Step 3: Arduino Coding"}, {"step": 4, "steps_text": "The purpose of the VS C# program was to shift the computational burden from the Arduino to the PC. This software receives the data the Arduino is providing, computes and displays the speed in the form of a graph.What I first did was to google how to do serial communication in C#. I found a lot of good info on MSDN.com along with a good example, then I just threw out what I didn't need - basically everything except the reading part. I set up the COM port and the speed to match with that of the Arduino, then just gave it a few tries and dumped everything that came on the serial port into a multi-line text box.After the values were read, I could just use the readto & split functions to isolate one measurements from each other, and from delimiter characters. These were plotted on a Chart control, and the values began to appear on the screen. If you can't see the Chart control in your VS toolbox, you can google the problem and find the solution here (look for answer #1): linkThe measurement principleTo find the connection between the number of counts and the distance the head travels, we zeroed the count value, moved the printer head 100mm by hand, and observed the change in counts. We finally came up with the following proportion: 1 count = 0.17094mm. Since we can query the distance and we can measure the time between the samples, we can calculate the rate at which the position shift happens - we can calculate the speed! There is a rough software timing of 50ms thanks to TMR0, but we observed that these timings weren't too accurate. In fact, after some software speed measurements, we found that the timed 50ms isn't 50ms at all. This meant that the samples weren't taken at fixed interval, so the speed calculation couldn't use a fixed time-base either. Once we found this issue, it was easy to move on: we took the difference in distance and the difference in time and calculated the speed as D_distance/D_time (instead of D-distance/50ms).Also, because our equation would return speed in units of mm/50ms, we need to multiply this by 1200 to get the distance the head would go in one minute, in [mm/minute].Note: the Mach 3 CNC mill controlling software defines the feed-rates in units of [mm/minute]FilteringFrom this point on, the measurements seemed to be pretty accurate, but there was some noise on the measured signal. We suspected that this was due to mechanical inconsistencies in the shaft, shaft coupling, etc, so decided to filter it out, to get a nice mean value of that what is measured.Fine adjustments to the softwareIn order to change the sample rate and filter rate during runtime, scrollbars were added - one for each. Also, the ability to hide the plots was also introduced.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Visual Studio C# Software"}, {"step": 5, "steps_text": "After the hardware and software parts were ready, we ran three sets of measurements with mach 3 + my software, you can see the results on the attached pictures.Later experiments showed better accuracy, with both filter and sample rates increased. The plots show the measured speed with solid red, and the average with dash-dotted blue. That being said, it looks like Mach 3 handles these speed settings quite accurately, but now we know for sure:)I hope you enjoyed this short instructable about reverse-engineering and turning water into wine!Cheers!", "step_imgs": ["https://cdn.instructables.com/F43/39YZ/JEYIOF84/F4339YZJEYIOF84.LARGE.jpg", "https://cdn.instructables.com/FEA/ECVW/JEYIOF85/FEAECVWJEYIOF85.LARGE.jpg", "https://cdn.instructables.com/FL7/8XX9/JEYIOF88/FL78XX9JEYIOF88.LARGE.jpg", "https://cdn.instructables.com/FCY/MQYY/JEYIOFRY/FCYMQYYJEYIOFRY.LARGE.jpg"], "step_title": "Step 5: Results"}], "channel": "Arduino"}, {"category": "technology", "description": "By: Danica Fujiwara and William McGroutherCars are the main mode of transportation in the world today. Specifically, in California, we are surrounded by streets, highways, and toll roads that thousands of cars drive on daily. However, cars use gas and california uses the most gasoline than any other state in the U.S., approximately 4,500 gallons per day. For our CPE 133 Final project,  we decided to create system in which it could track the speed of a car and tell whether it exceeds the most efficient speed for the best gas mileage or fuel economy. This project would help drivers become aware of their fuel economy which in turn would hopefully help  them save money, use less gas, and create less pollution in the air.", "title": "Fuel Efficiency Detector", "url": "https://www.instructables.com/id/Fuel-Efficiency-Detector/", "section": "technology", "steps": [{"step": 1, "steps_text": "Materials needed for this project:- Basys 3 FPGA- Arduino Uno- Breadboard - Adafruit BNO055 Absolute Orientation Sensor- Male to Male Wires", "step_imgs": ["https://cdn.instructables.com/FAJ/KZBG/JEUKL8X0/FAJKZBGJEUKL8X0.LARGE.jpg", "https://cdn.instructables.com/FOR/G62I/JEUKL8X3/FORG62IJEUKL8X3.LARGE.jpg", "https://cdn.instructables.com/FAO/3APQ/JEUKL8X4/FAO3APQJEUKL8X4.LARGE.jpg", "https://cdn.instructables.com/FTD/W9BI/JESSZLDP/FTDW9BIJESSZLDP.LARGE.jpg"], "step_title": "Step 1:  Materials"}, {"step": 2, "steps_text": "Finite State DiagramThis project has two different states within the finite state diagram shown above. The light can either be on(represented by \u20181\u2019)  or off(represented by \u20180\u2019).  The state changes depending on the input of the tracking speed(ts) and the constant optimal speed.Black Box Diagram  Also above there is a Black Box diagram of the Fuel Efficiency module that contains the schematic of the Speed Comparator and the Seven Segment Display that are further discussed below. This  VHDL code receives an 8-bit input from the measurements of the accelerometer that is connected to the arduino.", "step_imgs": ["https://cdn.instructables.com/F9Y/P6XH/JEUKL8E7/F9YP6XHJEUKL8E7.LARGE.jpg", "https://cdn.instructables.com/FI8/NTM0/JEUKL8GT/FI8NTM0JEUKL8GT.LARGE.jpg"], "step_title": "Step 2: Understanding the Design"}, {"step": 3, "steps_text": "For this project, there are three VHDL files that construct our design, Fuel_Efficency_FinalProject module, Speed_Comparator module, and the sseg_dec module where Speed_Comparator and the sseg_dec are at the lower level to make up the Fuel Efficiency module. The Speed comparator Module  This module takes in an 8-bit speed in miles per hour and compares it to the optimal speed for the least amount of gas consumption. The average optimal speed for a car\u2019s best gas mileage is around 55 mph and under. However, this can vary from car to car which can be customized within the module. The line 45 of code that can be changed for personal optimization is show below if (tracking > \"00110111\") thenWhere \u201c00110111\u201d (55 in binary) can be changed to any 8-bit number for your personal car\u2019s ideal speed for least amount of fuel consumption. If the speed is over the optimal number the light will turn on notifying that the car is not using maximum fuel efficiency. The Seven Segment DisplayModuleThis module takes in an 8-bit speed in miles per hour and displays the speed on the seven segment display. This would allow the user to know how fast they are going to know whether he or she needs to slow down. This module was given to us within our class and was written by Bryan mealy that contains the components bin2bcdconv which converts the binary 8-bit input to BCD form that is easier to decode and clk_div so that the display can visually show a number with 3 digits by changing the anode output at a high clock frequency . This code accepts an 8- bit number converts the number into a readable display on the basys 3 board.  The Fuel Efficiency moduleThis is the main file that uses the modules above as components. Its inputs are the clock, and the tracking speed. The clock is built within the basys 3 board and the tracking speed is given by the arduino\u2019s output which is connected to The Analog signal pmod port (XADC). Each bit of the 8-bit tracking speed is map to the ports shown within the wiring section in step4. Other Basys 3 constraints can be found within Basys_3_Master.xdc.", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 3: Coding VHDL"}, {"step": 4, "steps_text": "This project uses one main arduino file that requires the use of several libraries, some of which are already in your arduino program and others have to be downloaded either from this instructable or the Adafruit website(link below).Librarieslink to Adafruit BNO055 page :  https://learn.adafruit.com/adafruit-bno055-absolu...Adafruit has developed 2 libraries for use of the BNO055, and give examples of how to use them. In this project we will be using the .getVector function to have the arduino output the accelerometer's data.This project also utilizes some libraries already installed in the arduino program, like the math library.Main FileThis file uses the accelerometer data from the .getVector function and uses mathematical equations to turn it into a speed in miles per hour, that is then outputted in 8 bits of data to the Basys 3(see the \"Wiring the Hardware\" section for more information).", "step_imgs": ["/assets/img/pixel.png", "/assets/img/pixel.png", "/assets/img/pixel.png"], "step_title": "Step 4: Coding Arduino"}, {"step": 5, "steps_text": "Arduino WiringThe Arduino should be wired to the breadboard like they are in the pictures above.Basys 3 WiringThe outputs of the arduino are mapped to the inputs of the Basys 3 through the Analog signal pmod JXADC ports. Each bit of the 8-bit tracking speed can be connected to one of the pins shown in the picture above. The least significant bit(digital pin 7) gets connected to ts(7) and the most significant bit(digital pin 0) gets connected to ts(0).", "step_imgs": ["https://cdn.instructables.com/FFT/NO8R/JEUKL8X6/FFTNO8RJEUKL8X6.LARGE.jpg", "https://cdn.instructables.com/FFT/HWD7/JEUKL8DJ/FFTHWD7JEUKL8DJ.LARGE.jpg", "https://cdn.instructables.com/F10/3QXI/JEUKL8DK/F103QXIJEUKL8DK.LARGE.jpg", "https://cdn.instructables.com/FRH/LX48/JESSZN43/FRHLX48JESSZN43.LARGE.jpg"], "step_title": "Step 5: Wiring the Hardware"}], "channel": "Assistive Tech"}, {"category": "technology", "description": "Luminous treasure box, the name sounds fun. And that would be real fun! We will make this box, which will be closed during the day, once in the night, its light will get brighter with the box opened slowly. Ha-ha...the inner workings of the box is that analog ambient light sensor can detect light strong or weak. With the brightness changing, the output values will be different. At night, to reach the set value, the servo will rotate, and LED turn on at the same time. What you needed:1\u00d7  Analog Ambient Light Sensor1\u00d7  TowerPro SG50 Servo 1\u00d7  Digital Piranha LED Light Module - Red1\u00d7  IO Expansion Shield1\u00d7  Intel\u00ae Edison with Arduino Breakout Kit", "title": "Intel\u00ae Edison Hands-on Day 7: Luminous Treasure Box", "url": "https://www.instructables.com/id/Intel-Edison-Hands-on-Day-7-Luminous-Treasure-Box/", "section": "technology", "steps": [{"step": 1, "steps_text": "TowerPro SG50 Servo \u2192 Digital 9 Analog Ambient Light Sensor \u2192 Analog 0Digital Piranha LED Light Module - Red \u2192 Digital 3Fixed the servo at the connection of the box, the LED in the box. Of course, the sensor is exposed to detect ambient light. After the installation is completed, place the box in the dark. And you can check if the box should open automatically.", "step_imgs": ["https://cdn.instructables.com/FBX/R5LZ/I21RKCNA/FBXR5LZI21RKCNA.LARGE.jpg"], "step_title": "Step 1: Connection Diagram"}, {"step": 2, "steps_text": "#include     Servo myservo;int LED = 3;              //the number of the LED pin int val = 0;             //variable to store the sensor valueint pos = 0;int light =0;void setup(){// initialize the digital pin as an output.     pinMode(LED,OUTPUT);     // initialize serial communication at 9600\nbits per second:      Serial.begin(9600);              // attaches the servo on pin 9 to the\nservo object     myservo.attach(9);        // tell servo to go to position in 0\ndegree             myservo.write(0);          }void loop(){     val = analogRead(0);     // read the input on analog pin 0     Serial.println(val);    // print\nout the value you read     //Once smaller than the set value,increasing\nangles    if(val<40){            pos = pos +2;          if(pos >= 90){  //After moverd to 90 degree, keep in this\ndegree              pos = 90;                        }                  // tell servo to go to position in\nvariable 'pos'          myservo.write(pos);             delay(100);          // As the angle\nincreases, increased brightness LED          light = map(pos,0,90,0,255);            analogWrite(LED,light);   //set the brightness      }else{                            pos = pos -2;    //minus 2 degree          if(pos <= 0){             pos = 0;       //reduced up to 0 degrees          }          myservo.write(pos);               delay(100);               light = map(pos,0,90,0,255);           analogWrite(LED,light);       }}", "step_imgs": [], "step_title": "Step 2: Example Code"}], "channel": "Electronics"}]